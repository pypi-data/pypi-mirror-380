# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _byteblower
else:
    import _byteblower

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_SwigPyIterator

    def value(self):
        return _byteblower.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _byteblower.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _byteblower.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _byteblower.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _byteblower.SwigPyIterator_equal(self, x)

    def copy(self):
        return _byteblower.SwigPyIterator_copy(self)

    def next(self):
        return _byteblower.SwigPyIterator_next(self)

    def __next__(self):
        return _byteblower.SwigPyIterator___next__(self)

    def previous(self):
        return _byteblower.SwigPyIterator_previous(self)

    def advance(self, n):
        return _byteblower.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _byteblower.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _byteblower.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _byteblower.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _byteblower.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _byteblower.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _byteblower.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _byteblower:
_byteblower.SwigPyIterator_swigregister(SwigPyIterator)
class ByteBlowerAPIException(Exception):
    r"""

    Base class for most of the ByteBlower Exceptions


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _byteblower.ByteBlowerAPIException_swiginit(self, _byteblower.new_ByteBlowerAPIException())
    __swig_destroy__ = _byteblower.delete_ByteBlowerAPIException

    def getInfo(self):
        r"""

        Gets some additional info of the error

        :rtype: str


        """
        return _byteblower.ByteBlowerAPIException_getInfo(self)

    def getMessage(self):
        r"""

        Get a description of the error

        :rtype: str


        """
        return _byteblower.ByteBlowerAPIException_getMessage(self)

    def what(self):
        r"""

        Get a description of the error

        :rtype: str


        """
        return _byteblower.ByteBlowerAPIException_what(self)

# Register ByteBlowerAPIException in _byteblower:
_byteblower.ByteBlowerAPIException_swigregister(ByteBlowerAPIException)

def Demangle(inName):
    return _byteblower.Demangle(inName)
class TechnicalError(ByteBlowerAPIException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TechnicalError_swiginit(self, _byteblower.new_TechnicalError(*args))
    __swig_destroy__ = _byteblower.delete_TechnicalError

# Register TechnicalError in _byteblower:
_byteblower.TechnicalError_swigregister(TechnicalError)
class DomainError(ByteBlowerAPIException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.DomainError_swiginit(self, _byteblower.new_DomainError(*args))
    __swig_destroy__ = _byteblower.delete_DomainError

# Register DomainError in _byteblower:
_byteblower.DomainError_swigregister(DomainError)
class ConfigError(DomainError):
    r"""

    Raised when the API is called with a configuration mistake

    This can happen in a few cases:

    - The API is called with a wrong argument.  
      E.g. The API expects a positive integer, but e.g. -1 is passed

    - A method is called on an object which is not fully configured yet.
      E.g. Start is called on an HTTP client, but the remote address was not configured.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.ConfigError_swiginit(self, _byteblower.new_ConfigError(*args))
    __swig_destroy__ = _byteblower.delete_ConfigError

# Register ConfigError in _byteblower:
_byteblower.ConfigError_swigregister(ConfigError)
class InitializationError(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.InitializationError_swiginit(self, _byteblower.new_InitializationError(*args))
    __swig_destroy__ = _byteblower.delete_InitializationError

# Register InitializationError in _byteblower:
_byteblower.InitializationError_swigregister(InitializationError)
class InProgressError(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.InProgressError_swiginit(self, _byteblower.new_InProgressError(*args))
    __swig_destroy__ = _byteblower.delete_InProgressError

# Register InProgressError in _byteblower:
_byteblower.InProgressError_swigregister(InProgressError)
class AddressResolutionFailed(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.AddressResolutionFailed_swiginit(self, _byteblower.new_AddressResolutionFailed(*args))
    __swig_destroy__ = _byteblower.delete_AddressResolutionFailed

# Register AddressResolutionFailed in _byteblower:
_byteblower.AddressResolutionFailed_swigregister(AddressResolutionFailed)
class DHCPFailed(InitializationError):
    r"""

    Raised when the DHCP process failed.

    This is usually due to a DISCOVER/SOLICIT/REQUEST message did not get a (valid)
    reply before the DHCP Timeout passed.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.DHCPFailed_swiginit(self, _byteblower.new_DHCPFailed(*args))
    __swig_destroy__ = _byteblower.delete_DHCPFailed

# Register DHCPFailed in _byteblower:
_byteblower.DHCPFailed_swigregister(DHCPFailed)
class RouterRequired(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.RouterRequired_swiginit(self, _byteblower.new_RouterRequired(*args))
    __swig_destroy__ = _byteblower.delete_RouterRequired

# Register RouterRequired in _byteblower:
_byteblower.RouterRequired_swigregister(RouterRequired)
class RouterSolicitationFailed(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.RouterSolicitationFailed_swiginit(self, _byteblower.new_RouterSolicitationFailed(*args))
    __swig_destroy__ = _byteblower.delete_RouterSolicitationFailed

# Register RouterSolicitationFailed in _byteblower:
_byteblower.RouterSolicitationFailed_swigregister(RouterSolicitationFailed)
class TCPAlreadyConnected(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPAlreadyConnected_swiginit(self, _byteblower.new_TCPAlreadyConnected(*args))
    __swig_destroy__ = _byteblower.delete_TCPAlreadyConnected

# Register TCPAlreadyConnected in _byteblower:
_byteblower.TCPAlreadyConnected_swigregister(TCPAlreadyConnected)
class TCPConnectionRefused(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPConnectionRefused_swiginit(self, _byteblower.new_TCPConnectionRefused(*args))
    __swig_destroy__ = _byteblower.delete_TCPConnectionRefused

# Register TCPConnectionRefused in _byteblower:
_byteblower.TCPConnectionRefused_swigregister(TCPConnectionRefused)
class TCPConnectionTimeout(InitializationError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPConnectionTimeout_swiginit(self, _byteblower.new_TCPConnectionTimeout(*args))
    __swig_destroy__ = _byteblower.delete_TCPConnectionTimeout

# Register TCPConnectionTimeout in _byteblower:
_byteblower.TCPConnectionTimeout_swigregister(TCPConnectionTimeout)
class TCPConnectionResetByPeer(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPConnectionResetByPeer_swiginit(self, _byteblower.new_TCPConnectionResetByPeer(*args))
    __swig_destroy__ = _byteblower.delete_TCPConnectionResetByPeer

# Register TCPConnectionResetByPeer in _byteblower:
_byteblower.TCPConnectionResetByPeer_swigregister(TCPConnectionResetByPeer)
class TCPConnectionAborted(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.TCPConnectionAborted_swiginit(self, _byteblower.new_TCPConnectionAborted(*args))
    __swig_destroy__ = _byteblower.delete_TCPConnectionAborted

# Register TCPConnectionAborted in _byteblower:
_byteblower.TCPConnectionAborted_swigregister(TCPConnectionAborted)
class PortNumberAlreadyUsed(ConfigError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.PortNumberAlreadyUsed_swiginit(self, _byteblower.new_PortNumberAlreadyUsed(*args))
    __swig_destroy__ = _byteblower.delete_PortNumberAlreadyUsed

# Register PortNumberAlreadyUsed in _byteblower:
_byteblower.PortNumberAlreadyUsed_swigregister(PortNumberAlreadyUsed)
class ByteBlowerServerUnreachable(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.ByteBlowerServerUnreachable_swiginit(self, _byteblower.new_ByteBlowerServerUnreachable(*args))
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerUnreachable

# Register ByteBlowerServerUnreachable in _byteblower:
_byteblower.ByteBlowerServerUnreachable_swigregister(ByteBlowerServerUnreachable)
class MeetingPointUnreachable(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.MeetingPointUnreachable_swiginit(self, _byteblower.new_MeetingPointUnreachable(*args))
    __swig_destroy__ = _byteblower.delete_MeetingPointUnreachable

# Register MeetingPointUnreachable in _byteblower:
_byteblower.MeetingPointUnreachable_swigregister(MeetingPointUnreachable)
class ByteBlowerServerIncompatible(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.ByteBlowerServerIncompatible_swiginit(self, _byteblower.new_ByteBlowerServerIncompatible(*args))
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerIncompatible

# Register ByteBlowerServerIncompatible in _byteblower:
_byteblower.ByteBlowerServerIncompatible_swigregister(ByteBlowerServerIncompatible)
class UnsupportedFeature(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.UnsupportedFeature_swiginit(self, _byteblower.new_UnsupportedFeature(*args))
    __swig_destroy__ = _byteblower.delete_UnsupportedFeature

# Register UnsupportedFeature in _byteblower:
_byteblower.UnsupportedFeature_swigregister(UnsupportedFeature)
class ResponseTimeout(DomainError):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.ResponseTimeout_swiginit(self, _byteblower.new_ResponseTimeout(*args))
    __swig_destroy__ = _byteblower.delete_ResponseTimeout

# Register ResponseTimeout in _byteblower:
_byteblower.ResponseTimeout_swigregister(ResponseTimeout)
EXCENTIS_ARCHLIB_HAVE_COMPAT_WARNINGS = _byteblower.EXCENTIS_ARCHLIB_HAVE_COMPAT_WARNINGS
EXCENTIS_COMPAT_HAS_CXX0X = _byteblower.EXCENTIS_COMPAT_HAS_CXX0X
EXCENTIS_COMPAT_HAS_CPP0X = _byteblower.EXCENTIS_COMPAT_HAS_CPP0X
EXCENTIS_COMPAT_HAS_CXX11 = _byteblower.EXCENTIS_COMPAT_HAS_CXX11
ResultDataType_Cumulative = _byteblower.ResultDataType_Cumulative
ResultDataType_Interval = _byteblower.ResultDataType_Interval
class DataRate(object):
    r"""

    Represents a data rate.  The datarate can be expressed in multiple formats.

    Example

    .. code-block:: python

       httpResultData = httpClient.ResultHistoryGet().CumulativeLatestGet()
       dataRate = httpResultData.RxByteCountRateGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, inSize, inDuration):
        _byteblower.DataRate_swiginit(self, _byteblower.new_DataRate(inSize, inDuration))

    def toString(self):
        r"""

        Returns the bytes per second in a readable string format

        :return: A human readable format of the speed
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.toString())


        """
        return _byteblower.DataRate_toString(self)

    def ByteRateGet(self):
        r"""

        Returns the bytes per second of the http session

        :return: The speed in bytes per second
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.ByteRateGet())


        """
        return _byteblower.DataRate_ByteRateGet(self)

    def BitRateGet(self):
        r"""

        Returns the bits per second of the http session

        :return: The speed in bits per second
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.BitRateGet())


        """
        return _byteblower.DataRate_BitRateGet(self)

    def KbpsGet(self):
        r"""

        Returns the kilobits per second of the http session

        :return: The speed in kilobits per second
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.KbpsGet())


        """
        return _byteblower.DataRate_KbpsGet(self)

    def MbpsGet(self):
        r"""

        Returns the megabits per second of the http session

        :return: The speed in megabits per second
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.MbpsGet())


        """
        return _byteblower.DataRate_MbpsGet(self)

    def GbpsGet(self):
        r"""

        Returns the gigabits per second of the http session

        :return: The speed in gigabits per second
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.GbpsGet())


        """
        return _byteblower.DataRate_GbpsGet(self)

    def bitrate(self):
        r"""

        Returns the number of bits per second

        .. deprecated: 2.x
           Use :meth:`BitRateGet` instead

        :return: The speed in bits per second
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.bitrate())


        """
        return _byteblower.DataRate_bitrate(self)

    def byterate(self):
        r"""


        .. deprecated: 2.x
           Use :meth:`ByteRateGet` instead

        :return: The speed in bytes per second
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.byterate())


        """
        return _byteblower.DataRate_byterate(self)
    __swig_destroy__ = _byteblower.delete_DataRate

# Register DataRate in _byteblower:
_byteblower.DataRate_swigregister(DataRate)
cvar = _byteblower.cvar
MAX_U_INT16 = cvar.MAX_U_INT16
MAX_U_INT32 = cvar.MAX_U_INT32
MAX_U_INT64 = cvar.MAX_U_INT64
MAX_INT16 = cvar.MAX_INT16
MAX_INT32 = cvar.MAX_INT32
MAX_INT64 = cvar.MAX_INT64

FrameTagType_TimeStamp = _byteblower.FrameTagType_TimeStamp
FrameTagType_SequenceNumber = _byteblower.FrameTagType_SequenceNumber
TimeStampFormat_Microseconds = _byteblower.TimeStampFormat_Microseconds
TimeStampFormat_Microseconds_CRC = _byteblower.TimeStampFormat_Microseconds_CRC
TimeStampFormat_TenNanoseconds = _byteblower.TimeStampFormat_TenNanoseconds
SequenceNumberFormat_SequenceNumber_0 = _byteblower.SequenceNumberFormat_SequenceNumber_0
SequenceNumberFormat_SequenceNumber_0_CRC = _byteblower.SequenceNumberFormat_SequenceNumber_0_CRC
LinkStatus_Offline = _byteblower.LinkStatus_Offline
LinkStatus_Online = _byteblower.LinkStatus_Online
LinkStatus_Unplugged = _byteblower.LinkStatus_Unplugged
LinkStatus_Unknown = _byteblower.LinkStatus_Unknown

def ConvertLinkStatusToString(inLinkStatus):
    return _byteblower.ConvertLinkStatusToString(inLinkStatus)

def ParseLinkStatus(arg1):
    return _byteblower.ParseLinkStatus(arg1)
LinkType_Ethernet = _byteblower.LinkType_Ethernet
LinkType_USB = _byteblower.LinkType_USB

def ConvertLinkTypeToString(inLinkType):
    return _byteblower.ConvertLinkTypeToString(inLinkType)

def ParseLinkType(arg1):
    return _byteblower.ParseLinkType(arg1)
PhysicalInterfaceType_Trunk = _byteblower.PhysicalInterfaceType_Trunk
PhysicalInterfaceType_NonTrunk = _byteblower.PhysicalInterfaceType_NonTrunk
PhysicalInterfaceType_NonTrunkUSB = _byteblower.PhysicalInterfaceType_NonTrunkUSB

def ConvertPhysicalInterfaceTypeToString(inType):
    return _byteblower.ConvertPhysicalInterfaceTypeToString(inType)

def ParsePhysicalInterfaceType(inString):
    return _byteblower.ParsePhysicalInterfaceType(inString)
IGMPVersion_IGMPv1 = _byteblower.IGMPVersion_IGMPv1
IGMPVersion_IGMPv2 = _byteblower.IGMPVersion_IGMPv2
IGMPVersion_IGMPv3 = _byteblower.IGMPVersion_IGMPv3

def ParseIGMPVersion(inIGMPVersion):
    return _byteblower.ParseIGMPVersion(inIGMPVersion)

def IGMPVersionToString(inIGMPVersion):
    return _byteblower.IGMPVersionToString(inIGMPVersion)
MLDVersion_MLDv1 = _byteblower.MLDVersion_MLDv1
MLDVersion_MLDv2 = _byteblower.MLDVersion_MLDv2

def ParseMLDVersion(inMLDVersion):
    return _byteblower.ParseMLDVersion(inMLDVersion)

def MLDVersionToString(inMLDVersion):
    return _byteblower.MLDVersionToString(inMLDVersion)
MulticastSourceFilter_Exclude = _byteblower.MulticastSourceFilter_Exclude
MulticastSourceFilter_Include = _byteblower.MulticastSourceFilter_Include

def ParseMulticastFilter(inMulticastFilter):
    return _byteblower.ParseMulticastFilter(inMulticastFilter)

def MulticastFilterToString(inMulticastFilter):
    return _byteblower.MulticastFilterToString(inMulticastFilter)
RetransmissionPolicy_Unknown = _byteblower.RetransmissionPolicy_Unknown
RetransmissionPolicy_RfcSuggested = _byteblower.RetransmissionPolicy_RfcSuggested
RetransmissionPolicy_FixedTiming = _byteblower.RetransmissionPolicy_FixedTiming
TimeUnit_Seconds = _byteblower.TimeUnit_Seconds
TimeUnit_Milliseconds = _byteblower.TimeUnit_Milliseconds
TimeUnit_Microseconds = _byteblower.TimeUnit_Microseconds
TimeUnit_Nanoseconds = _byteblower.TimeUnit_Nanoseconds

def ConvertTimeUnitToString(inTimeUnit):
    return _byteblower.ConvertTimeUnitToString(inTimeUnit)

def ParseTimeUnitFromString(arg1):
    return _byteblower.ParseTimeUnitFromString(arg1)

def ToNanoseconds(unit):
    return _byteblower.ToNanoseconds(unit)
DescriptionFormat_PlainText = _byteblower.DescriptionFormat_PlainText
class AbstractObject(object):
    r"""

    Base class for most of the ByteBlower Objects


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def DescriptionGet(self, *args):
        r"""

        Gets a textual description for the current object

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           print(server.DescriptionGet())


        Gets a textual description for the current object

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           print(server.DescriptionGet())


        """
        return _byteblower.AbstractObject_DescriptionGet(self, *args)

    def Refresh(self):
        r"""

        Retrieves the latest data from the server.

        When the method is called on a History object, the method will transfer the 
        samples from the server-side buffer to this API instance. The last sample will 
        always be the running sample. When a sample is closed, the oldest sample in the
        buffer will be removed.


        """
        return _byteblower.AbstractObject_Refresh(self)

# Register AbstractObject in _byteblower:
_byteblower.AbstractObject_swigregister(AbstractObject)
class AbstractRefreshableResult(AbstractObject):
    r"""

    Base class for Results which are refreshable.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_AbstractRefreshableResult

# Register AbstractRefreshableResult in _byteblower:
_byteblower.AbstractRefreshableResult_swigregister(AbstractRefreshableResult)
class ByteBlowerInterface(AbstractObject):
    r"""


    Example

    .. code-block:: python

       interface = bbServer.InterfaceGetByName('trunk-1-14')
       packetDump = interface.PacketDumpCreate()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPhysicalInterface(self):
        r"""


        :meta private:


        """
        return _byteblower.ByteBlowerInterface_GetPhysicalInterface(self)

    def NameGet(self):
        r"""

        Returns the name of the ByteBlower Interface 

        :return: Name of the ByteBlower Interface
        :rtype: str  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(interface.NameGet())


        """
        return _byteblower.ByteBlowerInterface_NameGet(self)

    def SpeedGet(self):
        r"""

        Returns the speed of a ByteBlower Interface

        :return: The speed of this ByteBlower Interface
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(interface.SpeedGet())


        """
        return _byteblower.ByteBlowerInterface_SpeedGet(self)

    def PortIdGet(self):
        r"""

        Returns the ID of this interface on the Physical Interface

        :return: The id of the ByteBlower Interface on the Physical Interface
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(interface.PortIdGet())


        """
        return _byteblower.ByteBlowerInterface_PortIdGet(self)

    def PortCountGet(self):
        r"""

        Returns the number of created ports on this interface

        :return: number of ports on this ByteBlowerInterface
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(interface.PortCountGet())


        """
        return _byteblower.ByteBlowerInterface_PortCountGet(self)

    def PortGet(self):
        r"""

        Returns a list of created ByteBlower ports on this ByteBlower Interface

        :return: A list of ByteBlower ports on this interface
        :rtype: ByteBlowerPortList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           portList = interface.PortGet()


        """
        return _byteblower.ByteBlowerInterface_PortGet(self)

    def PortCreate(self):
        r"""

        Creates a new ByteBlower Port on this ByteBlowerInterface.  

        :return: The created ByteBlower Port object.
        :rtype: ByteBlowerPort

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port = interface.PortCreate()


        """
        return _byteblower.ByteBlowerInterface_PortCreate(self)

    def PortDestroy(self, inPort):
        r"""

        Removes a ByteBlower Port from this interface

        :param port: Port that you want to destroy from the interface.
        :type port: ByteBlowerPort

        Example

        .. code-block:: python
           :emphasize-lines: 1

           interface.PortDestroy(port)


        """
        return _byteblower.ByteBlowerInterface_PortDestroy(self, inPort)

    def PacketDumpCreate(self):
        r"""

        Adds a Packet Dumper to this interface

        :return: returns a PacketDump object
        :rtype: PacketDump

        A Packet Dumper can be used to capture all bidirectional traffic coming in on 
        this ByteBlower Interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           packetDump = interface.PacketDumpCreate()


        """
        return _byteblower.ByteBlowerInterface_PacketDumpCreate(self)

    def PacketDumpDestroy(self, packet_dump):
        r"""

        removes a PacketDump from this interface

        :param dump: Packet Dumper that you want to destroy from the interface`.  
        :type dump: PacketDump

        Example

        .. code-block:: python
           :emphasize-lines: 2

           packetDump = interface.PacketDumpCreate()
           interface.PacketDumpDestroy(packetDump)


        """
        return _byteblower.ByteBlowerInterface_PacketDumpDestroy(self, packet_dump)

    def SwitchIdGet(self):
        r"""

        Returns the ID of the switch where the ByteBlower Interface resides

        :return: Id of the switch where the ByteBlower Interface is connected
        :rtype: int


        """
        return _byteblower.ByteBlowerInterface_SwitchIdGet(self)

# Register ByteBlowerInterface in _byteblower:
_byteblower.ByteBlowerInterface_swigregister(ByteBlowerInterface)
class ByteBlower(AbstractObject):
    r"""

    Singleton class that is the entry point to start using the ByteBlower API.  

    Typically, this is the first class you will use when writing a ByteBlower test 
    script. Use this class to connect to ByteBlower servers, to start or stop all 
    configured ByteBlower ports across those servers, and to control the logging 
    behavior.

    Retrieve the singleton ByteBlower *object* using the static method 
    :meth:`InstanceGet`.

    This class contains some static convenience methods. 
    They are wrappers around the corresponding non-static methods of the singleton 
    object.  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DefaultTimeout = _byteblower.ByteBlower_DefaultTimeout

    @staticmethod
    def InstanceGet():
        r"""

        Creates or returns the ByteBlower API singleton instance.  

        :return:  ByteBlower singleton instance.  
        :rtype: ByteBlower

        This object is the entry point to start working with the ByteBlower Python API.

        If no ByteBlower instance is created yet, this method creates one and returns 
        the object. If the instance exists already, it is simply returned.  Any other 
        static call will implicitly instantiate this singleton object.  

        Example

        .. code-block:: python

           from byteblowerll import byteblower as api
           instance = api.ByteBlower.InstanceGet()


        """
        return _byteblower.ByteBlower_InstanceGet()

    def APIVersionGet(self):
        r"""

        Returns the version of the API.  

        .. versionadded:: 2.6.0  

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 2

           from byteblowerll import byteblower as api
           print(api.ByteBlower.APIVersionGet())
           # returns 2.10.0


        """
        return _byteblower.ByteBlower_APIVersionGet(self)

    def ServerAdd(self, *args):
        r"""

        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        :return: An object that represents the server connection.  
        :rtype: ByteBlowerServer

        :raises ByteBlowerServerUnreachable: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises ByteBlowerServerIncompatible: When the ByteBlower server daemon is running an incompatible version.  

        :raises ValueError|TypeError: When the *<port>* parameter is provided and
                 is no integer.

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           server = bb.ServerAdd('byteblower-1.lab.byteblower.com')


        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        :return: An object that represents the server connection.  
        :rtype: ByteBlowerServer

        :raises ByteBlowerServerUnreachable: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises ByteBlowerServerIncompatible: When the ByteBlower server daemon is running an incompatible version.  

        :raises ValueError|TypeError: When the *<port>* parameter is provided and
                 is no integer.

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           server = bb.ServerAdd('byteblower-1.lab.byteblower.com')


        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        :return: An object that represents the server connection.  
        :rtype: ByteBlowerServer

        :raises ByteBlowerServerUnreachable: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises ByteBlowerServerIncompatible: When the ByteBlower server daemon is running an incompatible version.  

        :raises ValueError|TypeError: When the *<port>* parameter is provided and
                 is no integer.

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           server = bb.ServerAdd('byteblower-1.lab.byteblower.com')


        """
        return _byteblower.ByteBlower_ServerAdd(self, *args)

    def ServerGet(self):
        r"""

        Returns all server connections within this API instance.  

        :return: a list of :class:`.ByteBlowerServer` objects
        :rtype: ByteBlowerServerList

        See :meth:`ServerAdd` for more information.  

        Example

        .. code-block:: python

           server = bb.ServerGet()


        """
        return _byteblower.ByteBlower_ServerGet(self)

    def ServerRemove(self, inByteBlowerServer):
        r"""

        Disconnects from the ByteBlower server.

        :param server: The server to disconnect from
        :type server: ByteBlowerServer

        See :meth:`ServerAdd` for more information.

        .. note:: This will invalidate all created objects on this ByteBlower Server!

        Example

        .. code-block:: python

           bb.ServerRemove(server)


        """
        return _byteblower.ByteBlower_ServerRemove(self, inByteBlowerServer)

    def ServerRemoveAll(self):
        r"""

        Disconnects from all ByteBlower servers.  

        See :meth:`ServerRemove` for more information.

        .. note:: This will invalidate all created objects on this ByteBlower Server!

        Example

        .. code-block:: python

           bb.ServerRemoveAll()


        """
        return _byteblower.ByteBlower_ServerRemoveAll(self)

    def MeetingPointAdd(self, *args):
        r"""

        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  
        :rtype: MeetingPoint

        :raises MeetingPointUnreachable: When the MeetingPoint server daemon could not 
               be reached.  Typical causes are an incorrect or unreachable DNS name 
               or IP address or a MeetingPoint server daemon that is not running 
               (on purpose or due to a software  issue).  
        :raises ValueError|TypeError: When the *<port>* parameter is provided and is no 
               integer.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           meetingpoint = bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')


        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  
        :rtype: MeetingPoint

        :raises MeetingPointUnreachable: When the MeetingPoint server daemon could not 
               be reached.  Typical causes are an incorrect or unreachable DNS name 
               or IP address or a MeetingPoint server daemon that is not running 
               (on purpose or due to a software  issue).  
        :raises ValueError|TypeError: When the *<port>* parameter is provided and is no 
               integer.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           meetingpoint = bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')


        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  
        :rtype: MeetingPoint

        :raises MeetingPointUnreachable: When the MeetingPoint server daemon could not 
               be reached.  Typical causes are an incorrect or unreachable DNS name 
               or IP address or a MeetingPoint server daemon that is not running 
               (on purpose or due to a software  issue).  
        :raises ValueError|TypeError: When the *<port>* parameter is provided and is no 
               integer.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           meetingpoint = bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')


        """
        return _byteblower.ByteBlower_MeetingPointAdd(self, *args)

    def MeetingPointGet(self):
        r"""

        Returns all Meeting Point connections within this API instance.  

        .. versionadded:: 2.6.0  

        :return: a list with objects created within this API  instance. Can be empty  
        :rtype: MeetingPointList

        See :meth:`MeetingPointAdd` for more information  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           meetingPoints = bb.MeetingPointGet()


        """
        return _byteblower.ByteBlower_MeetingPointGet(self)

    def MeetingPointRemove(self, inMeetingPoint):
        r"""

        Disconnects from the ByteBlower MeetingPoint.

        :param meetingpoint: The MeetingPoint to disconnect from
        :type meetingpoint: MeetingPoint

        See :meth:`MeetingPointAdd` for more information.

        .. note:: This will invalidate all created objects on this ByteBlower 
        MeetingPoint!

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           meetingpoint = bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           bb.MeetingPointRemove(meetingpoint)


        """
        return _byteblower.ByteBlower_MeetingPointRemove(self, inMeetingPoint)

    def MeetingPointRemoveAll(self):
        r"""

        Disconnects from all ByteBlower MeetingPoints.  

        See :meth:`MeetingPointRemove` for more information.

        .. note:: This will invalidate all created objects on this ByteBlower MeetingPoint!

        Example

        .. code-block:: python
           :emphasize-lines: 5

           from byteblowerll import byteblower as api
           bb = api.ByteBlower.InstanceGet()
           meetingpoint = bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           # ..
           bb.MeetingPointRemoveAll()


        """
        return _byteblower.ByteBlower_MeetingPointRemoveAll(self)

    def ServerCount(self):
        r"""

        Counts the number of server objects created.  

        :return: the number of :class:`.ByteBlowerServer` objects
        :rtype: int 

        See :meth:`ServerAdd` for more information.  

        Example

        .. code-block:: python

           server = bb.ServerCount()


        """
        return _byteblower.ByteBlower_ServerCount(self)

    def PortsStart(self, inPorts):
        r"""

        Starts all traffic streams and application schedules on the specified ByteBlower ports.  

        :param ports: a list of :class:`.ByteBlowerPort` objects to start.
        :type ports: ByteBlowerPortList

        More specifically, for each traffic stream and schedulable object on the 
        specified ports, the configured *time to wait* kicks off and when this time has
        passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or sending out a multicast 
        join message or HTTP request. See :class:`.Stream` and :meth:`SchedulesStart` 
        for more information.  

        Streams or schedulable objects that are already scheduled and streams that are
        already active are ignored. Schedulable objects that are already stopped are 
        scheduled again. See :meth:`SchedulesStart` for more information.  

        If a port does not contain any streams or schedules, nothing happens for that port.   

        Example

        .. code-block:: python
           :emphasize-lines: 1

           bb.PortsStart()


        """
        return _byteblower.ByteBlower_PortsStart(self, inPorts)

    def PortsStop(self, inPorts):
        r"""

        Stops all traffic streams and application schedules on the specified ByteBlower ports.  

        :param args: Zero, one or more ByteBlowerPort objects on which to abort 
                     traffic streams and application schedules.  
        :type args: ByteBlowerPortList

        More specifically, all traffic streams and schedulable objects that are 
        currently scheduled are cancelled and all active traffic streams are stopped. 
        Since schedulable objects are only active for an instant, aborting these is not
        possible.  

        For more information about schedulable objects, see :meth:`SchedulesStart`.  

        Streams and schedules that are not running are ignored. This may be because 
        they have not yet started or because they are already finished or stopped.  

        If a port does not contain any streams or schedules, nothing happens for that 
        port.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           bb.PortsStop()


        """
        return _byteblower.ByteBlower_PortsStop(self, inPorts)

    def PortsStartAll(self):
        r"""

        Starts all traffic streams and application schedules on all created ByteBlower Ports.

        See :meth:`PortsStart` for more information.


        """
        return _byteblower.ByteBlower_PortsStartAll(self)

    def PortsStopAll(self):
        r"""

        Stops all traffic streams and application schedules on all created ByteBlower Ports.

        See :meth:`PortsStop` for more information.


        """
        return _byteblower.ByteBlower_PortsStopAll(self)

    def WirelessEndpointsStart(self, inWirelessEndpoints):
        r"""

        Starts all traffic streams and application schedules on the specified ByteBlower Endpoints.  

        :param endpoints: list with zero, one or more :class:`WirelessEndpoint` objects
                          on which to start traffic streams and application schedules.  
        :type endpoints: WirelessEndpointList

        :raises TechnicalError: When the items in *<wirelessEndpoints>* are spread across multiple MeetingPoints.  

        More specifically, for each traffic stream and trigger object on the specified 
        endpoints, the configured *time to wait* kicks off and when this time has 
        passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or HTTP request. See 
        :class:`.StreamMobile` for more information.  If a ByteBlower endpoint does not
        contain any streams or schedules, nothing happens for that ByteBlower Endpoint.  


        """
        return _byteblower.ByteBlower_WirelessEndpointsStart(self, inWirelessEndpoints)

    def WirelessEndpointsStartAndWait(self, inWirelessEndpoints):
        r"""

        Starts all traffic streams and application schedules on the specified ByteBlower Endpoints And waits until the devices are started.  

        :param endpoints: Zero, one or more WirelessEndpont objects on which to start traffic streams and application schedules.  
        :type endpoints: WirelessEndpointList

        :raises TechnicalError: When the items in *<wirelessEndpoints>* are spread across multiple MeetingPoints.  

        More specifically, for each traffic stream and trigger object on the specified 
        endpoints, the configured *time to wait* kicks off and when this time has 
        passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or HTTP request. 
        See :class:`.StreamMobile` for more information.  

        If a ByteBlower endpoint does not contain any streams or schedules, nothing 
        happens for that ByteBlower Endpoint.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           bb.WirelessEndpointsStartAndWait()


        """
        return _byteblower.ByteBlower_WirelessEndpointsStartAndWait(self, inWirelessEndpoints)

    def WirelessEndpointsPrepare(self, inWirelessEndpoints):
        r"""

        Prepares all the specified ByteBlower Endpoints.  

        :param endpoints: a list with zero, one or more WirelessEndpoint objects to 
                          prepare.  
        :type endpoints: WirelessEndpointList

        :raises TechnicalError: When the items in  *<wirelessEndpoints>* are spread 
                                across multiple MeetingPoints.  

        If a ByteBlower Endpoint does not contain any streams or schedules, nothing 
        happens for that ByteBlower Endpoint.  


        """
        return _byteblower.ByteBlower_WirelessEndpointsPrepare(self, inWirelessEndpoints)

    def WirelessEndpointsPrepareAsync(self, inWirelessEndpoints):
        r"""

        Prepares all the specified ByteBlower Endpoints in an asynchronious way.  

        :param endpoints: a list with zero, one or more WirelessEndpoint objects to 
                          prepare.  
        :type endpoints: WirelessEndpointList

        :raises TechnicalError: When the items in *<endpoints>* are spread across 
                                multiple MeetingPoints.  

        If a ByteBlower endpoint does not contain any streams or schedules, nothing 
        happens for that ByteBlower Endpoint.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           bb.WirelessEndpointsPrepareAsync()


        """
        return _byteblower.ByteBlower_WirelessEndpointsPrepareAsync(self, inWirelessEndpoints)

    def ResultsRefresh(self, inResults):
        r"""

        Refreshes multiple result objects.  

        .. versionadded:: 2.2

        :param results: A list of refreshable results
        :type results: AbstractRefreshableResultList

        Sometimes you want to refresh a lot of results-objects at the same time. You can refresh all those objects in one API call. The results will be batched per server and then refreshed.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           bb.ResultsRefresh()


        """
        return _byteblower.ByteBlower_ResultsRefresh(self, inResults)

    def SchedulesStart(self, inSchedules):
        r"""

        Starts the specified schedulable objects.  

        :param schedules: Zero, one or more schedulable objects to start.  
        :type schedules: ScheduleList

        More specifically, all specified schedulable objects have their *time to wait* 
        period kick off simultaneously and when this time has passed the corresponding 
        action is performed.  

        Typical actions include sending out a multicast join message or an HTTP 
        request. All schedulable objects are listed below.  

        Schedulable objects that are already scheduled are ignored. Schedulable objects
        that are already finished or cancelled are scheduled again.  

        While re-scheduling them will always succeed (and this method will return 
        without error), executing them multiple times may result in error states in 
        other places.  For example, a :class:`HTTPClient` can only manage one HTTP 
        session and will refuse to send out a second HTTP request.   

        Different kinds of schedulable objects exist throughout the API. They are 
        returned by methods such as :meth:`Igmpv1MemberSession.ScheduleAdd`.   

        After creating and configuring such schedules, they can be scheduled by either
        passing them to this method or by passing the port(s) on which they were created to 
        :meth:`PortsStart`.  

        The following schedulable object types are available in the API:

        - :class:`IGMPIPMulticastListen`
        - :class:`IGMPJoin`
        - :class:`IGMPLeave`  

        .. note:: Bug: HTTP requests are not yet available as a schedulable object and 
                    cannot be used with this method. 

        Example

        .. code-block:: python
           :emphasize-lines: 1

           bb.SchedulesStart()


        """
        return _byteblower.ByteBlower_SchedulesStart(self, inSchedules)

    def SchedulesStop(self, inSchedules):
        r"""

        Stops the specified schedulable objects.  

        :param inSchedules: Zero, one or more schedulable objects to abort.  
        :type inSchedules: ScheduleList

        More specifically, all specified schedulable objects that are currently 
        scheduled are cancelled. Schedulable objects are only active for an instant, so
        actually aborting them is not possible.  

        For more information about schedulable objects, see :meth:`SchedulesStart`.  

        Schedules that are not running are ignored. This may be because they have not
        yet started or because they are already finished or cancelled.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           bb.SchedulesStop()


        """
        return _byteblower.ByteBlower_SchedulesStop(self, inSchedules)

    def ScheduleGroupCreate(self):
        r"""

        Create a ScheduleGroup.  

        :rtype: ScheduleGroup

        Example

        .. code-block:: python
           :emphasize-lines: 1

           bb.ScheduleGroupCreate()


        """
        return _byteblower.ByteBlower_ScheduleGroupCreate(self)

    def ScheduleGroupGet(self):
        r"""

        Returns all existing ScheduleGroups.  

        :rtype: ScheduleGroupList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup = bb.ScheduleGroupGet('byteblower-1.lab.byteblower.com')


        """
        return _byteblower.ByteBlower_ScheduleGroupGet(self)

    @staticmethod
    def DestroyInstance():
        r"""

        Destroy the ByteBlower API Instance

        .. warning:: 
           This will destroy all created API objects.  

           This will cause all handles to created ByteBlower objects to render invalid. 

           Bug: accessing invalid handles will most likely crash your  pplication


        """
        return _byteblower.ByteBlower_DestroyInstance()

# Register ByteBlower in _byteblower:
_byteblower.ByteBlower_swigregister(ByteBlower)

def BB():
    return _byteblower.BB()
class User(AbstractObject):
    r"""

    A user connected to the ByteBlower server

    A User represents a connection between an API instance and a ByteBlower Port.

    This can be queried as following:

    .. code-block:: python

        from byteblowerll.byteblower import ByteBlower
        instance = ByteBlower.InstanceGet()
        server = instance.ServerAdd('byteblower-1.excentis.com')
        users = server.UsersGet()

        for user in users:
            print(user.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NameGet(self):
        r"""

        Returns the name of the API which has a ByteBlower Port on this interface.

        :rtype: str


        """
        return _byteblower.User_NameGet(self)

    def InterfaceGet(self):
        r"""

        Returns the interface on which the API has a ByteBlower Port on.

        :rtype: str


        """
        return _byteblower.User_InterfaceGet(self)

# Register User in _byteblower:
_byteblower.User_swigregister(User)
class UserMobile(AbstractObject):
    r"""

    A user connected to the ByteBlower MeetingPoint

    A User represents a connection between an API instance and a ByteBlower Endpoint.

    This can be queried as following:

    .. code-block:: python

        from byteblowerll.byteblower import ByteBlower
        instance = ByteBlower.InstanceGet()
        meetingpoint = instance.MeetingPointAdd('byteblower-1.excentis.com')
        users = meetingpoint.UsersGet()

        for user in users:
            print(user.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NameGet(self):
        r"""

        Returns the name of the API which has a WirelessEndpoint with the given UUID.

        :rtype: str


        """
        return _byteblower.UserMobile_NameGet(self)

    def UUIDGet(self):
        r"""

        Returns the UUID on which the API has a WirelessEndpoint object on.

        :rtype: str


        """
        return _byteblower.UserMobile_UUIDGet(self)

# Register UserMobile in _byteblower:
_byteblower.UserMobile_swigregister(UserMobile)
class StreamResultSnapshot(AbstractRefreshableResult):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_snapshot.TimestampGet())


        """
        return _byteblower.StreamResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_snapshot.TimestampFirstGet())


        """
        return _byteblower.StreamResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_snapshot.TimestampLastGet())


        """
        return _byteblower.StreamResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the transmitted packets.

        :rtype: int

        Example

        This example gets the transmitted packets

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_snapshot.PacketCountGet())


        """
        return _byteblower.StreamResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current transmitted bytes.

        :rtype: int

        Example

        This example gets the transmitted bytes

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_snapshot.ByteCountGet())


        """
        return _byteblower.StreamResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest frame size transmitted in this snapshot.

        .. versionadded:: 2.5.0

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_snapshot.FramesizeMaximumGet())


        """
        return _byteblower.StreamResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the smallest frame size transmitted in this snapshot.

        .. versionadded:: 2.5.0

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the smallest frame size transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_snapshot.FramesizeMinimumGet())


        """
        return _byteblower.StreamResultSnapshot_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_snapshot.IntervalDurationGet())


        """
        return _byteblower.StreamResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_snapshot.RefreshTimestampGet())


        """
        return _byteblower.StreamResultSnapshot_RefreshTimestampGet(self)

# Register StreamResultSnapshot in _byteblower:
_byteblower.StreamResultSnapshot_swigregister(StreamResultSnapshot)
class StreamResultData(AbstractObject):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.TimestampGet())


        """
        return _byteblower.StreamResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Gets the timestamp of the first transmitted packet in this snapshot

            print(streamData.TimestampLastGet())


        """
        return _byteblower.StreamResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.TimestampLastGet())


        """
        return _byteblower.StreamResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the transmitted packets.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the transmitted packets

            print(streamData.PacketCountGet())


        """
        return _byteblower.StreamResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current transmitted bytes.

        :rtype: int

        Example

        This example gets the transmitted bytes

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.ByteCountGet())


        """
        return _byteblower.StreamResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest framesize transmitted in this snapshot.

        .. versionadded:: 2.6.4

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the largest framesize transmitted in this snapshot

            print(streamData.FramesizeMaximumGet())


        """
        return _byteblower.StreamResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the smallest framesize transmitted in this snapshot

        .. versionadded:: 2.6.4

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the smallest framesize transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.FramesizeMinimumGet())


        """
        return _byteblower.StreamResultData_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.IntervalDurationGet())


        """
        return _byteblower.StreamResultData_IntervalDurationGet(self)

# Register StreamResultData in _byteblower:
_byteblower.StreamResultData_swigregister(StreamResultData)
class StreamResultList(object):
    r"""

    This is a List of multiple StreamResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamResultList___bool__(self)

    def __len__(self):
        return _byteblower.StreamResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamResultList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.StreamResultList_swiginit(self, _byteblower.new_StreamResultList(*args))
    __swig_destroy__ = _byteblower.delete_StreamResultList

# Register StreamResultList in _byteblower:
_byteblower.StreamResultList_swigregister(StreamResultList)
class StreamResultHistory(AbstractRefreshableResult):
    r"""

    Sender-side transmit result history.

    .. versionadded:: 2.1.0

    The history contains the sender information in time since the object is created
    or refreshed.

    ..note:: The information is not updated until :obj:`~.AbstractObject.Refresh`
             is called on this object.

    A Stream history result object can be created via a :class:`Stream`, using
    :meth:`Stream.ResultHistoryGet`

    .. note:: See History result for more information

    Example

    Get the counters per *sampling interval* for the stream result history.

    .. code-block:: python
       :emphasize-lines: 1

       stream_result_history = stream.ResultHistoryGet()
       print(stream_snapshot.TimestampFirstGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return: int Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.SamplingIntervalDurationGet())


        """
        return _byteblower.StreamResultHistory_SamplingIntervalDurationGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        :return: The length of the server sample buffer
        :rtype: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.SamplingBufferLengthGet())


        """
        return _byteblower.StreamResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. versionadded:: 2.3.0

        :param duration: Duration of a single snapshot in nanoseconds
        :type duration: int

        .. warning:: The previously collected history will be invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            stream_result_history.SamplingIntervalDurationSet(3000000)


        """
        return _byteblower.StreamResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        .. versionadded:: 2.3.0

        :param length: Number of samples to keep in the server-side buffer
        :type length: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            stream_result_history.SamplingBufferLengthSet(5)


        """
        return _byteblower.StreamResultHistory_SamplingBufferLengthSet(self, inLength)

    def Clear(self):
        r"""

        Clear the history.

        With each Refresh interval and cumulative counters are transferred from Server 
        to the Client. To remove all counter-objects in this history, you can execute 
        this method. Both Interval and Cumulative counter lists will be cleared.

        Example

        Clear the History.

        .. code-block:: python
           :emphasize-lines: 1

           stream_result_history.Clear()


        """
        return _byteblower.StreamResultHistory_Clear(self)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.

        :return: a list of :class:`.StreamResultData` objects containing the Cumulative counters
        :rtype: StreamResultList

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        Example
        This example gets the available accumulated results

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_result_history.CumulativeGet()[0].DescriptionGet())


        """
        return _byteblower.StreamResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: index
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: StreamResultData

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           print(stream_snapshot.CumulativeGetByIndex(1).DescriptionGet())


        """
        return _byteblower.StreamResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.

        .. versionadded:: 2.2.0

        :param timestamp: timestamp in nanoseconds
        :type timestamp: int

        :rtype: StreamResultData

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_result_history.CumulativeGetByTime(1432805398000000000))


        """
        return _byteblower.StreamResultHistory_CumulativeGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        .. versionadded:: 2.2.0

        :rtype: StreamResultData

        Example

        This example gets the latest closed Cumulative counter object

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.CumulativeLatestGet().DescriptionGet())


        """
        return _byteblower.StreamResultHistory_CumulativeLatestGet(self)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream_result_history.CumulativeLengthGet())


        """
        return _byteblower.StreamResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        :return: A list of :class:`StreamResultData` containing the Interval counters
        :rtype: StreamResultList

        Each result object contains interval counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

           stream_result_history.IntervalGet()


        """
        return _byteblower.StreamResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: index
        :type index: int

        :return: interval counter object at the specified index
        :rtype: StreamResultData

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalGetByIndex(1).DescriptionGet())


        """
        return _byteblower.StreamResultHistory_IntervalGetByIndex(self, index)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        .. versionadded:: 2.2.0

        :param timestamp: timestamp in nanoseconds
        :type timestamp: int

        :rtype: StreamResultData

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           interval = stream_result_history.IntervalGetByTime(1432805398000000000)


        """
        return _byteblower.StreamResultHistory_IntervalGetByTime(self, timestamp)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        .. versionadded:: 2.2.0

        :rtype: StreamResultData

        Example

        This example gets the latest closed Interval counter object

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalLatestGet().DescriptionGet())


        """
        return _byteblower.StreamResultHistory_IntervalLatestGet(self)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalLengthGet())


        """
        return _byteblower.StreamResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history was refreshed.

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        This is the timestamp on the server when the last time 
        :obj:`~.AbstractObject.Refresh` was called on this object.

        Example

        This example gets the Refresh timestamp

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.RefreshTimestampGet())


        """
        return _byteblower.StreamResultHistory_RefreshTimestampGet(self)

# Register StreamResultHistory in _byteblower:
_byteblower.StreamResultHistory_swigregister(StreamResultHistory)
class StreamRuntimeStatus(AbstractRefreshableResult):
    r"""

    Status information about a Stream

    A stream has some runtime status information:

    Is the stream running (:meth:`StatusGet`)?

    If not, was there an error (:meth:`ErrorStatusGet`)?

    If so, where did the error came from (:meth:`ErrorSourceGet`)?

    Example

    .. code-block:: python

       # stream is configured to transmit for 1 second

       status = stream.StatusGet()
       print('Stream stopped?', status.StatusGet() == TransmitStatus.INACTIVE)

       stream.Start()

       status.Refresh()
       print('Stream started?', status.StatusGet() == TransmitStatus.ACTIVE)   

       time.sleep(1)

       status.Refresh()
       print('Stream stopped?', status.StatusGet() == TransmitStatus.INACTIVE)   


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    transmit_error_status_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_status_UNKNOWN
    transmit_error_status_NONE = _byteblower.StreamRuntimeStatus_transmit_error_status_NONE
    transmit_error_status_OUT_OF_RESOURCES = _byteblower.StreamRuntimeStatus_transmit_error_status_OUT_OF_RESOURCES
    transmit_error_source_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_source_UNKNOWN
    transmit_error_source_NONE = _byteblower.StreamRuntimeStatus_transmit_error_source_NONE
    transmit_error_source_INTERFACE_HARDWARE = _byteblower.StreamRuntimeStatus_transmit_error_source_INTERFACE_HARDWARE
    transmit_error_source_SCHEDULING_CONFLICT = _byteblower.StreamRuntimeStatus_transmit_error_source_SCHEDULING_CONFLICT
    transmit_error_source_TXUSER = _byteblower.StreamRuntimeStatus_transmit_error_source_TXUSER
    transmit_status_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_status_UNKNOWN
    transmit_status_INACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_INACTIVE
    transmit_status_ACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_ACTIVE

    def StatusGet(self):
        r"""

        Returns the stream status.  

        :return: The current status of the stream.
        :rtype: TransmitStatus

        This way one can determine if a stream is still running or whether the stream 
        finished


        """
        return _byteblower.StreamRuntimeStatus_StatusGet(self)

    def ErrorStatusGet(self):
        r"""

        Returns error information.

        :return: The error information of the stream if applicable.
        :rtype: TransmitErrorStatus

        A stream can finish without issues, but can also run into error conditions.
        One of those error conditions is e.g. *Out-Of-Resources*.   This means that
        one tries to transmit e.g. more than 1Gbps over a 1Gbps link.


        """
        return _byteblower.StreamRuntimeStatus_ErrorStatusGet(self)

    def ErrorSourceGet(self):
        r"""

        Returns error source information.  

        :return: The source of the error.
        :rtype: TransmitErrorSource

        If :meth:`ErrorStatusGet` does not return :attr:`TransmitErrorStatus.NONE`, the
        returned value of this method will indicate a reason why the error state is 
        returned.


        """
        return _byteblower.StreamRuntimeStatus_ErrorSourceGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the information was last queried on the server.

        :return: The timestamp since epoch in nanoseconds
        :rtype: int

        .. code-block:: python
           :emphasize-lines: 3, 8

           # ...
           status_object = stream.StatusGet()
           print(status_object.RefreshTimestampGet())
           # Prints: 1559736027345545000

           time.sleep(1)

           print(status_object.RefreshTimestampGet())
           # Prints: 1559736028345545000


        """
        return _byteblower.StreamRuntimeStatus_RefreshTimestampGet(self)

# Register StreamRuntimeStatus in _byteblower:
_byteblower.StreamRuntimeStatus_swigregister(StreamRuntimeStatus)

def ConvertRuntimeTransmitStatus(inStatus):
    return _byteblower.ConvertRuntimeTransmitStatus(inStatus)

def ConvertRuntimeTransmitErrorStatus(inStatus):
    return _byteblower.ConvertRuntimeTransmitErrorStatus(inStatus)

def ConvertRuntimeTransmitErrorSource(inSource):
    return _byteblower.ConvertRuntimeTransmitErrorSource(inSource)
class Stream(AbstractObject):
    r"""

    A ByteBlower stream is an object representing a stream of ByteBlower frames (Frame) used for transmission on a ByteBlower port.

    A ByteBlower stream contains the following data:

    Frames
        A list of Frame objects

    NumberOfFrames
        The number of frames the stream should  transmit

    InterFrameGap
        The interval between 2 transmitted frames

    InitialTimeToWait
        An initial time to wait, if needed

    TimingModifier
        A timing modifier

    Example

    .. code-block:: python
       :emphasize-lines: 1
       :caption: A typical stream usage flow

       stream = port.TxStreamAdd()
       stream.NumberOfFramesSet(1000)
       stream.InterFrameGapSet(1000000)

       frame = stream.FrameAdd()
       # Configure the frame ...

       stream.Start()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NumberOfFramesGet(self):
        r"""

        Gets the configured number of frames the stream needs to transmit

        :return: The configured number of frames
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the number of frames configured on the stream.

           print(stream.NumberOfFramesGet())


        """
        return _byteblower.Stream_NumberOfFramesGet(self)

    def NumberOfFramesSet(self, nof):
        r"""

        Sets the number of frames the stream needs to transmit.

        This defines the number of frames a stream will send. -1 means continues.

        :param count: The number of frames to set. Use -1 to send infinitely.
        :type count: int

        .. note:: when count is set -1, keep in mind to stop the stream using
                  :meth:`Stop`

        Example

        This example sets the frame count of the stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the number frames to transmit to 1000

           stream.NumberOfFramesAdd(1000)


        """
        return _byteblower.Stream_NumberOfFramesSet(self, nof)

    def InterFrameGapGet(self):
        r"""

        Returns the inter-frame gap for the stream.

        :return: The inter-frame gap is returned in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: print the inter frame gap of the stream

           print(stream.InterFrameGapGet())


        """
        return _byteblower.Stream_InterFrameGapGet(self)

    def InterFrameGapSet(self, interFrameGap):
        r"""

        Sets the inter-frame gap for the stream.

        :param duration: Duration in nanoseconds
        :type duration: int

        Example

        This example sets the inter-frame gap on a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure the stream to send 10 frames per second

           stream.InterFrameGapSet(inter_frame_gap)


        """
        return _byteblower.Stream_InterFrameGapSet(self, interFrameGap)

    def InitialTimeToWaitGet(self):
        r"""

        Returns the time to wait before the first frame will be sent.

        :return: The initial time to wait in nanoseconds.
        :rtype: int

        Example

        This example gets the current initial time to wait from a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Print the initial time to wait for a stream

           print(stream.InitialTimeToWaitGet())


        """
        return _byteblower.Stream_InitialTimeToWaitGet(self)

    def InitialTimeToWaitSet(self, initTimeToWait):
        r"""

        Sets a delay before sending the first frame.

        :param duration: The duration in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: sets initial time to wait to 2 seconds

           stream.InitialTimeToWaitSet(wait)


        """
        return _byteblower.Stream_InitialTimeToWaitSet(self, initTimeToWait)

    def Start(self):
        r"""

        Starts the stream.

        The stream will be started when this method is called. This will also cause the
        results for the stream and attached frames to be cleared. The objects of the
        types below will thus be cleared.

        - :class:`.StreamResultSnapshot`
        - :class:`.StreamResultHistory`
        - :class:`.FrameResultSnapshot`
        - :class:`.FrameResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.Start()


        """
        return _byteblower.Stream_Start(self)

    def Stop(self):
        r"""

        Stops the stream.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.Stop()


        """
        return _byteblower.Stream_Stop(self)

    def ResultClear(self):
        r"""

        Resets the current result counters to zero and empties the ResultHistory.

        .. versionadded:: 2.1.0

        Calling this method causes the :class:`StreamResultSnapshot` and the
        :class:`.StreamResultHistory` to be reset.

        All counters will be set to zero and all historic data in the history will be
        removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: shows how ResultClear() affects the results from ResultGet()

           stream.ResultClear()


        """
        return _byteblower.Stream_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :return: The current cumulative stream result counters
        :rtype: StreamResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultGet().DescriptionGet())


        """
        return _byteblower.Stream_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        :rtype: StreamResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.Stream_ResultHistoryGet(self)

    def FrameAdd(self):
        r"""

        Adds a frame to the stream.

        :return: The freshly added frame
        :rtype: Frame

        Example

        This example adds a frame to a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Add a frame to the stream.

           frame = stream.FrameAdd()


        """
        return _byteblower.Stream_FrameAdd(self)

    def FrameGet(self):
        r"""

        Returns list of frames on this stream.

        :return: A list of added :class:`Frame` objects.
        :rtype: FrameList

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Iterate over the added frames and print their description

           for frame in stream.FrameGet():
               print(frame.DescriptionGet())


        """
        return _byteblower.Stream_FrameGet(self)

    def FrameDestroy(self, inFrame):
        r"""

        Removes a frame from the stream

        :param frame: The frame object to remove
        :type frame: Frame

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Iterate over the added frames and print their description

           stream.FrameDestroy(frame1)


        """
        return _byteblower.Stream_FrameDestroy(self, inFrame)

    def RandomSizeModifierAdd(self):
        r"""

        Adds a Random Size modifier to the stream

        .. deprecated:: 2.3.0
           This is deprecated.  Please use :meth:`.Frame.ModifierSizeRandomSet`

        .. note:: The name for this function is actually wrong.  A new size modifier
                  will replace existing size modifiers

        :return: The freshly created random size modifier
        :rtype: StreamRandomSizeModifier


        """
        return _byteblower.Stream_RandomSizeModifierAdd(self)

    def GrowingSizeModifierAdd(self):
        r"""

        Adds a Growing Size modifier to the stream

        .. deprecated:: 2.3.0
           This is deprecated.  Please use :meth:`.Frame.ModifierSizeGrowingSet`

        :return: The freshly created growing size modifier
        :rtype: StreamGrowingSizeModifier

        .. note:: The name for this function is actually wrong.  A new size modifier
                  will replace existing size modifiers


        """
        return _byteblower.Stream_GrowingSizeModifierAdd(self)

    def MultipleBurstModifierAdd(self):
        r"""

        Sets a burst modifier on the stream.

        :return: The freshly created modifier
        :rtype: MultipleBurstModifier

        This timing modifier will cause the stream to send *bursty* traffic.
        See :class:`MultipleBurstModifier` for configurable parameters.

        .. note:: The actual name of this method is wrong, a new modifier will remove a previous one.


        """
        return _byteblower.Stream_MultipleBurstModifierAdd(self)

    def NormalDistributionTimingModifierAdd(self):
        r"""

        Sets a normal distribution modifier on the stream.

        :return: The freshly created modifier
        :rtype: NormalDistributionTimingModifier

        See :class:`NormalDistributionTimingModifier` for configurable parameters.

        .. note:: The actual name of this method is wrong, a new modifier will remove a previous one.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the number of frames configured on the stream.

           normalDistribution = port.NormalDistributionTimingModifierAdd()


        """
        return _byteblower.Stream_NormalDistributionTimingModifierAdd(self)

    def ModifierFrameGet(self):
        r"""

        Gets the configured frame modifier

        .. deprecated: 2.3.0
           Instead of creating frame modifying objects on the stream, create them on
           the :class:`Frame` directly.
           See: :meth:`.Frame.ModifierSizeGrowingGet` and
           :meth:`Frame.ModifierSizeRandomGet`

        :return: The current frame modifier.
        :rtype: StreamGrowingSizeModifier|StreamRandomSizeModifier


        """
        return _byteblower.Stream_ModifierFrameGet(self)

    def ModifierFrameDestroy(self):
        r"""

        Destroys a frame modifier (e.g. size-modfier).

        .. deprecated: 2.3.0
           Instead of creating frame modifying objects on the stream, create them on
           the :class:`Frame` directly

        :param modifier: Modifier to remove
        :type modifier: StreamGrowingSizeModifier|StreamRandomSizeModifier


        """
        return _byteblower.Stream_ModifierFrameDestroy(self)

    def ModifierTimingGet(self):
        r"""

        Gets the configured timing modifier

        :return: Configured timing modifier
        :rtype: NormalDistributionTimingModifier | MultipleBurstModifier


        """
        return _byteblower.Stream_ModifierTimingGet(self)

    def ModifierTimingDestroy(self):
        r"""

        Removes a timing modifier

        :param modifier: Modifier to remove
        :type modifier: NormalDistributionTimingModifier | MultipleBurstModifier


        """
        return _byteblower.Stream_ModifierTimingDestroy(self)

    def StatusGet(self):
        r"""

        Returns status information.

        :rtype: StreamRuntimeStatus

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.StatusGet()


        """
        return _byteblower.Stream_StatusGet(self)

# Register Stream in _byteblower:
_byteblower.Stream_swigregister(Stream)
class StreamMobile(AbstractObject):
    r"""

    A StreamMobile object configures a stream of frames that will be transmitted by a
    WirelessEndpoint.

    .. versionadded:: 2.6.0

    The StreamMobile object allows you to add frame objects (:class:`FrameMobile`)
    and configure parameters like the number of frames that will be transmitted,
    the inter-frame gap and the initial time to wait before transmission.

    Example

    .. code-block:: python
       :caption: Typical usage flow

       frame_size = 1000  # bytes

       stream = wirelessEndpoint.TxStreamAdd()
       stream.NumberOfFramesSet(100)

       # Transmit at 10 frames per second, which is 100 milliseconds per frame
       stream.InterFrameGapSet(10000000)

       stream.DestinationAddressSet('192.168.0.2')
       stream.DestinationPortSet(4000)
       stream.SourcePortSet(4001)

       # Add a frame
       frame = stream.FrameAdd()

       # ... configure the frame, see FrameMobile documentation for this.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NumberOfFramesGet(self):
        r"""

        Returns the number of frames that will be transmitted by a stream.

        :return: the number of frames that will be transmitted by the stream
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the number of frames to be transmitted by a stream

           print(stream.NumberOfFramesGet())


        """
        return _byteblower.StreamMobile_NumberOfFramesGet(self)

    def NumberOfFramesSet(self, nof):
        r"""

        Sets the number of frames sent by a stream.

        :param count: The number of frames to send.
        :type count: int

        This method configures the number of frames a stream will transmit.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example sets the frame count of the stream.

           stream.NumberOfFramesSet(1000)


        """
        return _byteblower.StreamMobile_NumberOfFramesSet(self, nof)

    def InterFrameGapGet(self):
        r"""

        Returns the inter-frame gap for the stream.

        :return: The inter-frame gap is returned in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the inter-frame gap of a stream

           print(stream.InterFrameGapGet())


        """
        return _byteblower.StreamMobile_InterFrameGapGet(self)

    def InterFrameGapSet(self, interFrameGap):
        r"""

        Sets the inter-frame gap for the stream.

        :param duration: duration in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the inter-frame gap to 100ms

           stream.InterFrameGapSet(gap)


        """
        return _byteblower.StreamMobile_InterFrameGapSet(self, interFrameGap)

    def InitialTimeToWaitGet(self):
        r"""

        Returns the time to wait before the first frame will be sent.

        :return: The initial time to wait in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: get the current initial time to wait

           print(stream.InitialTimeToWaitGet())


        """
        return _byteblower.StreamMobile_InitialTimeToWaitGet(self)

    def InitialTimeToWaitSet(self, initTimeToWait):
        r"""

        Sets a delay before sending the first frame.

        :param duration: The amount of time to wait before sending the first frame
                         Unit is in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: set the initial time to wait to 2 seconds

           stream.InitialTimeToWaitSet(wait)


        """
        return _byteblower.StreamMobile_InitialTimeToWaitSet(self, initTimeToWait)

    def ResultClear(self):
        r"""

        Clears the results.

        .. note:: This affects the all results for a stream.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Resets the current result counters to zero.

           stream.ResultClear()


        """
        return _byteblower.StreamMobile_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :return: The cumulative results for the stream
        :rtype: StreamResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultGet().DescriptionGet())


        """
        return _byteblower.StreamMobile_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        :return: The history counters for the stream
        :rtype: StreamResultHistory

        .. code-block:: python
           :emphasize-lines: 1

           history = stream.ResultHistoryGet()


        """
        return _byteblower.StreamMobile_ResultHistoryGet(self)

    def FrameAdd(self):
        r"""

        Adds a frame to the stream.

        :return: The newly created frame
        :rtype: FrameMobile

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example adds a frame to a stream.

           stream.FrameAdd()


        """
        return _byteblower.StreamMobile_FrameAdd(self)

    def FrameGet(self):
        r"""

        Returns list of frames on this stream.

        :return: A list of all configured frames on the stream
        :rtype: FrameMobileList

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints all configured frames on a stream

           for frame in stream.FrameGet():
               print(frame.DescriptionGet())


        """
        return _byteblower.StreamMobile_FrameGet(self)

    def FrameDestroy(self, inFrame):
        return _byteblower.StreamMobile_FrameDestroy(self, inFrame)

    def SourcePortSet(self, inPort):
        r"""

        Sets the source port in the UDP header of the frames that will be transmitted.

        :param port: The UDP source port number for the transmitted frames (1-65535)
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.SourcePortSet(8000)


        """
        return _byteblower.StreamMobile_SourcePortSet(self, inPort)

    def SourcePortGet(self):
        r"""

        Returns the source port in the UDP header of the frames that will be
        transmitted.

        :return: The UDP source port
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example gets the UDP source port of a stream

           print('UDP source:', stream.SourcePortGet())


        """
        return _byteblower.StreamMobile_SourcePortGet(self)

    def DestinationAddressSet(self, inAddress):
        r"""

        Sets the destination address in the IP header of the frames that will be
        transmitted.

        :param address: The destination IPv4 or IPv6 address to send the frames to.
        :type address: str

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: set an IPv4 destination

           stream.DestinationAddressSet('192.168.0.4')


        """
        return _byteblower.StreamMobile_DestinationAddressSet(self, inAddress)

    def DestinationAddressGet(self):
        r"""

        Returns the destination address in the IP header of the frames that will be
        transmitted.

        :return: the Destination IP address the frames will be sent to
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.DestinationAddressGet())


        """
        return _byteblower.StreamMobile_DestinationAddressGet(self)

    def DestinationPortSet(self, inDestinationPort):
        r"""

        Sets the destination port in the UDP header of the frames that will be
        transmitted.

        :param portnumber: UDP destination port to send the frame to (1-65535)
        :type portnumber: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.DestinationPortSet(4000)


        """
        return _byteblower.StreamMobile_DestinationPortSet(self, inDestinationPort)

    def DestinationPortGet(self):
        r"""

        Returns the destination port in the UDP header of the frames that will be
        transmitted.

        :return: The UDP destination port that will be used.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.DestinationPortGet())


        """
        return _byteblower.StreamMobile_DestinationPortGet(self)

    def TypeOfServiceGet(self):
        r"""

        Returns the type-of-service field (or TOS bits) in the IP header of the frames
        that will be transmitted.

        :return: The contents of the Type-Of-Service field.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example gets the current TOS field.

           print('TOS set to:', stream.TypeOfServiceGet())


        """
        return _byteblower.StreamMobile_TypeOfServiceGet(self)

    def TypeOfServiceSet(self, inTos):
        r"""

        Sets the type-of-service field (or TOS bits) in the IP header of the frames
        that will be transmitted.

        :param tos: The contents of the type-of-service field in the IP header
        :type tos: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.TypeOfServiceSet(2)


        """
        return _byteblower.StreamMobile_TypeOfServiceSet(self, inTos)

# Register StreamMobile in _byteblower:
_byteblower.StreamMobile_swigregister(StreamMobile)
class Schedule(AbstractObject):
    r"""

    This class contains the base functionality to configure a scheduled action.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InitialTimeToWaitGet(self):
        r"""

        Returns the time when the action is scheduled. This time is set using
        :meth:`InitialTimeToWaitSet` At that time, the first frame will be sent.

        :return: The initial time to wait in nanoseconds.
        :rtype: int


        """
        return _byteblower.Schedule_InitialTimeToWaitGet(self)

    def InitialTimeToWaitSet(self, ns):
        r"""

        Sets the time when the action will be scheduled. That is, when the first frame
        will be sent.

        :param time: The time when the action will be scheduled.
                     Valid range: 0 to *max_uint64* [ns]
        :type time: int

        Sets the initial time to wait before the first frame will be sent. By default,
        the unit has a nanosecond resolution. But you can also provide a time unit.

        The schedule can be started using :meth:`Start`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the initial time to wait to 9 nanoseconds

           schedule.InitialTimeToWaitSet(9)


        """
        return _byteblower.Schedule_InitialTimeToWaitSet(self, ns)

    def Prepare(self):
        r"""

        This method will prepare all the schedule, but NOT start it.

        Example

        Preparing the schedule

        .. code-block:: python
           :emphasize-lines: 1

           schedule.Prepare()


        """
        return _byteblower.Schedule_Prepare(self)

    def Start(self):
        r"""

        Starts the scheduled action.

        The first packet will be sent after the initial time to wait.


        """
        return _byteblower.Schedule_Start(self)

    def Stop(self):
        r"""

        Stops the running scheduled action.

        If the action has not been started, nothing will happen.


        """
        return _byteblower.Schedule_Stop(self)

# Register Schedule in _byteblower:
_byteblower.Schedule_swigregister(Schedule)
class Rx(AbstractObject):
    r"""

    Base class for Frame blasting receive side triggers.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FilterSet(self, inFilter):
        r""":meta private:"""
        return _byteblower.Rx_FilterSet(self, inFilter)

    def FilterGet(self):
        r""":meta private:"""
        return _byteblower.Rx_FilterGet(self)

# Register Rx in _byteblower:
_byteblower.Rx_swigregister(Rx)
class TaggedRx(Rx):
    r"""

    Base class for Frame blasting receive side triggers relying on frame alteration.

    These triggers include:

    - Latency
    - Out Of Sequence


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FrameTagGet(self):
        r"""

        Returns the FrameTagRx object related to this trigger.

        Each (transmitted) frame  can be enabled to have a time tag and/or an sequence
        tag inserted into the frame. The :class:`.FrameTagRx` object on this trigger
        can be used to define how that transmitted tag is processed.

        The FrameTag.Rx object which is returned by this method represents the current
        configuration of the frame tag processing. This object can be used to configure
        the processing of the injected frame tag.

        For more detailed information about Frame tagging, you can also take a look at
        ByteBlower API Knowledgebase: Background: Adding FrameTags to your ByteBlower
        frame - structure and behaviour

        .. warning:: On older ByteBlower servers, this requires a lot of resources, so
                     this option must be used with care.

        .. versionadded:: 1.8.18

        :rtype: FrameTagRx

        Example

        In this example, we will retrieve the FrameTagRx object for the frame tag:

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyTrigger.FrameTagGet().DescriptionGet())


        """
        return _byteblower.TaggedRx_FrameTagGet(self)

    def FrameTagSet(self, fromFrameTagTx):
        r"""

        Configure the FrameTag.Rx to match the given FrameTagTx.

        .. versionadded:: 1.8.18

        :param tag: The FrameTagTx to obtain the metrics and format configuration from.
        :type tag: FrameTagTx

        :raises: ByteBlower.Server.NotSupported - Unsupported Server Capability:
                 'Manage TX/RX Frame Tag placement': When a transmitted frame tag with
                 unsupported metrics and/or format is given.

        :raises: python_error - "FrameTag is of incorrect Type": When a transmitted
                 frame tag of invalid type is given (sequence vs. time)

        This method takes a :class:`FrameTagTx` and applies its metrics and format
        configuration on this trigger's :class:`.FrameTagRx`.

        .. note:: The transmitted frame tag type (sequence number, time stamp, ...)
                  must match the receiver frame tag type that is used for this trigger.

        The transmitted frame tag (sequence number, timestamp) can be obtained from the
        Frame (:meth:`Frame.FrameTagSequenceGet`, resp. :meth:`Frame.FrameTagTimeGet`)

        Example

        This example applies the transmitted time tag configuration on the receiver's
        time tag:

        .. code-block:: python
           :emphasize-lines: 1

              outOfSequence_trigger.FrameTagSet(frameTag)


        """
        return _byteblower.TaggedRx_FrameTagSet(self, fromFrameTagTx)

    def FrameTagDefaultSet(self):
        r"""

        Resets the receive-side frame tag to its server-default settings.

        This is implemented in the specific triggers


        """
        return _byteblower.TaggedRx_FrameTagDefaultSet(self)

# Register TaggedRx in _byteblower:
_byteblower.TaggedRx_swigregister(TaggedRx)
class Capture(Rx):
    r"""

    Abstract base class for a capture


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FileNameRemoteGet(self):
        return _byteblower.Capture_FileNameRemoteGet(self)

    def Start(self):
        return _byteblower.Capture_Start(self)

    def Stop(self):
        return _byteblower.Capture_Stop(self)

    def ResultGet(self):
        return _byteblower.Capture_ResultGet(self)

# Register Capture in _byteblower:
_byteblower.Capture_swigregister(Capture)
class SchedulableObject(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_SchedulableObject

    def ScheduleStart(self):
        return _byteblower.SchedulableObject_ScheduleStart(self)

    def ScheduleStop(self):
        return _byteblower.SchedulableObject_ScheduleStop(self)

    def ScheduleRemove(self, inSchedule):
        return _byteblower.SchedulableObject_ScheduleRemove(self, inSchedule)

    def ScheduleRemoveAll(self):
        return _byteblower.SchedulableObject_ScheduleRemoveAll(self)

    def ScheduleGet(self):
        return _byteblower.SchedulableObject_ScheduleGet(self)

    def ServerGet(self):
        return _byteblower.SchedulableObject_ServerGet(self)

# Register SchedulableObject in _byteblower:
_byteblower.SchedulableObject_swigregister(SchedulableObject)
class Layer25Configuration(AbstractObject):
    r"""

    Base class for the allowed Layer2.5 configuration objects


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register Layer25Configuration in _byteblower:
_byteblower.Layer25Configuration_swigregister(Layer25Configuration)
class DHCPv4SessionInfo(AbstractObject):
    r"""

    Class containing the info about the DHCPSession.

    This class represents the session info gathered from a DHCPSession. It will
    contain counters of the amount of DHCPMessages transmitted and received. It
    also contains some values of the obtained lease ( leasetime, GiAddr, SiAddr,
    OptionValues )

    .. code-block:: python
       :emphasize-lines: 2

       session_info = protocol.DHCPv4SessionInfoGet()
       for option in info.DHCPOptionGet():
          print(option)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxGet(self):
        r"""

        Returns the number of DHCPMessages transmitted.

        :return: Number of DHCP messages transmitted
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info)


        """
        return _byteblower.DHCPv4SessionInfo_TxGet(self)

    def RxGet(self):
        r"""

        Returns the number of DHCPMessages recieved.

        :return: Number of DHCP messages received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info)


        """
        return _byteblower.DHCPv4SessionInfo_RxGet(self)

    def DHCPOptionGet(self):
        r"""

        Returns a list if received DHCPOptions.

        :return: List of DHCPOptions in the form of OptionNumber-Value
        :rtype: Int64StringMap

        Example

        .. code-block:: python
           :emphasize-lines: 1

           for option in session_info.DHCPOptionGet:
              print(option)


        """
        return _byteblower.DHCPv4SessionInfo_DHCPOptionGet(self)

    def SiAddrGet(self):
        r"""

        Returns the IP address of next server to use in bootstrap.

        :return: next server IP address
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.SiAddrGet())


        """
        return _byteblower.DHCPv4SessionInfo_SiAddrGet(self)

    def GiAddrGet(self):
        r"""

        Returns the ipAddress of the relay agent, used in booting via a relay agent.

        :return: Relay agent IP address
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.GiAddrGet())


        """
        return _byteblower.DHCPv4SessionInfo_GiAddrGet(self)

    def DHCPServerAddrGet(self):
        r"""

        Returns the ipAddress of the DHCPServer.

        :return: Address of the DHCP server
        :rtype: str

        This address is parsed out of DHCPServerIdentifier option ( Option 54 )

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.DHCPServerAddrGet())


        """
        return _byteblower.DHCPv4SessionInfo_DHCPServerAddrGet(self)

    def LeaseTimeGet(self):
        r"""

        Returns IP Address lease time.

        :return: The leasetime in NanoSeconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.LeaseTimeGet())


        """
        return _byteblower.DHCPv4SessionInfo_LeaseTimeGet(self)

    def TransactionIDGet(self):
        r"""

        Returns the transaction ID used in this DHCP session.

        :rtype: str


        """
        return _byteblower.DHCPv4SessionInfo_TransactionIDGet(self)

    def DiscoverTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Discover message is sent.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.DiscoverTimestampLastGet())


        """
        return _byteblower.DHCPv4SessionInfo_DiscoverTimestampLastGet(self)

    def OfferTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Offer message is received.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.OfferTimestampLastGet())


        """
        return _byteblower.DHCPv4SessionInfo_OfferTimestampLastGet(self)

    def RequestTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Request message is sent.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RequestTimestampLastGet())


        """
        return _byteblower.DHCPv4SessionInfo_RequestTimestampLastGet(self)

    def AckTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Ack message is received.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.AckTimestampLastGet())


        """
        return _byteblower.DHCPv4SessionInfo_AckTimestampLastGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :return: RefreshTimestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RefreshTimestampGet())


        """
        return _byteblower.DHCPv4SessionInfo_RefreshTimestampGet(self)

# Register DHCPv4SessionInfo in _byteblower:
_byteblower.DHCPv4SessionInfo_swigregister(DHCPv4SessionInfo)
class DHCPv6SessionInfo(AbstractObject):
    r"""

    Class containing the info about the DHCPSession.

    This class represents the session info gathered from a DHCPv6Session. It will
    contain counters of the amount of DHCPMesseage transmitted and received.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxGet(self):
        r"""

        Returns the number of DHCPMessages transmitted.

        :return:  Number of DHCP messages transmitted
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcpSessionInfo.TxGet())


        """
        return _byteblower.DHCPv6SessionInfo_TxGet(self)

    def RxGet(self):
        r"""

        Returns the number of DHCPMessages recieved.

        :return:  Number of DHCP messages received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcpSessionInfo.RxGet())


        """
        return _byteblower.DHCPv6SessionInfo_RxGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the results are last retrieved from the server

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RefreshTimestampGet())


        """
        return _byteblower.DHCPv6SessionInfo_RefreshTimestampGet(self)

    def SolicitTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Solicit message is sent.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.SolicitTimestampLastGet())


        """
        return _byteblower.DHCPv6SessionInfo_SolicitTimestampLastGet(self)

    def AdvertiseTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Advertise message is received.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.AdvertiseTimestampLastGet())


        """
        return _byteblower.DHCPv6SessionInfo_AdvertiseTimestampLastGet(self)

    def RequestTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Request message is sent.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RequestTimestampLastGet())


        """
        return _byteblower.DHCPv6SessionInfo_RequestTimestampLastGet(self)

    def ReplyTimestampLastGet(self):
        r"""

        Returns the timestamp when the last DHCP Reply message is received.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.ReplyTimestampLastGet())


        """
        return _byteblower.DHCPv6SessionInfo_ReplyTimestampLastGet(self)

# Register DHCPv6SessionInfo in _byteblower:
_byteblower.DHCPv6SessionInfo_swigregister(DHCPv6SessionInfo)
class DHCPv4Protocol(AbstractObject):
    r"""

    This is the entry point to configure the DHCP client behavior of a ByteBlowerPort.

    A ByteBlowerPort can perform DHCP the get an IP address, gateway and netmask.
    Currently, no other options are supported but this will change in the future.

    Users can configure the timing parameters used in the different stages of the
    DHCP protocol:
    - Discover

      During the discover stage the ByteBlower port will broadcast discover
      messages.

    - Request

      Once one or more offers are received the ByteBlower port will broadcast its
      request message. If acknowledge the ByteBlower port will start using this
      address.

    - Renew

      When half of the lease time received in the acknowledge message of the
      request has passed, a ByteBlowerPort will sent a renew message to the server
      to extend its lease.

    Although DHCP allows clients to use unicast messages in the Request stage,
    ByteBlower currently only supports broadcast messages in this stage.

    A DHCPv4 Protocol also supports different retransmission strategies:

    Fixed
        This policy will use the same timeout value for each timeout.
    RFCSuggested
        This policy implements the policy described in :rfc:2131.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Perform(self):
        r"""

        Start DHCP and wait for the result.

        This method will force the DHCP client on the ByteBlower port to send a first
        DHCP discover message. It the client is already active, a new discover message
        will be sent. This is a synchronous call, so the full DHCPv6 solicit and
        request will be done once this call returns, or an error have occurred.

        :raises DHCPFailed: When no offer was received during the DHCP discover
                stage or when no DHCPAck was received during DHCPRequest stage

        Example

        This example will perform DHCP on the specified ByteBlowerPort.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.Perform()


        """
        return _byteblower.DHCPv4Protocol_Perform(self)

    def PerformAsync(self):
        r"""

        Will start DHCP and return immediately.

        .. versionadded:: 2.2

        This method will force the DHCP client on the ByteBlower port to send a first
        DHCP discover message. If the client is already active, a new discover message
        will be sent. This is a asynchronous call, so it will return immediately. If
        you want to see if there an exception occurred during this async, call the
        :meth:`Perform` method.

        Example

        This example will perform DHCP on the specified ByteBlowerPort.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.PerformAsync()


        """
        return _byteblower.DHCPv4Protocol_PerformAsync(self)

    def Release(self):
        r"""

        Release the DHCP lease.

        :return: This method will return nothing, but will return after DHCP Release is
                 performed
        :rtype: int

        This method will release the address previously received using DHCP. After
        this, the address will not be used anymore by the ByteBlower port and the DHCP
        server can reuse the address for other DHCP clients. Of course, packets sent by
        the ByteBlower port as part of streams can still use the address.
        Example

        This example will release the DHCP address.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.Release()


        """
        return _byteblower.DHCPv4Protocol_Release(self)

    def BroadcastFlagEnable(self, inValue):
        r"""

        Enables the DHCP broadcast flag

        .. versionadded:: 2.11.2

        :param enable: Whether or not to enable the Broadcast flag
        :type enable: bool

        When a ByteBlower port performs DHCP, the port will use the unicast DHCP method
        as described in the DHCP RFC.  Pre-2.11.2 ByteBlower servers used the legacy
        broadcast technique, which is sometimes detected by devices as a broadcast
        storm.

        Example

        This example will enable the Broadcast flag and thus the legacy behavour of the
        ByteBlower server

        .. code-block:: python
           :emphasize-lines: 2

           dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
           dhcp_protocol.BroadcastFlagEnable(True)
           print(dhcp_protocol.BroadcastFlagIsEnabled())


        """
        return _byteblower.DHCPv4Protocol_BroadcastFlagEnable(self, inValue)

    def BroadcastFlagIsEnabled(self):
        r"""

        Returns whether or not the broadcast flag is enabled.

        .. versionadded:: 2.11.2

        :return: Whether or not the flag is enabled
        :rtype: bool

        When a ByteBlower port performs DHCP, the port will use the unicast DHCP method
        as described in the DHCP RFC.  Pre-2.11.2 ByteBlower servers used the legacy
        broadcast technique, which is sometimes detected by devices as a broadcast
        storm.

        Example

        This example will enable the Broadcast flag and thus the legacy behavour of the
        ByteBlower server

        .. code-block:: python
           :emphasize-lines: 2

           dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
           dhcp_protocol.BroadcastFlagEnable(True)
           print(dhcp_protocol.BroadcastFlagIsEnabled())


        """
        return _byteblower.DHCPv4Protocol_BroadcastFlagIsEnabled(self)

    def ReleaseEnable(self, inValue):
        r"""

        Enable/disable sending DHCP release during destruction.

        :param enable: Boolean to enable or disable the release of the address at the
                       end of the test.
                       (Default: True)
        :type enable: bool

        When a ByteBlowerPort is destructed and this port has performed DHCP, such a
        port should release its address. If this behavior is prefered, then this should
        be done by using the Release.Enable method to indicate the ByteBlowerPort
        should release its address if possible. A ByteBlowerPort is able to release its
        address at destruction time if the destination mac address is in the
        ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be sent
        out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.ReleaseEnable(False)


        """
        return _byteblower.DHCPv4Protocol_ReleaseEnable(self, inValue)

    def ReleaseIsEnabled(self):
        r"""

        Return whether sending DHCP release during destruction is enabled.

        :return: If the port will release its IP at destruction
        :rtype: bool

        When a ByteBlowerPort is destructed and this port has performed DHCP, it should
        release its address. If this behavior is prefered, then this should be done by
        using the :meth:`ReleaseEnable` method to inidicate the ByteBlowerPort should
        release its address if possible. A ByteBlowerPort is able to release its
        address at destruction time if the destination mac address is in the
        ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be sent
        out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 2

           dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
           print(dhcp_protocol.ReleaseIsEnabled())


        """
        return _byteblower.DHCPv4Protocol_ReleaseIsEnabled(self)

    def RetransmissionPolicyGet(self):
        r"""

        Returns the current configured retransmission policy.

        :return: Current configured Retransmission Policy
                 (Default: :attr:`.RetransmissionPolicy.FixedTiming`)
        :rtype: RetransmissionPolicy

        This policy is used in calculating the timeout value for each outstanding
        message and is the same for all message types.

        Example

        This example will get the retransmission policy.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RetransmissionPolicyGet())


        """
        return _byteblower.DHCPv4Protocol_RetransmissionPolicyGet(self)

    def RetransmissionPolicySet(self, policy):
        r"""

        Configures the Retransmission Policy.

        :param policy: The policy to configure
                       (Default: :attr:`.RetransmissionPolicy.FixedTiming`)
        :type policy: RetransmissionPolicy

        The Retransmission Policy defines the timing for the DHCP messages.

        Example

        This example will set the retransmission policy to fixed timing.


        """
        return _byteblower.DHCPv4Protocol_RetransmissionPolicySet(self, policy)

    def DiscoverInitialTimeoutGet(self):
        r"""

        Returns the current *<InitialTimeout>* for the DHCP discover stage.

        :return:  Current '*<InitialTimeout>* value for the discover stage.
                  The unit is nanosecond (ns).
        :rtype: int

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The
        *<InitialTimeout>* is the timeout used to decide if the discover message must
        be retransmitted or not. The next timeout value will be calculated using the
        configured retransmission policy.

        Example

        This example will get the current *<InitialTimeout>* for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.DiscoverInitialTimeoutGet())


        """
        return _byteblower.DHCPv4Protocol_DiscoverInitialTimeoutGet(self)

    def DiscoverInitialTimeoutSet(self, inValue):
        r"""

        Sets the *<InitialTimeout>* for the DHCP discover stage.

        :param initial_timeout: New value for the initial timeout.
                                The unit is in nanosecond (ns), but the unit
        :type initial_timeout: int

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The
        *<InitialTimeout>* is the timeout used to decide if the discover message must
        be retransmitted or not. The next timeout value will be calculated using the
        configured retransmission policy.

        Example

        This example will set the *<InitialTimeout>* for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.DiscoverInitialTimeoutSet(2000000000)


        """
        return _byteblower.DHCPv4Protocol_DiscoverInitialTimeoutSet(self, inValue)

    def DiscoverMaxRetriesGet(self):
        r"""

        Returns the current maximum retries for the DHCP discover stage.

        :return: Current value for the number of retries in the discover stage.
        :rtype: int

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The maximum
        number of times the DHCP client will retransmit the discover message is
        returned by this method.

        Example

        This example will get the current maximum number of retries for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.DiscoverMaxRetriesGet())


        """
        return _byteblower.DHCPv4Protocol_DiscoverMaxRetriesGet(self)

    def DiscoverMaxRetriesSet(self, inValue):
        r"""

        Sets the maximum retries for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The maximum
        number of times the DHCP client will retransmit the discover message is
        configured by this method.

        :param maxRetries: The new value for the maximum number of retransmission of
                           the discover message.
        :type maxRetries: int

        Example

        This example will set the maximum number of retries for the discover stage to
        3 times.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.DiscoverMaxRetriesSet(3)


        """
        return _byteblower.DHCPv4Protocol_DiscoverMaxRetriesSet(self, inValue)

    def RequestInitialTimeoutGet(self):
        r"""

        Returns the current *<InitialTimeout>* for the DHCP request stage.

        :return: Current *<InitialTimeout>* value for the request stage.
                 The unit is nanosecond (ns).
        :rtype: int

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The *<InitialTimeout>*
        is the timeout used to decide if the request message must be retransmitted or
        not. The next timeout value will be calculated using the configured retransmission
        policy.

        Example

        This example will get the current *<InitialTimeout>* for the request stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RequestInitialTimeoutGet())


        """
        return _byteblower.DHCPv4Protocol_RequestInitialTimeoutGet(self)

    def RequestInitialTimeoutSet(self, inTime):
        r"""

        Sets the *<InitialTimeout>* for the DHCP request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The *<InitialTimeout>*
        is the timeout used to decide if the request message must be retransmitted or
        not. The next timeout value will be calculated using the configured
        retransmission policy.

        :param InitialTimeout: New value for the initial timeout.
                               The unit is in nanosecond (ns).
        :type InitialTimeout: int

        Example

        This example will set the *<InitialTimeout>* for the request stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RequestInitialTimeoutSet(3000000000)


        """
        return _byteblower.DHCPv4Protocol_RequestInitialTimeoutSet(self, inTime)

    def RequestMaxRetriesGet(self):
        r"""

        Returns the current maximum retries for the DHCP Request stage.

        :return: Current value for the number of retries in the request stage.
        :rtype: int

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The maximum number of
        times the DHCP client will retransmit the request message is returned by this
        method.

        Example

        This example will get the current maximum number of retries to 10 for the request stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RequestMaxRetriesSet(10)


        """
        return _byteblower.DHCPv4Protocol_RequestMaxRetriesGet(self)

    def RequestMaxRetriesSet(self, inValue):
        r"""

        Sets the maximum retries for the DHCP Request stage.

        :param maxRetries: The new value for the maximum number of retransmissions of
                           the request message.
                           (Default: 5)
        :type maxRetries: int

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The maximum number of
        times the DHCP client will retransmit the request message is configured by
        this method.

        Example

        This example will set the current maximum number of retries to 10 for the request
        stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RequestMaxRetriesSet(10)  

        """
        return _byteblower.DHCPv4Protocol_RequestMaxRetriesSet(self, inValue)

    def DHCPv4SessionInfoGet(self):
        r"""

        Returns the sessionInfo object for this DHCP Session.

        :rtype: DHCPv4SessionInfo

        This object contains all the DHCP sessionInfo like Tx,Rx, current leaseTime,
        giaddr etc...

        Example

        This example will return the DHCPv4SessionInfo object for this DHCP session.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcpProtocol.DHCPv4SessionInfoGet().DescriptionGet())


        """
        return _byteblower.DHCPv4Protocol_DHCPv4SessionInfoGet(self)

# Register DHCPv4Protocol in _byteblower:
_byteblower.DHCPv4Protocol_swigregister(DHCPv4Protocol)
class DHCPv6Protocol(AbstractObject):
    r"""

    The :class:`.DHCPv6Protocol` is the entry point to configure the DHCPv6 client behavior of a ByteBlowerPort.

    A ByteBlowerPort can perform DHCPv6 for configuring IP addresses, IP prefixes
    and/or other parameters required to operate on an IPv6 network.

    A ByteBlowerPort can acquire and combine IP addresses using stateless address
    autoconfiguration, or by using DHCPv6 or static configuration. DHCP tends to be
    preferred at sites where central management of hosts is valued; stateless
    autoconfiguration does not require any sort of central management, and is
    therefore preferable in networks where no management is readily available,
    such as a typical home network.

    IPv6 hosts that use stateless autoconfiguration may require information other
    than an IP address. DHCPv6 can be used to acquire this information, even though
    it is not being used to configure IP addresses.

    DHCPv6 can also be used to deligate prefix information to e.g. home gateways.
    Such gateways require not only an IPv6 address for use in communicating with
    upstream routers, but also an IPv6 prefix for use in configuring devices on the
    downstream side of the router. DHCPv6 Prefix delegation provides a mechanism
    for configuring such routers. ByteBlower currently doesn't support prefix
    delegation yet, but can only be used as a host.

    ByteBlower allows full control of the timing parameters of the DHCPv6 client
    side. The retransmission policy used for DHCPv6 is the one suggested in the
    rfc:`3315`.

    Configurable timing parameters are:

    - Initial Timeout
    - Maximum Duration
    - Maximum Retries
    - Maximum Timeout

    These timing parameters can be applied to the following stages of DHCPv6:

    - Solicit
    - Request
    - Renew
    - Inform
    - Confirm

    For each state the parameters do the following:
        ByteBlower will send up to *<MaxRetries>* messages. The total duration of
        the the state may take up the *<MaxDuration>*. For the first attempt, a
        ByteBlowerPort will wait up to  *<InitialTimeout>* nanoseconds before
        retrying. Each attempt will wait for  maximum '*<MaxTimeout>* nanoseconds
        before concluding that the messages has timed out.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PerformAsync(self):
        r"""

        This method will bootstrap the DHCPv6 process.

        .. versionadded:: 2.2

        :return: This method will return nothing and return immediately

        The client will start with sending DHCPv6 solicit messages. This is a
        asynchronous call, so it will return immediately. If you want to see if there
        an exception occured during this async, call the perform method.

        Example

        This example will start the DHCPv6 process.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.PerformAsync()


        """
        return _byteblower.DHCPv6Protocol_PerformAsync(self)

    def Perform(self):
        r"""

        This method will bootstrap the DHCPv6 process.

        The client will start with sending DHCPv6 solicit messages. This is a
        synchronous call, so the full DHCPv6 solicit and request will be done once this
        call returns, or an error have occurred.

        :return: This method will return nothing, but will return after DHCP is
                 performed successfully. If DHCP fails, and exception is thrown.
        :rtype: int

        :raises DHCPFailed: Thrown if no offer was received during the DHCP solicit 
                            stage or no DHCPReply during DHCPRequest stage

        Example

        This example will start the DHCPv6 process.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.Perform()


        """
        return _byteblower.DHCPv6Protocol_Perform(self)

    def Release(self):
        r"""

        Release the address previously received using DHCPv6

        This method will release the address previously received using DHCP. After
        this, the address will not be used anymore by the ByteBlower port and the DHCP
        server can reuse the address for other DHCP clients. Offcourse, packets sent by
        the ByteBlower port as part of streams can still use the address.

        :return: This method will return nothing, but will return after DHCP Release is
                 performed

        Example

        This example will release the DHCP address.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.Release()


        """
        return _byteblower.DHCPv6Protocol_Release(self)

    def ReleaseEnable(self, inValue):
        r"""

        Enable automatic release when the ByteBlower port is destroyed

        :param enable: True to enable the automatic release of the address
                       (Default: True)
        :type enable: bool

        When a ByteBlowerPort is destructed and this port has performed DHCP, such a
        port should release its address. If this behavior is prefered, then this
        should be done by using the :meth:`ReleaseEnable` method to inidicate the
        ByteBlowerPort should release its address if possible. A ByteBlowerPort is able
        to release its address at destruction time if the destination mac address is in
        the ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be
        sent out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.ReleaseEnable()


        """
        return _byteblower.DHCPv6Protocol_ReleaseEnable(self, inValue)

    def ReleaseIsEnabled(self):
        r"""

        Returns True when automatic release is enabled

        :return: If the port will release its IP at destruction
        :rtype: bool

        When a ByteBlowerPort is destructed and this port has performed DHCP, it should
        release its address. If this behavior is prefered, then this should be done by
        using the Release.Enable method to inidicate the ByteBlowerPort should release
        its address if possible. A ByteBlowerPort is able to release its address at
        destruction time if the destination mac address is in the ByteBlowerPort's
        ARP cache. If not, the DHCP release messages will not be sent out, because it
        could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.ReleaseIsEnabled())


        """
        return _byteblower.DHCPv6Protocol_ReleaseIsEnabled(self)

    def SolicitInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Solicit state.

        :param value: New value for *<InitialTimeout>* for stage Solicit.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.SolicitInitialTimeoutSet(100000)


        """
        return _byteblower.DHCPv6Protocol_SolicitInitialTimeoutSet(self, arg2)

    def SolicitInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Solicit state.

        :return: Current value for *<InitialTimeout>* for stage Solicit.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.SolicitInitialTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_SolicitInitialTimeoutGet(self)

    def SolicitMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Solicit state.

        :param value: New value for *<MaxTimeout>* for stage Solicit.
                      This is a time value, in nanosecond units.
        :type value: int

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Solicit stage.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.SolicitMaxTimeoutSet(10000)


        """
        return _byteblower.DHCPv6Protocol_SolicitMaxTimeoutSet(self, arg2)

    def SolicitMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Solicit state.

        :return: Current value for *<MaxTimeout>* for stage Solicit.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.SolicitMaxTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_SolicitMaxTimeoutGet(self)

    def SolicitMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Solicit state.

        :param value: New value for *<MaxRetries>* for stage Solicit.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Solicit message.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxRetries>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.SolicitMaxRetriesGet())


        """
        return _byteblower.DHCPv6Protocol_SolicitMaxRetriesSet(self, arg2)

    def SolicitMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Solicit state.

        :return: Current value for *<MaxRetries>* for stage Solicit.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Solicit message.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.SolicitMaxRetriesGet())


        """
        return _byteblower.DHCPv6Protocol_SolicitMaxRetriesGet(self)

    def SolicitMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Solicit state.

        :param value: New value for *<MaxDuration>* for stage Solicit.
                      This is a time value, in nanosecond units.
        :type value: int

        Example
        This example demonstrates how to set the value for *<MaxDuration>* to 1000000 in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.SolicitMaxDurationSet(1000000)


        """
        return _byteblower.DHCPv6Protocol_SolicitMaxDurationSet(self, arg2)

    def SolicitMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Solicit state.

        :return: Current value for *<MaxDuration>* for stage Solicit.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.SolicitMaxDurationGet())


        """
        return _byteblower.DHCPv6Protocol_SolicitMaxDurationGet(self)

    def RequestInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Request state.

        :param value: New value for *<InitialTimeout>* for stage Request.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RequestInitialTimeoutSet(1000000)


        """
        return _byteblower.DHCPv6Protocol_RequestInitialTimeoutSet(self, arg2)

    def RequestInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Request state.

        :return: Current value for *<InitialTimeout>* for stage Request.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RequestInitialTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_RequestInitialTimeoutGet(self)

    def RequestMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Request state.

        :param value: New value for *<MaxTimeout>* for stage Request.
                      This is a time value, in nanosecond units
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RequestMaxTimeoutSet(1000000)


        """
        return _byteblower.DHCPv6Protocol_RequestMaxTimeoutSet(self, arg2)

    def RequestMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Request state.

        :return: Current value for *<MaxTimeout>* for stage Request.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RequestMaxTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_RequestMaxTimeoutGet(self)

    def RequestMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Request state.

        :param value: New value for *<MaxRetries>* for stage Request.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Request message.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 10 in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RequestMaxRetriesSet(10)


        """
        return _byteblower.DHCPv6Protocol_RequestMaxRetriesSet(self, arg2)

    def RequestMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Request state.

        :return: Current value for *<MaxRetries>* for stage Request.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Request message.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RequestMaxRetriesGet())


        """
        return _byteblower.DHCPv6Protocol_RequestMaxRetriesGet(self)

    def RequestMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Request state.

        :param value: New value for *<MaxDuration>* for stage Request.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxDuration>* to 10 in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RequestMaxDurationSet(1000000)


        """
        return _byteblower.DHCPv6Protocol_RequestMaxDurationSet(self, arg2)

    def RequestMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Request state.

        :return: Current value for *<MaxDuration>* for stage Request.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the Request stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RequestMaxDurationGet())


        """
        return _byteblower.DHCPv6Protocol_RequestMaxDurationGet(self)

    def ConfirmInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Confirm state.

        :param value: New value for *<InitialTimeout>* for stage Confirm.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.ConfirmInitialTimeoutSet(100000)


        """
        return _byteblower.DHCPv6Protocol_ConfirmInitialTimeoutSet(self, arg2)

    def ConfirmInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Confirm state.

        :return: Current value for *<InitialTimeout>* for stage Confirm.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.ConfirmInitialTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_ConfirmInitialTimeoutGet(self)

    def ConfirmMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Confirm state.

        :param value: New value for *<MaxTimeout>* for stage Confirm.
                      This is a time value, in nanosecond inits.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.ConfirmMaxTimeoutSet(5000000000)


        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxTimeoutSet(self, arg2)

    def ConfirmMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Confirm state.

        :return: Current value for *<MaxTimeout>* for stage Confirm.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.ConfirmMaxTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxTimeoutGet(self)

    def ConfirmMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Confirm state.

        :param value: New value for *<MaxRetries>* for stage Confirm.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Confirmmessage.
        :type value: int

        Example
        This example demonstrates how to set the value for *<MaxRetries>* to 12 in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.ConfirmMaxRetriesSet(12)


        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxRetriesSet(self, arg2)

    def ConfirmMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Confirm state.

        :return:  Current value for *<MaxRetries>* for stage Confirm.
                  This is a positive integer value, indicating the number of times the
                  ByteBlowerPort will resend its Confirm message.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcpv6.ConfirmMaxRetriesGet())


        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxRetriesGet(self)

    def ConfirmMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Confirm state.

        :param value:  New value for *<MaxDuration>* for stage Confirm.
                       This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxDuration>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.ConfirmMaxDurationSet(100000)


        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxDurationSet(self, arg2)

    def ConfirmMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Confirm state.

        :return: Current value for *<MaxDuration>* for stage Confirm.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.ConfirmMaxDurationGet())


        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxDurationGet(self)

    def RenewInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Renew state.

        :param value: New value for *<InitialTimeout>* for stage Renew.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* to 10000 in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RenewInitialTimeoutSet(10000)


        """
        return _byteblower.DHCPv6Protocol_RenewInitialTimeoutSet(self, arg2)

    def RenewInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Renew state.

        :return: Current value for *<InitialTimeout>* for stage Renew.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RenewInitialTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_RenewInitialTimeoutGet(self)

    def RenewMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Renew state.

        :param value: New value for *<MaxTimeout>* for stage Renew.
                     This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcpv6.RenewMaxTimeoutSet(5000)


        """
        return _byteblower.DHCPv6Protocol_RenewMaxTimeoutSet(self, arg2)

    def RenewMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Renew state.

        :return:  Current value for *<MaxTimeout>* for stage Renew.
                  This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RenewMaxTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_RenewMaxTimeoutGet(self)

    def RenewMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Renew state.

        :param value: New value for *<MaxRetries>* for stage Renew.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Renew message.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 12in the Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RenewMaxRetriesSet(12)


        """
        return _byteblower.DHCPv6Protocol_RenewMaxRetriesSet(self, arg2)

    def RenewMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Renew state.

        :return: Current value for *<MaxRetries>* for stage Renew.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Renew message.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RenewMaxRetriesGet())


        """
        return _byteblower.DHCPv6Protocol_RenewMaxRetriesGet(self)

    def RenewMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Renew state.

        :param value: New value for *<MaxDuration>* for stage Renew.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxDuration>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.RenewMaxDurationSet(100000)


        """
        return _byteblower.DHCPv6Protocol_RenewMaxDurationSet(self, arg2)

    def RenewMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Renew state.

        :return: Current value for *<MaxDuration>* for stage Renew.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.RenewMaxDurationGet())


        """
        return _byteblower.DHCPv6Protocol_RenewMaxDurationGet(self)

    def InformInitialTimeoutSet(self, arg2):
        r"""

        Setter for *<InitialTimeout>* when in the Inform state.

        :param value: New value for *<InitialTimeout>* for stage Inform.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.InformInitialTimeoutSet()


        """
        return _byteblower.DHCPv6Protocol_InformInitialTimeoutSet(self, arg2)

    def InformInitialTimeoutGet(self):
        r"""

        Getter for *<InitialTimeout>* when in the Inform state.

        :return: Current value for *<InitialTimeout>* for stage Inform.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.InformInitialTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_InformInitialTimeoutGet(self)

    def InformMaxTimeoutSet(self, arg2):
        r"""

        Setter for *<MaxTimeout>* when in the Inform state.

        :param value: New value for *<MaxTimeout>* for stage Inform.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.InformMaxTimeoutSet(100000)


        """
        return _byteblower.DHCPv6Protocol_InformMaxTimeoutSet(self, arg2)

    def InformMaxTimeoutGet(self):
        r"""

        Getter for *<MaxTimeout>* when in the Inform state.

        :return: Current value for *<MaxTimeout>* for stage Inform.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.InformMaxTimeoutGet())


        """
        return _byteblower.DHCPv6Protocol_InformMaxTimeoutGet(self)

    def InformMaxRetriesSet(self, arg2):
        r"""

        Setter for *<MaxRetries>* when in the Inform state.

        :param value: New value for *<MaxRetries>* for stage Inform.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Inform message.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 5 in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.InformMaxRetriesSet(5)


        """
        return _byteblower.DHCPv6Protocol_InformMaxRetriesSet(self, arg2)

    def InformMaxRetriesGet(self):
        r"""

        Getter for *<MaxRetries>* when in the Inform state.

        :return: Current value for *<MaxRetries>* for stage Inform.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Inform message.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.InformMaxRetriesGet())


        """
        return _byteblower.DHCPv6Protocol_InformMaxRetriesGet(self)

    def InformMaxDurationSet(self, arg2):
        r"""

        Setter for *<MaxDuration>* when in the Inform state.

        :param value: New value for *<MaxDuration>* for stage Inform.
                      This is a time value, in nanosecond units.
        :type value: int

        Example

        This example demonstrates how to set the value for *<MaxDuration>* to 100000 in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.InformMaxDurationSet(100000)


        """
        return _byteblower.DHCPv6Protocol_InformMaxDurationSet(self, arg2)

    def InformMaxDurationGet(self):
        r"""

        Getter for *<MaxDuration>* when in the Inform state.

        :return: Current value for *<MaxDuration>* for stage Inform.
                 This is a time value, in nanosecond units.
        :rtype: int

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.InformMaxDurationGet())


        """
        return _byteblower.DHCPv6Protocol_InformMaxDurationGet(self)

    def RetransmissionPolicyGet(self):
        r"""

        Returns the current configured retransmission policy. This policy is used in
        calculating the timeout value for each outstanding message and is the same for
        all message types.

        :return:  Current configured Retransmission Policy
                 (Default: :attr:`.RetransmissionPolicy.RfcSuggested`)
        :rtype: RetransmissionPolicy

        Example

        This example will get the retransmission policy.

        .. code-block:: python
           :emphasize-lines: 5

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')

           dhcpProtocol = l3.ProtocolDhcpGet()
           policy = dhcpProtocol.RetransmissionPolicyGet()


        """
        return _byteblower.DHCPv6Protocol_RetransmissionPolicyGet(self)

    def RetransmissionPolicySet(self, policy):
        r"""

        Configures the Retransmission Policy. 

        The Retransmission Policy defines the timing for the DHCP messages.

        :param policy: The Retransmission policy to be set.
                       (Default: :attr:`.RetransmissionPolicy.RfcSuggested`)
        :type policy: RetransmissionPolicy

        Example

        This example will set the retransmission policy to fixed timing.

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')


        """
        return _byteblower.DHCPv6Protocol_RetransmissionPolicySet(self, policy)

    def DHCPv6SessionInfoGet(self):
        r"""

        Returns the sessionInfo object for this DHCP Session.

        This object contains all the DHCP sessionInfo like Tx,Rx

        :return: The statistics object for this DHCP session
        :rtype: DHCPv6SessionInfo

        Example

        This example will return the :class:`DHCPv6SessionInfo` object for this DHCP
        session.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcp_protocol.DHCPv6SessionInfoGet().DescriptionGet())


        """
        return _byteblower.DHCPv6Protocol_DHCPv6SessionInfoGet(self)

# Register DHCPv6Protocol in _byteblower:
_byteblower.DHCPv6Protocol_swigregister(DHCPv6Protocol)
TCPConnectionState_CLOSED = _byteblower.TCPConnectionState_CLOSED
TCPConnectionState_LISTEN = _byteblower.TCPConnectionState_LISTEN
TCPConnectionState_SYN_RECEIVED = _byteblower.TCPConnectionState_SYN_RECEIVED
TCPConnectionState_SYN_SENT = _byteblower.TCPConnectionState_SYN_SENT
TCPConnectionState_ESTABLISHED = _byteblower.TCPConnectionState_ESTABLISHED
TCPConnectionState_FIN_WAIT_1 = _byteblower.TCPConnectionState_FIN_WAIT_1
TCPConnectionState_FIN_WAIT_2 = _byteblower.TCPConnectionState_FIN_WAIT_2
TCPConnectionState_CLOSING = _byteblower.TCPConnectionState_CLOSING
TCPConnectionState_CLOSE_WAIT = _byteblower.TCPConnectionState_CLOSE_WAIT
TCPConnectionState_LAST_ACK = _byteblower.TCPConnectionState_LAST_ACK
TCPConnectionState_TIME_WAIT = _byteblower.TCPConnectionState_TIME_WAIT

def ConvertTCPConnectionStateToString(inState):
    return _byteblower.ConvertTCPConnectionStateToString(inState)

def ParseTCPConnectionStateFromString(inState):
    return _byteblower.ParseTCPConnectionStateFromString(inState)
TCPCongestionAvoidanceAlgorithm__None = _byteblower.TCPCongestionAvoidanceAlgorithm__None
TCPCongestionAvoidanceAlgorithm_NewReno = _byteblower.TCPCongestionAvoidanceAlgorithm_NewReno
TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic
TCPCongestionAvoidanceAlgorithm_Sack = _byteblower.TCPCongestionAvoidanceAlgorithm_Sack
TCPCongestionAvoidanceAlgorithm_SackWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_SackWithCubic

def ConvertTCPCongestionAvoidanceAlgorithmToString(inTCAA):
    return _byteblower.ConvertTCPCongestionAvoidanceAlgorithmToString(inTCAA)

def ParseTCPCongestionAvoidanceAlgorithmFromString(inValue):
    return _byteblower.ParseTCPCongestionAvoidanceAlgorithmFromString(inValue)
HTTPRequestMethod_Undefined = _byteblower.HTTPRequestMethod_Undefined
HTTPRequestMethod_Options = _byteblower.HTTPRequestMethod_Options
HTTPRequestMethod_Get = _byteblower.HTTPRequestMethod_Get
HTTPRequestMethod_Head = _byteblower.HTTPRequestMethod_Head
HTTPRequestMethod_Post = _byteblower.HTTPRequestMethod_Post
HTTPRequestMethod_Put = _byteblower.HTTPRequestMethod_Put
HTTPRequestMethod_Delete = _byteblower.HTTPRequestMethod_Delete
HTTPRequestMethod_Trace = _byteblower.HTTPRequestMethod_Trace

def ConvertHTTPRequestMethodToString(inHTTPRequestMethod):
    return _byteblower.ConvertHTTPRequestMethodToString(inHTTPRequestMethod)

def ParseHTTPRequestMethodFromString(inHTTPRequestMethod):
    return _byteblower.ParseHTTPRequestMethodFromString(inHTTPRequestMethod)
HTTPRequestStatus_Configuration = _byteblower.HTTPRequestStatus_Configuration
HTTPRequestStatus_Scheduled = _byteblower.HTTPRequestStatus_Scheduled
HTTPRequestStatus_Connecting = _byteblower.HTTPRequestStatus_Connecting
HTTPRequestStatus_Running = _byteblower.HTTPRequestStatus_Running
HTTPRequestStatus_Finished = _byteblower.HTTPRequestStatus_Finished
HTTPRequestStatus_Stopped = _byteblower.HTTPRequestStatus_Stopped
HTTPRequestStatus_Error = _byteblower.HTTPRequestStatus_Error

def ConvertHTTPRequestStatusToString(inHTTPRequestStatus):
    return _byteblower.ConvertHTTPRequestStatusToString(inHTTPRequestStatus)

def ParseHTTPRequestStatusFromString(inStr):
    return _byteblower.ParseHTTPRequestStatusFromString(inStr)
HTTPMultiClientStatus_Configuration = _byteblower.HTTPMultiClientStatus_Configuration
HTTPMultiClientStatus_Scheduled = _byteblower.HTTPMultiClientStatus_Scheduled
HTTPMultiClientStatus_Running = _byteblower.HTTPMultiClientStatus_Running
HTTPMultiClientStatus_Finished = _byteblower.HTTPMultiClientStatus_Finished
HTTPMultiClientStatus_Stopped = _byteblower.HTTPMultiClientStatus_Stopped

def ConvertHTTPMultiClientStatusToString(inHTTPRequestStatus):
    return _byteblower.ConvertHTTPMultiClientStatusToString(inHTTPRequestStatus)
HTTPRequestType_Size = _byteblower.HTTPRequestType_Size
HTTPRequestType_Duration = _byteblower.HTTPRequestType_Duration

def ConvertHTTPRequestTypeToString(inHTTPRequestType):
    return _byteblower.ConvertHTTPRequestTypeToString(inHTTPRequestType)

def ParseHTTPRequestTypeFromString(s):
    return _byteblower.ParseHTTPRequestTypeFromString(s)
class CapturedFrame(AbstractObject):
    r"""

    A representation of a Captured Frame captured using a :class:`.CaptureRawPacket`.

    Example

    .. code-block:: python

       result = captureRaw.ResultGet()
       frame = result.FramesGetByIndex(0)
       print(frame.LengthGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, inAbstractObject, inTimestamp, bytes):
        _byteblower.CapturedFrame_swiginit(self, _byteblower.new_CapturedFrame(inAbstractObject, inTimestamp, bytes))

    def BufferGet(self):
        r"""

        Gets access to the binary buffer in which the frame is stored.

        :return: hex representation of the content of the captured frame
        :rtype: Buffer

        Example

        This example gets the bytes in HEX

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.BufferGet())


        """
        return _byteblower.CapturedFrame_BufferGet(self)

    def LengthGet(self):
        r"""

        Gets the packet length of this CapturedFrame. This is the length without CRC.

        :return: Length of the packet without CRC
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.LengthGet())


        """
        return _byteblower.CapturedFrame_LengthGet(self)

    def TimestampGet(self):
        r"""

        Gets timestamp [NS] of this CapturedFrame.

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        This example gets the timestamp of the captured frame

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.TimestampGet())


        """
        return _byteblower.CapturedFrame_TimestampGet(self)

    def BytesGet(self):
        r"""

        Gets the bytes in HEX format of this CapturedFrame.

        :return: hex representation of the content of the captured frame
        :rtype: str

        Example

        This example gets the bytes in HEX

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.BytesGet())


        """
        return _byteblower.CapturedFrame_BytesGet(self)

# Register CapturedFrame in _byteblower:
_byteblower.CapturedFrame_swigregister(CapturedFrame)
class CapturedHTTPData(AbstractObject):
    r"""

    This class represents captured HTTP data.

    The HTTP data is a local snapshot of the HTTP data received in a HTTP session
    at the ByteBlower Server.

    HTTP data capture is currently supported on HTTP Client objects.

    .. code-block:: python
       :emphasize-lines: 2

       captureData = httpClient.CaptureGet()
       print(captureData.HttpSizeGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def HttpSizeGet(self):
        r"""

        Returns the number of captured bytes of HTTP data.

        :return: Size of captured HTTP data in Bytes.
        :rtype: int

        The value includes the size of both HTTP header and payload.

        .. note:: This only outputs the local cached HTTP data. The local cached
                  HTTP data is a snapshot of the HTTP data received at the ByteBlower
                  server. If no local snapshot was available yet, an initial one will
                  be obtained from the server. You may want to synchronize the local
                  cached data using the :obj:`~.AbstractObject.Refresh` method on this
                  object.

        :raises UnsupportedFeature: When the ByteBlower Server does not support HTTP 
                                    Client captures

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: a HTTP GET request for an index.html test page

           print(captureData.HttpSizeGet())


        """
        return _byteblower.CapturedHTTPData_HttpSizeGet(self)

    def HttpBytesGet(self):
        r"""

        Returns the captured HTTP data.

        :return: Captured HTTP data as string.
        :rtype: str

        :raises UnsupportedFeature: When the ByteBlower Server does not support HTTP 
                                    Client captures

        The data includes both HTTP header and payload.

        .. note:: This only outputs the local cached HTTP data. The local cached
                  HTTP data is a snapshot of the HTTP data received at the ByteBlower
                  server. If no local snapshot was available yet, an initial one will
                  be obtained from the server. You may want to synchronize the local
                  cached data using the :obj:`~.AbstractObject.Refresh` method on this
                  object.

        Example

        Suppose we sent a HTTP GET request for an 'index.html' test page

        .. code-block:: python
           :emphasize-lines: 1

           print(captureData.HttpBytesGet())

        .. code-block:: 

           HTTP/1.1 200 OK
           Date: Wed, 12 Feb 2014 13:23:32 GMT
           Server: Apache/2.2.22 (Debian)
           Last-Modified: Thu, 10 Feb 2011 11:32:16 GMT
           ETag: "27c083-b1-49bebeefcb000"
           Accept-Ranges: bytes
           Content-Length: 177
           Vary: Accept-Encoding
           Content-Type: text/html
           X-Pad: avoid browser bug
           <html><body><h1>It works!</h1>
           <p>This is the default web page for this server.</p>
           <p>The web server software is running but no content has been added,
           yet.</p>
           </body></html>

        """
        return _byteblower.CapturedHTTPData_HttpBytesGet(self)

    def HttpBytesSave(self, inFileName):
        r"""

        Saves the captured HTTP data to file.

        :param fileName: Destination filename for the captured HTTP data.
        :type fileName: str

        :raises UnsupportedFeature: When the ByteBlower Server does not support HTTP 
                                    Client captures

        .. note:: This only outputs the local cached HTTP data. 
                  The local cached HTTP data is a snapshot of the HTTP data received at
                  the ByteBlower server. 
                  If no local snapshot was available yet, an initial one will be 
                  obtained from the server. You may want to synchronize the local 
                  cached data using the :obj:`~.AbstractObject.Refresh` method on this
                  object.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Stores all HTTP data captured to `c:.txt`

           captureData.HttpBytesSave('httpResults.txt')


        """
        return _byteblower.CapturedHTTPData_HttpBytesSave(self, inFileName)

# Register CapturedHTTPData in _byteblower:
_byteblower.CapturedHTTPData_swigregister(CapturedHTTPData)
class CaptureRawPacket(Capture):
    r"""

    This class is used to capture the raw packet data that is received on the
    Physical interface that is associated with a ByteBlowerPort.

    With this class, one can capture the data that is received by the ByteBlower 
    Port and save this to a pcap file on your pc. You can also apply a filter 
    (BPF-style) to only capture the packets of your interest.

    Example

    .. code-block:: python

       captureRaw = bbPort2.RxCaptureBasicAdd()
       captureRaw.FilterSet('ip dst 1.1.1.2')
       captureRaw.Start()
       #...
       captureRaw.Stop()
       result = captureRaw.ResultGet()
       print(result.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FilterSet(self, inFilter):
        r"""

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does reset the counter values which
                  were triggered by a previous filter string. Also the earlier 
                  collected history is invalidated.

        :param bpf: Valid BPF filter string. For creating valid BPF filter strings, 
                    please have a look at http://www.tcpdump.org/#documentation
                    for more  information.
        :type bpf: str

        :raises ConfigError: When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

           captureRaw.FilterSet('ip dst 1.1.1.2')


        """
        return _byteblower.CaptureRawPacket_FilterSet(self, inFilter)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string
        :rtype: str

        Example

        Suppose we configured the trigger with filter string:
        where `ipv4_1` and `ipv4_2` are :class:`.IPv4Configuration` objects and
        `frameSize` is the (layer2) size of the frames (without CRC!). The BPF
        filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 1

           print(captureRaw.FilterGet())


        """
        return _byteblower.CaptureRawPacket_FilterGet(self)

    def FileNameRemoteGet(self):
        r"""

        Returns the name for the capture as stored on the ByteBlower server

        :rtype: str


        """
        return _byteblower.CaptureRawPacket_FileNameRemoteGet(self)

    def Start(self):
        r"""

        Start capturing.

        .. note:: Calling Start while already running does not throw an exception.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           captureRaw.Start()


        """
        return _byteblower.CaptureRawPacket_Start(self)

    def Stop(self):
        r"""

        Stop capturing.

        .. note:: Calling Stop while not running does not throw an exception.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           captureRaw.Stop()


        """
        return _byteblower.CaptureRawPacket_Stop(self)

    def ResultGet(self):
        r"""

        Returns the capture result.

        :rtype: CaptureResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           result = captureRaw.ResultGet()


        """
        return _byteblower.CaptureRawPacket_ResultGet(self)

# Register CaptureRawPacket in _byteblower:
_byteblower.CaptureRawPacket_swigregister(CaptureRawPacket)
class CaptureResultSnapshot(AbstractRefreshableResult):
    r"""

    This class represents the result of a :class:`.CaptureRawPacket`.

    It contains the metrics and the frames that are captured.
    To get an update of the values use ::Refresh.

    Example

    .. code-block:: python

       captureRaw = bbPort2.RxCaptureBasicAdd()
       captureRaw.FilterSet('ip dst 1.1.1.2')
       captureRaw.Start()
       # ...
       captureRaw.Stop()
       resultSnapshot = captureRaw.ResultGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clears the counters and deletes the captured packets from the capture.

        Example

        This example returns the captured frames

        .. code-block:: python
           :emphasize-lines: 1

           resultSnapshot.Clear()


        """
        return _byteblower.CaptureResultSnapshot_Clear(self)

    def PacketCountGet(self):
        r"""

        Returns the number of packets captured.

        :return: The number of packets this capture captured
        :rtype: int

        Example

        This example returns the number of packets captured

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.PacketCountGet())


        """
        return _byteblower.CaptureResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Returns the number of bytes captured.

        :return: The number of bytes captured
        :rtype: int

        Example

        This example returns the number of bytes captured

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.ByteCountGet())


        """
        return _byteblower.CaptureResultSnapshot_ByteCountGet(self)

    def ErrorCountGet(self):
        r"""

        Returns Error count.

        :return: Returns the number of packets with incorrect CRC
        :rtype: int

        Example

        This example returns the number of corrupt frames

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.ErrorCountGet())


        """
        return _byteblower.CaptureResultSnapshot_ErrorCountGet(self)

    def CaptureDurationGet(self):
        r"""

        Returns the duration of the capture.

        :return: The duration of the capture in nanoseconds
        :rtype: int

        Example

        This example returns the duration of the capture

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.CaptureDurationGet())


        """
        return _byteblower.CaptureResultSnapshot_CaptureDurationGet(self)

    def StateNameGet(self):
        r"""

        Returns the status of the current capture.

        :return: Returns current state of this capture.

                 Possible values are:

                 - unknown
                 - unavailable
                 - inactive
                 - active
                 - invalid
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.StateNameGet())


        """
        return _byteblower.CaptureResultSnapshot_StateNameGet(self)

    def FramesGet(self):
        r"""

        Returns a list of captured frames.

        :return: a list of :class:`CapturedFrame` objects.
        :rtype: CapturedFrameList

        Example

        This example returns the captured frames

        .. code-block:: python
           :emphasize-lines: 1

           framesResult = resultSnapshot.FramesGet()
           for frame in framesResult:
           print(frame.DescriptionGet())


        """
        return _byteblower.CaptureResultSnapshot_FramesGet(self)

    def FramesGetByIndex(self, index):
        r"""

        Returns a Rx.Capture.Frame at the provided index.

        :rtype: CapturedFrame

        Example

        This example returns the captured frame given by the index

        .. code-block:: python
           :emphasize-lines: 1

           frame = resultSnapshot.FramesGetByIndex(0)


        """
        return _byteblower.CaptureResultSnapshot_FramesGetByIndex(self, index)

    def PcapLastFileNameGet(self):
        r"""

        The fileName where the last pcap was saved to.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.PcapLastFileNameGet())
           # prints: pcapResult.pcap


        """
        return _byteblower.CaptureResultSnapshot_PcapLastFileNameGet(self)

    def PcapSave(self, filename):
        r"""

        Stores the captured frames into a `pcap` file.

        :param fileName: Destination filename for the capture file.
        :type fileName: str

        :raises: ByteBlower.Rx.Capture.GetFailed - When no results are available or
                 when an exception occurred while obtaining the results.

        :raises: ByteBlower.Rx.Capture.GetFramesFailed - Invalid captured packet offset.

        The stored capture file can be opened by e.g. `wireshark`.

        Example

        Stores all packets captured by filter to `c:\pcap`

        .. code-block:: python
           :emphasize-lines: 1

           resultSnapshot.PcapSave('resultPcap.pcap')


        """
        return _byteblower.CaptureResultSnapshot_PcapSave(self, filename)

    def PcapNanoSave(self, filename):
        r"""

        Stores the captured frames into a `pcap` file.

        :param filename: Destination filename for the capture file.
        :type filename: str

        :raises: <python_error> - No pcap support found: When the pcap library is not
                 installed on the ByteBlower client PC.
        :raises: ByteBlower.Rx.Capture.GetFailed - When no results are available or
                 when an exception occurred while obtaining the results.
        :raises: ByteBlower.Rx.Capture.GetFramesFailed - Invalid captured packet offset.

        The stored capture file can be opened by e.g. `wireshark`.

        Example

        Stores all packets captured by filter to `c:\pcap` which is in PcapNano format

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           server.PortCreate('trunk-1-1')
           # TODO??


        """
        return _byteblower.CaptureResultSnapshot_PcapNanoSave(self, filename)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.RefreshTimestampGet())


        """
        return _byteblower.CaptureResultSnapshot_RefreshTimestampGet(self)

# Register CaptureResultSnapshot in _byteblower:
_byteblower.CaptureResultSnapshot_swigregister(CaptureResultSnapshot)
class TCPSessionInfo(AbstractObject):
    r"""

    Class containing info about the TCP session.

    Example

    .. code-block:: python

       tcpSessionInfo = httpSessionInfo.TcpSessionInfoGet()
       # print an integer which indicates a certain State
       print(tcpSessionInfo.ConnectionStateGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        r"""

        Returns the current TCP connection state.

        :rtype: TCPConnectionState

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ConnectionStateGet())


        """
        return _byteblower.TCPSessionInfo_ConnectionStateGet(self)

    def CongestionAvoidanceAlgorithmGet(self):
        r"""

        Returns the congestion avoidance algorithm used in this TCP session.

        :rtype: TCPCongestionAvoidanceAlgorithm

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpSessionInfo.CongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.TCPSessionInfo_CongestionAvoidanceAlgorithmGet(self)

    def PragueIsEnabled(self):
        r"""

        Returns whether the TCP Prague CAA is successfully negotiated.

        :return: True when TCP Prague is/was in use.  False when the Fallback CAA is
                 used or TCP Prague was not enabled.
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpSessionInfo.PragueIsEnabled())


        """
        return _byteblower.TCPSessionInfo_PragueIsEnabled(self)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the maximum segment size this TCP connection is allowed to use when transmitting data.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpSessionInfo.MaximumSegmentSizeGet())


        """
        return _byteblower.TCPSessionInfo_MaximumSegmentSizeGet(self)

    def ResultGet(self):
        r"""

        Returns the current cumulative result counters for this session.

        :rtype: TCPResultSnapshot

        The snapshot contains byte counters and time values.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ResultGet().DescriptionGet())


        """
        return _byteblower.TCPSessionInfo_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current TCP Results over time.

        :rtype: TCPResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.TCPSessionInfo_ResultHistoryGet(self)

# Register TCPSessionInfo in _byteblower:
_byteblower.TCPSessionInfo_swigregister(TCPSessionInfo)
class TCPTunnel(AbstractObject):
    r"""

    Creates a TCP port forwarding configuration between a local host and a remote server.

    .. versionadded:: 2.7.0

    Traffic is forwarded between localhost and the remote endpoint.

    Example:

    .. code-block:: python

        # Provision a ByteBlower Port.
        # ...

        tcp_tunnel = port.TunnelTcpAdd()
        tcp_tunnel.RemoteAddressSet('10.3.4.5')
        tcp_tunnel.RemotePortSet(443)
        tcp_tunnel.LocalPortSet(12345)
        tcp_tunnel.Start()

    in another shell:

    .. code-block:: sh

       wget https://10.3.4.5:443 -O test


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LocalPortSet(self, inLocalPort):
        r"""

        Configures the local port number of the port mapping configuration.

        :param port: Local TCP port to use
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tcpTunnel.LocalPortSet(12345)


        """
        return _byteblower.TCPTunnel_LocalPortSet(self, inLocalPort)

    def RemotePortSet(self, inLocalPort):
        r"""

        Configures the remote port to which data will be forwarded.

        :param port: Remote TCP port to connect to
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tcpTunnel.LocalPortSet(80)


        """
        return _byteblower.TCPTunnel_RemotePortSet(self, inLocalPort)

    def RemoteAddressSet(self, remote_address):
        r"""

        Configures the IP of the remote endpoint.

        :param address: Remote IP address to set
        :type address: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tcpTunnel.RemoteAddressSet('192.168.1.10')


        """
        return _byteblower.TCPTunnel_RemoteAddressSet(self, remote_address)

    def Start(self):
        r"""

        Activates the port mapping configuration.

        Once the port mapping is activated it becomes possible to access the remote
        endpoint through external applications like curl, wget, ssh or the a web
        browser.

        For example:

        .. code-block:: sh

            curl --insecure https://localhost:123435
            wget --no-check-certificate https://localhost:12345

        Of course, you can also use Python's networking packages like http.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tcpTunnel.Start()


        """
        return _byteblower.TCPTunnel_Start(self)

    def Stop(self):
        r"""

        Stops the port mapping configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tcpTunnel.Stop()


        """
        return _byteblower.TCPTunnel_Stop(self)

# Register TCPTunnel in _byteblower:
_byteblower.TCPTunnel_swigregister(TCPTunnel)
class TCPResultData(AbstractObject):
    r"""

    Contains static TCP result counters.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        r"""

        Returns the current TCP connection state.

        :rtype: TCPConnectionState

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpResultData.ConnectionStateGet())


        """
        return _byteblower.TCPResultData_ConnectionStateGet(self)

    def TxSegmentCountTotalGet(self):
        r"""

        Returns the total number of transmitted segments.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RxSegmentCountTotalGet())


        """
        return _byteblower.TCPResultData_TxSegmentCountTotalGet(self)

    def RxSegmentCountTotalGet(self):
        r"""

        Returns the total number of received segments.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RxSegmentCountTotalGet())


        """
        return _byteblower.TCPResultData_RxSegmentCountTotalGet(self)

    def RxSegmentCountOutOfOrderGet(self):
        r"""

        Returns the number of segments that were received out of order.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RxSegmentCountOutOfOrderGet())


        """
        return _byteblower.TCPResultData_RxSegmentCountOutOfOrderGet(self)

    def TxByteCountHeaderGet(self):
        r"""

        Returns the number of transmitted TCP header bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TxByteCountHeaderGet())


        """
        return _byteblower.TCPResultData_TxByteCountHeaderGet(self)

    def TxByteCountPayloadGet(self):
        r"""

        Returns the number of transmitted TCP payload bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TxByteCountPayloadGet())


        """
        return _byteblower.TCPResultData_TxByteCountPayloadGet(self)

    def TxByteCountTotalGet(self):
        r"""

        Returns the total number of bytes transmitted on the current TCP connection.

        :rtype: int

        This is the sum of the tranmitted TCP header and payload bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TxByteCountTotalGet())


        """
        return _byteblower.TCPResultData_TxByteCountTotalGet(self)

    def RxByteCountHeaderGet(self):
        r"""

        Returns the number of received TCP header bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RxByteCountHeaderGet())


        """
        return _byteblower.TCPResultData_RxByteCountHeaderGet(self)

    def RxByteCountPayloadGet(self):
        r"""

        Returns the number of received TCP payload bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RxByteCountPayloadGet())


        """
        return _byteblower.TCPResultData_RxByteCountPayloadGet(self)

    def RxByteCountTotalGet(self):
        r"""

        Returns the total number of bytes received on the current TCP connection.

        :rtype: int

        This is the sum of the received TCP header and payload bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RxByteCountTotalGet())


        """
        return _byteblower.TCPResultData_RxByteCountTotalGet(self)

    def ReceiverWindowCurrentGet(self):
        r"""

        Returns the current TCP receiver window (RWND).

        :rtype: int

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.ReceiverWindowCurrentGet())


        """
        return _byteblower.TCPResultData_ReceiverWindowCurrentGet(self)

    def ReceiverWindowMinimumGet(self):
        r"""

        Returns the smallest recorded TCP receiver window (RWND).

        :rtype: int

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.ReceiverWindowMinimumGet())


        """
        return _byteblower.TCPResultData_ReceiverWindowMinimumGet(self)

    def ReceiverWindowMaximumGet(self):
        r"""

        Returns the largest recorded TCP receiver window (RWND).

        :rtype: int

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.ReceiverWindowMaximumGet())


        """
        return _byteblower.TCPResultData_ReceiverWindowMaximumGet(self)

    def CongestionWindowCurrentGet(self):
        r"""

        Returns the current TCP congestion window (CWND).

        :rtype: int

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.CongestionWindowCurrentGet())


        """
        return _byteblower.TCPResultData_CongestionWindowCurrentGet(self)

    def CongestionWindowMinimumGet(self):
        r"""

        Returns the smallest recorded TCP congestion window (CWND).

        :rtype: int

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.CongestionWindowMinimumGet())


        """
        return _byteblower.TCPResultData_CongestionWindowMinimumGet(self)

    def CongestionWindowMaximumGet(self):
        r"""

        Returns the largest recorded TCP congestion window (CWND).

        :rtype: int

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.CongestionWindowMaximumGet())


        """
        return _byteblower.TCPResultData_CongestionWindowMaximumGet(self)

    def RxLocalCongestionNotificationCountGet(self):
        r"""

        Returns the number of segments received with an explicit congestion notification.

        .. versionadded:: 2.22.0


        """
        return _byteblower.TCPResultData_RxLocalCongestionNotificationCountGet(self)

    def RxRemoteCongestionNotificationCountGet(self):
        r"""

        Returns the number of segments received with an explicit congestion notification.

        .. versionadded:: 2.22.0


        """
        return _byteblower.TCPResultData_RxRemoteCongestionNotificationCountGet(self)

    def FlightSizeCurrentGet(self):
        r"""

        Returns the number of bytes that are currently in-flight.

        :rtype: int

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.FlightSizeCurrentGet())O


        """
        return _byteblower.TCPResultData_FlightSizeCurrentGet(self)

    def FlightSizeMinimumGet(self):
        r"""

        Returns the smallest recorded flight-size.

        :rtype: int

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.FlightSizeMinimumGet())


        """
        return _byteblower.TCPResultData_FlightSizeMinimumGet(self)

    def FlightSizeMaximumGet(self):
        r"""

        Returns the largest recorded flight-size.

        :rtype: int

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.FlightSizeMaximumGet())


        """
        return _byteblower.TCPResultData_FlightSizeMaximumGet(self)

    def SlowStartThresholdCurrentGet(self):
        r"""

        Returns the current TCP slow-start threshold (SSTHRESH).

        :rtype: int

        The slow-start threshold indicates the congestion window value where the
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.SlowStartThresholdCurrentGet())


        """
        return _byteblower.TCPResultData_SlowStartThresholdCurrentGet(self)

    def SlowStartThresholdMinimumGet(self):
        r"""

        Returns the smallest recorded TCP slow-start threshold (SSTHRESH).

        :rtype: int

        The slow-start threshold indicates the congestion window value where the
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.SlowStartThresholdMinimumGet())


        """
        return _byteblower.TCPResultData_SlowStartThresholdMinimumGet(self)

    def SlowStartThresholdMaximumGet(self):
        r"""

        Returns the largest recorded TCP slow-start threshold (SSTHRESH).

        :rtype: int

        The slow-start threshold indicates the congestion window value where the
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.SlowStartThresholdMaximumGet())


        """
        return _byteblower.TCPResultData_SlowStartThresholdMaximumGet(self)

    def RoundTripTimeMinimumGet(self):
        r"""

        Returns the smallest recorded round-trip time (RTT) in nanoseconds.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RoundTripTimeMinimumGet())


        """
        return _byteblower.TCPResultData_RoundTripTimeMinimumGet(self)

    def RoundTripTimeMaximumGet(self):
        r"""

        Returns the largest recorded round-trip time (RTT) in nanoseconds.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RoundTripTimeMaximumGet())


        """
        return _byteblower.TCPResultData_RoundTripTimeMaximumGet(self)

    def RoundTripTimeCurrentGet(self):
        r"""

        Returns the current round-trip time (RTT) in nanoseconds.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RoundTripTimeCurrentGet())


        """
        return _byteblower.TCPResultData_RoundTripTimeCurrentGet(self)

    def RoundTripTimeAverageGet(self):
        r"""

        Returns the average round-trip time (RTT) in nanoseconds.

        .. versionadded:: 2.22.0

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RoundTripTimeAverageGet())


        """
        return _byteblower.TCPResultData_RoundTripTimeAverageGet(self)

    def RetransmissionCountTotalGet(self):
        r"""

        Returns the total number of retranmissions.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RetransmissionCountTotalGet())


        """
        return _byteblower.TCPResultData_RetransmissionCountTotalGet(self)

    def RetransmissionCountFastGet(self):
        r"""

        Returns the total number of fast retranmissions.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RetransmissionCountFastGet())


        """
        return _byteblower.TCPResultData_RetransmissionCountFastGet(self)

    def RetransmissionCountSlowGet(self):
        r"""

        Returns the total number of timeout retranmissions.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RetransmissionCountSlowGet())


        """
        return _byteblower.TCPResultData_RetransmissionCountSlowGet(self)

    def TimestampSynSentGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-SYN segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TimestampSynSentGet())


        """
        return _byteblower.TCPResultData_TimestampSynSentGet(self)

    def TimestampSynReceivedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received the TCP-SYN segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TimestampSynReceivedGet())


        """
        return _byteblower.TCPResultData_TimestampSynReceivedGet(self)

    def TimestampEstablishedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection entered the established state.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TimestampEstablishedGet())


        """
        return _byteblower.TCPResultData_TimestampEstablishedGet(self)

    def TimestampFinSentGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-FIN segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TimestampFinSentGet())


        """
        return _byteblower.TCPResultData_TimestampFinSentGet(self)

    def TimestampFinReceivedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received the TCP-FIN segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TimestampFinReceivedGet())


        """
        return _byteblower.TCPResultData_TimestampFinReceivedGet(self)

    def NumberOfSynSentGet(self):
        r"""

        Returns the number of TCP SYN segments that have been sent.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.NumberOfSynSentGet())


        """
        return _byteblower.TCPResultData_NumberOfSynSentGet(self)

    def NumberOfSynReceivedGet(self):
        r"""

        Returns the number of TCP SYN segments that have been received.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.NumberOfSynReceivedGet())


        """
        return _byteblower.TCPResultData_NumberOfSynReceivedGet(self)

    def NumberOfFinSentGet(self):
        r"""

        Returns the number of TCP FIN segments that have been sent.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.NumberOfFinSentGet())


        """
        return _byteblower.TCPResultData_NumberOfFinSentGet(self)

    def NumberOfFinReceivedGet(self):
        r"""

        Returns the number of TCP FIN segments that have been received.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.NumberOfFinReceivedGet())


        """
        return _byteblower.TCPResultData_NumberOfFinReceivedGet(self)

    def TxTimestampLastGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent its last TCP segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TxTimestampLastGet())


        """
        return _byteblower.TCPResultData_TxTimestampLastGet(self)

    def RxTimestampLastGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received its last TCP segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.RxTimestampLastGet())


        """
        return _byteblower.TCPResultData_RxTimestampLastGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns nanosecond duration between when result objects are created.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.IntervalDurationGet())


        """
        return _byteblower.TCPResultData_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Returns the nanosecond timestamp for when this result object was created.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultData.TimestampGet())


        """
        return _byteblower.TCPResultData_TimestampGet(self)

# Register TCPResultData in _byteblower:
_byteblower.TCPResultData_swigregister(TCPResultData)
class TCPResultDataList(object):
    r"""

    This is a List of multiple TCPResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TCPResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TCPResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TCPResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.TCPResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TCPResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TCPResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TCPResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TCPResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TCPResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TCPResultDataList___setitem__(self, *args)

    def empty(self):
        return _byteblower.TCPResultDataList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.TCPResultDataList_size(self)

    def __init__(self, *args):
        _byteblower.TCPResultDataList_swiginit(self, _byteblower.new_TCPResultDataList(*args))
    __swig_destroy__ = _byteblower.delete_TCPResultDataList

# Register TCPResultDataList in _byteblower:
_byteblower.TCPResultDataList_swigregister(TCPResultDataList)
class TCPResultSnapshot(AbstractRefreshableResult):
    r"""

    Contains TCP result counters.

    You can refresh the counters by calling the :obj:`~.AbstractObject.Refresh` method on this object.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        r"""

        Returns the current TCP connection state.

        :rtype: TCPConnectionState

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpResultSnapshot.ConnectionStateGet())


        """
        return _byteblower.TCPResultSnapshot_ConnectionStateGet(self)

    def TxSegmentCountTotalGet(self):
        r"""

        Returns the total number of transmitted segments.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TxSegmentCountTotalGet())


        """
        return _byteblower.TCPResultSnapshot_TxSegmentCountTotalGet(self)

    def RxSegmentCountTotalGet(self):
        r"""

        Returns the total number of received segments.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RxSegmentCountTotalGet())


        """
        return _byteblower.TCPResultSnapshot_RxSegmentCountTotalGet(self)

    def RxSegmentCountOutOfOrderGet(self):
        r"""

        Returns the number of segments that were received out of order.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RxSegmentCountOutOfOrderGet())


        """
        return _byteblower.TCPResultSnapshot_RxSegmentCountOutOfOrderGet(self)

    def TxByteCountHeaderGet(self):
        r"""

        Returns the number of transmitted TCP header bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TxByteCountHeaderGet())


        """
        return _byteblower.TCPResultSnapshot_TxByteCountHeaderGet(self)

    def TxByteCountPayloadGet(self):
        r"""

        Returns the number of transmitted TCP payload bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TxByteCountPayloadGet())


        """
        return _byteblower.TCPResultSnapshot_TxByteCountPayloadGet(self)

    def TxByteCountTotalGet(self):
        r"""

        Returns the total number of bytes transmitted on the current TCP connection.

        :rtype: int

        This is the sum of the tranmitted TCP header and payload bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TxByteCountTotalGet())


        """
        return _byteblower.TCPResultSnapshot_TxByteCountTotalGet(self)

    def RxByteCountHeaderGet(self):
        r"""

        Returns the number of received TCP header bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RxByteCountHeaderGet())


        """
        return _byteblower.TCPResultSnapshot_RxByteCountHeaderGet(self)

    def RxByteCountPayloadGet(self):
        r"""

        Returns the number of received TCP payload bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RxByteCountPayloadGet())


        """
        return _byteblower.TCPResultSnapshot_RxByteCountPayloadGet(self)

    def RxByteCountTotalGet(self):
        r"""

        Returns the total number of bytes received on the current TCP connection.

        :rtype: int

        This is the sum of the received TCP header and payload bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RxByteCountTotalGet())


        """
        return _byteblower.TCPResultSnapshot_RxByteCountTotalGet(self)

    def ReceiverWindowCurrentGet(self):
        r"""

        Returns the current TCP receiver window (RWND).

        :rtype: int

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.ReceiverWindowCurrentGet())


        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowCurrentGet(self)

    def ReceiverWindowMinimumGet(self):
        r"""

        Returns the smallest recorded TCP receiver window (RWND).

        :rtype: int

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.ReceiverWindowMinimumGet())


        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowMinimumGet(self)

    def ReceiverWindowMaximumGet(self):
        r"""

        Returns the largest recorded TCP receiver window (RWND).

        :rtype: int

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.ReceiverWindowMaximumGet())


        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowMaximumGet(self)

    def CongestionWindowCurrentGet(self):
        r"""

        Returns the current TCP congestion window (CWND).

        :rtype: int

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.CongestionWindowCurrentGet())


        """
        return _byteblower.TCPResultSnapshot_CongestionWindowCurrentGet(self)

    def CongestionWindowMinimumGet(self):
        r"""

        Returns the smallest recorded TCP congestion window (CWND).

        :rtype: int

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.CongestionWindowMinimumGet())


        """
        return _byteblower.TCPResultSnapshot_CongestionWindowMinimumGet(self)

    def CongestionWindowMaximumGet(self):
        r"""

        Returns the largest recorded TCP congestion window (CWND).

        :rtype: int

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.CongestionWindowMaximumGet())


        """
        return _byteblower.TCPResultSnapshot_CongestionWindowMaximumGet(self)

    def RxLocalCongestionNotificationCountGet(self):
        r"""

        Returns the number of segments received with an explicit congestion notification.

        .. versionadded:: 2.22.0


        """
        return _byteblower.TCPResultSnapshot_RxLocalCongestionNotificationCountGet(self)

    def RxRemoteCongestionNotificationCountGet(self):
        r"""

        Returns the number of segments received with an explicit congestion notification.

        .. versionadded:: 2.22.0


        """
        return _byteblower.TCPResultSnapshot_RxRemoteCongestionNotificationCountGet(self)

    def FlightSizeCurrentGet(self):
        r"""

        Returns the number of bytes that are currently in-flight.

        :rtype: int

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.FlightSizeCurrentGet())


        """
        return _byteblower.TCPResultSnapshot_FlightSizeCurrentGet(self)

    def FlightSizeMinimumGet(self):
        r"""

        Returns the smallest recorded flight-size.

        :rtype: int

        The flight size is the number of bytes that has been transmitted but not
        yet acknowledged.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.FlightSizeMinimumGet())


        """
        return _byteblower.TCPResultSnapshot_FlightSizeMinimumGet(self)

    def FlightSizeMaximumGet(self):
        r"""

        Returns the largest recorded flight-size.

        :rtype: int

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.FlightSizeMaximumGet())


        """
        return _byteblower.TCPResultSnapshot_FlightSizeMaximumGet(self)

    def SlowStartThresholdCurrentGet(self):
        r"""

        Returns the current TCP slow-start threshold (SSTHRESH).

        :rtype: int

        The slow-start threshold indicates the congestion window value where the
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.SlowStartThresholdCurrentGet())


        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdCurrentGet(self)

    def SlowStartThresholdMinimumGet(self):
        r"""

        Returns the smallest recorded TCP slow-start threshold (SSTHRESH).

        :rtype: int

        The slow-start threshold indicates the congestion window value where the
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.SlowStartThresholdMinimumGet())


        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdMinimumGet(self)

    def SlowStartThresholdMaximumGet(self):
        r"""

        Returns the largest recorded TCP slow-start threshold (SSTHRESH).

        :rtype: int

        The slow-start threshold indicates the congestion window value where the
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.SlowStartThresholdMaximumGet())


        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdMaximumGet(self)

    def RoundTripTimeMinimumGet(self):
        r"""

        Returns the smallest recorded round-trip time (RTT) in nanoseconds.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RoundTripTimeMinimumGet())


        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeMinimumGet(self)

    def RoundTripTimeMaximumGet(self):
        r"""

        Returns the largest recorded round-trip time (RTT) in nanoseconds.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RoundTripTimeMaximumGet())


        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeMaximumGet(self)

    def RoundTripTimeCurrentGet(self):
        r"""

        Returns the current round-trip time (RTT) in nanoseconds.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RoundTripTimeCurrentGet())


        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeCurrentGet(self)

    def RoundTripTimeAverageGet(self):
        r"""

        Returns the average round-trip time (RTT) in nanoseconds.

        .. versionadded:: 2.22.0

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RoundTripTimeAverageGet())


        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeAverageGet(self)

    def RetransmissionCountTotalGet(self):
        r"""

        Returns the total number of retranmissions.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RetransmissionCountTotalGet())


        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountTotalGet(self)

    def RetransmissionCountFastGet(self):
        r"""

        Returns the total number of fast retranmissions.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RetransmissionCountFastGet())


        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountFastGet(self)

    def RetransmissionCountSlowGet(self):
        r"""

        Returns the total number of timeout retranmissions.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RetransmissionCountSlowGet())


        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountSlowGet(self)

    def TimestampSynSentGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-SYN segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TimestampSynSentGet())


        """
        return _byteblower.TCPResultSnapshot_TimestampSynSentGet(self)

    def TimestampSynReceivedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received the TCP-SYN segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TimestampSynReceivedGet())


        """
        return _byteblower.TCPResultSnapshot_TimestampSynReceivedGet(self)

    def TimestampEstablishedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection entered the established state.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TimestampEstablishedGet())


        """
        return _byteblower.TCPResultSnapshot_TimestampEstablishedGet(self)

    def TimestampFinSentGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-FIN segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TimestampFinSentGet())


        """
        return _byteblower.TCPResultSnapshot_TimestampFinSentGet(self)

    def TimestampFinReceivedGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received the TCP-FIN segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TimestampFinReceivedGet())


        """
        return _byteblower.TCPResultSnapshot_TimestampFinReceivedGet(self)

    def NumberOfSynSentGet(self):
        r"""

        Returns the number of TCP SYN segments that have been sent.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.NumberOfSynSentGet())


        """
        return _byteblower.TCPResultSnapshot_NumberOfSynSentGet(self)

    def NumberOfSynReceivedGet(self):
        r"""

        Returns the number of TCP SYN segments that have been received.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.NumberOfSynReceivedGet())


        """
        return _byteblower.TCPResultSnapshot_NumberOfSynReceivedGet(self)

    def NumberOfFinSentGet(self):
        r"""

        Returns the number of TCP FIN segments that have been sent.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.NumberOfFinSentGet())


        """
        return _byteblower.TCPResultSnapshot_NumberOfFinSentGet(self)

    def NumberOfFinReceivedGet(self):
        r"""

        Returns the number of TCP FIN segments that have been received.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.NumberOfFinReceivedGet())


        """
        return _byteblower.TCPResultSnapshot_NumberOfFinReceivedGet(self)

    def TxTimestampLastGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection sent its last TCP segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TxTimestampLastGet())


        """
        return _byteblower.TCPResultSnapshot_TxTimestampLastGet(self)

    def RxTimestampLastGet(self):
        r"""

        Returns a nanosecond timestamp for when this TCP connection received its last TCP segment.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RxTimestampLastGet())


        """
        return _byteblower.TCPResultSnapshot_RxTimestampLastGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns nanosecond duration between when result objects are created.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.IntervalDurationGet())


        """
        return _byteblower.TCPResultSnapshot_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Returns the nanosecond timestamp for when this result object was created.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.TimestampGet())


        """
        return _byteblower.TCPResultSnapshot_TimestampGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultSnapshot.RefreshTimestampGet())


        """
        return _byteblower.TCPResultSnapshot_RefreshTimestampGet(self)

# Register TCPResultSnapshot in _byteblower:
_byteblower.TCPResultSnapshot_swigregister(TCPResultSnapshot)
class TCPResultHistory(AbstractRefreshableResult):
    r"""

    Interface that allows you to obtain the cumulative and interval result data
    objects regarding TCP stats.

    At fixed time intervals, ByteBlower takes Interval and Cumulative stats of the
    TCP session. Only a fixed number of stats ( use :meth:`SamplingBufferLengthGet`
    to know how many ) are kept in memory at the ByteBlower server. Using the
    'Refresh()' method those stats are transfered to the client pc where they
    are stored until you clear them ( :meth:`Clear` ).

    The interval duration of such a historyObject can be obtained using
    :meth:`SamplingIntervalDurationGet`


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        r"""


        :return: a list of :class:`.TCPResultData` containing the Cumulative counters
        :rtype: TCPResultDataList

        Returns a list of recent TCP result objects containing cumulative counters.

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultList = tcpResultHistory.CumulativeGet()


        """
        return _byteblower.TCPResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a list of recent TCP result objects containing cumulative counters.

        :param index: index of the cumulative snapshot to query
        :type index: int

        :return: The queried Cumulative snapshot
        :rtype: TCPResultData

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.CumulativeGetByIndex(0).DescriptionGet())


        """
        return _byteblower.TCPResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns a list of recent TCP result objects containing cumulative counters.

        :return:  The length of the cumulative list
        :rtype: int

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.CumulativeLengthGet())


        """
        return _byteblower.TCPResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of recent TCP result objects containing interval counters.

        :return: a list of :class:`.TCPResultData` containing the Interval counters
        :rtype: TCPResultDataList

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The duration of the interval can
        be obtained using :meth:`SamplingIntervalDurationGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           intervalCounterList = tcpResultHistory.IntervalGetByTime(time).Intervalget()


        """
        return _byteblower.TCPResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a list of recent TCP result objects containing interval counters.

        :param index: The index of the interval snapshot to be queried.
        :type index: int

        :rtype: TCPResultData

        Each result object contains the counters only for a specific time interval. The
        duration of the interval can be obtained using
        :meth:`SamplingIntervalDurationGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.IntervalGetByIndex(0).DescriptionGet())


        """
        return _byteblower.TCPResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns a list of recent TCP result objects containing interval counters.

        :return: The length of the Interval list
        :rtype: int

        Each result object contains the counters only for a specific time interval. The
        duration of the interval can be obtained using
        :meth:`SamplingIntervalDurationGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.IntervalLengthGet())


        """
        return _byteblower.TCPResultHistory_IntervalLengthGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        .. versionadded:: 2.2.0

        :param timestamp: Timestamps in nanoseconds since epoch selecting a cumulative snapshot
        :type timestamp: int

        :rtype: TCPResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.CumulativeGetByTime(timestamp).DescriptionGet())


        """
        return _byteblower.TCPResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        .. versionadded:: 2.2.0

        :rtype: TCPResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.IntervalGetByTime(timestamp).DescriptionGet())


        """
        return _byteblower.TCPResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        .. versionadded:: 2.2.0

        :rtype: TCPResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.CumulativeLatestGet())


        """
        return _byteblower.TCPResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        .. versionadded:: 2.2.0

        :rtype: TCPResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.IntervalLatestGet().DescriptionGet())


        """
        return _byteblower.TCPResultHistory_IntervalLatestGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.SamplingIntervalDurationGet())


        """
        return _byteblower.TCPResultHistory_SamplingIntervalDurationGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer at server-side.

        :return: The length of the server sample buffer
        :rtype: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.SamplingBufferLengthGet())


        """
        return _byteblower.TCPResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. versionadded:: 2.3.0

        :param interval: The duration in nanoseconds for a single sample
        :type interval: int

        .. warning: The previously collected history will be invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tcpResultHistory.SamplingIntervalDurationSet(1000000000)


        """
        return _byteblower.TCPResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        .. versionadded:: 2.3.0

        :param samples: The number of samples to keep in the Server buffer
        :type samples: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tcpResultHistory.SamplingBufferLengthSet(6)


        """
        return _byteblower.TCPResultHistory_SamplingBufferLengthSet(self, inLength)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history is requested.

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        This is the timestamp on the server when the last time 'Refresh()' was called.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpResultHistory.RefreshTimestampGet())


        """
        return _byteblower.TCPResultHistory_RefreshTimestampGet(self)

    def Clear(self):
        r"""

        Clears the history.

        With each invocation of 'Refresh()', interval and cumulative counters are
        transferred from Server to the Client. To remove all counter-objects in this
        history, you can  execute this method. Both Interval and Cumulative counter
        lists will be cleared.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tcpResultHistory.Clear()


        """
        return _byteblower.TCPResultHistory_Clear(self)

# Register TCPResultHistory in _byteblower:
_byteblower.TCPResultHistory_swigregister(TCPResultHistory)
class HTTPResultData(AbstractObject):
    r"""

    Contains the HTTP result counters.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AverageDataSpeedGet(self):
        r"""

        Rate in bytes per seconds of the data transferred.

        :return: Rate in bytes per second
        :rtype: DataRate

        This method determines the direction of the traffic based on the HTTP method
        and whether the parent is an HTTPServer or HTTPClient.

        - A "GET" request on an HTTPServer : TX traffic.
        - A "GET" request on an HTTPClient : RX traffic.
        - A "PUT" request on an HTTPServer : RX traffic.
        - A "PUT" request on an HTTPClient : TX traffic.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.AverageDataSpeedGet().BitRateGet())


        """
        return _byteblower.HTTPResultData_AverageDataSpeedGet(self)

    def RxByteCountHeaderGet(self):
        r"""

        The size of the received HTTP header in bytes.

        :rtype: int

        HTTP header contains the HTTP header fields. These fields define the operating
        parameters of an HTTP transaction (e.g. :
        User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0
        )

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.RxByteCountHeaderGet())


        """
        return _byteblower.HTTPResultData_RxByteCountHeaderGet(self)

    def RxByteCountPayloadGet(self):
        r"""

        The size of the received HTTP Payload in bytes.

        :rtype: int

        The size of the actual content of the HTTP transaction

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.RxByteCountPayloadGet())


        """
        return _byteblower.HTTPResultData_RxByteCountPayloadGet(self)

    def RxByteCountRateGet(self):
        r"""

        Rate of the data received.

        :return: Rate in bytes per second
        :rtype: DataRate

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.RxByteCountRateGet())


        """
        return _byteblower.HTTPResultData_RxByteCountRateGet(self)

    def RxByteCountTotalGet(self):
        r"""

        Total of bytes received.

        :return: Total received bytes
        :rtype: int

        The total is the sum of :meth:`RxByteCountHeaderGet` and
        :meth:`RxByteCountPayloadGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.RxByteCountTotalGet())


        """
        return _byteblower.HTTPResultData_RxByteCountTotalGet(self)

    def TxByteCountHeaderGet(self):
        r"""

        The size of the transmitted HTTPHeader in bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxByteCountHeaderGet())


        """
        return _byteblower.HTTPResultData_TxByteCountHeaderGet(self)

    def TxByteCountRateGet(self):
        r"""

        Rate in bytes per seconds of the data sent.

        :return: Rate in bytes per second
        :rtype: DataRate

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxByteCountRateGet().BitRateGet())


        """
        return _byteblower.HTTPResultData_TxByteCountRateGet(self)

    def TxByteCountPayloadGet(self):
        r"""

        The size of the transmitted HTTPPayload in bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.TxByteCountPayloadGet())


        """
        return _byteblower.HTTPResultData_TxByteCountPayloadGet(self)

    def TxByteCountTotalGet(self):
        r"""

        Total of transmitted bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.TxByteCountTotalGet())


        """
        return _byteblower.HTTPResultData_TxByteCountTotalGet(self)

    def TxTimestampFirstGet(self):
        r"""

        Timestamp (in nanoseconds) of first transmitted packet.

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxTimestampFirstGet())


        """
        return _byteblower.HTTPResultData_TxTimestampFirstGet(self)

    def TxTimestampLastGet(self):
        r"""

        Timestamp (in nanoseconds) of last transmitted packet.

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxTimestampLastGet())


        """
        return _byteblower.HTTPResultData_TxTimestampLastGet(self)

    def RxTimestampFirstGet(self):
        r"""

        Timestamp (in nanoseconds) of first received packet.

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.RxTimestampFirstGet())


        """
        return _byteblower.HTTPResultData_RxTimestampFirstGet(self)

    def RxTimestampLastGet(self):
        r"""

        Timestamp (in nanoseconds) of last received packet.

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.RxTimestampLastGet())


        """
        return _byteblower.HTTPResultData_RxTimestampLastGet(self)

    def LatencyMinimumGet(self, default_value):
        r"""

        Returns the minimum latency measured.

        :param default: Default value when this counter is not available
        :type default: int

        :return: The measured minimum latency in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.LatencyMinimumGet())


        """
        return _byteblower.HTTPResultData_LatencyMinimumGet(self, default_value)

    def LatencyMaximumGet(self, default_value):
        r"""

        Returns the maximum latency measured.

        :param default: Default value when this counter is not available
        :type default: int

        :return: The measured maximum latency in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.LatencyMaximumGet())


        """
        return _byteblower.HTTPResultData_LatencyMaximumGet(self, default_value)

    def LatencyAverageGet(self, default_value):
        r"""

        Returns the average latency measured.

        :param default: Default value when this counter is not available
        :type default: int

        :return: The measured average latency in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.LatencyAverageGet())


        """
        return _byteblower.HTTPResultData_LatencyAverageGet(self, default_value)

    def JitterGet(self, default_value):
        r"""

        Returns the jitter on the latency measured.

        :param default: Default value when this counter is not available
        :type default: int

        :return: The measured jitter in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.JitterGet())


        """
        return _byteblower.HTTPResultData_JitterGet(self, default_value)

    def IntervalDurationGet(self):
        r"""

        Returns the duration of this interval in nanoseconds.

        :return: intervalduration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.IntervalDurationGet())


        """
        return _byteblower.HTTPResultData_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds
        :rtype: int

        Example
        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TimestampGet())


        """
        return _byteblower.HTTPResultData_TimestampGet(self)

# Register HTTPResultData in _byteblower:
_byteblower.HTTPResultData_swigregister(HTTPResultData)
class HTTPResultDataList(object):
    r"""

    This is a List of multiple HTTPResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPResultDataList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPResultDataList_swiginit(self, _byteblower.new_HTTPResultDataList(*args))
    __swig_destroy__ = _byteblower.delete_HTTPResultDataList

# Register HTTPResultDataList in _byteblower:
_byteblower.HTTPResultDataList_swigregister(HTTPResultDataList)
class HTTPResultSnapshot(AbstractRefreshableResult):
    r"""

    Contains HTTP result counters.

    You can refresh the counters by calling the :obj:`~.AbstractObject.Refresh` 
    method on this object.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AverageDataSpeedGet(self):
        r"""

        Rate of the data transferred.

        Depending on the HTTP method or if the parent of this object is an
        :class:`HTTPServer` or :class:`HTTPClient`, the rate of the traffic sent or
        received will be returned

        :return: Rate in bytes per second
        :rtype: DataRate

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.AverageDataSpeedGet())


        """
        return _byteblower.HTTPResultSnapshot_AverageDataSpeedGet(self)

    def RxByteCountHeaderGet(self):
        r"""

        The size of the received HTTPheader in bytes.

        HTTP header contains the HTTP header fields. These fields define the operating
        parameters of an HTTP transaction (e.g. : User-Agent: Mozilla/5.0 (X11;
        Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 )

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           result = httP
            print(resultSnapshot.RxByteCountHeaderGet())


        """
        return _byteblower.HTTPResultSnapshot_RxByteCountHeaderGet(self)

    def RxByteCountPayloadGet(self):
        r"""

        The size of the received HTTP Payload in bytes.

        :rtype: int

        The size of the actual content of the HTTP transaction

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.RxByteCountPayloadGet())


        """
        return _byteblower.HTTPResultSnapshot_RxByteCountPayloadGet(self)

    def RxByteCountRateGet(self):
        r"""

        Rate of the data received.

        :return: Rate in bytes per second
        :rtype: DataRate

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.RxByteCountRateGet())


        """
        return _byteblower.HTTPResultSnapshot_RxByteCountRateGet(self)

    def RxByteCountTotalGet(self):
        r"""

        Total number of bytes received.

        :return: Total received bytes
        :rtype: int

        The total is the sum of :meth:`RxByteCountHeaderGet` and
        :meth:`RxByteCountPayloadGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.RxByteCountTotalGet())


        """
        return _byteblower.HTTPResultSnapshot_RxByteCountTotalGet(self)

    def TxByteCountHeaderGet(self):
        r"""

        The size of the transmitted HTTPHeader in bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.TxByteCountHeaderGet())


        """
        return _byteblower.HTTPResultSnapshot_TxByteCountHeaderGet(self)

    def TxByteCountPayloadGet(self):
        r"""

        The size of the transmitted HTTPPayload in bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.TxByteCountPayloadGet())


        """
        return _byteblower.HTTPResultSnapshot_TxByteCountPayloadGet(self)

    def TxByteCountRateGet(self):
        r"""

        Rate of the data sent.

        :return: Rate in bytes per second
        :rtype: DataRate

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnaphot.TxByteCountPayloadGet())


        """
        return _byteblower.HTTPResultSnapshot_TxByteCountRateGet(self)

    def TxByteCountTotalGet(self):
        r"""

        Total of transmitted bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.TxByteCountTotalGet())


        """
        return _byteblower.HTTPResultSnapshot_TxByteCountTotalGet(self)

    def TxTimestampFirstGet(self):
        r"""

        Timestamp (in nanoseconds) of first transmitted packet.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.TxTimestampFirstGet())


        """
        return _byteblower.HTTPResultSnapshot_TxTimestampFirstGet(self)

    def TxTimestampLastGet(self):
        r"""

        Timestamp (in nanoseconds) of last transmitted packet.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.TxTimestampLastGet())


        """
        return _byteblower.HTTPResultSnapshot_TxTimestampLastGet(self)

    def RxTimestampFirstGet(self):
        r"""

        Timestamp (in nanoseconds) of first received packet.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.RxTimestampFirstGet())


        """
        return _byteblower.HTTPResultSnapshot_RxTimestampFirstGet(self)

    def RxTimestampLastGet(self):
        r"""

        Timestamp (in nanoseconds) of last received packet.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnapshot.RxTimestampLastGet())


        """
        return _byteblower.HTTPResultSnapshot_RxTimestampLastGet(self)

    def LatencyMinimumGet(self, default_value):
        r"""

        Returns the minimum latency measured.

        :param default: Default value when this counter is not available
        :type default: int

        :return: The measured minimum latency in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.LatencyMinimumGet())


        """
        return _byteblower.HTTPResultSnapshot_LatencyMinimumGet(self, default_value)

    def LatencyMaximumGet(self, default_value):
        r"""

        Returns the maximum latency measured.

        :param default: Default value when this counter is not available
        :type default: int

        :return: The measured maximum latency in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.LatencyMaximumGet())


        """
        return _byteblower.HTTPResultSnapshot_LatencyMaximumGet(self, default_value)

    def LatencyAverageGet(self, default_value):
        r"""

        Returns the average latency measured.

        :param default: Default value when this counter is not available
        :type default: int

        :return: The measured average latency in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.LatencyAverageGet())


        """
        return _byteblower.HTTPResultSnapshot_LatencyAverageGet(self, default_value)

    def JitterGet(self, default_value):
        r"""

        Returns the jitter on the latency measured.

        :param default: Default value when this counter is not available
        :type default: int

        :return: The measured jitter in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.JitterGet())


        """
        return _byteblower.HTTPResultSnapshot_JitterGet(self, default_value)

    def IntervalDurationGet(self):
        r"""

        Returns the duration (in nanoseconds) between snapshot objects.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.IntervalDurationGet())


        """
        return _byteblower.HTTPResultSnapshot_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds
        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnaphot.TimestampGet())


        """
        return _byteblower.HTTPResultSnapshot_TimestampGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.RefreshTimestampGet())


        """
        return _byteblower.HTTPResultSnapshot_RefreshTimestampGet(self)

# Register HTTPResultSnapshot in _byteblower:
_byteblower.HTTPResultSnapshot_swigregister(HTTPResultSnapshot)
class HTTPResultHistory(AbstractRefreshableResult):
    r"""

    General interface for getting cumulative or interval results.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative results.

        :return: a list of :class:`HTTPResultData` containing the Cumulative counters
        :rtype: HTTPResultDataList

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

           print(resultHistory.CumulativeGet()[0].DescriptionGet())


        """
        return _byteblower.HTTPResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: index
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: HTTPResultData

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.CumulativeGetByIndex(0)


        """
        return _byteblower.HTTPResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return: The length of the cumulative list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultHistory.CumulativeLengthGet())


        """
        return _byteblower.HTTPResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        :return: a list of :class:`HTTPResultData` containing the Interval counters
        :rtype: HTTPResultDataList

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.IntervalGet()[0]


        """
        return _byteblower.HTTPResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: index
        :type index: int

        :return: interval counter object at the specified index
        :rtype: HTTPResultData

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.IntervalGetByIndex(0)


        """
        return _byteblower.HTTPResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.IntervalLengthGet())


        """
        return _byteblower.HTTPResultHistory_IntervalLengthGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        :param timestamp: the timestamp of the queried snapshot in nanoseconds since epoch
        :type timestamp: int

        :rtype: HTTPResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.CumulativeGetByTime(timestamp)


        """
        return _byteblower.HTTPResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        :rtype: HTTPResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           interval = resultHistory.IntervalGetByTime(timestamp)


        """
        return _byteblower.HTTPResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :rtype: HTTPResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.CumulativeLatestGet())


        """
        return _byteblower.HTTPResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :rtype: HTTPResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.IntervalLatestGet(0)


        """
        return _byteblower.HTTPResultHistory_IntervalLatestGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.SamplingIntervalDurationGet())


        """
        return _byteblower.HTTPResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. versionadded:: 2.3.0

        :param interval: The duration in nanoseconds of a single sample
        :type interval: int

        .. warning:: The previously collected history will be invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            resultHistory.SamplingIntervalDurationSet(1000000000)


        """
        return _byteblower.HTTPResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        :return: The length of the server sample buffer
        :rtype: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.


        """
        return _byteblower.HTTPResultHistory_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        .. versionadded:: 2.3.0

        :param length: Number of samples to keep in the server-side buffer
        :type length: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :type length: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.SamplingBufferLengthSet(6))


        """
        return _byteblower.HTTPResultHistory_SamplingBufferLengthSet(self, inLength)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the results were last refreshed.

        :return: timestamp in nanoseconds from epoch
        :rtype: int

        Results can be refreshed by calling :obj:`~.AbstractObject.Refresh` on this 
        object.

        .. code-block:: python
           :emphasize-lines: 1

           print(resultHistory.RefreshTimestampGet())


        """
        return _byteblower.HTTPResultHistory_RefreshTimestampGet(self)

    def Clear(self):
        r"""

        Clears the history.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultHistory.Clear()


        """
        return _byteblower.HTTPResultHistory_Clear(self)

# Register HTTPResultHistory in _byteblower:
_byteblower.HTTPResultHistory_swigregister(HTTPResultHistory)
class HTTPSessionInfo(AbstractObject):
    r"""

    Class containing the info about the HTTPSession.

    This class represents the session info gather from a HTTP session. It will
    contain states of the TCP session, Timestamp of received requests average
    throughputs etc...


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Role_Client = _byteblower.HTTPSessionInfo_Role_Client
    Role_Server = _byteblower.HTTPSessionInfo_Role_Server

    def RoleGet(self):
        r"""

        Returns the role of the session.

        Possible values are:

        :return: The role the session was/is playing
        :rtype: Role

        Example

        retrieve the httpsession info from the httpClient

        .. code-block:: python
           :emphasize-lines: 1

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO???


        """
        return _byteblower.HTTPSessionInfo_RoleGet(self)

    def TcpSessionInfoGet(self):
        r"""

        Returns the TCP Session Information for this session.

        :rtype: TCPSessionInfo

        The TCP Session information contains information about the TCP underlying
        session.

        .. code-block:: python
           :emphasize-lines: 1

           print(httpSessionInfo.TcpSessionInfoGet().DescriptionGet())


        """
        return _byteblower.HTTPSessionInfo_TcpSessionInfoGet(self)

    def RequestMethodGet(self):
        r"""

        Returns the http request method of the session.

        :return: The request method used in this session
        :rtype: HTTPRequestMethod

        Example

        retrieve the httpsession info from the httpClient

        .. code-block:: python
           :emphasize-lines: 1

           print(httpSessionInfo.RequestMethodGet() == HTTPRequestMethod.Get)


        """
        return _byteblower.HTTPSessionInfo_RequestMethodGet(self)

    def RequestTypeGet(self):
        r"""

        Returns the request type ( Duration or Size )

        :return: request Type
        :rtype: HTTPRequestType

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpSessionInfo.RequestTypeGet() == HTTPRequestType.Duration)


        """
        return _byteblower.HTTPSessionInfo_RequestTypeGet(self)

    def RequestStatusGet(self):
        r"""

        Returns the status of the HTTP request.

        :rtype: HTTPRequestStatus

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpSessionInfo.RequestStatusGet() == HTTPRequestStatus.Running)


        """
        return _byteblower.HTTPSessionInfo_RequestStatusGet(self)

    def ErrorMessageGet(self):
        r"""

        Returns the error message.

        :return: The error message string
        :rtype: str

        When the request status is "Error" then extra information can be obtained
        with this method.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpSessionInfo.ErrorMessageGet())


        """
        return _byteblower.HTTPSessionInfo_ErrorMessageGet(self)

    def RequestValueGet(self):
        r"""

        Returns the request value.

        :return: Request Value
        :rtype: int

        In case of duration based session it returns the duration that was requested by
        the httpClient. For Size it returns the requested payload size

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.RequestValueGet())


        """
        return _byteblower.HTTPSessionInfo_RequestValueGet(self)

    def RequestDurationGet(self):
        r"""

        Returns the configured Request Duration

        :return: The configured duration in nanoseconds or 0 when the Request Type is not Duration
        :rtype: int


        """
        return _byteblower.HTTPSessionInfo_RequestDurationGet(self)

    def RequestSizeGet(self):
        r"""

        Returns the configured Request Size

        :return: The configured size in bytes or 0 when the Request Type is not Size
        :rtype: int


        """
        return _byteblower.HTTPSessionInfo_RequestSizeGet(self)

    def ServerClientIdGet(self):
        r"""

        Returns the unique identifier for this session.

        :rtype: str

        See: :obj:`.HTTPClient.ServerClientIdGet`


        """
        return _byteblower.HTTPSessionInfo_ServerClientIdGet(self)

    def ResultGet(self):
        r"""

        Returns the HTTPResultSnapshot for this session.

        :rtype: HTTPResultSnapshot

        The snapshot contains byte counters and time values.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.ResultGet().DescriptionGet())


        """
        return _byteblower.HTTPSessionInfo_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the HTTPResultHistory for this session.

        :rtype: HTTPResultHistory

        The history contains a list of snapshots taken at one second intervals. To 
        update the history use the :obj:`~.AbstractObject.Refresh` method on this 
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.HTTPSessionInfo_ResultHistoryGet(self)

# Register HTTPSessionInfo in _byteblower:
_byteblower.HTTPSessionInfo_swigregister(HTTPSessionInfo)
class HTTPMultiResultData(AbstractObject):
    r"""

    Contains the result counters for :class:`HTTPMultiClient` or
    :class:`HTTPMultiServer`.

    .. code-block:: python
       :emphasize-lines: 2

       http_multi_data = http_client.ResultHistoryGet().CumulativeGetByIndex(0)
       print(http_multi_data.TxTimestampLastGet(10000000000))


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FinishedGet(self):
        r"""

        Indicates whether the flow has finished.

        :return: True indicates if the flow has finished.
        :rtype: bool

        For the :class:`HTTPMultiClient` this means that client state is Finished or
        Stopped. For the :class:`HTTPMultiServer` this means the server state is
        Stopped.


        """
        return _byteblower.HTTPMultiResultData_FinishedGet(self)

    def RxByteCountGet(self):
        r"""

        Returns number of received bytes.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultData_RxByteCountGet(self)

    def TxByteCountGet(self):
        r"""

        Returns number of sent bytes.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultData_TxByteCountGet(self)

    def RxSpeedGet(self):
        r"""

        Returns average Rx speed .

        :rtype: DataRate


        """
        return _byteblower.HTTPMultiResultData_RxSpeedGet(self)

    def TxSpeedGet(self):
        r"""

        Returns average Tx speed .

        :rtype: DataRate


        """
        return _byteblower.HTTPMultiResultData_TxSpeedGet(self)

    def TxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp of the first transmitted packet or a default value in case no packets were transmitted.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.TxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TxTimestampFirstGet(self, default_value)

    def TxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp of the last transmitted packet or a default value in case no packets were transmitted.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype:int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.TxTimestampLastGet(10000000000))


        """
        return _byteblower.HTTPMultiResultData_TxTimestampLastGet(self, default_value)

    def RxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first receieved packet or a default value in case no packets were received.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.RxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RxTimestampFirstGet(self, default_value)

    def RxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp of the last receieved packet or a default value in case no packets were received.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.RxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RxTimestampLastGet(self, default_value)

    def TcpRxByteCountGet(self):
        r"""

        Returns number of bytes received by the TCP protocol. 

        :rtype: int

        This includes the TCP header.


        """
        return _byteblower.HTTPMultiResultData_TcpRxByteCountGet(self)

    def TcpTxByteCountGet(self):
        r"""

        Returns number of bytes sent by the TCP protocol. This includes the TCP header and TCP retransmissions.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultData_TcpTxByteCountGet(self)

    def TcpRxSpeedGet(self):
        r"""

        Returns average Rx speed on OSI layer 4.

        :rtype: DataRate


        """
        return _byteblower.HTTPMultiResultData_TcpRxSpeedGet(self)

    def TcpTxSpeedGet(self):
        r"""

        Returns average Tx speed on OSI layer 4.

        :rtype: DataRate


        """
        return _byteblower.HTTPMultiResultData_TcpTxSpeedGet(self)

    def TcpRxSegmentCountGet(self):
        r"""

        Returns number of packets received by the TCP protocol.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultData_TcpRxSegmentCountGet(self)

    def TcpTxSegmentCountGet(self):
        r"""

        Returns number of packets sent by the TCP protocol.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultData_TcpTxSegmentCountGet(self)

    def TcpTxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first transmitted TCP segment or a default value in case no packets were transmitted.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.TcpTxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpTxTimestampFirstGet(self, default_value)

    def TcpTxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last transmitted TCP segment or a default value in case no packets were transmitted. 

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        Prints -1 if the counter is not available.

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.TcpTxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpTxTimestampLastGet(self, default_value)

    def TcpRxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first receieved TCP segment or a default value in case no packets were received.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.TcpRxTimestampFirstGet(100000))


        """
        return _byteblower.HTTPMultiResultData_TcpRxTimestampFirstGet(self, default_value)

    def TcpRxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp of the last receieved TCP segment or a default value in case no packets were received.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.TcpRxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpRxTimestampLastGet(self, default_value)

    def RoundTripTimeAverageGet(self, default_value):
        r"""

        Returns average TCP round-trip time or a default value in case no round-trip samples are available.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: The TCP RTT expressed in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.RoundTripTimeAverageGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeAverageGet(self, default_value)

    def RoundTripTimeMinimumGet(self, default_value):
        r"""

        Returns minimum TCP round-trip time or a default value in case no round-trip samples are available.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: The TCP RTT expressed in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.RoundTripTimeMinimumGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeMinimumGet(self, default_value)

    def RoundTripTimeMaximumGet(self, default_value):
        r"""

        Returns maximum TCP round-trip time or a default value in case no round-trip samples are available.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: The TCP RTT in nanoseconds or the given default value.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.RoundTripTimeMaximumGet)


        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeMaximumGet(self, default_value)

    def RetransmissionsGet(self):
        r"""

        Returns number of TCP retransmissions.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultData_RetransmissionsGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns the snapshot duration interval in nanoseconds.

        :return: interval duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

              print(http_multi_data.IntervalDurationGet())


        """
        return _byteblower.HTTPMultiResultData_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds since epoch
        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.TimestampGet())


        """
        return _byteblower.HTTPMultiResultData_TimestampGet(self)

    def ConnectionsAttemptedGet(self):
        r"""

        Returns the number of TCP connection attempts that were initiated.

        :rtype: int

        For the :class:`HTTPMultiClient` this means the number of active TCP connection
        attempts initiated. For the :class:`HTTPMultiServer` this means the number of
        passive TCP connection requests received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(http_multi_data.ConnectionsAttemptedGet())


        """
        return _byteblower.HTTPMultiResultData_ConnectionsAttemptedGet(self)

    def ConnectionsEstablishedGet(self):
        r"""

        Returns the number of succesful TCP connection attempts that reached ESTABLISHED state.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.ConnectionsEstablishedGet())


        """
        return _byteblower.HTTPMultiResultData_ConnectionsEstablishedGet(self)

    def ConnectionsAbortedGet(self):
        r"""

        Returns the number of aborted TCP connection attempts.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.ConnectionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultData_ConnectionsAbortedGet(self)

    def ConnectionsRefusedGet(self):
        r"""

        Returns the number of TCP connection attempts that were refused by the other side.

        :rtype: int

        For the :class:`HTTPMultiServer` this value is always zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.ConnectionsRefusedGet())


        """
        return _byteblower.HTTPMultiResultData_ConnectionsRefusedGet(self)

    def SessionsFinishedGet(self):
        r"""

        Returns the number HTTP requests that finished succesfully.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.SessionsFinishedGet())


        """
        return _byteblower.HTTPMultiResultData_SessionsFinishedGet(self)

    def SessionsAbortedGet(self):
        r"""

        Returns the number HTTP requests that failed because they were aborted locally.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.SessionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultData_SessionsAbortedGet(self)

    def SessionsResetByPeerGet(self):
        r"""

        Returns the number HTTP requests that failed because a TCP RESET message was received.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.SessionsResetByPeerGet())


        """
        return _byteblower.HTTPMultiResultData_SessionsResetByPeerGet(self)

    def DebugCountersNamesGet(self):
        r"""

        Returns a list of debug counter names.

        :rtype: StringList

        .. note:: The list of names is not backwards compatible.


        """
        return _byteblower.HTTPMultiResultData_DebugCountersNamesGet(self)

    def DebugCountersGetByName(self, name):
        r"""

        Returns a list of debug counter values.

        :param name: The name of the debug counter (obtained from
                     :meth:`DebugCountersNamesGet`).
        :type name: str

        :rtype: int

        .. note:: The list of debug values is not backwards compatible.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_multi_data.DebugCountersGetByName('State_Closing'))


        """
        return _byteblower.HTTPMultiResultData_DebugCountersGetByName(self, name)

# Register HTTPMultiResultData in _byteblower:
_byteblower.HTTPMultiResultData_swigregister(HTTPMultiResultData)
class HTTPMultiResultSnapshot(AbstractRefreshableResult):
    r"""

    Refreshable snapshot that contains the result counters for HTTPMultiClient or
    HTTPMultiServer.

    You can refresh the counters by calling the :obj:`~.AbstractObject.Refresh` 
    method on this object.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FinishedGet(self):
        r"""

        Indicates whether the flow has finished.

        :return: True if the flow has finished.
        :rtype: bool

        For the :class:`HTTPMultiClient` this means that client state is Finished or
        Stopped. For the :class:`HTTPMultiServer` this means the server state is
        Stopped.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.FinishedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_FinishedGet(self)

    def RxByteCountGet(self):
        r"""

        Returns number of received bytes.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultSnapshot_RxByteCountGet(self)

    def TxByteCountGet(self):
        r"""

        Returns number of sent bytes.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultSnapshot_TxByteCountGet(self)

    def RxSpeedGet(self):
        r"""

        Returns average Rx speed.

        :rtype: DataRate


        """
        return _byteblower.HTTPMultiResultSnapshot_RxSpeedGet(self)

    def TxSpeedGet(self):
        r"""

        Returns average Tx speed.

        :rtype: DataRate


        """
        return _byteblower.HTTPMultiResultSnapshot_TxSpeedGet(self)

    def TxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first transmitted packet or a default value in case no packets were transmitted.

        :param default: A default value to return in case no samples are available
        :type default: int
        :param default: A default value to return in case no packets were transmitted
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.TxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TxTimestampFirstGet(self, default_value)

    def TxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last transmitted packet or a default value in case no packets were transmitted.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example
        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.TxTimestampLastGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TxTimestampLastGet(self, default_value)

    def RxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first receieved packet or a default value in case no packets were received.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.RxTimestampFirstGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RxTimestampFirstGet(self, default_value)

    def RxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last receieved packet or a default value in case no packets were received.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.RxTimestampLastGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RxTimestampLastGet(self, default_value)

    def TcpRxByteCountGet(self):
        r"""

        Returns number of bytes received by the TCP protocol. This includes the TCP header.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxByteCountGet(self)

    def TcpTxByteCountGet(self):
        r"""

        Returns number of bytes sent by the TCP protocol. This includes the TCP header and TCP retransmissions.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxByteCountGet(self)

    def TcpRxSpeedGet(self):
        r"""

        Returns average Rx speed on OSI layer 4

        :rtype: DataRate


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxSpeedGet(self)

    def TcpTxSpeedGet(self):
        r"""

        Returns average Tx speed on OSI Layer 4.

        :rtype: DataRate


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxSpeedGet(self)

    def TcpRxSegmentCountGet(self):
        r"""

        Returns number of packets received by the TCP protocol.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxSegmentCountGet(self)

    def TcpTxSegmentCountGet(self):
        r"""

        Returns number of packets sent by the TCP protocol.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxSegmentCountGet(self)

    def TcpTxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first transmitted TCP segment or a default value in case no packets were transmitted.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.TcpTxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxTimestampFirstGet(self, default_value)

    def TcpTxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last transmitted TCP segment or a default value in case no packets were transmitted.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.TcpTxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxTimestampLastGet(self, default_value)

    def TcpRxTimestampFirstGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the first receieved TCP segment or a default value in case no packets were received.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.TcpRxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxTimestampFirstGet(self, default_value)

    def TcpRxTimestampLastGet(self, default_value):
        r"""

        Returns the timestamp (in nanoseconds) of the last receieved TCP segment or a default value in case no packets were received.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.TcpRxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxTimestampLastGet(self, default_value)

    def RoundTripTimeAverageGet(self, default_value):
        r"""

        Returns average TCP round-trip time or a default value in case no round-trip samples are available.

        :param default: A default value to return in case no samples are available
        :type default: int

        :return: The TCP RTT expressed in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.RoundTripTimeAverageGet(10000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeAverageGet(self, default_value)

    def RoundTripTimeMinimumGet(self, default_value):
        r"""

        Returns minimum TCP round-trip time or a default value in case no round-trip samples are available.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.RoundTripTimeMinimumGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeMinimumGet(self, default_value)

    def RoundTripTimeMaximumGet(self, default_value):
        r"""

        Returns maximum TCP round-trip time or a default value in case no round-trip samples are available.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.RoundTripTimeMaximumGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeMaximumGet(self, default_value)

    def RetransmissionsGet(self):
        r"""

        Returns number of TCP retransmissions.

        :rtype: int


        """
        return _byteblower.HTTPMultiResultSnapshot_RetransmissionsGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns the duration (in nanoseconds) between snapshot objects.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.IntervalDurationGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_IntervalDurationGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds
        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.TimestampGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_TimestampGet(self)

    def ConnectionsAttemptedGet(self):
        r"""

        Returns the number of TCP connection attempts that were initiated.

        :rtype: int

        For the :class:`HTTPMultiClient` this means the number of active TCP connection
        attempts initiated. For the :class:`HTTPMultiServer` this means the number of
        passive TCP connection requests received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.ConnectionsAttemptedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsAttemptedGet(self)

    def ConnectionsEstablishedGet(self):
        r"""

        Returns the number of succesful TCP connection attempts that reached ESTABLISHED state.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.ConnectionsEstablishedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsEstablishedGet(self)

    def ConnectionsAbortedGet(self):
        r"""

        Returns the number of aborted TCP connection attempts.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.RetransmissionsGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsAbortedGet(self)

    def ConnectionsRefusedGet(self):
        r"""

        Returns the number of TCP connection attempts that were refused by the other side.

        :rtype: int

        For the :class:`HTTPMultiServer` this value is always zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(multiSnapshot.ConnectionsRefusedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsRefusedGet(self)

    def SessionsFinishedGet(self):
        r"""

        Returns the number HTTP requests that finished succesfully.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.SessionsFinishedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsFinishedGet(self)

    def SessionsAbortedGet(self):
        r"""

        Returns the number HTTP requests that failed because they were aborted locally.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.SessionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsAbortedGet(self)

    def SessionsResetByPeerGet(self):
        r"""

        Returns the number HTTP requests that failed because a TCP RESET message was received.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.SessionsResetByPeerGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsResetByPeerGet(self)

    def DebugCountersNamesGet(self):
        r"""

        Returns a list of debug counter names.

        :rtype: StringList

        .. note:: The list of names is not backwards compatible.


        """
        return _byteblower.HTTPMultiResultSnapshot_DebugCountersNamesGet(self)

    def DebugCountersGetByName(self, name):
        r"""

        Returns a debug counter by name.

        :param name: name of the counter to fetch
        :type name: str

        :rtype: int

        .. note: : The list of debug values is not backwards compatible.

        :param name: The name of the debug counter (obtained from
                     :meth:`DebugCountersNamesGet`).


        """
        return _byteblower.HTTPMultiResultSnapshot_DebugCountersGetByName(self, name)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(multiSnapshot.RefreshTimestampGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RefreshTimestampGet(self)

# Register HTTPMultiResultSnapshot in _byteblower:
_byteblower.HTTPMultiResultSnapshot_swigregister(HTTPMultiResultSnapshot)
class HTTPMultiResultHistory(AbstractRefreshableResult):
    r"""

    General interface for getting cumulative or interval results.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative results.

        :return: list of :class:`HTTPMultiResultData` containing the Cumulative counters
        :rtype: HTTPMultiDataList

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.CumulativeGet())


        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: number of the snapshot to get
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: HTTPMultiResultData

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.CumulativeGetByIndex(0))


        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return: The length of the cumulative list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.CumulativeLengthGet())


        """
        return _byteblower.HTTPMultiResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        :return: a list of :class:`.HTTPMultiResultData` containing the Interval counters
        :rtype: HTTPMultiDataList

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.IntervalGet()[0].DescriptionGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: The interval counter to fetch
        :type index: int

        :return: interval counter object at the specified index
        :rtype: HTTPMultiResultData

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.IntervalGetByIndex(0).DescriptionGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.IntervalLengthGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalLengthGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        :param timestamp: timestamp in nanoseconds since epoch
        :type timestamp: int

        :rtype: HTTPMultiResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.CumulativeGetByTime(timestamp))


        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        :param timestamp: timestamp in nanoseconds since epoch
        :type timestamp: int

        :rtype: HTTPMultiResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.IntervalGetByTime(timestamp).DescriptionGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :rtype: HTTPMultiResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.CumulativeLatestGet())


        """
        return _byteblower.HTTPMultiResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :rtype: HTTPMultiResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.IntervalLatestGet().DescriptionGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalLatestGet(self)

    def RefreshTimestampGet(self):
        r"""

        RefreshTimestampGet.

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.RefreshTimestampGet())


        """
        return _byteblower.HTTPMultiResultHistory_RefreshTimestampGet(self)

    def Clear(self):
        r"""

        Clears the history.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_result_history.Clear()


        """
        return _byteblower.HTTPMultiResultHistory_Clear(self)

# Register HTTPMultiResultHistory in _byteblower:
_byteblower.HTTPMultiResultHistory_swigregister(HTTPMultiResultHistory)
class HTTPMultiClient(AbstractObject):
    r"""

    HTTPMultiClient can be used in combination with MultiServer to start multiple
    concurrent HTTP requests.

    .. versionadded:: 2.10.0

    When starting the flow, the configured number of HTTP requests will be started.
    Each time a request is finished (succesfully or unsuccesfully) it will be
    replaced by a new request. This is repeated until one of the configured stop
    conditions is reached. Possible stop conditions are: total duration, total size
    or number of connections created. If no stop conditions are configured then the
    flow continues indefinitely.

    Main parameters:

    MaximumConcurrentRequests
        Number of HTTP requests to run concurrently

    Duration
        Total duration of the flow

    Size
        Total number of bytes that may transmitted

    SessionDuration
        Duration of individual requests

    SessionSize
        Number of bytes transmitted by individual requests

    CumulativeConnectionLimit
        Maximum number of connections that may be created during the whole flow


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def StatusGet(self):
        r"""

        Returns the status of the flow.

        :rtype: HTTPMultiClientStatus

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.StatusGet()


        """
        return _byteblower.HTTPMultiClient_StatusGet(self)

    def FinishedGet(self):
        r"""

        Returns true if the flow has finished or was stopped explicitly.

        :rtype: bool

        Example

        Check if the multi-session is finished

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.FinishedGet())


        """
        return _byteblower.HTTPMultiClient_FinishedGet(self)

    def DurationSet(self, value):
        r"""

        Sets the maximum total duration of the flow.

        :param requestDuration: The total duration of the flow.
                                A value of zero indicates unlimited duration.
                                (Default: 0)
        :type requestDuration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure the flow to run for 15 minutes

           httpMultiClient.DurationSet(15*60*1000000000)


        """
        return _byteblower.HTTPMultiClient_DurationSet(self, value)

    def DurationGet(self):
        r"""

        Returns the flow duration.

        :return:  The configured request duration in nanoseconds.
                  A value of zero indicates unlimited duration
                  (Default: 0)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.DurationGet())


        """
        return _byteblower.HTTPMultiClient_DurationGet(self)

    def SizeSet(self, value):
        r"""

        Puts a size limit on the total number of bytes that can be sent.

        :param requestsize: The maximum cumulative payload size of all flows. 
                            A value of zero indicates unlimited size.
                            (Default: 0)
        :type: int

        Example

        Allow a global payload of 1 GB

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.SizeSet(1000000000)


        """
        return _byteblower.HTTPMultiClient_SizeSet(self, value)

    def SizeGet(self):
        r"""

        Returns the size limit.

        :rtype: int

        A value of zero indicates unlimited size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SizeGet())


        """
        return _byteblower.HTTPMultiClient_SizeGet(self)

    def SessionDurationSet(self, value):
        r"""

        Sets the duration for the individual HTTP requests.

        :param duration: The duration of an individual HTTP Request in nanoseconds.  
                         (Default: 0)
        :type duration: int

        Each request will run for the configured duration. This duration will
        automatically be reduced near the end of the flow so that the global time limit
        (see :meth:`DurationSet`) is not exceeded.

        A value of zero indicates unlimited duration.

        :param requestDuration: The duration of each HTTP request.

        Example

        Configure each request to run for 10 seconds

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SessionDurationSet(10000000000))


        """
        return _byteblower.HTTPMultiClient_SessionDurationSet(self, value)

    def SessionDurationGet(self):
        r"""

        Returns the session duration expressed in nanoseconds.

        :return: The duration of the session.
                 A value of zero indicates an unlimited duration.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SessionDurationGet())


        """
        return _byteblower.HTTPMultiClient_SessionDurationGet(self)

    def SessionSizeSet(self, value):
        r"""

        Sets the size for the individual HTTP requests.

        :param size: The size in bytes for a single HTTP Request.
                     A value of zero means unlimited
                     (Default: 0)
        :type size: int

        Each new started request will send or receive the configured size in bytes.

        Example

        Configure each request to send 15000 bytes:

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.SessionSizeSet(1500)


        """
        return _byteblower.HTTPMultiClient_SessionSizeSet(self, value)

    def SessionSizeGet(self):
        r"""

        Returns the session size.

        :rtype: int

        A value of zero indicates unlimited size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SessionSizeGet())


        """
        return _byteblower.HTTPMultiClient_SessionSizeGet(self)

    def SessionRateLimitSet(self, bytes_per_second):
        r"""

        Sets a rate limit for the individual HTTP requests.

        :param limit: The rate limit in bytes per second. (Default: 0)
        :type limit: int

        A value of zero indicates no rate limit.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.SessionRateLimitSet(1500)


        """
        return _byteblower.HTTPMultiClient_SessionRateLimitSet(self, bytes_per_second)

    def SessionRateLimitGet(self):
        r"""

        Returns the rate limit for the individual HTTP requests.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SessionRateLimitGet())


        """
        return _byteblower.HTTPMultiClient_SessionRateLimitGet(self)

    def MaximumConcurrentRequestsGet(self):
        r"""

        Returns the maximum number of concurrent requests.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.MaximumConcurrentRequestsGet())


        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentRequestsGet(self)

    def MaximumConcurrentRequestsSet(self, value):
        r"""

        Sets the maximum number of concurrent requests.

        :param numberOfRequests: Maximum number of concurrent requests.
                                 (Default: 1)
        :type numberOfRequests: int

        The flow will start the requested number of HTTP requests and then maintain
        this number by starting a new request every time a request has finished or
        failed.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Allow 100 concurrent HTTP requests

           httpMultiClient.MaximumConcurrentRequestsSet(100)


        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentRequestsSet(self, value)

    def CumulativeConnectionLimitGet(self):
        r"""

        Returns the limit on the total number of connections that may be created.

        :rtype: int

        A value of zero indicates no limit (infinite number of connections may be
        created).

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.CumulativeConnectionLimitGet())


        """
        return _byteblower.HTTPMultiClient_CumulativeConnectionLimitGet(self)

    def CumulativeConnectionLimitSet(self, value):
        r"""

        Sets a limit on the total number of connections that may be created.

        :param limit: The maximum of connections to be set.
                      A value of zero indicates no limit.
                      (Default: 0)
        :type limit: int

        Once the total number of connection attempts has reached the configured limit
        no new connections will be created. If there are no active connections at that
        time then flow immediately enters Finished state. Otherwise the flow remains in
        Running state until all remaining requests have finished.

        Example

        Allow 100 connection attempts in total

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.CumulativeConnectionLimitSet(100)


        """
        return _byteblower.HTTPMultiClient_CumulativeConnectionLimitSet(self, value)

    def MaximumConcurrentConnectionAttemptsGet(self):
        r"""

        Returns the maximum number of concurrent connection attempts.

        :rtype: int


        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentConnectionAttemptsGet(self)

    def MaximumConcurrentConnectionAttemptsSet(self, value):
        r"""

        Sets the maximum number of concurrent connection attempts.

        :param val: The maximum number of concurrent attempts to set.
                    (Default: 1)
        :type val: int

        This method limits maximum number of requests that can be in the TCP SYN-SENT
        state.

        Example

        Allow 100 concurrent connection attempts:

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.MaximumConcurrentConnectionAttemptsSet(100)


        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentConnectionAttemptsSet(self, value)

    def RemoteAddressSet(self, value):
        r"""

        Sets the remote address for the HTTP requests.

        :param address: The destination address for the HTTP requests.
        :type address: str

        This should be the address of the :class:`HTTPMultiServer`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.RemoteAddressSet('1.1.1.1')


        """
        return _byteblower.HTTPMultiClient_RemoteAddressSet(self, value)

    def RemoteAddressGet(self):
        r"""

        Returns the remote address.

        :Rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.RemoteAddressGet())


        """
        return _byteblower.HTTPMultiClient_RemoteAddressGet(self)

    def RemotePortSet(self, value):
        r"""

        Sets the remote port for the HTTP requests.

        :param portNumber: The destination port for the HTTP requests.
        :type portNumber: int

        This should be the port that the :class:`HTTPMultiServer` is listening to.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.RemotePortSet(80)


        """
        return _byteblower.HTTPMultiClient_RemotePortSet(self, value)

    def RemotePortGet(self):
        r"""

        Returns the remote port.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.RemotePortGet())


        """
        return _byteblower.HTTPMultiClient_RemotePortGet(self)

    def LocalPortRangeSet(self, _from, to):
        r"""

        Sets the local port range for the TCP connections.

        :param min: The minimum value of the port range.
        :type min: int
        :param max: The maximum value of the port range.
        :type max: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.LocalPortRangeSet(20000,30000)


        """
        return _byteblower.HTTPMultiClient_LocalPortRangeSet(self, _from, to)

    def LocalPortRangeGet(self):
        r"""

        Returns the port range.

        :rtype: IntegerList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.LocalPortRangeGet())


        """
        return _byteblower.HTTPMultiClient_LocalPortRangeGet(self)

    def MaximumSegmentSizeSet(self, value):
        r"""

        Sets the TCP maximum segment size.

        :param mss: The TCP MSS to use Should be between 1 and 65535.
        :type mss: int

        This option specifies an upper bound on the TCP segment size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.MaximumSegmentSizeSet(65535)


        """
        return _byteblower.HTTPMultiClient_MaximumSegmentSizeSet(self, value)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the TCP maximum segment size.

        :rtype: int

        Default value: 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.MaximumSegmentSizeGet())


        """
        return _byteblower.HTTPMultiClient_MaximumSegmentSizeGet(self)

    def ReceiveWindowInitialSizeSet(self, value):
        r"""

        Sets the TCP receive window.

        :param windowsize: New value of the TCP receive window. Must be between 1 and
                           65535 bytes.
                           (Default: 65535)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.ReceiveWindowInitialSizeSet(65535)


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowInitialSizeSet(self, value)

    def ReceiveWindowInitialSizeGet(self):
        r"""

        Returns the TCP receive window.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.MaximumConcurrentConnectionAttemptsGet())


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowInitialSizeGet(self)

    def ReceiveWindowScalingIsEnabled(self):
        r"""

        Returns if TCP window scaling is enabled or not.

        :return: True: window scale enabled , False: window scale disabled
        :rtype: bool

        Window scaling enables window sizes that are larger than 65535 bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.ReceiveWindowScalingIsEnabled())


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingIsEnabled(self)

    def ReceiveWindowScalingEnable(self, inEnable):
        r"""

        Enables of disables the TCP window scale option.

        :param enable: True to enable Window Scaling.
        :type enable: bool

        Window scaling window sizes that are larger than 65535 bytes.

        Example

        To enable window scaling

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.ReceiveWindowScalingEnable(True)


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingEnable(self, inEnable)

    def ReceiveWindowScalingValueSet(self, value):
        r"""

        Sets the TCP window scale value.

        :param scale: (0-8), which is used for bitwise shifting.
        :type scale: int

        :raises ConfigError: when the value is not an integer

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        rfc:`1323`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.ReceiveWindowScalingValueSet(3)


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingValueSet(self, value)

    def ReceiveWindowScalingValueGet(self):
        r"""

        Returns the TCP window scale value.

        :return: current receive window scale
        :rtype: int

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingValueGet(self)

    def SlowStartThresholdSet(self, value):
        r"""

        Set the initial slow-start threshold value used by TCP.

        :param ssthresh: New value for the slow-start threshold
        :type sshthresh: int

        :raises ConfigError: when the value is not a positive integer

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.SlowStartThresholdSet(1000000)


        """
        return _byteblower.HTTPMultiClient_SlowStartThresholdSet(self, value)

    def SlowStartThresholdGet(self):
        r"""

        Returns the initial slow-start threshold value used by TCP.

        :return: Slow-start threshold
        :rtype: int

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SlowStartThresholdGet())


        """
        return _byteblower.HTTPMultiClient_SlowStartThresholdGet(self)

    def TcpCongestionAvoidanceAlgorithmSet(self, value):
        r"""

        Configure the preferred TCP Congestion Avoidance Algorithm.

        :param congestionAvoidanceAlgorithm: Congestion Avoidance Algorithm to configure.
        :type congestionAvoidanceAlgorithm: TCPCongestionAvoidanceAlgorithm

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure NewReno as congestionAvoidance Algorithm

           httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure Sack as congestionAvoidance Algorithm

           httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure None as congestionAvoidance Algorithm

           httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)


        """
        return _byteblower.HTTPMultiClient_TcpCongestionAvoidanceAlgorithmSet(self, value)

    def TcpCongestionAvoidanceAlgorithmGet(self):
        r"""

        Returns the preferred TCP Congestion Avoidance Algorithm.

        :return: current Congestion Avoidance Algorithm.
        :rtype: TCPCongestionAvoidanceAlgorithm

        Possible values are:
        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.TcpCongestionAvoidanceAlgorithmGet()==TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.HTTPMultiClient_TcpCongestionAvoidanceAlgorithmGet(self)

    def TcpPragueEnable(self, value):
        r"""

        Whether or not TCP Prague must be enabled.

        :param enable: True to enable TCP Prague, False to disable
        :type enable: bool

        TCP Prague is an implementation which is heavily used in L4S


        """
        return _byteblower.HTTPMultiClient_TcpPragueEnable(self, value)

    def TcpPragueIsEnabled(self):
        r"""

        Returns whether or not TCP Prague support is enabled

        :rtype: bool


        """
        return _byteblower.HTTPMultiClient_TcpPragueIsEnabled(self)

    def TypeOfServiceSet(self, value):
        r"""

        Sets the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        :param tos: Value for the Type Of Service IP field
        :type tos: int

        Both IP headers reserve space to specify the expected quality of service(QOS).
        IPv4 calls this field the 'Type Of Service'. In IPv6 one uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the method is generic, it is used for both IPv4 and IPv6 layers. The
        implementation will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase,thus before the
        parent ByteBlower port is started. Invoking the method at other moments will
        result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.TypeOfServiceSet(16)


        """
        return _byteblower.HTTPMultiClient_TypeOfServiceSet(self, value)

    def TypeOfServiceGet(self):
        r"""

        Returns the 'Type Of Service' or 'Traffic Class' value.

        :rtype: int


        """
        return _byteblower.HTTPMultiClient_TypeOfServiceGet(self)

    def FlowLabelSet(self, value):
        r"""

        Sets the flow label for IPv6 flows.

        :param label: The IPv6 Flow label.
        :type label: int

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.FlowLabelSet(1234)


        """
        return _byteblower.HTTPMultiClient_FlowLabelSet(self, value)

    def FlowLabelGet(self):
        r"""

        Returns the "Flow Label" for IPv6 flows.

        :rtype: int

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient = port.RemotePortGet()
           print(httpMultiClient.FlowLabelGet())


        """
        return _byteblower.HTTPMultiClient_FlowLabelGet(self)

    def HttpMethodSet(self, *args):
        r"""

        Sets the HTTP request method.

        :param method: HTTP Method to use.  HTTP GET will send traffic from HTTP server
                       to HTTP client, PUT will upload traffic from HTTP Client to HTTP
                       server.  (Default: GET)
        :type method: HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.HttpMethodSet(HTTPRequestMethod.Get))


        Sets the HTTP request method.

        :param method: HTTP Method to use.  HTTP GET will send traffic from HTTP server
                       to HTTP client, PUT will upload traffic from HTTP Client to HTTP
                       server.  (Default: GET)
        :type method: HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.HttpMethodSet(HTTPRequestMethod.Get))


        """
        return _byteblower.HTTPMultiClient_HttpMethodSet(self, *args)

    def HttpMethodGet(self):
        r"""

        Returns the HTTP request method.

        :rtype: HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.HttpMethodGet() == HTTPRequestMethod.Get)


        """
        return _byteblower.HTTPMultiClient_HttpMethodGet(self)

    def InitialTimeToWaitSet(self, ns):
        r"""

        Sets the initial time to wait before really starting the flow.

        This can be used if you want to different flows to start at different times.

        :param timetowait: Time to wait before the flow will start. (Default: 0)
        :type timetowait: int

        Example

        Initial Time to wait of 60 seconds

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.InitialTimeToWaitSet(60000000000)


        """
        return _byteblower.HTTPMultiClient_InitialTimeToWaitSet(self, ns)

    def InitialTimeToWaitGet(self):
        r"""

        Returns the initial time to wait value.

        :return: The initial time to wait in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.InitialTimeToWaitGet())


        """
        return _byteblower.HTTPMultiClient_InitialTimeToWaitGet(self)

    def Start(self):
        r"""

        Starts the flow.

        :raises ConfigError: This exception is thrown in case of an incomplete 
                             configuration. For example if the remote IP or remote port
                             is not set.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.Start()


        """
        return _byteblower.HTTPMultiClient_Start(self)

    def Stop(self):
        r"""

        Stops the flow.

        Explicitly stops a flow. Normally the flow finishes automatically when the
        configured duration or size has been reached. This method stops the flow
        immediately.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.Stop()


        """
        return _byteblower.HTTPMultiClient_Stop(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Returns the duration for the result snapshots.

        :return: expressed as nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SamplingIntervalDurationGet())


        """
        return _byteblower.HTTPMultiClient_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, value):
        r"""

        Sets the duration of the result snapshots.

        :param duration: Duration in nanoseconds of a single sample
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.SamplingIntervalDurationSet(1500000)


        """
        return _byteblower.HTTPMultiClient_SamplingIntervalDurationSet(self, value)

    def SamplingBufferLengthGet(self):
        r"""

        Returns the snapshot buffer length.

        :return: The length of the server sample buffer on the server-side
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SamplingBufferLengthGet())


        """
        return _byteblower.HTTPMultiClient_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, value):
        r"""

        Configure the snapshot buffer size.

        :param length: The number of samples that should be kept on the server-side buffer
        :type length: int

        ByteBlower server stores the snapshots in a circular buffer before they are
        transferred to the client. If the buffer overflows then the oldest snapshot is
        overwritten. This method configures the maximum size of the buffer.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.SamplingBufferLengthSet(6)


        """
        return _byteblower.HTTPMultiClient_SamplingBufferLengthSet(self, value)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :rtype: HTTPMultiResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.ResultGet().DescriptionGet())


        """
        return _byteblower.HTTPMultiClient_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the result history.

        :rtype: HTTPMultiResultHistory

        This method returns a :class:`HTTPMultiResultHistory` Object. This will
        contain the Cumulative and the Interval counters over time.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.HTTPMultiClient_ResultHistoryGet(self)

# Register HTTPMultiClient in _byteblower:
_byteblower.HTTPMultiClient_swigregister(HTTPMultiClient)
HTTPMultiServerStatus_Stopped = _byteblower.HTTPMultiServerStatus_Stopped
HTTPMultiServerStatus_Started = _byteblower.HTTPMultiServerStatus_Started
class HTTPMultiServer(AbstractObject):
    r"""

    HTTPMultiServer provides the server-side for HTTPMultiClient.

    See :class:`HTTPMultiClient` for more information.

    .. versionadded:: 2.10.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def StatusGet(self):
        r"""

        Returns the HTTP server status.

        :rtype: HTTPMultiServerStatus

        Example

        Before starting the HTTP server:  `HTTPMultiServerStatus.Stopped`
        After starting the HTTP server:  `HTTPMultiServerStatus.Started`

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.StatusGet() == HTTPMultiServerStatus_Started)


        """
        return _byteblower.HTTPMultiServer_StatusGet(self)

    def PortSet(self, inPort):
        r"""

        Sets the TCP port on which the HTTP server will listen.

        :param port: The TCP port on which the HTTP server will listen for incoming
                     requests.
        :type port: int

        :raises ValueError: When the value is not an Integer
        :raises ConfigError: When the value is not between 1 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server.PortSet(80)


        """
        return _byteblower.HTTPMultiServer_PortSet(self, inPort)

    def PortGet(self):
        r"""

        Returns the TCP port for the HTTP server.

        :return: The configured TCP Port
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.PortGet())


        """
        return _byteblower.HTTPMultiServer_PortGet(self)

    def MaximumSegmentSizeSet(self, value):
        r"""

        Sets the TCP maximum segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.
        :type size: int

        :raises ConfigError: when the configured value is out of range

        This option specifies an upper bound on the TCP segment size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           result_history = http_server.MaximumSegmentSizeSet(65535)


        """
        return _byteblower.HTTPMultiServer_MaximumSegmentSizeSet(self, value)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the TCP maximum segment size.

        :return: The TCP Maximum Segment Size (MSS, Default: 65535)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.MaximumSegmentSizeGet())


        """
        return _byteblower.HTTPMultiServer_MaximumSegmentSizeGet(self)

    def ReceiveWindowInitialSizeSet(self, value):
        r"""

        Sets the initial receive window for the server.

        :param windowsize: New value of the initial receive window.
        :type windowsize: int

        :raises TypeError: When the value is not an Integer
        :raises ConfigError: When the value is out of range

        Small windowsizes can decrease the performance of a TCP session. Please use
        good size for your configuration and network setup.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server.SlowStartThresholdSet(65535)


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowInitialSizeSet(self, value)

    def ReceiveWindowInitialSizeGet(self):
        r"""

        Gets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.ReceiveWindowInitialSizeGet())


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowInitialSizeGet(self)

    def ReceiveWindowScalingIsEnabled(self):
        r"""

        Returns if window scaling is enabled or not.

        :return: True when scaling is enabled, false when scaling is disabled
        :rtype: bool

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        Example

        When enabled:

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.ReceiveWindowScalingIsEnabled())


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingIsEnabled(self)

    def ReceiveWindowScalingEnable(self, value):
        r"""

        Enables of disables windowscaling.

        :param scaling: bool which will enable (True) or disable (False) windowscaling.
        :type scaling: bool

        :raises TypeError: when the value is not true or false

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        Example

        To enable window scaling  or  To disable window scaling  or

        .. code-block:: python
           :emphasize-lines: 1

           http_server.ReceiveWindowScalingEnable(True)


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingEnable(self, value)

    def ReceiveWindowScalingValueSet(self, value):
        r"""

        Sets the window scale which will be used for new clients.

        :param scale: 0-8, which is used for bitwise shifting.
        :type scale: int

        :raises TypeError: When the value is not an integer
        :raises ConfigError: When the value is out of range

        This must be done before requesting a page from a client, because this option
        is negotiated at the beginning of the TCP session.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server.ReceiveWindowScalingValueSet(6)


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingValueSet(self, value)

    def ReceiveWindowScalingValueGet(self):
        r"""

        Returns the current receive window scale.

        :return: current receive window scale
        :rtype: int

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.
        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingValueGet(self)

    def SlowStartThresholdSet(self, value):
        r"""

        Set the initial slow-start threshold value used by TCP.

        :param ssthresh: New value for the slow-start threshold
        :type ssthresh: int

        :raises ConfigError: When the value is not a positive integer

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

           http_server.SlowStartThresholdSet(1000000)


        """
        return _byteblower.HTTPMultiServer_SlowStartThresholdSet(self, value)

    def SlowStartThresholdGet(self):
        r"""

        Returns the initial slow-start threshold value used by TCP.

        :return: Slow-start threshold
        :rtype: int

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.SlowStartThresholdGet())


        """
        return _byteblower.HTTPMultiServer_SlowStartThresholdGet(self)

    def TcpCongestionAvoidanceAlgorithmSet(self, value):
        r"""

        Selects the TCP Congestion Avoidance Algorithm.

        :parameter algorithm: Congestion Avoidance Algorithm to configure.
        :type algorithm: TCPCongestionAvoidanceAlgorithm

        Selects the TCP Congestion Avoidance Algorithm which will be used for new
        clients. This must be selected before requesting a page from a client,
        because for some algorithms, the congestion avoidance support is negotiated a
        the beginning of the TCP session.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure NewReno as congestionAvoidance Algorithm

           http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure Sack as congestionAvoidance Algorithm

           http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure None as congestionAvoidance Algorithm

           http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)


        """
        return _byteblower.HTTPMultiServer_TcpCongestionAvoidanceAlgorithmSet(self, value)

    def TcpCongestionAvoidanceAlgorithmGet(self):
        r"""

        Gets the current TCP Congestion Avoidance Algorithm for new clients.

        :return: current Congestion Avoidance Algorithm.
        :rtype: TCPCongestionAvoidanceAlgorithm

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.HTTPMultiServer_TcpCongestionAvoidanceAlgorithmGet(self)

    def TcpPragueEnable(self, value):
        r"""

        Whether or not TCP Prague must be enabled.

        :param enable: True to enable TCP Prague, False to disable
        :type enable: bool

        TCP Prague is an implementation which is heavily used in L4S


        """
        return _byteblower.HTTPMultiServer_TcpPragueEnable(self, value)

    def TcpPragueIsEnabled(self):
        r"""

        Returns whether or not TCP Prague support is enabled

        :rtype: bool


        """
        return _byteblower.HTTPMultiServer_TcpPragueIsEnabled(self)

    def Start(self):
        r"""

        Starts the HTTP server on the configured port with the configured
        configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server.Start()


        """
        return _byteblower.HTTPMultiServer_Start(self)

    def Stop(self):
        r"""

        Stops the HTTP server.

        Running sessions will be aborted and incoming connection requests will be
        refused.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server.Stop()


        """
        return _byteblower.HTTPMultiServer_Stop(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.SamplingIntervalDurationGet())


        """
        return _byteblower.HTTPMultiServer_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, value):
        r"""

        Sets the duration of one sampling interval.

        :param interval: duration of a single sample in nanoseconds
        :type interval: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server.SamplingIntervalDurationGet())


        """
        return _byteblower.HTTPMultiServer_SamplingIntervalDurationSet(self, value)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        :return: The length of the server sample buffer
        :rtype: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold.


        """
        return _byteblower.HTTPMultiServer_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, value):
        r"""

        Sets the number of samples to keep in the buffer.

        :param length: The length of the server-side sample buffer
        :type length: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server.SamplingBufferLengthSet(6)


        """
        return _byteblower.HTTPMultiServer_SamplingBufferLengthSet(self, value)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :rtype: HTTPMultiResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_server_result = http_server.ResultGet().DescriptionGet())


        """
        return _byteblower.HTTPMultiServer_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the result history.

        :rtype: HTTPMultiResultHistory

        This method returns a history object. This contains the Cumulative and the 
        Interval counters over time.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           result_history = http_server.ResultHistoryGet()


        """
        return _byteblower.HTTPMultiServer_ResultHistoryGet(self)

# Register HTTPMultiServer in _byteblower:
_byteblower.HTTPMultiServer_swigregister(HTTPMultiServer)
class HTTPClient(SchedulableObject):
    r"""

    HTTP client application that may schedule HTTP requests to real webservers or
    the HTTP server application.

    Using this class, you can simulate TCP (Transmission Control Protocol) traffic
    The TCP is simulated by a HTML request to the HTTPServer. This is the HTTP 
    Client that will perform the GET or the PUT. This request can be sent to
    the :class:`HTTPServer` or even a real HTTPServer.

    .. code-block:: python

       httpClient = port.ProtocolHttpClientAdd()
        httpClient.RemoteAddressSet('1.1.1.1')
        httpClient.RemotePortSet(80)
        httpClient.CaptureEnable()
        httpClient.RequestDurationSet(10 * 1000)
        httpClient.ReceiveWindowScalingValueSet(7)
        httpClient.SlowStartThresholdSet(2000000000)
        httpClient.RequestStart()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RequestStatusGet(self):
        r"""

        Returns the status of the HTTP request.

        :rtype: HTTPRequestStatus

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.RequestStatusGet() == HTTPRequestStatus.Scheduled)


        """
        return _byteblower.HTTPClient_RequestStatusGet(self)

    def ErrorMessageGet(self):
        r"""

        Returns the error message.

        :return: The error message string
        :rtype: bool

        When the request status is "Error" then extra information can be obtained
        with this method.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.ErrorMessageGet())


        """
        return _byteblower.HTTPClient_ErrorMessageGet(self)

    def FinishedGet(self):
        r"""

        Returns whether or not the HTTP session has finished.

        :return: True: Finished (with or without error), 
                 False: Not Finished
        :rtype: bool

        Example

        Check if the client is finished

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.FinishedGet())


        """
        return _byteblower.HTTPClient_FinishedGet(self)

    def HasSession(self):
        r"""

        Returns whether or not we have a HTTP session.

        :return:  True We have a session, False  We don't have a session
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.MaximumSegmentSizeGet())


        """
        return _byteblower.HTTPClient_HasSession(self)

    def HasError(self):
        r"""

        Returns true if an error has occurred.

        :return: True: An error has occurred,
                 False: No error has occurred
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.HasError())


        """
        return _byteblower.HTTPClient_HasError(self)

    def WaitUntilConnected(self, timeout):
        r"""

        Waits until connection is established or timeout has expired.

        :param timeout: How long we should wait before giving up (and returning false).
        :type timeout: int

        :return: True when the HTTP session connects within the timeout. 
                 False when the HTTP session failed to connect before the timeout 
                 expired.
        :rtype: bool
        :raises ConfigError: when called from configuration or stopped state.

        Valid states in which this method may be called: scheduled, connecting,
        running and finished.

        Returns true immediately when called from running or finished states.

        Returns false if timeout expired before running state was reached.

        When called from error state or if error state is reached while waiting then the
        server-side exception that caused the error state will be rethrown here.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           while not httpClient.WaitUntilConnected(1000000000):
              print('Waiting until connected...')


        """
        return _byteblower.HTTPClient_WaitUntilConnected(self, timeout)

    def WaitUntilFinished(self, timeout_ns):
        r"""

        Waits until request is finished or timeout has expired.

        :param timeout: How long we should wait before giving up (and returning false).
        :type timeout: int

        :return: True when the request finished before the timeout expired
                 False when the request was not finished.
        :raises ConfigError: if called from configuration or stopped state.

        Valid states in which this method may be called:

        - scheduled
        - connecting
        - running
        - finished.

        Returns true immediately when called from finished state.

        Returns false if timeout expired before finished state was reached.

        When called from error state or if error state is reached while waiting then
        the server-side exception that caused the error state will be rethrown here.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           while not httpClient.WaitUntilFinished(1000000000):
              print('Wait until finished...')


        """
        return _byteblower.HTTPClient_WaitUntilFinished(self, timeout_ns)
    RequestStartType_Direct = _byteblower.HTTPClient_RequestStartType_Direct
    RequestStartType_Scheduled = _byteblower.HTTPClient_RequestStartType_Scheduled

    def RequestStartTypeSet(self, inRequestStartType):
        r"""

        Configures the Start Type of a HTTP Request.

        :param startType: Start Type of the HTTP request.
                          Must be either :attr:`.RequestStartType.Direct` or 
                          :attr:`.RequestStartType.Scheduled`
                          (Default: :attr:`.RequestStartType.Direct`)
        :type startType: RequestStartType

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Setting the startype to direct

           httpClient.RequestStartTypeSet(RequestStartType.Direct)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Setting the startype to scheduled use 
                     :meth:`RequestInitialTimeToWaitSet` to configure the schedule

            httpClient.RequestStartTypeSet(RequestStartType.Scheduled)


        """
        return _byteblower.HTTPClient_RequestStartTypeSet(self, inRequestStartType)

    def RequestStartTypeGet(self):
        r"""

        Returns the current configured Start Type.

        :return: Start Type of the HTTP request. Must be either 
                 :attr:`.RequestStartType.Direct` or  
                 :attr:`.RequestStartType.Scheduled`
                 (Default: :attr:`.RequestStartType.Direct`)
        :rtype: RequestStartType

        Example

        On a httpClient with direct starttype

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.RequestStartTypeGet() == RequestStartType.Scheduled)


        """
        return _byteblower.HTTPClient_RequestStartTypeGet(self)

    def RequestStart(self):
        r"""

        Start the current configured HTTP Request.

        :raises ConfigError: This exception is thrown when some configurations are 
                             incorrect. For example if the RemoteAddress is an IPv6 
                             address and the HTTPClient has a IPv4 address.

        The Start Type can be configured using :meth:`RequestStartTypeSet`

        Configuring the Request is done using :meth:`RequestSizeSet` and
        :meth:`RequestDurationSet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.RequestStart()


        """
        return _byteblower.HTTPClient_RequestStart(self)

    def RequestStop(self):
        r"""

        This will stop the client.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RequestStop()


        """
        return _byteblower.HTTPClient_RequestStop(self)

    def RequestSizeSet(self, inRequestSize):
        r"""

        Method which will configure a page to send out an HTTP Request to request a certain number of Bytes.

        :param requestsize: The number of Bytes to send the HTTP Request for.
        :type requestsize: int

        A HTTP Request page will be configured to request for a certain size of data on
        a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with the number of requested Bytes
        transferred over the network.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`
                  The HTTP Method defines the way the data traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`
                  The Start Type defines when the HTTP Request will start.

        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.
        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Setting the requestsize to 10000000 Bytes

           httpClient.RequestSizeSet(10000000)


        """
        return _byteblower.HTTPClient_RequestSizeSet(self, inRequestSize)

    def RequestSizeGet(self):
        r"""

        Method which will return the configured requested pagesize expressed in Bytes.

        :return: The configured requested pagesize in Bytes
        :rtype: int

        A HTTP Request page will be configured to request for a certain size of data on
        a ByteBlower HTTP server.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Getting the configured requestsize

           print(httpClient.RequestSizeGet())


        """
        return _byteblower.HTTPClient_RequestSizeGet(self)

    def RequestDurationSet(self, inDurationNs):
        r"""

        Method which will configure a page to send out an HTTP Request to transmit data
        during a certain time.

        :param duration: The duration in nanoseconds of data traffic to send the 
                         HTTP Request for.
        :type duration: int

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with data transferred over the
        network until the requested duration has passed.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`. The HTTP Method defines the way the data
                  traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`. The Start Type defines when the HTTP
                  Request will     start.

        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: will configure a request to transfer data during 1.5 seconds expressed in nano seconds

           httpClient.RequestDurationSet(int(1.5 * 1000000000))


        """
        return _byteblower.HTTPClient_RequestDurationSet(self, inDurationNs)

    def RequestDurationGet(self):
        r"""

        Method which will return the configured HTTP Request duration.

        :return: The HTTP request duration in nanoseconds.
        :rtype: int

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        Example

        Get the configured request duration

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.RequestDurationGet())


        """
        return _byteblower.HTTPClient_RequestDurationGet(self)

    def RequestRateLimitSet(self, inRateLimitBytesps):
        r"""

        Method which will limit the rate of the HTTP traffic to a certain amount..

        :param rateLimit: The rate limit, in bytes per second.
        :type rateLimit: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Setting the rate limit to 10 MBytesps

           httpClient.RequestRateLimitSet(10000000)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Disable rate limit

           httpClient.RequestRateLimitSet(0)


        """
        return _byteblower.HTTPClient_RequestRateLimitSet(self, inRateLimitBytesps)

    def RequestRateLimitGet(self):
        r"""

        Method which will return the configured rate-limit of the HTTP traffic.

        :return: rateLimit The rate limit, in bytes per second.
                 A value of zero indicates not limit.
                 (Default: 0)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Getting the configured rate limit.

           print(httpClient.RequestRateLimitGet())


        """
        return _byteblower.HTTPClient_RequestRateLimitGet(self)

    def RequestPageSet(self, arg2):
        r"""

        Method which will set the HTML page which will be requested.

        :param pagename: The page to send the HTTP Request for.
        :type pagename: str

        If you are requesting on a ByteBlower HTTP Server, please check
        :meth:`RequestSizeSet` and :meth:`RequestDurationSet` for specialized HTTP
        Requests

        Method which will set the HTML page which will be requested. When
        :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        A typical use in ByteBlower is a request for a certain size to a ByteBlower
        HTTP server. e.g. `10000000.html` This will give us a nice TCP traffic test
        with the number of requested Bytes transferred over the network.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet` The HTTP Method defines the way the data
                  traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet` The Start Type defines the way the data
                  traffic will flow.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Setting the client to request for the page: 100000.html

           httpClient.RequestPageSet('100000.html')


        """
        return _byteblower.HTTPClient_RequestPageSet(self, arg2)

    def RequestPageGet(self):
        r"""

        Method which will get the HTML page which will be requested.

        :return: the HTML page name that will be requested
        :rtype: str

        If you are requesting on a ByteBlower HTTP Server, please check
        :meth:`RequestSizeSet` and :meth:`RequestDurationSet` for specialized HTTP
        Requests

        Method which will set the HTML page which will be requested. When
        :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        A typical use in ByteBlower is a request for a certain size to a ByteBlower
        HTTP server. e.g. 10000000.html This will give us a nice TCP traffic test with
        the number of requested Bytes transferred over the network.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`
                  The HTTP Method defines the way the data traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`
                  The Start Type defines when the data traffic will start.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.RequestPageGet())


        """
        return _byteblower.HTTPClient_RequestPageGet(self)

    def RequestUriSet(self, inURI):
        r"""

        Method which will set the URI, it contains the complete HTTP URI which will be requested.

        :param uri: The URI the httpClient must request.
        :type uri: str

        When :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        Different from the :meth:`RequestPageSet` method, this method allows you to
        configure a HTTP Request to external (non-ByteBlower) HTTP servers without
        adding the 'server-client-id' to the HTTP Request page's path. Configuring the
        URI will also configure the HTTP Server address and HTTP Server TCP to which
        the HTTP Request is sent.

        .. note:: DNS resolution is not supported for the URI, so the HTTP Server needs
                  to be an IPv4 or IPv6 address.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure the HTTP Client to send a request to HTTP Server 
                     1.1.1.1, on the default TCP port 80, for page '/test/index.html'

           httpClient.RequestUriSet(http://1.1.1.1/test/index.html)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: configure the HTTP Client to send a request to HTTP Server 
                     10.10.10.2, on TCP port 8080, for page '/project/index.html'

           httpClient.RequestUriSet(http://10.10.10.2:8080/project/index.html)


        """
        return _byteblower.HTTPClient_RequestUriSet(self, inURI)

    def RequestUriGet(self):
        r"""

        Returns the requested URI.

        :return: HTTP Request URI as configured by :meth:`RequestUriSet`
        :rtype: str

        Returns the URI like it is or will be requested by the client.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.RequestUriGet())


        """
        return _byteblower.HTTPClient_RequestUriGet(self)

    def LocalPortSet(self, inPort):
        r"""

        Configure the TCP port for the client to use.

        :param port: TCP port on which the client will listen or replies and send its
                     requests.
        :type port: int

        :raises TypeError: When the value is not an Integer
        :raises ConfigError: when the value is not between 1 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.LocalPortSet(45780)


        """
        return _byteblower.HTTPClient_LocalPortSet(self, inPort)

    def LocalPortGet(self):
        r"""

        Returns the TCP the httpclient will use to send its HTTPRequest.

        :return: The TCP port the client uses.
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.LocalPortGet())


        """
        return _byteblower.HTTPClient_LocalPortGet(self)

    def RemoteAddressSet(self, inAddress):
        r"""

        Configure the destination address.

        :param address: Address of the HTTP server this client will use.
        :type address: str

        Method to configure the address of the HTTP server which this client will try
        to contact.

        .. note:: Be aware that only addresses are used, no DNS is supported at this
                  moment.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RemoteAddressSet('1.1.1.1')


        """
        return _byteblower.HTTPClient_RemoteAddressSet(self, inAddress)

    def RemoteAddressGet(self):
        r"""

        Return the configured destination address.

        :return: IP Address of the HTTP Server to send a request to.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.RemoteAddressGet())


        """
        return _byteblower.HTTPClient_RemoteAddressGet(self)

    def RemotePortSet(self, inRemotePort):
        r"""

        Configure the TCP port which the client will use as destination port.

        :param port: TCP port of the HTTP server which the client will try to contact.
        :type port: int

        :raises TypeError: When the value is not an Integer
        :raises ConfigError: when the value is not between 1 and 65535

        This method is used to configure the TCP port of the server which the client
        will try to contact.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure the client to use port 80 as destination port

           httpClient.RemotePortSet(80)


        """
        return _byteblower.HTTPClient_RemotePortSet(self, inRemotePort)

    def RemotePortGet(self):
        r"""

        Returns the configured destination port.

        :return: the remote (destination) tcp port
        :rtype: int

        This method returns the current configured TCP port of the HTTP server which
        this client will try to contact.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port = httpClient.RemotePortGet()


        """
        return _byteblower.HTTPClient_RemotePortGet(self)

    def MaximumSegmentSizeSet(self, inValue):
        r"""

        Sets the TCP maximum segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.
        :type size: int

        This option specifies an upper bound on the TCP segment size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.MaximumSegmentSizeSet(65535)


        """
        return _byteblower.HTTPClient_MaximumSegmentSizeSet(self, inValue)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the configured TCP maximum segment size.

        :return: the configured TCP MSS in bytes
                 (Default: 65535)
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.MaximumSegmentSizeGet())


        """
        return _byteblower.HTTPClient_MaximumSegmentSizeGet(self)

    def ReceiveWindowInitialSizeSet(self, inValue):
        r"""

        Sets the initial receive window for the client.

        :param windowsize: New value of the initial receive window.
        :type windowsize: int

        :raises TypeError: When the value is not an Integer
        :raises ConfigError: When the value is out of range

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.ReceiveWindowInitialSizeSet(65535)


        """
        return _byteblower.HTTPClient_ReceiveWindowInitialSizeSet(self, inValue)

    def ReceiveWindowInitialSizeGet(self):
        r"""

        Gets the initial receive window for the client.

        :return: The configured initial receive window size.
                 (Default: 65535)
        :rtype: int

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.ReceiveWindowInitialSizeGet())


        """
        return _byteblower.HTTPClient_ReceiveWindowInitialSizeGet(self)

    def ReceiveWindowScalingIsEnabled(self):
        r"""

        Returns if windowscaling is enabled or not.

        :return: True window scale enabled, 
                 False window scale disabled
                 (Default: True)
        :rtype: bool

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        Example

        When enabled:

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ReceiveWindowScalingIsEnabled())


        """
        return _byteblower.HTTPClient_ReceiveWindowScalingIsEnabled(self)

    def ReceiveWindowScalingEnable(self, inEnable):
        r"""

        Enables of disables windowscaling.

        :param scaling: Which will enable (True) or disable (false) windowscaling.
                        (Default: True)
        :type scaling: bool

        :raises TypeError: When the value is not true or false

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: To enable window scaling

           httpClient.ReceiveWindowScalingEnable(True)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: To disable window scaling

           httpClient.ReceiveWindowScalingEnable(False)


        """
        return _byteblower.HTTPClient_ReceiveWindowScalingEnable(self, inEnable)

    def ReceiveWindowScalingValueSet(self, inValue):
        r"""

        Configures the window scale which will be used for the client.

        .. note:: This must be done before requesting the page, because this option is
                  negotiated at the beginning of the TCP session.

        :raises TypeError: when the value is not an Integer

        :raises ConfigError: When the value is not in the range 0-8

        :param scale: (0-8), which is used for bitwise shifting.
                      (Default: 3)
        :type scale: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.ReceiveWindowScalingValueSet()


        """
        return _byteblower.HTTPClient_ReceiveWindowScalingValueSet(self, inValue)

    def ReceiveWindowScalingValueGet(self):
        r"""

        Returns the current receive window scale.

        :return: The current receive window scale
                 (Default: 3)
        :rtype: int

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        rfc:`1323`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPClient_ReceiveWindowScalingValueGet(self)

    def SlowStartThresholdSet(self, inValue):
        r"""

        Set the initial slow-start threshold value used by TCP.

        :param ssthresh: The slow start threshold to use
                         (Default: 65535)
        :type ssthresh: int

        :raises ConfigError: When the value is not a positive integer

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput.
        See :rfc:`5681` "TCP Congestion Control" for more information on this topic.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: To set slow-start threshold to 1000000

            httpClient.SlowStartThresholdSet(1000000)


        """
        return _byteblower.HTTPClient_SlowStartThresholdSet(self, inValue)

    def SlowStartThresholdGet(self):
        r"""

        Returns the initial slow-start threshold value used by TCP.

        :return: slowstart threshold
                 (Default: 65535)
        :rtype: int

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681` "TCP
        Congestion Control" for more information on this topic.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.SlowStartThresholdGet())


        """
        return _byteblower.HTTPClient_SlowStartThresholdGet(self)

    def TcpCongestionAvoidanceAlgorithmSet(self, inValue):
        r"""

        Selects the used TCP Congestion Avoidance Algorithm (TCAA).

        This must be selected before requesting the page, because for some algorithms,
        the congestion avoidance support is negotiated a the beginning of the TCP
        session.

        :param algorithm: current Congestion Avoidance Algorithm.
                          (Default: :attr:`TCPCongestionAvoidanceAlgorithm.No_Algorithm`)
        :type algorithm: TCPCongestionAvoidanceAlgorithm

        :raises ConfigError: Invalid TCP congestion avoidance algorithm: 
                             When the value could not be interpreted as a valid TCAA

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure NewReno as congestionAvoidance Algorithm

            httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure Sack as congestionAvoidance Algorithm

           httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure None as congestionAvoidance Algorithm

           httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)


        """
        return _byteblower.HTTPClient_TcpCongestionAvoidanceAlgorithmSet(self, inValue)

    def TcpCongestionAvoidanceAlgorithmGet(self):
        r"""

        Gets the current configured TCP Congestion Avoidance Algorithm.

        :return: current Congestion Avoidance Algorithm.
                 (Default: :attr:`TCPCongestionAvoidanceAlgorithm.No_Algorithm`)
        :rtype: TCPCongestionAvoidanceAlgorithm

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewRenoWithCubic)


        """
        return _byteblower.HTTPClient_TcpCongestionAvoidanceAlgorithmGet(self)

    def TcpPragueEnable(self, value):
        r"""

        Request TCP Prague / L4S support for this flow..

        .. versionadded:: 2.22.0

        :param enable: Whether or not to try to use L4S on this flow.
        :type enable: bool

        When TCP Prague or L4S is supported by the ByteBlower Port, this method
        will enable L4S / TCP Prague on this flow. 

        To determine whether or not the action succeeded, one should call
        TcpPragueIsEnabled() after an invocation of this method.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.TcpPragueEnable(True)
           is_enabled = http_client.TcpPragueIsEnabled()


        """
        return _byteblower.HTTPClient_TcpPragueEnable(self, value)

    def TcpPragueIsEnabled(self):
        r"""

        Returns whether or not TCP Prague is enabled.

        .. versionadded:: 2.22.0

        :rtype: bool

        When TCP Prague or L4S is enabled on the HTTP Client for this flow, this
        method will return True.  If TCP Prague was not configured, this method 
        will return False.

        Checking the Tcp.L4S capability will determine if TCP Prague or L4S is 
        supported by the ByteBlower Server.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           return http_client.TcpPragueIsEnabled()


        """
        return _byteblower.HTTPClient_TcpPragueIsEnabled(self)

    def RequestInitialTimeToWaitGet(self):
        r"""

        Returns the initial time to wait before a scheduled Request starts.

        :return: The initial time to wait before a scheduled request starts.
                 Units are nanoseconds
                 (Default: 0)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.RequestInitialTimeToWaitGet())


        """
        return _byteblower.HTTPClient_RequestInitialTimeToWaitGet(self)

    def RequestInitialTimeToWaitSet(self, inDelay):
        r"""

        Sets the initial time to wait before really requesting a page (for a scheduled Request).

        :param timetowait: Time to wait before the request will be really sent.
                           Units are nanoseconds
                           (Default: 0)
        :type timetowait: int

        This can be used if you want to start different request on different timestamps.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Initial Time to wait of 60 seconds expressed in nanoseconds

            httpClient.RequestInitialTimeToWaitSet(60000000000)


        """
        return _byteblower.HTTPClient_RequestInitialTimeToWaitSet(self, inDelay)

    def HttpSessionInfoGet(self):
        r"""

        Returns the HttpSessionInfo from this session.

        :rtype: HTTPSessionInfo

        The HttpSessionInfo contains all the information of the current session. From
        state until the counters of received/transmitted bytes

        Example

        .. code-block:: python
           :emphasize-lines: 1

           sessionInfoGet = httpClient.HttpSessionInfoGet()


        """
        return _byteblower.HTTPClient_HttpSessionInfoGet(self)

    def HttpSessionInfoDestroy(self):
        r"""

        Removes a HTTP Session statistics object

        Removing a HTTP Session statistics object will free up the storage required on
        the ByteBlower server and the API instance.  Any stored value containing this
        object will be invalid.


        """
        return _byteblower.HTTPClient_HttpSessionInfoDestroy(self)

    def HttpMethodSet(self, *args):
        r"""

        Configures the HTTPRequest method to be used.

        :param method: HTTP Request method to use
                       (Default: :attr:`.HTTPRequestMethod.Get`)
        :type method: HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.HttpMethodSet(HTTPRequestMethod.Get)


        Configures the HTTPRequest method to be used.

        :param method: HTTP Request method to use
                       (Default: :attr:`.HTTPRequestMethod.Get`)
        :type method: HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.HttpMethodSet(HTTPRequestMethod.Get)


        """
        return _byteblower.HTTPClient_HttpMethodSet(self, *args)

    def HttpMethodGet(self):
        r"""

        Returns the used HTTPRequest method.

        :return: The configured HTTP Request Method
                 (Default: :attr:`.HTTPRequestMethod.Get`)
        :rtype: HTTPRequestMethod

        Example

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.HTTPClient_HttpMethodGet(self)

    def CaptureEnable(self, inValue=True):
        r"""

        Enable the capture of the HTTPData.

        :param enable: Whether or not to capture the received HTTP data
        :type enable: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.CaptureEnable()


        Enable the capture of the HTTPData.

        :param enable: Whether or not to capture the received HTTP data
        :type enable: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.CaptureEnable()


        """
        return _byteblower.HTTPClient_CaptureEnable(self, inValue)

    def IsCaptureEnabled(self):
        r"""

        Returns whether the capture of the HTTPData is enabled.

        :return: Whether or not to capture the received HTTP data
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.IsCaptureEnabled()


        """
        return _byteblower.HTTPClient_IsCaptureEnabled(self)

    def CaptureGet(self):
        r"""

        Return the captured HTTP Data.

        :rtype: CapturedHTTPData

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.CaptureGet().DescriptionGet())


        """
        return _byteblower.HTTPClient_CaptureGet(self)

    def CaptureClear(self):
        r"""

        Clears the capture if enabled


        """
        return _byteblower.HTTPClient_CaptureClear(self)

    def LatencyEnable(self, inValue=True):
        r"""

        Enable one way latency measurements on the HTTP layer.

        :param enable: Whether or not to enable latency measurements
        :type enable: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.LatencyEnable()


        Enable one way latency measurements on the HTTP layer.

        :param enable: Whether or not to enable latency measurements
        :type enable: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.LatencyEnable()


        """
        return _byteblower.HTTPClient_LatencyEnable(self, inValue)

    def IsLatencyEnabled(self):
        r"""

        Returns whether latency measurements are enabled.

        :return: Whether or not to latency measurements are enabled
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.IsLatencyEnabled()


        """
        return _byteblower.HTTPClient_IsLatencyEnabled(self)

    def ClientIdGet(self):
        r"""

        Returns the unique client ID.

        :return: The httpclient unique ID
        :rtype: str

        Each client has a unique ID so that information about the same connection can
        be requested on a HTTP server object. This method returns the unique ClientID
        for this HTTP client.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ClientIdGet())


        """
        return _byteblower.HTTPClient_ClientIdGet(self)

    def ServerIdGet(self):
        r"""

        Returns the unique ByteBlower Server ID.

        :return: The ByteBlower server unique ID.
        :rtype: str

        Each ByteBlower server has a unique ID. This identifier stays persistant over
        the lifetime of the ByteBlowerServers (changed when rebooted).  This serverId
        together with the clientId identifies a HTTPConnection. By adding those 2 id's
        together it is unlikely that 2 httpclients each running on a different server
        end up with the same connection ID.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.ServerIdGet())


        """
        return _byteblower.HTTPClient_ServerIdGet(self)

    def ServerClientIdGet(self):
        r"""

        Return the combination of the server Id ( aka ByteBlower Server Id ) and client Id.

        :return: The combined server- and client Id
        :rtype: str

        This returns a combination of the ServerId and the Client Id. This combination
        will identify a HTTP connection. It is this combination of id's you can use to
        request the :class:`.HTTPSessionInfo` on the HTTP server
        (:obj:`.HTTPServer.HttpSessionInfoGet`)

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ServerClientIdGet())


        """
        return _byteblower.HTTPClient_ServerClientIdGet(self)

    def ResultGet(self):
        r"""

        Returns the current HTTP statistics for a this session.

        :return: The current cumulative HTTP Results for the this session
        :rtype: HTTPResultSnapshot


        """
        return _byteblower.HTTPClient_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current HTTP statistics history for a this session.

        :return: The current HTTP Result history for the this session
        :rtype: HTTPResultHistory


        """
        return _byteblower.HTTPClient_ResultHistoryGet(self)

    def HistorySamplingIntervalDurationGet(self):
        r"""

        Gets the default Sampling interval for the HTTP Session history.

        :return: The duration of a single sample in nanoseconds
        :rtype: int

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.HistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPClient_HistorySamplingIntervalDurationGet(self)

    def HistorySamplingBufferLengthGet(self):
        r"""

        Gets the default Sampling Buffer Length for the HTTP Session history.

        :return: The size of the sample buffer size on the server-side.
        :rtype: int

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.HistorySamplingBufferLengthGet())


        """
        return _byteblower.HTTPClient_HistorySamplingBufferLengthGet(self)

    def HistorySamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the default Sampling interval for the HTTP Session history.

        :param duration: duration of a single sample in nanoseconds
        :type duration: int

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the HTTP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.HistorySamplingIntervalDurationSet(500)


        """
        return _byteblower.HTTPClient_HistorySamplingIntervalDurationSet(self, inDuration)

    def HistorySamplingBufferLengthSet(self, inLength):
        r"""

        Sets the default Sampling Buffer Length for the HTTP Session history.

        :param length: The length of the server-side sample buffer
        :type length: int

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the HTTP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.HistorySamplingBufferLengthSet(10)


        """
        return _byteblower.HTTPClient_HistorySamplingBufferLengthSet(self, inLength)

    def TcpHistorySamplingIntervalDurationGet(self):
        r"""

        Gets the default Sampling interval for the TCP Session history.

        :return: The duration of a single sample in nanoseconds
        :rtype: int

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.TcpHistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPClient_TcpHistorySamplingIntervalDurationGet(self)

    def TcpHistorySamplingBufferLengthGet(self):
        r"""

        Gets the default Sampling Buffer Length for the TCP Session history.

        :rtype: int

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.TcpHistorySamplingBufferLengthGet())


        """
        return _byteblower.HTTPClient_TcpHistorySamplingBufferLengthGet(self)

    def TcpHistorySamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the default Sampling interval for the TCP Session history.

        :param duration: duration of a single sample in nanoseconds
        :type duration: int

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the TCP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.TcpHistorySamplingIntervalDurationSet(500)


        """
        return _byteblower.HTTPClient_TcpHistorySamplingIntervalDurationSet(self, inDuration)

    def TcpHistorySamplingBufferLengthSet(self, inLength):
        r"""

        Sets the default Sampling Buffer Length for the TCP Session history.

        :param length: The size of the sample buffer on the server-side
        :type length: int

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the TCP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.TcpHistorySamplingBufferLengthSet(12)


        """
        return _byteblower.HTTPClient_TcpHistorySamplingBufferLengthSet(self, inLength)

    def TypeOfServiceSet(self, value):
        r"""

        Configures the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        :param tos: The Type Of Service field to use in the IPv4 header
        :type tos: int

        Both IP headers reserve space to specify the expected quality of service (QOS).
        IPv4 calls this field the 'Type Of Service'. In IPv6 one uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the method is generic, it is used for both IPv4 and IPv6 layers. The
        implementaion will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase,thus before the
        parent ByteBlower port is started. Invoking the method at other moments will
        result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.TypeOfServiceSet(16)


        """
        return _byteblower.HTTPClient_TypeOfServiceSet(self, value)

    def TypeOfServiceGet(self):
        r"""

        Retrieves the 'Type Of Service' or 'Traffic Class' configuration of the IP layer.

        .. versionadded:: 2.5.0

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 (Default: 0)
        :rtype: int

        Both IP headers reserve space to for an the expected quality of service (QOS)
        field. In IPv4 this field is called the 'Type Of Service'. IPv6 uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the getter is generic, it is used for both IPv4 and IPv6 layers.

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           type = httpClient.TypeOfServiceGet()


        """
        return _byteblower.HTTPClient_TypeOfServiceGet(self)

    def FlowLabelSet(self, value):
        r"""

        Configures the flow label for IPv6 flows.

        .. versionadded:: 2.7.0

        :param label: IPv6 Flow label to set in the IPv6 header
        :type label: int

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.FlowLabelSet(1234)


        """
        return _byteblower.HTTPClient_FlowLabelSet(self, value)

    def FlowLabelGet(self):
        r"""

        Returns the configured "Flow Label" for IPv6 flows.

        .. versionadded:: 2.7.0

        :rtype: int

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.FlowLabelGet())


        """
        return _byteblower.HTTPClient_FlowLabelGet(self)

# Register HTTPClient in _byteblower:
_byteblower.HTTPClient_swigregister(HTTPClient)

def ConvertRequestStartTypeToString(inRequestStartType):
    return _byteblower.ConvertRequestStartTypeToString(inRequestStartType)

def ParseRequestStartType(inStr):
    return _byteblower.ParseRequestStartType(inStr)
class HTTPClientMobile(AbstractObject):
    r"""

    HTTP client application that may schedule HTTP requests to the HTTP server
    application.

    .. versionadded:: 2.5.0

    Using this class, you can simulate TCP (Transmission Control Protocol) traffic
    The TCP is simulated by a HTML request to the HTTPServer. This is the HttpClient
    that will perform the GET or the PUT. This request can be sent to the
    :class:`HTTPServer` object

    Example

    .. code-block:: python
       :caption: Standard usage of the HTTPClient for WirelessEndpoints

       http_client = wireless_endpoint.ProtocolHttpClientAdd()

       # configure the HTTP server to talk with
       http_client.RemoteAddressSet('10.4.8.2')
       http_client.RemotePortSet(8080)

       # we want a session of 10 seconds
       nanoseconds_per_second = 1 * 1000 * 1000 * 1000
       http_client.RequestDurationSet(10 * nanoseconds_per_second)

       # we do not want to start immediately
       http_client.RequestInitialTimeToWaitSet(1 * nanoseconds_per_second)

       # we want the client to restart if the connection is broken
       # e.g. when the access point restarts
       http_client.RestartEnable(True)

       # start the wireless endpoint 
       wireless_endpoint.Prepare()
       wireless_endpoint.Start()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RequestStatusGet(self):
        r"""


        :rtype: HTTPRequestStatus

        :meta private:

        """
        return _byteblower.HTTPClientMobile_RequestStatusGet(self)

    def ErrorMessageGet(self):
        r"""


        :rtype: str

        :meta private:

        """
        return _byteblower.HTTPClientMobile_ErrorMessageGet(self)

    def RequestSizeSet(self, inRequestSize):
        r"""

        Method which will configure a page to send out an HTTP Request to request a
        certain number of Bytes.

        .. versionadded:: 2.22.0

        :param size: The number of Bytes to send the HTTP Request for.
                     A value of zero means unlimited
                     (Default: 0)
        :type size: int

        A HTTP Request page will be configured to request for a certain size of data on
        a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with the number of requested Bytes
        transferred over the network.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`
                  The HTTP Method defines the way the data traffic will flow.

        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        Example

        Setting the requestsize to 10000000 Bytes

        .. code-block:: python
           :emphasize-lines: 1

           httpClient.RequestSizeSet(10000000)


        """
        return _byteblower.HTTPClientMobile_RequestSizeSet(self, inRequestSize)

    def RequestSizeGet(self):
        r"""

        Method which will return the configured requested pagesize expressed in Bytes.

        .. versionadded:: 2.22.0

        :return: The configured requested pagesize in bytes
        :rtype: int

        A HTTP Request page will be configured to request for a certain size of data on
        a ByteBlower HTTP server.

        Example

        Getting the configured requestsize

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.RequestSizeGet())


        """
        return _byteblower.HTTPClientMobile_RequestSizeGet(self)

    def RequestDurationSet(self, inDurationNs):
        r"""

        Method which will configure a page to send out an HTTP Request to transmit data during a certain time.

        :param duration: The duration of data traffic to send the HTTP Request for.
        :type duration: int

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with data transferred over the
        network until the requested duration has passed.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`

        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: Request a data transfer for 3 seconds.

           nanoseconds_per_second = 1000 * 1000 * 1000

           http_client.RequestDurationSet(3 * nanoseconds_per_second)


        """
        return _byteblower.HTTPClientMobile_RequestDurationSet(self, inDurationNs)

    def RequestDurationGet(self):
        r"""

        Method which will return the configured HTTP Request duration.

        :return: The HTTP request duration.
        :rtype: int

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Prints the configured request duration

           print(http_client.RequestDurationGet())


        """
        return _byteblower.HTTPClientMobile_RequestDurationGet(self)

    def LocalPortSet(self, inPort):
        r"""

        Configure the TCP port for the client to use.

        :param port: TCP port on the client will use to communicate with the HTTP 
                     server. Valid range: 1-65535
        :type port: int

        :raises TypeError: When the value is not an Integer
        :raises ConfigError: When the value is not between 1 and 65535

        This method will set the TCP port for the client.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the local TCP port to 20000

           http_client.LocalPortSet(20000)


        """
        return _byteblower.HTTPClientMobile_LocalPortSet(self, inPort)

    def LocalPortGet(self):
        r"""

        Returns the TCP the HTTPClientMobile will use to send its HTTPRequest.

        :return: The TCP port the client uses.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.LocalPortGet())


        """
        return _byteblower.HTTPClientMobile_LocalPortGet(self)

    def RemoteAddressSet(self, inAddress):
        r"""

        Configure the destination address.

        :param address: IP address of the HTTP server this client will use.
        :type address: str

        Method to configure the address of the HTTP server which this client will try
        to contact.

        .. note:: Be aware that only addresses are used, no DNS is supported at this
                  moment.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RemoteAddressSet('192.168.0.4')


        """
        return _byteblower.HTTPClientMobile_RemoteAddressSet(self, inAddress)

    def RemoteAddressGet(self):
        r"""

        Return the configured destination address.

        :return: destination address
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RemoteAddressGet())


        """
        return _byteblower.HTTPClientMobile_RemoteAddressGet(self)

    def RemotePortSet(self, inRemotePort):
        r"""

        Configure the TCP port which the client will use as destination port.

        :param port: TCP port of the HTTP server which the client will try to contact.
        :type port: int

        :raises TypeError: When the value is not an Integer
        :raises ConfigError: when the value is not between 1 and 65535

        This method is used to configure the TCP port of the server which the client
        will try to contact.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the remote port to port 80.

           http_client.RemotePortSet(80)


        """
        return _byteblower.HTTPClientMobile_RemotePortSet(self, inRemotePort)

    def RemotePortGet(self):
        r"""

        Returns the configured destination port.

        :return: the remote (destination) tcp port
        :rtype: int

        This method returns the current configured TCP port of the HTTP server which
        this client will try to contact.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RemotePortGet())


        """
        return _byteblower.HTTPClientMobile_RemotePortGet(self)

    def HttpSessionInfoGet(self):
        r"""


        :rtype: HTTPSessionInfo

        :meta private:

        """
        return _byteblower.HTTPClientMobile_HttpSessionInfoGet(self)

    def HttpSessionInfoDestroy(self):
        r"""


        :type session: HTTPSessionInfo

        :meta private:

        """
        return _byteblower.HTTPClientMobile_HttpSessionInfoDestroy(self)

    def RequestInitialTimeToWaitGet(self):
        r"""

        Returns the initial time to wait before a scheduled Request starts.

        :return: The initial time in nanoseconds to wait before a scheduled request 
                 starts. (default 0)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RequestInitialTimeToWaitGet())


        """
        return _byteblower.HTTPClientMobile_RequestInitialTimeToWaitGet(self)

    def RequestInitialTimeToWaitSet(self, inDelay):
        r"""

        Sets the initial time to wait before really requesting a page (for a scheduled
        Request).

        :param timetowait: Time in nanoseconds to wait before the request will be really 
                           sent. 
                           (default: 0)
        :type timetowait: int

        This can be used if you want to start different request on different
        timestamps.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RequestInitialTimeToWaitSet(1000000000)


        """
        return _byteblower.HTTPClientMobile_RequestInitialTimeToWaitSet(self, inDelay)

    def HttpMethodSet(self, *args):
        r"""

        Configures the HTTPRequest method to be used.

        :param method: The method to be used.               
        :type method: HTTPRequestMethod

        .. note:: Only 2 HTTP methods are supported for now:

                  - :attr:`HTTPRequestMethod.Get`: (default) starts a download
                  - :attr:`HTTPRequestMethod.Put`: starts an upload

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.HttpMethodSet(HTTPRequestMethod.Put)


        Configures the HTTPRequest method to be used.

        :param method: The method to be used.               
        :type method: HTTPRequestMethod

        .. note:: Only 2 HTTP methods are supported for now:

                  - :attr:`HTTPRequestMethod.Get`: (default) starts a download
                  - :attr:`HTTPRequestMethod.Put`: starts an upload

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.HttpMethodSet(HTTPRequestMethod.Put)


        """
        return _byteblower.HTTPClientMobile_HttpMethodSet(self, *args)

    def HttpMethodGet(self):
        r"""

        Returns the used HTTPRequest method.

        :return: The current selected HTTP request method
                 (Default: :attr:`.HTTPRequestMethod.Get`)
        :rtype: HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.HttpMethodGet() == HTTPRequestMethod.Get)


        """
        return _byteblower.HTTPClientMobile_HttpMethodGet(self)

    def LatencyEnable(self, inValue=True):
        r"""


        :type enable: bool

        :meta private:


        :type enable: bool

        :meta private:

        """
        return _byteblower.HTTPClientMobile_LatencyEnable(self, inValue)

    def RequestRateLimitSet(self, inRateLimitBytesps):
        r"""

        Method which will limit the rate of the HTTP traffic to a certain amount..

        :param ratelimit: The rate limit, in bytes per second.  0 disables the rate limit.
        :type ratelimit: int

        Example

        .. code-block:: python
           :emphasize-lines: 4
           :caption: Set the ratelimit to 10 megabytes per second

           bytes_per_megabyte = 1000 * 1000

           http_client = wireless_endpoint.ProtocolHttpClientAdd()
           http_client.RequestRateLimitSet(10 * bytes_per_megabyte)

        Example

        Disable rate limit

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RequestRateLimitSet(0)


        """
        return _byteblower.HTTPClientMobile_RequestRateLimitSet(self, inRateLimitBytesps)

    def RequestRateLimitGet(self):
        r"""

        Method which will return the configured rate-limit of the HTTP traffic.

        :return: rateLimit The rate limit, in bytes per second.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the configured rate limit in bytes per second

           print(http_client.RequestRateLimitGet())


        """
        return _byteblower.HTTPClientMobile_RequestRateLimitGet(self)

    def RestartIsEnabled(self):
        r"""

        Method which will return whether or not the HTTP Client will restart the session when the connection fails.

        .. versionadded:: 2.10.0

        :return: True if enabled, false otherwise.
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RestartIsEnabled())


        """
        return _byteblower.HTTPClientMobile_RestartIsEnabled(self)

    def RestartEnable(self, arg2):
        r"""

        Let the HTTP Client try to restart the session when a connection fails.

        .. versionadded:: 2.10.0

        :param enable: True to enable, False to disable.
        :type enable: bool

        The HTTP Client will setup a new HTTP connection when the connection is lost for
        some reason. Possible reasons are loss of the network connection on the device,
        loss of the TCP connection due to a rebooting device somewhere in the network...

        To distinguish the different sessions, the ClientServerId is used as a prefix.
        The connection attempt number is appended to the ID

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Enable the restart behaviour

           http_client.RestartEnable(True)


        """
        return _byteblower.HTTPClientMobile_RestartEnable(self, arg2)

    def TcpPragueEnable(self, value):
        r"""

        Request TCP Prague / L4S support for this flow..

        .. versionadded:: 2.22.0

        :param enable: True to enable
        :type enable: bool

        When TCP Prague or L4S is supported by the Endpoint device, this method
        will enable L4S / TCP Prague on this flow. 
        In the other case, the method will silently fail and keep the default
        value of False.

        To determine whether or not the action succeeded, one should call
        TcpPragueIsEnabled() after an invocation of this method.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.TcpPragueEnable(True)
           is_enabled = http_client.TcpPragueIsEnabled()


        """
        return _byteblower.HTTPClientMobile_TcpPragueEnable(self, value)

    def TcpPragueIsEnabled(self):
        r"""

        Returns whether or not TCP Prague is enabled.

        .. versionadded:: 2.22.0

        :rtype: bool

        When TCP Prague or L4S is enabled on the Endpoint for this flow, this
        method will return True.  If TCP Prague was not configured or the Endpoint
        does not support TCP Prague or L4S, this method will return False.

        Checking the Tcp.L4S capability will determine if TCP Prague or L4S is 
        supported by the Endpoint device.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           return http_client.TcpPragueIsEnabled()


        """
        return _byteblower.HTTPClientMobile_TcpPragueIsEnabled(self)

    def ClientIdGet(self):
        r"""

        Returns the unique client ID.

        :return: the HTTPClientMobile unique ID
        :rtype: str

        Each client has a unique ID so that information about the same connection can
        be requested on a HTTP server object. This method returns the unique ClientID
        for this HTTP client.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.ClientId())


        """
        return _byteblower.HTTPClientMobile_ClientIdGet(self)

    def ServerIdGet(self):
        r"""

        Returns the unique ByteBlower Server ID.

        :return: The ByteBlower server unique ID.
        :rtype: str

        Each ByteBlower server has a unique ID. This identifier stays persistent over
        the lifetime of the ByteBlowerServers ( changed when rebooted ). This serverId
        together with the clientId identifies a HTTPConnection. By adding those 2 id's
        together it is unlikely that 2 HTTPClientMobiles each running on a different
        server end up with the same connection ID.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the Server ID

           print(http_client.ServerIdGet())


        """
        return _byteblower.HTTPClientMobile_ServerIdGet(self)

    def ServerClientIdGet(self):
        r"""

        This method returns the combination of the server Id (aka ByteBlower Server Id) and client Id.

        :return: The combined server- and client Id
        :rtype: str

        This returns a combination of the ServerId and the Client Id. This combination
        will identify a HTTP connection. It is this combination of id's you can use to
        request the :class:`HTTPSessionInfo` on the HTTP server :class:`HTTPServer`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.ServerClientIdGet())


        """
        return _byteblower.HTTPClientMobile_ServerClientIdGet(self)

    def ResultGet(self):
        r"""


        :rtype: HTTPResultSnapshot

        :meta private:

        """
        return _byteblower.HTTPClientMobile_ResultGet(self)

    def ResultHistoryGet(self):
        r"""


        :rtype: HTTPResultHistory
        :meta private:

        """
        return _byteblower.HTTPClientMobile_ResultHistoryGet(self)

    def HistorySamplingIntervalDurationGet(self):
        r"""


        :rtype: int

        :meta private:

        """
        return _byteblower.HTTPClientMobile_HistorySamplingIntervalDurationGet(self)

    def HistorySamplingIntervalDurationSet(self, inDuration):
        r"""


        :type duration: int

        :meta private:

        """
        return _byteblower.HTTPClientMobile_HistorySamplingIntervalDurationSet(self, inDuration)

    def TypeOfServiceSet(self, value):
        r"""

        Configures the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        :param tos: The literal value to be set (0-255)
        :type tos: int

        This method sets the :term:`Type of Service` for an IPv4 connection or the
        :term:`Traffic Class` for an IPv6 connection. Despite naming, they are both 
        8 bits wide. For ease of use, the method is generic, it is used for both IPv4
        and IPv6 layers. The implementation will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before 
        the parent ByteBlower port is started. Invoking the method at other moments 
        will result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.TypeOfServiceSet(8)


        """
        return _byteblower.HTTPClientMobile_TypeOfServiceSet(self, value)

    def TypeOfServiceGet(self):
        r"""

        Retrieves the 'Type Of Service' or 'Traffic Class' configuration of the IP layer.

        .. versionadded:: 2.5.0

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 (Default: 0)
        :rtype: int

        Both IP headers reserve space to for an the expected quality of service(QOS)
        field. In IPv4 this field is called the 'Type Of Service'. IPv6 uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the getter is generic, it is used for both IPv4 and IPv6 layers.

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.TypeOfServiceGet())


        """
        return _byteblower.HTTPClientMobile_TypeOfServiceGet(self)

# Register HTTPClientMobile in _byteblower:
_byteblower.HTTPClientMobile_swigregister(HTTPClientMobile)
HTTPServerStatus_Running = _byteblower.HTTPServerStatus_Running
HTTPServerStatus_Stopped = _byteblower.HTTPServerStatus_Stopped
HTTPServerStatus_Error = _byteblower.HTTPServerStatus_Error
HTTPServerStatus_Unknown = _byteblower.HTTPServerStatus_Unknown
class HTTPServer(AbstractObject):
    r"""

    HTTP server application that handles incoming HTTP requests with the correct
    URL format by returning a document of the appropriate size.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Start(self):
        r"""

        Starts the HTTP server on the configured port with the configured configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.Start()


        """
        return _byteblower.HTTPServer_Start(self)

    def Stop(self):
        r"""

        Stops the HTTP server.

        Running sessions will be stopped and new requests will be ignored.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.Stop()


        """
        return _byteblower.HTTPServer_Stop(self)

    def StatusGet(self):
        r"""

        Returns the HTTP server status.

        :rtype: HTTPServerStatus

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Before starting the HTTP server

           print(httpServer.StatusGet() == HTTPRequestStatus.Stopped)


        """
        return _byteblower.HTTPServer_StatusGet(self)

    def PortSet(self, inPort):
        r"""

        Configures the TCP port on which the HTTP server will listen.

        :param port: The TCP port on which the HTTP server will listen for incoming
                     requests.
        :type port: int

        :raises TypeError: When the value is not an Integer
        :raises ConfigError: when the value is not between 1 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.PortSet(80)


        """
        return _byteblower.HTTPServer_PortSet(self, inPort)

    def PortGet(self):
        r"""

        Returns the configured TCP port for the HTTP server.

        :return: The configured TCP Port
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.PortGet())


        """
        return _byteblower.HTTPServer_PortGet(self)

    def HttpSessionInfoGet(self, inServerClientId):
        r"""

        Returns the HTTP Session statistics for this session.

        :param clientID: ID of the client which has connected with this server. This ID
                         can be retrieved using the :meth:`HTTPClient.ServerClientIdGet`
        :type clientID: str

        :rtype: HTTPSessionInfo

        :raises ConfigError: when the HTTP Server did not setup the given HTTP
                 session (e.g. when the TCP connection failed)

        The object contains all the information of the current session. From
        state until the counters of received/transmitted bytes

        .. warning:: call :meth:`HasSession` to verify that the client session exists,
                     before calling this function. Otherwise, an exception may be
                     thrown.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.HttpSessionInfoGet())


        """
        return _byteblower.HTTPServer_HttpSessionInfoGet(self, inServerClientId)

    def HasSession(self, inServerClientId):
        r"""

        Returns whether or not a client session exists with the given server-client-identifier.

        :return: True when we have a Session, False if we don't
        :rtype: bool

        See also: :meth:`.HTTPClient.ServerClientIdGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.HasSession('BBhttpS2502398654/BBhttpC1146349503' ))


        """
        return _byteblower.HTTPServer_HasSession(self, inServerClientId)

    def ResultGet(self, inServerClientId):
        r"""

        Returns the current HTTP statistics for a given session.

        :param serverClientId: Identifier of the session to get results for.
        :type serverClientId: str

        :return: The current cumulative HTTP Results for the given session
        :rtype: HTTPResultSnapshot


        """
        return _byteblower.HTTPServer_ResultGet(self, inServerClientId)

    def ResultHistoryGet(self, inServerClientId):
        r"""

        Returns the current HTTP statistics history for a given session.

        :param serverClientId: Identifier of the session to get results for.
        :type serverClientId: str

        :return: The current HTTP Result history for the given session
        :rtype: HTTPResultHistory


        """
        return _byteblower.HTTPServer_ResultHistoryGet(self, inServerClientId)

    def HttpSessionInfoDestroy(self, inServerClientId):
        r"""

        Removes a HTTP Session statistics object

        :param session: Session to remove
        :type session: HTTPSessionInfo

        Removing a HTTP Session statistics object will free up the storage required on
        the ByteBlower server and the API instance.  Any stored value containing this
        object will be invalid.


        """
        return _byteblower.HTTPServer_HttpSessionInfoDestroy(self, inServerClientId)

    def MaximumSegmentSizeSet(self, inValue):
        r"""

        Sets the TCP maximum segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.
        :type size: int

        This option specifies an upper bound on the TCP segment size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.MaximumSegmentSizeSet(65525)


        """
        return _byteblower.HTTPServer_MaximumSegmentSizeSet(self, inValue)

    def MaximumSegmentSizeGet(self):
        r"""

        Returns the configured TCP maximum segment size.

        :rtype: int

        The default value is 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.MaximumSegmentSizeGet())


        """
        return _byteblower.HTTPServer_MaximumSegmentSizeGet(self)

    def ReceiveWindowInitialSizeSet(self, inValue):
        r"""

        Sets the initial receive window for the server.

        :param windowsize: New value of the initial receive window.
        :type windowsize: int

        :raises TypeError: When the value is not an Integer
        :raises ConfigError: When the value is out of range

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.ReceiveWindowInitialSizeSet(65535)


        """
        return _byteblower.HTTPServer_ReceiveWindowInitialSizeSet(self, inValue)

    def ReceiveWindowInitialSizeGet(self):
        r"""

        Gets the initial receive window for the server.

        :rtype: int

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.ReceiveWindowInitialSizeGet())


        """
        return _byteblower.HTTPServer_ReceiveWindowInitialSizeGet(self)

    def ReceiveWindowScalingIsEnabled(self):
        r"""

        Returns if window scaling is enabled or not.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :return: True: Window scaling is enabled, False when disabled
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.ReceiveWindowScalingIsEnabled())


        """
        return _byteblower.HTTPServer_ReceiveWindowScalingIsEnabled(self)

    def ReceiveWindowScalingEnable(self, inWindowScaling):
        r"""

        Enables of disables windowscaling.

        :param scaling: True to enable or False to disable windowscaling.
        :type scaling: bool

        :raises TypeError: when the value does not evaluate to True or False

        Windowscaling allows the Window Size to grow further than 65,536 bytes. For 
        high speed or high latency links, window scaling should be enabled for a good
        throughput.

        Example

        To enable window scaling  or  To disable window scaling  or

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.ReceiveWindowScalingEnable(True)


        """
        return _byteblower.HTTPServer_ReceiveWindowScalingEnable(self, inWindowScaling)

    def SessionStorageIsEnabled(self):
        r"""


        :return: whether or not this feature is enabled
        :rtype: bool


        """
        return _byteblower.HTTPServer_SessionStorageIsEnabled(self)

    def SessionStorageEnable(self, value):
        r"""

        Enable or disable storage for the HTTP Sessions

        :param enable: Enable session storage.  (Default: True)
        :type enable: bool

        The ByteBlower HTTP Server creates sessions and their histories by default.
        When one will never query those results, this feature can be disabled, so 
        server resources will be free'd automatically as soon the HTTP Session finishes


        """
        return _byteblower.HTTPServer_SessionStorageEnable(self, value)

    def ReceiveWindowScalingValueGet(self):
        r"""

        Returns the current receive window scale.

        :return: current receive window scale (Default: 3)
        :rtype: int

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in
        :rfc:`1323`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPServer_ReceiveWindowScalingValueGet(self)

    def ReceiveWindowScalingValueSet(self, inRcvWindowScale):
        r"""

        Configures the window scale which will be used for new clients.

        :param scale: Integer (0-8), which is used for bitwise shifting.
                      (Default: 3)
        :type scale: int

        :raises ConfigError: When the scaling value is out of range.

        This must be done before requesting a page from a client, because this option
        is negotiated at the beginning of the TCP session.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in
        IETF rfc:`1323`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.ReceiveWindowScalingValueSet(7)


        """
        return _byteblower.HTTPServer_ReceiveWindowScalingValueSet(self, inRcvWindowScale)

    def SlowStartThresholdSet(self, inValue):
        r"""

        Set the initial slow-start threshold value used by TCP.

        :param ssthresh: New value for the slow-start threshold. Default: 65535 
        :type ssthresh: int

        :raises ConfigError: When the value is not a positive integer

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.SlowStartThresholdSet(1000000)


        """
        return _byteblower.HTTPServer_SlowStartThresholdSet(self, inValue)

    def SlowStartThresholdGet(self):
        r"""

        Returns the initial slow-start threshold value used by TCP.

        :return: Slow-start threshold (Default: 65535) 
        :rtype: int

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.SlowStartThresholdGet())


        """
        return _byteblower.HTTPServer_SlowStartThresholdGet(self)

    def TcpCongestionAvoidanceAlgorithmSet(self, inValue):
        r"""

        Selects the TCP Congestion Avoidance Algorithm.

        :param algorithm: Congestion Avoidance Algorithm to configure. 
                          (Default: :attr:`.TCPCongestionAvoidanceAlgorithm.No_Algorithm`)
        :type algorithm: TCPCongestionAvoidanceAlgorithm

        :raises TypeError:  When the value could not be interpreted as a valid TCAA
        :raises ConfigError: When the value is not a supported TCAA

        Selects the TCP Congestion Avoidance Algorithm which will be used for new
        clients. This must be selected before requesting a page from a client, because
        for some algorithms, the congestion avoidance support is negotiated a the
        beginning of the TCP session.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure NewReno as congestionAvoidance Algorithm

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure Sack as congestionAvoidance Algorithm

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure None as congestionAvoidance Algorithm

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)


        """
        return _byteblower.HTTPServer_TcpCongestionAvoidanceAlgorithmSet(self, inValue)

    def TcpCongestionAvoidanceAlgorithmGet(self):
        r"""

        Gets the current configured TCP Congestion Avoidance Algorithm for new clients.

        :return: current Congestion Avoidance Algorithm.
                 (Default: :attr:`.TCPCongestionAvoidanceAlgorithm.No_Algorithm`)
        :rtype: TCPCongestionAvoidanceAlgorithm

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewRenoWithCubic)


        """
        return _byteblower.HTTPServer_TcpCongestionAvoidanceAlgorithmGet(self)

    def TcpPragueEnable(self, value):
        r"""

        Whether or not TCP Prague must be enabled.

        :param enable: True to enable TCP Prague, False to disable
        :type enable: bool

        TCP Prague is an implementation which is heavily used in L4S


        """
        return _byteblower.HTTPServer_TcpPragueEnable(self, value)

    def TcpPragueIsEnabled(self):
        r"""

        Returns whether or not TCP Prague support is enabled

        :rtype: bool


        """
        return _byteblower.HTTPServer_TcpPragueIsEnabled(self)

    def ClientIdentifiersGet(self):
        r"""

        Returns the list of known identifiers of HTTP clients which made a connection
        to this server.

        :return: List of Client Identifiers which have connected this server.
        :rtype: StringList

        See also: :meth:`HTTPClient.ServerClientIdGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.ClientIdentifiersGet()[0])


        """
        return _byteblower.HTTPServer_ClientIdentifiersGet(self)

    def HistorySamplingIntervalDurationGet(self):
        r"""

        Gets the default Sampling interval for the HTTP Session history.

        :rtype: int

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.HistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPServer_HistorySamplingIntervalDurationGet(self)

    def HistorySamplingBufferLengthGet(self):
        r"""

        Gets the default Sampling Buffer Length for the HTTP Session history.

        :rtype: int

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage is that previous 
        history items are not invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.HistorySamplingBufferLengthGet())


        """
        return _byteblower.HTTPServer_HistorySamplingBufferLengthGet(self)

    def HistorySamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the default Sampling interval for the HTTP Session history.

        :param interval: Duration of a single sample in nanoseconds
        :type interval: int

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.HistorySamplingIntervalDurationSet(500)


        """
        return _byteblower.HTTPServer_HistorySamplingIntervalDurationSet(self, inDuration)

    def HistorySamplingBufferLengthSet(self, inLength):
        r"""

        Sets the default Sampling Buffer Length for the HTTP Session history.

        :param length: Number of samples to keep in the server-side buffer
        :type length: int

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.HistorySamplingBufferLengthSet(10)


        """
        return _byteblower.HTTPServer_HistorySamplingBufferLengthSet(self, inLength)

    def TcpHistorySamplingIntervalDurationGet(self):
        r"""

        Gets the default Sampling interval for the TCP Session history.

        :rtype: int

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage is not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.TcpHistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPServer_TcpHistorySamplingIntervalDurationGet(self)

    def TcpHistorySamplingBufferLengthGet(self):
        r"""

        Gets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.TcpHistorySamplingBufferLengthGet())


        """
        return _byteblower.HTTPServer_TcpHistorySamplingBufferLengthGet(self)

    def TcpHistorySamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the default Sampling interval for the TCP Session history.

        :param duration: duration in nanoseconds for a single sample
        :type duration: int

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage is that previous 
        history items are not invalidated.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.TcpHistorySamplingIntervalDurationSet(500)


        """
        return _byteblower.HTTPServer_TcpHistorySamplingIntervalDurationSet(self, inDuration)

    def TcpHistorySamplingBufferLengthSet(self, inLength):
        r"""

        Sets the default Sampling Buffer Length for the TCP Session history.

        :param length: Number of samples to keep in the server-side buffer
        :type length: int

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.TcpHistorySamplingBufferLengthSet(10)


        """
        return _byteblower.HTTPServer_TcpHistorySamplingBufferLengthSet(self, inLength)

# Register HTTPServer in _byteblower:
_byteblower.HTTPServer_swigregister(HTTPServer)
class ICMPEchoSession(AbstractObject):
    r"""

    Session for handling ICMP Echo Requests and Replies.

    This Session uses the ICMP protocol for receiving and / or transmitting
    ICMP Echo Request and / or Replies

    Some use cases for this session are:

    - DUT validation

      - Verify Echo Request / Replies are either or not filtered out

      - Verify public / private connectivity for Routers, NAT gateways, ...

    - DUT stability

      - Verify Echo Replies are received during some stability tests


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RemoteAddressSet(self, inIPAddress):
        r"""

        Configure the destination IPv4 address.

        .. versionadded:: 2.3.0

        This method configures the destination IPv4 address for our ICMP Echo packets

        The destination IPv4 address defines to where the ICMP Echo Requests will be
        sent or from where ICMP Echo Responses are / were received.

        :param ipv4Address: The Destination IPv4 Address for this session.

        :raises: <python_error> - Invalid IPv4 address: When the value could not
                 be interpreted as an IPv4 address

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.RemoteAddressSet('10.8.254.69')


        """
        return _byteblower.ICMPEchoSession_RemoteAddressSet(self, inIPAddress)

    def RemoteAddressGet(self):
        r"""

        Returns the ICMP Echo Request destination IPv4 address.

        .. versionadded:: 2.3.0

        :rtype: str

        :return: The Destination IPv4 address for this session.

        :raises: ByteBlower.Session - When the destination IPv4 address was not yet
                 configured

        This method returns the IPv4 address which has been configured with
        :meth:`RemoteAddressSet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.RemoteAddressGet())


        """
        return _byteblower.ICMPEchoSession_RemoteAddressGet(self)

    def TtlSet(self, inTTL):
        r"""

        Configures the IPv4 time-to-live.

        .. versionadded:: 1.8.18

        :param ttl: The IPv4 TTL you wish to configure. (Valid range: 0 to 255.)
                    Default: 255
        :type ttl: int

        :raises: <python_error> - bad lexical cast: When the value could not be
                                  interpreted as a valid integer
        :raises ConfigError:  When the value is out of range

        This method configures the IPv4 TTL (time-to-live) for the ICMP Echo packets.

        The TTL defines the maximum lifetime of an IPv4 (in this case ICMP) packet in
        the network. Every router that the packet passes decrements the TTL field in
        the packet. When the TTL reaches value 0 before it is delivered at its
        destination, it will be dropped. The router will respond to the sender with an
        ICMP packet type 11 (Time Exceeded).

        .. note:: The IPv4 TTL applies for all ICMP Echo packets (Requests and Responses)

        .. note:: The TTL only applies for this session, other sessions in this
                  `class:`.ICMPProtocol` are not affected.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure a TTL of 127 for the ICMP Request and Reply packets

           icmpEchoSession.TtlSet(127)


        """
        return _byteblower.ICMPEchoSession_TtlSet(self, inTTL)

    def TtlGet(self):
        r"""

        Returns the current IPv4 time-to-live.

        :return: IPv4 time-to-live for all ICMP Echo packets
        :rtype: int

        This method returns the current IPv4 TTL (time-to-live) for the
        ICMP Echo packets.

        The TTL defines the maximum lifetime of an IPv4 (in this case ICMP) packet in
        the network. Every router that the packet passes decrements the TTL field in
        the packet. When the TTL reaches value 0 before it is delivered at its
        destination, it will be dropped. The router will respond to the sender with an
        ICMP packet type 11 (Time Exceeded).

        .. note:: The IPv4 TTL applies for all ICMP Echo packets (Requests and Responses)

        Default value: 255

        .. versionadded:: 1.8.18


        """
        return _byteblower.ICMPEchoSession_TtlGet(self)

    def TypeOfServiceSet(self, inTOS):
        r"""

        Configures the 'Type Of Service' used at the IP layer.

        .. versionadded:: 2.5.0

        :param tos: The value of Type Of Service in the IP header
        :type tos: int

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before
        the parent ByteBlower port is started. Invoking the method at other moments
        will result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.TypeOfServiceSet(16)


        """
        return _byteblower.ICMPEchoSession_TypeOfServiceSet(self, inTOS)

    def TypeOfServiceGet(self):
        r"""

        Retrieves the 'Type Of Service' configuration of the IP layer.

        .. versionadded:: 2.5.0

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 The default value is 0.
        :rtype: int

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.TypeOfServiceGet())


        """
        return _byteblower.ICMPEchoSession_TypeOfServiceGet(self)

    def IdentifierGet(self):
        r"""

        Returns the ICMP Echo Request ICMPID.

        :return: The ICMP Echo Request ICMP ID for this Session.
        :rtype: int

        This method returns the ICMP Echo Request ICMPID.
        This is also known as the Application ID

        The Application ID is either generated randomly or is the one that has been
        provided with :meth:`.ICMPProtocol.SessionAdd`

        Example

        Returns the (integer) value of the ICMP ID (Application ID)

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.IdentifierGet())


        """
        return _byteblower.ICMPEchoSession_IdentifierGet(self)

    def DataSizeSet(self, inDataSize):
        r"""

        Configures the data size.

        This method configures the data size of our ICMP Echo Requests

        The data size of our ICMP Echo Requests is the payload size of the packet

        :param dataSize: The ICMP data size you wish to configure.

        The valid range of `dataSize` is:
        (0 to *<port_mdl>*) - *<ICMP_header_size>*.

        Where

        <port_mdl>
            Value of :meth:`.ByteBlowerPort.MDLGet`

        *<ICMP_header_size>*
            Ethernet header size (14) + IPv4 header size (20) + ICMP header size (8)

        Default value: 56

        :raises: <python_error> - bad lexical cast: When the value could not be
                 interpreted as a valid integer
        :raises: ByteBlower.Protocol.InvalidValue - When the value is out of range

        Example

        Configure 92Bytes payload for the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.DataSizeSet(92)


        """
        return _byteblower.ICMPEchoSession_DataSizeSet(self, inDataSize)

    def DataSizeGet(self):
        r"""

        Returns the data size.

        :return: ICMP Echo data size
        :rtype: int

        This method returns the data size of our ICMP Echo Requests

        The data size of our ICMP Echo Requests is the payload size of the packet

        Default value: 56

        Example

        The ICMP session has been configure to add 76Bytes payload in the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.DataSizeGet())


        """
        return _byteblower.ICMPEchoSession_DataSizeGet(self)

    def EchoRequestSend(self):
        r"""

        Transmit an ICMP Echo Request.

        :raises: ByteBlower.Session.Unavailable - When the destination IPv4 address was
                 not yet configured
        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv4
                 address cannot be reached

        This method sends one ICMP Echo Request.

        .. note:: This method call is (partially) non-blocking. The call will not
                  return as soon the session is setup and the request is sent or an
                  error occurred (exception is thrown). The call does not wait until
                  an Echo Reply is received.

        .. note:: The Destination IPv4 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests


        """
        return _byteblower.ICMPEchoSession_EchoRequestSend(self)

    def EchoStatsClear(self):
        r"""

        Resets the ICMP Session statistics.

        .. deprecated:: 2.3.0
                        The recommended approach is to destruct this session and create
                        a new one.

        This method resets the ICMP Session statistics.


        """
        return _byteblower.ICMPEchoSession_EchoStatsClear(self)

    def EchoLoopIntervalSet(self, inTimeNs):
        r"""

        Configures the Echo Request interval.

        :param loopInterval: The interval between two ICMP Echo Request packets [ns].
                             Valid range: 0 to *<max_uint64>*[ns]
                             Where *<max_uint64>*  = 0xFFFFFFFFFFFFFFFF = 18446744073709551615
                             (= maximum unsigned 64bit integer)
        :type loopInterval: int

        This method configures the interval between subsequent Echo Request packets
        when sending in a loop.

        The interval has a nanosecond resolution. You can provide a time unit for the
        loop interval value.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        Default value: 1s

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure an interval of 50 microseconds (50000 nanoseconds)

           icmpEchoSession.EchoLoopIntervalSet(50000)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure an interval of 500 milliseconds

           icmpEchoSession.EchoLoopIntervalSet(500000000)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure an interval of 1.25 milliseconds

           icmpEchoSession.EchoLoopIntervalSet(1250000)


        """
        return _byteblower.ICMPEchoSession_EchoLoopIntervalSet(self, inTimeNs)

    def EchoLoopIntervalGet(self):
        r"""

        Returns the Echo Request interval.

        :return: The interval between two ICMP Echo Request packets [ns]
        :rtype: int

        This method returns the interval between subsequent Echo Request packets when
        sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        .. note:: The interval is always returned in nanoseconds resolution. No unit is
                  added to the value.

        Default value: 1s

        Example

        The transmit loop is configured with an interval of 625 microseconds

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.EchoLoopIntervalGet())


        """
        return _byteblower.ICMPEchoSession_EchoLoopIntervalGet(self)

    def EchoLoopCountSet(self, inCount):
        r"""

        Configures the Echo Request count.

        .. versionadded:: 1.8.18

        :param packetCount: The number of ICMP Echo Request packets to transmit
        :type packetCount: int

        :raises TypeError: When the value could not be interpreted as a valid integer

        This method configures the number of Echo Requests which will be transmitted
        when sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        Default value: infinite

        The actual value is *<max_uint64>* = 0xFFFFFFFFFFFFFFFF = 18446744073709551615)

        Example

        Configure the loop to transmit 100 ICMP Echo Request packets

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.EchoLoopCountSet(100)


        """
        return _byteblower.ICMPEchoSession_EchoLoopCountSet(self, inCount)

    def EchoLoopCountGet(self):
        r"""

        Returns the Echo Request count.

        This method returns the number of Echo Requests which will be transmitted when
        sending in a loop.

        Default value: infinite
        (*<max_uint64>* = 0xFFFFFFFFFFFFFFFF = 18446744073709551615)

        :return: The number of ICMP Echo Request packets in a loop

        .. versionadded:: 1.8.18

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

            print(icmpEchoSession.EchoLoopCountGet())


        """
        return _byteblower.ICMPEchoSession_EchoLoopCountGet(self)

    def EchoLoopStart(self):
        r"""

        Starts sending Echo Requests in a loop.

        :raises: ByteBlower.Session.Unavailable - When the destination IPv4 address
                 was not yet configured
        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv4
                 address cannot be reached

        This method start sending Echo Requests in a loop.

        The interval between Echo Request can be configured using the method
        :meth:`EchoLoopIntervalSet`

        If a limited number of Echo Request is desired, this can be configured using
        the method :meth:`EchoLoopCountSet`

        .. note:: This method call is (partially) non-blocking. The call will return as
                  soon as the session is started an the loop is running or an error
                  occurred during session initialization.

        .. note:: The Destination IPv4 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests


        """
        return _byteblower.ICMPEchoSession_EchoLoopStart(self)

    def EchoLoopStop(self):
        r"""

        Stops sending Echo Requests in a loop.

        This method stops sending Echo Requests in a loop. The loop can be started with
        :meth:`EchoLoopStart`

        .. note:: This method does not throw an exception if the loop was not started

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.EchoLoopStop()


        """
        return _byteblower.ICMPEchoSession_EchoLoopStop(self)

    def SessionInfoGet(self):
        r"""

        Returns the session information.

        .. versionadded:: 2.3.0

        :return: The session information in an object.
        :rtype: ICMPEchoSessionInfo

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.EchoLoopStart()


        """
        return _byteblower.ICMPEchoSession_SessionInfoGet(self)

# Register ICMPEchoSession in _byteblower:
_byteblower.ICMPEchoSession_swigregister(ICMPEchoSession)
class ICMPEchoSessionInfo(AbstractRefreshableResult):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxEchoRequestsGet(self):
        r"""

        Returns the ICMP Echo requests which were transmitted for the session.

        :return: The number of ICMP Echo requests which were sent during the session
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSessionInfo.TxEchoRequestsGet())


        """
        return _byteblower.ICMPEchoSessionInfo_TxEchoRequestsGet(self)

    def TxEchoRepliesGet(self):
        r"""

        Returns the ICMP Echo replies which were transmitted for the session.

        :return: The number of ICMP Echo replies which were sent during the session
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSessionInfo.TxEchoRepliesGet())


        """
        return _byteblower.ICMPEchoSessionInfo_TxEchoRepliesGet(self)

    def RxEchoRequestsGet(self):
        r"""

        Returns the ICMP Echo requests which were received for the session.

        :return: The number of ICMP Echo requests which were received during the
                 session
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSessionInfo.RxEchoRequestsGet())


        """
        return _byteblower.ICMPEchoSessionInfo_RxEchoRequestsGet(self)

    def RxEchoRepliesGet(self):
        r"""

        Returns the ICMP Echo replies which were received for the session.

        :return: The number of ICMP Echo replies which were received during the session
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSessionInfo.RxEchoRepliesGet())


        """
        return _byteblower.ICMPEchoSessionInfo_RxEchoRepliesGet(self)

    def RefreshTimestampGet(self):
        r"""

        Gets the timestamp on the server of when the session info was refreshed.

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSessionInfo.RefreshTimestampGet())


        """
        return _byteblower.ICMPEchoSessionInfo_RefreshTimestampGet(self)

# Register ICMPEchoSessionInfo in _byteblower:
_byteblower.ICMPEchoSessionInfo_swigregister(ICMPEchoSessionInfo)
class ICMPProtocol(AbstractObject):
    r"""

    The ICMP protocol is attached to the IPv4 protocol and allows the host to start
    ICMP sessions, through which it can communicate with the Layer3 IP network.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SessionAdd(self, *args):
        r"""

        Creates an ICMP Echo Session, through which this host can query the Layer3 IP network.

        :param applicationId: Provide an application id for this session.
                              This should be unique across the host. If none is given,
                              a random value is generated.
                              Default: `Random generate number`
        :type applicationId: int

        :return: The created echo session is immediately returned.
        :rtype: ICMPEchoSession

        See :class:`ICMPEchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed in :meth:`SessionGet`.
        If you want such sessions to be listed there, you will need to call
        :meth:`SessionAdd` given the `applicationId` that is used by the external tool.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        Creates an ICMP Echo Session, through which this host can query the Layer3 IP network.

        :param applicationId: Provide an application id for this session.
                              This should be unique across the host. If none is given,
                              a random value is generated.
                              Default: `Random generate number`
        :type applicationId: int

        :return: The created echo session is immediately returned.
        :rtype: ICMPEchoSession

        See :class:`ICMPEchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed in :meth:`SessionGet`.
        If you want such sessions to be listed there, you will need to call
        :meth:`SessionAdd` given the `applicationId` that is used by the external tool.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        """
        return _byteblower.ICMPProtocol_SessionAdd(self, *args)

    def SessionGet(self):
        r"""

        Returns the active list of ICMP Echo Sessions.

        :return: A list of :class:`ICMPEchoSession` objects
        :rtype: ICMPEchoSessionList

        .. note:: The ICMP Protocol may have more active sessions at *server-side* than
                  listed here.

                  This list only returns the :class:`ICMPEchoSession` objects for which
                  a handle has been created at client-side. See below for more
                  information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed here. If you want such sessions
        to be listed here, you will need to call :meth:`SessionAdd` given the
        `applicationId` that is used by the external tool.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           list = icmpProtocol.SessionGet()


        """
        return _byteblower.ICMPProtocol_SessionGet(self)

    def SessionDestroy(self, inSession):
        r"""

        Removes an ICMP Session from the server

        :param session: Session to remove
        :type session: ICMPEchoSession


        """
        return _byteblower.ICMPProtocol_SessionDestroy(self, inSession)

# Register ICMPProtocol in _byteblower:
_byteblower.ICMPProtocol_swigregister(ICMPProtocol)
class ICMPv6EchoSession(AbstractObject):
    r"""

    Session for handling ICMPv6 Echo Requests and Replies.

    This Session uses the ICMPv6 protocol for receiving and / or transmitting
    ICMPv6 Echo Request and / or Replies An ICMPv6 session can be created using
    :meth:`.ICMPv6Protocol.SessionAdd`

    Some use cases for this session are:

    DUT validation
        Verify some DUT behavioural items

        - Verify whether Echo Request / Replies are filtered out or not
        - Verify public / private connectivity for Routers, NAT gateways, ...

    DUT stability
        Verify that Echo Replies are received during stability tests


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RemoteAddressSet(self, inIPAddress):
        r"""

        Configure the destination IPv6 address.

        .. versionadded:: 2.3.0

        :param ipv6address: The Destination IPv6 Address for this session.
        :type ipv6address: str

        :raises: python_error: Invalid IPv6 address: When the value could not be
                 interpreted as an IPv6 address

        This method configures the destination IPv6 address for our ICMPv6 Echo packets

        The destination IPv6 address defines to where the ICMPv6 Echo Requests will be
        sent or from where ICMPv6 Echo Responses are / were received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.RemoteAddressSet(2001:0db8:85a3:0042:1000:8a2e:0370:7334)


        """
        return _byteblower.ICMPv6EchoSession_RemoteAddressSet(self, inIPAddress)

    def RemoteAddressGet(self):
        r"""

        Returns the ICMPv6 Echo Request destination IPv6 address.

        :return: The Destination IPv6 address for this session.
        :rtype: str

        :raises: ByteBlower.Session - When the destination IPv6 address was not yet
                 configured

        .. versionadded:: 2.3.0

        This method returns the IPv6 address which has been configured with
        :meth:`RemoteAddressSet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.RemoteAddressGet())


        """
        return _byteblower.ICMPv6EchoSession_RemoteAddressGet(self)

    def DataSizeSet(self, inDataSize):
        r"""

        Configures the data size.

        :param datasize: The ICMPv6 data size you wish to configure.
        :type datasize: int

        :raises TypeError: When the value could not be interpreted as a valid integer
        :raises ConfigError: When the value is out of range

        This method configures the data size of our ICMPv6 Echo Requests

        The data size of our ICMPv6 Echo Requests is the payload size of the packet

        Valid range: 0 to *<port_mdl>* - *<ICMPv6_header_size>*.
        Where

        *<port_mdl>*
            Value of :meth:`ByteBlowerPort.MDLGet`

        *<ICMPv6_header_size>*
            Ethernet header size  (14) + IPv6 header size (40) + ICMPv6 header size (8)

        Default value: 56

        Example

        Configure 92Bytes payload for the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.DataSizeSet(92)


        """
        return _byteblower.ICMPv6EchoSession_DataSizeSet(self, inDataSize)

    def DataSizeGet(self):
        r"""

        Returns the data size of our ICMPv6 Echo Requests.

        :return: ICMPv6 Echo data size
        :rtype: int

        The data size of our ICMPv6 Echo Requests is the payload size of the packet

        Default value: 56

        Example

        The ICMPv6 session has been configure to add 76 Bytes payload in the ICMPv6
        Request packets

        .. code-block:: python
           :emphasize-lines: 1

           pritn(icmpEchoSession.DataSizeGet())


        """
        return _byteblower.ICMPv6EchoSession_DataSizeGet(self)

    def IdentifierGet(self):
        r"""

        Getting the ICMPv6 Echo Request Identifier (Application ID)

        :return: The ICMPv6 Echo Request ICMPv6 Identifier for this Session.
        :rtype: int

        Example

        Returns the (integer) value of the ICMP ID (Application ID)

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.IdentifierGet())


        """
        return _byteblower.ICMPv6EchoSession_IdentifierGet(self)

    def EchoRequestSend(self):
        r"""

        Transmit an ICMPv6 Echo Request.

        :raises: ByteBlower.Session.Unavailable - When the destination IPv6 address was
                 not yet configured

        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv6
                 address cannot be reached

        This method sends one ICMPv6 Echo Request.

        .. note:: This method call is (partially) non-blocking. The call will not
                  return as soon the session is setup and the request is sent or an
                  error occurred (exception is thrown). The call does not wait until an
                  Echo Reply is received.

        .. note:: The Destination IPv6 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests


        """
        return _byteblower.ICMPv6EchoSession_EchoRequestSend(self)

    def EchoStatisticsClear(self):
        r"""

        Resets the ICMPv6 Session statistics.

        .. deprecated:: 2.3.0.
          The recommended approach is to destruct this session and create a new one.

        This method resets the ICMPv6 Session statistics.


        """
        return _byteblower.ICMPv6EchoSession_EchoStatisticsClear(self)

    def EchoLoopIntervalSet(self, inTimeNs):
        r"""

        Configures the Echo Request interval.

        :param loopInterval: The interval between two ICMPv6 Echo Request packets [ns].
        :type loopInterval: int

        :raises TypeError: When the value is not an integer

        This method configures the interval between subsequent Echo Request packets
        when sending in a loop.

        The interval has a nanosecond resolution. You can provide a time unit for the
        loop interval value.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        Valid range: 0 to *<max_uint64>*

            Where *<max_uint64>*    0xFFFFFFFFFFFFFFFF
            = 18446744073709551615
            (= maximum unsigned 64bit integer)

        Default value: 1s

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure an interval of 50 microseconds (50000 nanoseconds)

           icmpEchoSession.EchoLoopIntervalSet(50000)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure an interval of 500 milliseconds

           icmpEchoSession.EchoLoopIntervalSet(500000000)

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure an interval of 1.25 milliseconds

           icmpEchoSession.EchoLoopIntervalSet(1250000)


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopIntervalSet(self, inTimeNs)

    def EchoLoopIntervalGet(self):
        r"""

        Returns the Echo Request interval.

        :return: The interval between two ICMPv6 Echo Request packets [ns]
        :rtype: int

        This method returns the interval between subsequent Echo Request packets when
        sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        .. note:: The interval is always returned in nanoseconds resolution.
                  No unit is added to the value.

        Default value: 1s

        Example

        The transmit loop is configured with an interval of 625 microseconds

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.EchoLoopIntervalGet())


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopIntervalGet(self)

    def EchoLoopCountSet(self, arg2):
        r"""

        Configures the Echo Request count.

        .. versionadded:: 1.8.18

        :param packetcount: The number of ICMPv6 Echo Request packets to transmit
        :type packetcount: int

        This method configures the number of Echo Requests which will be transmitted
        when sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        Default value: infinite
        The actual value is

            *<max_uint64>*
            = 0xFFFFFFFFFFFFFFFF
            = 18446744073709551615
            (= maximum unsigned 64bit integer)

        :raises: python_error bad lexical cast: When the value could not be
                 interpreted as a valid integer

        Example

        Configure the loop to transmit 500 ICMP Echo Request packets

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.EchoLoopCountSet(500)


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopCountSet(self, arg2)

    def EchoLoopCountGet(self):
        r"""

        Returns the Echo Request count.

        :return: The number of ICMPv6 Echo Request packets in a loop
        :rtype: int

        This method returns the number of Echo Requests which will be transmitted when
        sending in a loop.

        Default value: infinite

            The actual value is *<max_uint64>*
            = 0xFFFFFFFFFFFFFFFF
            = 18446744073709551615 (= maximum unsigned 64bit integer)

        .. versionadded:: 1.8.18

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.EchoLoopCountGet())


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopCountGet(self)

    def EchoLoopStart(self):
        r"""

        Starts sending Echo Requests in a loop.

        :raises: Session.Unavailable - When the destination IPv6 address was not yet
                 configured

        :raises: Protocol.Session.CreationFailed - When the destination IPv6 address
                 cannot be reached

        This method start sending Echo Requests in a loop.

        The interval between Echo Request can be configured using the method
        :meth:`EchoLoopIntervalSet`

        If a limited number of Echo Request is desired, this can be configured using
        the method :meth:`EchoLoopCountSet`

        .. note:: This method call is (partially) non-blocking. The call will return as
                  soon as the session is started an the loop is running or an error
                  occurred during session initialization.

        .. note:: The Destination IPv6 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopStart(self)

    def EchoLoopStop(self):
        r"""

        Stops sending Echo Requests in a loop.

        This method stops sending Echo Requests in a loop. The loop can be started with
        :meth:`EchoLoopStart`

        .. note:: This method does not throw an exception if the loop was not started


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopStop(self)

    def HopLimitSet(self, arg2):
        r"""

        Setting the ICMPv6 Echo Request HopLimit.

        :param hopLimit: The ICMPv6 Echo Request ICMPv6 HopLimit for this Session.
                         The maximum legal value is 255.
        :type hopLimit: int

        The Hop Limit field is decremented when the packet is forwarded by a router.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.HopLimitSet(123)


        """
        return _byteblower.ICMPv6EchoSession_HopLimitSet(self, arg2)

    def HopLimitGet(self):
        r"""

        Getting the ICMPv6 Echo Request HopLimit.

        :return: The ICMPv6 Echo Request ICMPv6 HopLimit for this Session.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.HopLimitGet())


        """
        return _byteblower.ICMPv6EchoSession_HopLimitGet(self)

    def TrafficClassSet(self, inTrafficClass):
        r"""

        Configures the 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        :param class: The Traffic class to configure:
        :type class: int

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before
        the parent ByteBlower port is started. Invoking the method at other moments
        will result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.TrafficClassSet(16)


        """
        return _byteblower.ICMPv6EchoSession_TrafficClassSet(self, inTrafficClass)

    def TrafficClassGet(self):
        r"""

        Retrieves the 'Traffic Class' configuration of the IP layer.

        .. versionadded:: 2.5.0

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
        :rtype: int

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        The default value is 0.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.TrafficClassGet())


        """
        return _byteblower.ICMPv6EchoSession_TrafficClassGet(self)

    def SessionInfoGet(self):
        r"""

        Returns the session information.

        .. versionadded:: 2.3.0

        :return: The ICMPv6 Echo session information.
        :rtype: ICMPv6EchoSessionInfo

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.SessionInfoGet().DescriptionGet())


        """
        return _byteblower.ICMPv6EchoSession_SessionInfoGet(self)

# Register ICMPv6EchoSession in _byteblower:
_byteblower.ICMPv6EchoSession_swigregister(ICMPv6EchoSession)
class ICMPv6EchoSessionInfo(AbstractRefreshableResult):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxEchoRequestsGet(self):
        r"""

        Returns the ICMP Echo requests which were transmitted for the session.

        :return: The number of ICMP Echo requests which were sent during the session
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.TxEchoRequestsGet()


        """
        return _byteblower.ICMPv6EchoSessionInfo_TxEchoRequestsGet(self)

    def TxEchoRepliesGet(self):
        r"""

        Returns the ICMP Echo replies which were transmitted for the session.

        :return: The number of ICMP Echo replies which were sent during the session
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.TxEchoRepliesGet())


        """
        return _byteblower.ICMPv6EchoSessionInfo_TxEchoRepliesGet(self)

    def RxEchoRequestsGet(self):
        r"""

        Returns the ICMP Echo requests which were received for the session.

        :return: The number of ICMP Echo requests which were received during the session
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.RxEchoRequestsGet())


        """
        return _byteblower.ICMPv6EchoSessionInfo_RxEchoRequestsGet(self)

    def RxEchoRepliesGet(self):
        r"""

        Returns the ICMP Echo replies which were received for the session.

        :return: The number of ICMP Echo replies which were received during the session
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.RxEchoRepliesGet())


        """
        return _byteblower.ICMPv6EchoSessionInfo_RxEchoRepliesGet(self)

    def RefreshTimestampGet(self):
        r"""

        Gets the timestamp on the server of when the session info was refreshed.

        :return: Returns the timestamp of the refresh
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSession.RefreshTimestampGet())


        """
        return _byteblower.ICMPv6EchoSessionInfo_RefreshTimestampGet(self)

# Register ICMPv6EchoSessionInfo in _byteblower:
_byteblower.ICMPv6EchoSessionInfo_swigregister(ICMPv6EchoSessionInfo)
class ICMPv6Protocol(AbstractObject):
    r"""

    ICMPv6 Protocol.

    Every :class:`IPv6Configuration` has a ICMPv6Protocol attached. With this class
    you can create a :class:`.ICMPv6EchoSession` to send Echo Requests


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SessionAdd(self, *args):
        r"""

        Creates an ICMPv6 Echo Session, through which this host can query the Layer3
        IP network.

        :param id: (optional) Application identifier
        :type id: int

        :return: The created echo session.
        :rtype: ICMPv6EchoSession

        See :class:`.ICMPv6EchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMPv6 session
        (e.g. `ping6`), that session will not be listed in :meth:`SessionGet`. If you
        want such sessions to be listed there, you will need to call :meth:`SessionAdd`
        given the `applicationId` that is used by the
        external tool.

        :param applicationId: Provide an ICMPv6 application id for this session. This
                              should be unique across the host. If none is given, a
                              random value is generated.
                              Default: `Random generate number`

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        Creates an ICMPv6 Echo Session, through which this host can query the Layer3
        IP network.

        :param id: (optional) Application identifier
        :type id: int

        :return: The created echo session.
        :rtype: ICMPv6EchoSession

        See :class:`.ICMPv6EchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMPv6 session
        (e.g. `ping6`), that session will not be listed in :meth:`SessionGet`. If you
        want such sessions to be listed there, you will need to call :meth:`SessionAdd`
        given the `applicationId` that is used by the
        external tool.

        :param applicationId: Provide an ICMPv6 application id for this session. This
                              should be unique across the host. If none is given, a
                              random value is generated.
                              Default: `Random generate number`

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        """
        return _byteblower.ICMPv6Protocol_SessionAdd(self, *args)

    def SessionGet(self):
        r"""

        Returns the active list of ICMPv6 Echo Sessions.

        :return: a list of :class:`ICMPv6EchoSession` objects.
        :rtype: ICMPv6EchoSessionList

        .. note:: The ICMPv6 Protocol may have more active sessions at *server-side*
                  than listed here. This list only returns the
                  :class:`.ICMPv6EchoSession` objects for which a handle has been
                  created at client-side. See below for more information.

        When an external tool connects to the :class:`.ByteBlowerPort` with an ICMPv6
        session (e.g. `ping6`), that session will not be listed here. If you want such
        sessions to be listed here, you will need to call :meth:`SessionAdd` given the
        `applicationId` that is used by the external tool.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           list = icmpProtocol.SessionGet()


        """
        return _byteblower.ICMPv6Protocol_SessionGet(self)

    def SessionDestroy(self, inSession):
        r"""

        Remove an ICMPv6 Echo session

        :param session: ICMPv6 session to remove
        :type session: ICMPv6EchoSession


        """
        return _byteblower.ICMPv6Protocol_SessionDestroy(self, inSession)

# Register ICMPv6Protocol in _byteblower:
_byteblower.ICMPv6Protocol_swigregister(ICMPv6Protocol)
class IGMPIPMulticastListen(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, inIGMPv3MemberSession):
        _byteblower.IGMPIPMulticastListen_swiginit(self, _byteblower.new_IGMPIPMulticastListen(inIGMPv3MemberSession))

    def SourceFilterSet(self, filter):
        return _byteblower.IGMPIPMulticastListen_SourceFilterSet(self, filter)

    def SourceFilterGet(self):
        return _byteblower.IGMPIPMulticastListen_SourceFilterGet(self)

    def MulticastSourcesSet(self, sourceList):
        return _byteblower.IGMPIPMulticastListen_MulticastSourcesSet(self, sourceList)

    def MulticastSourcesGet(self):
        return _byteblower.IGMPIPMulticastListen_MulticastSourcesGet(self)
    __swig_destroy__ = _byteblower.delete_IGMPIPMulticastListen

# Register IGMPIPMulticastListen in _byteblower:
_byteblower.IGMPIPMulticastListen_swigregister(IGMPIPMulticastListen)
class IGMPJoin(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.IGMPJoin_swiginit(self, _byteblower.new_IGMPJoin(*args))
    __swig_destroy__ = _byteblower.delete_IGMPJoin

# Register IGMPJoin in _byteblower:
_byteblower.IGMPJoin_swigregister(IGMPJoin)
class IGMPLeave(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.IGMPLeave_swiginit(self, _byteblower.new_IGMPLeave(*args))
    __swig_destroy__ = _byteblower.delete_IGMPLeave

# Register IGMPLeave in _byteblower:
_byteblower.IGMPLeave_swigregister(IGMPLeave)
class IGMPProtocol(AbstractObject):
    r"""

    The Internet Group Management Protocol (IGMP) Protocol for IPv4 manages
    multicast group membership for a given IPv4 host.

    This class support three IGMP Protocol versions:

    IGMPv1
        :rfc:1112

    IGMPv2
        :rfc:2236. IGMPv2 allows group membership termination to be quickly
        reported to the routing protocol, which is important for high-bandwidth
        multicast groups and/or subnets with highly volatile group membership.

    IGMPv3
        :rfc:3376. Version 3 of IGMP adds support for "source filtering", that
        is, the ability for a system to report interest in receiving packets
        **only** from specific source addresses, or from **all but** specific
        source addresses, sent to a particular multicast address. That information
        may be used by multicast routing protocols to avoid delivering multicast
        packets from specific sources to networks where there are no interested
        receivers.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolInfoGet(self):
        r"""

        Returns the ProtocolInfo object that contains various stats on the IGMPProtocol

        :rtype: IGMPProtocolInfo

        Example

        .. code-block:: python
           :emphasize-lines: 1

           protocolInfo = icmpProtocol.ProtocolInfoGet()


        """
        return _byteblower.IGMPProtocol_ProtocolInfoGet(self)

    def ProtocolInfoDestroy(self, inIGMPProtocolInfo):
        r"""

        Removes the protocol statistics

        :param stats: Statistics object to destory
        :type stats: IGMPProtocolInfo


        """
        return _byteblower.IGMPProtocol_ProtocolInfoDestroy(self, inIGMPProtocolInfo)

    def SessionV1Add(self, inGroupAddress):
        r"""

        Adding a IGMPv1 Session.

        :rtype: IGMPv1MemberSession

        Example

        .. code-block:: python
           :emphasize-lines: 1

           sessionv1 = icmpProtocol.SessionV1Add('235.0.0.1')


        """
        return _byteblower.IGMPProtocol_SessionV1Add(self, inGroupAddress)

    def SessionV2Add(self, inGroupAddress):
        r"""

        Adding a IGMPv2 Session.

        :rtype: IGMPv2MemberSession

        Example

        .. code-block:: python
           :emphasize-lines: 1

           sessionv2 = icmpProtocol.SessionV2Add('235.0.0.1')


        """
        return _byteblower.IGMPProtocol_SessionV2Add(self, inGroupAddress)

    def SessionV3Add(self, inGroupAddress):
        r"""

        Adding a IVMPv3 Session.

        :rtype: IGMPv3MemberSession

        Example

        .. code-block:: python
           :emphasize-lines: 1

           sessionv3 = icmpProtocol.SessionV3Add('235.0.0.1')


        """
        return _byteblower.IGMPProtocol_SessionV3Add(self, inGroupAddress)

    def SessionDestroy(self, *args):
        r"""

        Removes a given session

        :param session: IGMP session to stop
        :type session: IGMPv1MemberSession | IGMPv2MemberSession | IGMPv3MemberSession | IGMPMemberSession


        Removes a given session

        :param session: IGMP session to stop
        :type session: IGMPv1MemberSession | IGMPv2MemberSession | IGMPv3MemberSession | IGMPMemberSession


        Removes a given session

        :param session: IGMP session to stop
        :type session: IGMPv1MemberSession | IGMPv2MemberSession | IGMPv3MemberSession | IGMPMemberSession


        """
        return _byteblower.IGMPProtocol_SessionDestroy(self, *args)

# Register IGMPProtocol in _byteblower:
_byteblower.IGMPProtocol_swigregister(IGMPProtocol)
class IGMPProtocolInfo(AbstractRefreshableResult):
    r"""

    Class: IGMPProtocolInfo


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        r"""

        Gets the number of received IGMP messages

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxGet(self)

    def RxQueriesGet(self):
        r"""

        Gets the number of received IGMP queries

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxQueriesGet(self)

    def RxReportsGet(self):
        r"""

        Gets the number of received IGMP reports

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxReportsGet(self)

    def RxVersion1QueriesGet(self):
        r"""

        Gets the number of received IGMPv1 queries

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxVersion1QueriesGet(self)

    def RxVersion1ReportsGet(self):
        r"""

        Gets the number of received IGMPv1 reports

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxVersion1ReportsGet(self)

    def RxVersion2QueriesGet(self):
        r"""

        Gets the number of received IGMPv2 queries

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxVersion2QueriesGet(self)

    def RxVersion2ReportsGet(self):
        r"""

        Gets the number of received IGMPv2 reports

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxVersion2ReportsGet(self)

    def RxVersion2LeavesGet(self):
        r"""

        Gets the number of received IGMPv2 leaves

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxVersion2LeavesGet(self)

    def RxVersion3QueriesGet(self):
        r"""

        Gets the number of received IGMPv3 queries

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxVersion3QueriesGet(self)

    def RxVersion3ReportsGet(self):
        r"""

        Gets the number of received IGMPv3 reports

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RxVersion3ReportsGet(self)

    def TxGet(self):
        r"""

        Gets the number of transmitted IGMP messages

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_TxGet(self)

    def TxReportsGet(self):
        r"""

        Gets the number of transmitted IGMP reports

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_TxReportsGet(self)

    def TxVersion1ReportsGet(self):
        r"""

        Gets the number of transmitted IGMPv1 reports

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_TxVersion1ReportsGet(self)

    def TxVersion2ReportsGet(self):
        r"""

        Gets the number of transmitted IGMPv2 reports

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_TxVersion2ReportsGet(self)

    def TxVersion2LeavesGet(self):
        r"""

        Gets the number of transmitted IGMPv2 leaves

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_TxVersion2LeavesGet(self)

    def TxVersion3ReportsGet(self):
        r"""

        Gets the number of transmitted IGMPv3 reports

        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_TxVersion3ReportsGet(self)

    def RefreshTimestampGet(self):
        r"""

        Gets the timestamp when these statistics were last updated

        :return: The timestamp in nanoseconds since epoch
        :rtype: int


        """
        return _byteblower.IGMPProtocolInfo_RefreshTimestampGet(self)

# Register IGMPProtocolInfo in _byteblower:
_byteblower.IGMPProtocolInfo_swigregister(IGMPProtocolInfo)
class IGMPMemberSession(SchedulableObject):
    r"""

    Base class for IGMP member sessions


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def MulticastAddressGet(self):
        r"""

        Returns the multicast address for which this member session exists.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           igmpAddress = session.MulticastAddressGet()


        """
        return _byteblower.IGMPMemberSession_MulticastAddressGet(self)

    def VersionGet(self):
        r"""

        Returns the IGMP version this member session serves.

        :rtype: IGMPVersion


        """
        return _byteblower.IGMPMemberSession_VersionGet(self)

    def SessionInfoGet(self):
        r"""

        Returns the IGMP Session statistics for this session.

        :rtype: IGMPMemberSessionInfo

        Example

        .. code-block:: python
           :emphasize-lines: 1

           statistics = session.SessionInfoGet()


        """
        return _byteblower.IGMPMemberSession_SessionInfoGet(self)

    def SessionInfoDestroy(self, inMemberSessionInfo):
        r"""

        Destroys the session statistics.

        :type session: IGMPMemberSessionInfo


        """
        return _byteblower.IGMPMemberSession_SessionInfoDestroy(self, inMemberSessionInfo)

# Register IGMPMemberSession in _byteblower:
_byteblower.IGMPMemberSession_swigregister(IGMPMemberSession)
class IGMPv1MemberSession(IGMPMemberSession):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Join(self):
        r"""

        Joins the session


        """
        return _byteblower.IGMPv1MemberSession_Join(self)

    def Leave(self):
        r"""

        Leaves the session


        """
        return _byteblower.IGMPv1MemberSession_Leave(self)

# Register IGMPv1MemberSession in _byteblower:
_byteblower.IGMPv1MemberSession_swigregister(IGMPv1MemberSession)
class IGMPv2MemberSession(IGMPMemberSession):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Join(self):
        r"""

        Joins the session


        """
        return _byteblower.IGMPv2MemberSession_Join(self)

    def Leave(self):
        r"""

        Leaves the session


        """
        return _byteblower.IGMPv2MemberSession_Leave(self)

# Register IGMPv2MemberSession in _byteblower:
_byteblower.IGMPv2MemberSession_swigregister(IGMPv2MemberSession)
class IGMPv3MemberSession(IGMPMemberSession):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MulticastListen(self, inSourceFilter, inSourceList):
        r"""

        Starts listening for a specific IGMPv3 member session

        :param filter: Whether to include or exclude the given source list
        :type filter: MulticastSourceFilter

        :param list: list of multicast senders to include/exclude
        :type list: StringList


        """
        return _byteblower.IGMPv3MemberSession_MulticastListen(self, inSourceFilter, inSourceList)

    def SourceFilterModeGet(self):
        r"""

        Gets the include/exclude mode

        :rtype: MulticastSourceFilter


        """
        return _byteblower.IGMPv3MemberSession_SourceFilterModeGet(self)

    def SourceListGet(self):
        r"""

        Gets the source list.

        :rtype: StringList


        """
        return _byteblower.IGMPv3MemberSession_SourceListGet(self)

# Register IGMPv3MemberSession in _byteblower:
_byteblower.IGMPv3MemberSession_swigregister(IGMPv3MemberSession)
class IGMPMemberSessionInfo(AbstractRefreshableResult):
    r"""

    InfoObject of the IGMPSession. Contains various stats of the IGMPSession

    Example

    .. code-block:: python
       :emphasize-lines: 1

       sessionv1 = igmpProtocol.SessionV1Add()
       igmpMemberSessionInfo = sessionv1.SessionInfoGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        r"""

        Returns the number of IGMP messages received by this session.

        :return: number of IGMP messages received by this session

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.RxGet())


        """
        return _byteblower.IGMPMemberSessionInfo_RxGet(self)

    def RxQueriesGet(self):
        r"""

        Returns the number of received IGMP queries by this session.

        :return: Number of IGMP v1 queries received

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.RxQueriesGet())


        """
        return _byteblower.IGMPMemberSessionInfo_RxQueriesGet(self)

    def RxVersion1ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v1 reports received

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.RxVersion1ReportsGet())


        """
        return _byteblower.IGMPMemberSessionInfo_RxVersion1ReportsGet(self)

    def RxVersion2ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v2 reports received

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.RxVersion2ReportsGet())


        """
        return _byteblower.IGMPMemberSessionInfo_RxVersion2ReportsGet(self)

    def TxGet(self):
        r"""

        Returns the number of IGMP messages transmitted by this session.

        :return: Number of IGMP messages transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.TxGet())


        """
        return _byteblower.IGMPMemberSessionInfo_TxGet(self)

    def TxVersion1ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V1 reports by this session.

        :return: Number of IGMP v1 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.TxVersion1ReportsGet())


        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion1ReportsGet(self)

    def TxVersion2ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v2 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.TxVersion2ReportsGet())


        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion2ReportsGet(self)

    def TxVersion2LeavesGet(self):
        r"""

        Returns the number of transmitted IGMP V2 leaves by this session.

        :return: Number of IGMP v2 leaves transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.TxVersion2LeavesGet())


        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion2LeavesGet(self)

    def TxVersion3ReportsGet(self):
        r"""

        Returns the number of transmitted IGMP V3 reports by this session.

        :return: Number of IGMP v3 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.TxVersion3ReportsGet())



        Gets the number of transmitted IGMPv3 reports

        :rtype: int


        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion3ReportsGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :return: RefreshTimestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(igmpMemberSessionInfo.RefreshTimestampGet())


        """
        return _byteblower.IGMPMemberSessionInfo_RefreshTimestampGet(self)

# Register IGMPMemberSessionInfo in _byteblower:
_byteblower.IGMPMemberSessionInfo_swigregister(IGMPMemberSessionInfo)
class MLDMulticastListenerSessionInfo(AbstractRefreshableResult):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        r"""

        Returns the number of received MLD messages by this session.

        :return: Number of MLD messages received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxGet(self)

    def RxListenerQueriesGet(self):
        r"""

        Returns the number of received MLD queries by this session.

        :return: Number of MLD v1 queries received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxListenerQueriesGet(self)

    def RxVersion1ListenerReportsGet(self):
        r"""

        Returns the number of received MLD v1 Listener reports by this session.

        :return:  Number of MLD v1 Listener reports received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxVersion1ListenerReportsGet(self)

    def TxGet(self):
        r"""

        Returns the number of transmitted MLD messages by this session.

        :return: Number of MLD messages Transmitted
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxGet(self)

    def TxVersion1ListenerReportsGet(self):
        r"""

        Returns the number of transmitted MLD V1 reports by this session.

        :return: Number of transmitted MLD v1 reports
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion1ListenerReportsGet(self)

    def TxVersion1ListenerDonesGet(self):
        r"""

        Returns the number of received MLD V1 Listeners done by this session.

        :return:  Number of transmitted MLD v1 Listener dones
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion1ListenerDonesGet(self)

    def TxVersion2ListenerReportsGet(self):
        r"""

        Returns the number of received MLD queries by this session.

        :return: Number of transmitted MLD v2 Listener reports
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion2ListenerReportsGet(self)

    def RefreshTimestampGet(self):
        r"""

        Retuns the timestamp when the info was last refreshed.

        :return: RefreshTimestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RefreshTimestampGet(self)

# Register MLDMulticastListenerSessionInfo in _byteblower:
_byteblower.MLDMulticastListenerSessionInfo_swigregister(MLDMulticastListenerSessionInfo)
class MLDMulticastListenerSession(SchedulableObject):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def MulticastAddressGet(self):
        r"""

        Returns the Multicast IPv6 address for which this session exists.

        :rtype: str


        """
        return _byteblower.MLDMulticastListenerSession_MulticastAddressGet(self)

    def VersionGet(self):
        r"""


        :rtype: MLDVersion


        """
        return _byteblower.MLDMulticastListenerSession_VersionGet(self)

    def SessionInfoGet(self):
        r"""


        :rtype: MLDMulticastListenerSessionInfo


        """
        return _byteblower.MLDMulticastListenerSession_SessionInfoGet(self)

    def SessionInfoDestroy(self, inMulticastListenerSessionInfo):
        r"""

        Cleanup the session info.

        :param session: Session to remove.
        :type session: MLDMulticastListenerSessionInfo


        """
        return _byteblower.MLDMulticastListenerSession_SessionInfoDestroy(self, inMulticastListenerSessionInfo)

# Register MLDMulticastListenerSession in _byteblower:
_byteblower.MLDMulticastListenerSession_swigregister(MLDMulticastListenerSession)
class MLDProtocol(AbstractObject):
    r"""

    The Multicast Listener Discovery Protocol (MLD) Protocol for IPv6 manages
    multicast address listening for a given IPv6 host.

    This class support two MLD Protocol versions:

    MLDv1
        RFC 2710

    MLDv2
        RFC 3810. 

        Version 2 of MLD adds support for 'source filtering', that is, the ability 
        for a system to report interest in receiving packets *only* from specific 
        source addresses, or from *all but* specific source addresses, sent to a 
        particular multicast address. That information may be used by multicast 
        routing protocols to avoid delivering multicast packets from specific 
        sources to networks where there are no interested receivers.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolInfoGet(self):
        r"""

        Gets the MLD protocol statistics

        :rtype: MLDProtocolInfo


        """
        return _byteblower.MLDProtocol_ProtocolInfoGet(self)

    def ProtocolInfoDestroy(self, inMLDProtocolInfo):
        r"""

        Removes/Destroys the MLD protocol statistics

        :param info: ProtocolInfo object to destroy
        :type info: MLDProtocolInfo

        This will invalidate the MLDProtocolInfo object given.  
        One should not try to access the destroyed object.


        """
        return _byteblower.MLDProtocol_ProtocolInfoDestroy(self, inMLDProtocolInfo)

    def SessionV1Add(self, inMulticastAddress):
        r"""

        Create a MLDv1 session.

        :rtype: MLDv1MulticastListenerSession

        Example


        """
        return _byteblower.MLDProtocol_SessionV1Add(self, inMulticastAddress)

    def SessionV2Add(self, inMulticastAddress):
        r"""

        Create a MLDv2 session.

        :rtype: MLDv2MulticastListenerSession

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDProtocol_SessionV2Add(self, inMulticastAddress)

    def SessionDestroy(self, *args):
        r"""

        Returns the active list of MLD sessions.

        :param session: Session to destroy
        :type session: MLDv1MulticastListenerSession | MLDv2MulticastListenerSession

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        Returns the active list of MLD sessions.

        :param session: Session to destroy
        :type session: MLDv1MulticastListenerSession | MLDv2MulticastListenerSession

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDProtocol_SessionDestroy(self, *args)

# Register MLDProtocol in _byteblower:
_byteblower.MLDProtocol_swigregister(MLDProtocol)
class MLDProtocolInfo(AbstractRefreshableResult):
    r"""

    This object contains MLD statistics


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        r"""

        The number of MLD messages received

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_RxGet(self)

    def RxListenerQueriesGet(self):
        r"""

        The number of MLD Listener Queries received

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_RxListenerQueriesGet(self)

    def RxListenerReportsGet(self):
        r"""

        The number of MLD Listener Reports received

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_RxListenerReportsGet(self)

    def RxVersion1ListenerQueriesGet(self):
        r"""

        The number of MLDv1 Listener Query messages received

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerQueriesGet(self)

    def RxVersion1ListenerReportsGet(self):
        r"""

        The number of MLDv1 Listener Report messages received

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerReportsGet(self)

    def RxVersion1ListenerDonesGet(self):
        r"""

        The number of MLDv1 Listener Done messages received

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerDonesGet(self)

    def RxVersion2ListenerQueriesGet(self):
        r"""

        The number of MLDv2 Listener Query messages received

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_RxVersion2ListenerQueriesGet(self)

    def RxVersion2ListenerReportsGet(self):
        r"""

        The number of MLDv2 Listener Report messages received

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_RxVersion2ListenerReportsGet(self)

    def TxGet(self):
        return _byteblower.MLDProtocolInfo_TxGet(self)

    def TxListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_TxListenerReportsGet(self)

    def TxVersion1ListenerReportsGet(self):
        r"""

        The number of MLDv1 Listener Report messages transmitted

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_TxVersion1ListenerReportsGet(self)

    def TxVersion1ListenerDonesGet(self):
        r"""

        The number of MLDv1 Listener Done messages transmitted

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_TxVersion1ListenerDonesGet(self)

    def TxVersion2ListenerReportsGet(self):
        r"""

        The number of MLDv2 Listener Report messages transmitted

        :rtype: int


        """
        return _byteblower.MLDProtocolInfo_TxVersion2ListenerReportsGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the statistics were refreshed.

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        This is the timestamp on the server when the last time 
        :obj:`~.AbstractObject.Refresh` was called on this object.


        """
        return _byteblower.MLDProtocolInfo_RefreshTimestampGet(self)

# Register MLDProtocolInfo in _byteblower:
_byteblower.MLDProtocolInfo_swigregister(MLDProtocolInfo)
class MLDv1MulticastListenerSession(MLDMulticastListenerSession):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ListeningStart(self):
        r"""

        Starts listening for this Multicast session


        """
        return _byteblower.MLDv1MulticastListenerSession_ListeningStart(self)

    def ListeningStop(self):
        r"""

        Stops listening for this Multicast session


        """
        return _byteblower.MLDv1MulticastListenerSession_ListeningStop(self)

# Register MLDv1MulticastListenerSession in _byteblower:
_byteblower.MLDv1MulticastListenerSession_swigregister(MLDv1MulticastListenerSession)
class MLDv1StartListening(object):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _byteblower.MLDv1StartListening_swiginit(self, _byteblower.new_MLDv1StartListening(arg2))
    __swig_destroy__ = _byteblower.delete_MLDv1StartListening

# Register MLDv1StartListening in _byteblower:
_byteblower.MLDv1StartListening_swigregister(MLDv1StartListening)
class MLDv1StopListening(object):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _byteblower.MLDv1StopListening_swiginit(self, _byteblower.new_MLDv1StopListening(arg2))
    __swig_destroy__ = _byteblower.delete_MLDv1StopListening

# Register MLDv1StopListening in _byteblower:
_byteblower.MLDv1StopListening_swigregister(MLDv1StopListening)
class MLDv2MulticastListenerSession(MLDMulticastListenerSession):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MulticastListen(self, inSourceFilter, inSourceList):
        r"""


        :param sourceFilter: Will the source list be included or excluded?
        :type sourceFilter: MulticastSourceFilter

        :param sourceList: List of addresses to include or exclude
        :type sourceList: StringList


        """
        return _byteblower.MLDv2MulticastListenerSession_MulticastListen(self, inSourceFilter, inSourceList)

    def SourceFilterModeGet(self):
        r"""


        :rtype: MulticastSourceFilter


        """
        return _byteblower.MLDv2MulticastListenerSession_SourceFilterModeGet(self)

    def SourceListGet(self):
        r"""


        :rtype: StringList


        """
        return _byteblower.MLDv2MulticastListenerSession_SourceListGet(self)

# Register MLDv2MulticastListenerSession in _byteblower:
_byteblower.MLDv2MulticastListenerSession_swigregister(MLDv2MulticastListenerSession)
class MLDv2IPMulticastListen(object):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _byteblower.MLDv2IPMulticastListen_swiginit(self, _byteblower.new_MLDv2IPMulticastListen(arg2))

    def SourceFilterSet(self, filter):
        r"""



        """
        return _byteblower.MLDv2IPMulticastListen_SourceFilterSet(self, filter)

    def SourceFilterGet(self):
        r"""



        """
        return _byteblower.MLDv2IPMulticastListen_SourceFilterGet(self)

    def MulticastSourcesSet(self, sourceList):
        r"""



        """
        return _byteblower.MLDv2IPMulticastListen_MulticastSourcesSet(self, sourceList)

    def MulticastSourcesGet(self):
        r"""



        """
        return _byteblower.MLDv2IPMulticastListen_MulticastSourcesGet(self)
    __swig_destroy__ = _byteblower.delete_MLDv2IPMulticastListen

# Register MLDv2IPMulticastListen in _byteblower:
_byteblower.MLDv2IPMulticastListen_swigregister(MLDv2IPMulticastListen)
class TelnetClient(AbstractObject):
    r"""

    A Telnet client application that allows communication with an external Telnet
    server.

    .. versionadded:: 2.2.0

    The Telnet protocol allows for bidirectional interactive communication between
    a Telnet client (i.e. this application) on a ByteBlower port and an external
    Telnet server.

    The Telnet protocol can be used to log in on other machines using a virtual
    terminal. By sending Telnet commands using :meth:`Send`, waiting for a small
    amount of time and reading the response using :meth:`Receive`, a complete
    interactive session may be constructed.

    The protocol can also be used to debug other network protocols. For example,
    contacting an HTTP server (on port 80) using a Telnet client and sending a
    valid HTTP request towards it, should correctly return the HTTP response data.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.TelnetClient_PortGet(self)

    def RemoteAddressSet(self, inAddress):
        r"""

        Sets the IP address of the Telnet server to which this client connects.

        :param address: The IP address of the Telnet server to which this client
                        connects. This should be either an valid IPv4 address or a
                        valid IPv6 address.
        :type address: str

        :raises ConfigError: If an invalid IP address is entered, this error is thrown.

        :raises ConfigError: If an IPv4 address is provided, while this client is on an 
                             IPv6 ByteBlower port or vice versa, this exception is 
                             thrown.

        :raises InProgressError: If a Telnet session is currently opened, this 
                                 exception is thrown. Use :meth:`Close` to close the
                                 session before changing the Telnet server address.

        Before this address is set, no connection can be opened or traffic can be sent.

        Both IPv4 and IPv6 addresses are supported, but the provided (remote) address
        must match be of the same type as the ByteBlower port of this client.

        .. note:: Currently, DNS is not supported, so providing a URL is not possible.

        Example

        This snippet sets the IP address of the Telnet server to be contacted.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemoteAddressSet(self, inAddress)

    def RemoteAddressGet(self):
        r"""

        Returns the IP address of the Telnet server to which this client connects.

        :return: The IP address of the Telnet server to which this client connects.
                 This should be either an valid IPv4 address or a valid IPv6 address.
        :rtype: str

        :raises: ByteBlower.Protocol.InvalidValue - If the remote IP address is not
                 configured yet

        Before this address is set, no connection can be opened or traffic can be sent.

        Both IPv4 and IPv6 addresses are supported, but the provided (remote) address
        must match use the same IP protocol as the ByteBlower port of this client.

        .. note:: Currently, DNS is not supported, so providing a URL is not possible.

        Example

        This example returns the IP address of the Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemoteAddressGet(self)

    def RemotePortSet(self, inRemotePort):
        r"""

        Configures (remote) TCP port on the Telnet server to which this client
        connects.

        :param port: The TCP port on the Telnet server to which this client connects.
                     This should be an integer value. Values larger the maximum port
                     value of 65536 overflow into a valid port number.
                     The default value is 23
        :type port: int

        :raises: InvalidValue.Integer - If the parameter value isn't an integer

        :raises: ByteBlower.Protocol.ConfigLocked - If a Telnet session is currently
                 opened, this exception is thrown. Use :meth:`Close` to close the
                 session before changing the Telnet server port.

        The client will communicate with the Telnet server on the configured port.

        If the TCP port isn't explicitly set (yet), the server will take the default
        Telnet server port (23).

        Example

        This snippet sets the port number of the Telnet server to be contacted.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemotePortSet(self, inRemotePort)

    def RemotePortGet(self):
        r"""

        Returns the (remote) TCP port on the Telnet server to which this client
        connects

        :return: The currently configured TCP port on the Telnet server to which this
                 client connects. 
                 The default value is 23
        :rtype: int

        The client will communicate with the Telnet server on the configured port.

        If the TCP port isn't explicitly set (yet), this will return the default Telnet
        server port (23).

        Example

        This example returns the port number of the Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemotePortGet(self)

    def LocalPortSet(self, inLocalPort):
        r"""

        Configures the (local) TCP port used by this client.

        :param port: The TCP port to be used by this client. This should be an integer
                     value. Values larger the maximum port value of 65536 overflow into
                     a valid port number.
        :type port: int

        :raises: InvalidValue.Integer - If the parameter value isn't an integer

        :raises: ByteBlower.Protocol.ConfigLocked - If a Telnet session is currently
                 opened, this exception is thrown. Use ::Close to close the session
                 before changing the Telnet server port.

        The client will communicate with the server through a TCP network socket on
        this port and listen on it for incoming traffic.

        If the TCP port isn't explicitly set (yet), the server will use a valid and
        unique TCP port number for within the scope of the ByteBlower port
        (e.g. 32687).

        Default value Valid and unique client TCP port

        Example

        This snippet sets the port number on which this client will connect to the
        Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_LocalPortSet(self, inLocalPort)

    def LocalPortGet(self):
        r"""

        Returns the (local) TCP port used by this client.

        :return: The currently configured TCP port on this client.
        :rtype: int

        The client will communicate with the server through a TCP network socket on
        this port and listen on it for incoming traffic.

        If the TCP port isn't explicitly set (yet), this will return a valid and unique
        TCP port number for within the scope of the ByteBlower port (e.g. 32687).

        Default value Valid unique client TCP port

        Example

        This example returns the port number on which this client connects to the
        Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_LocalPortGet(self)

    def Open(self):
        r"""

        Starts the Telnet client and opens the session with the Telnet server.

        It will create a new TCP connection. The TCP statistics will be reset. If a
        Telnet session is already open, nothing is done.

        After calling this method, data may be sent to the server :meth:`Send` will be
        queued for transmission after this handshake.

        .. warning::  When contacting a non-existing or unreachable Telnet server, 
                      this application has unexpected behavior. The :meth:`Open` method
                      returns immediately and TCP moves to the 'active' status. After 
                      the timeout expires, TCP moves to the 'finished' status instead 
                      of the 'timeOut' status. All the while, data may be sent using 
                      :meth:`Send`. This data is queued during the handshake, but it 
                      will not be sent.

        :raises: ByteBlower.Protocol.Unavailable - If the Telnet server address has not
                 been configured, this exception is thrown. Use :meth:`RemoteAddressSet`
                 to configure the Telnet server address.

        Example

        This command opens the Telnet session, which initiates the handshake of the
        underlying TCP session. It returns immediately.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Open(self)

    def Send(self, inData):
        r"""

        Sends the provided to the Telnet server over the network.

        :param data: This string will be sent to the server for processing.
        :type data: str

        :raises: ByteBlower.Protocol.InvalidAction - When no session is active, this
                 exception is thrown. Use :meth:`Open` to open the session.

        Data may be sent as soon as a connection is opened. Data sent during the TCP
        handshake will be queued to be sent immediately after it.

        .. warning:: When contacting a non-existing or unreachable Telnet server, this 
                     method will not provide an error. When the TCP handshake fails 
                     (probably due to timeout), TCP will move (incorrectly) to finished
                     after a while. None of the traffic sent at layer 5 will be 
                     received by the Telnet server.

        Example

        This command sends the provided data over the network towards the Telnet
        server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Send(self, inData)

    def Receive(self):
        r"""

        Reads data received over the Telnet session from the network and returns it.

        :return: The data received from the Telnet server.
        :rtype: str

        :raises: ByteBlower.Protocol.InvalidAction - When no session is active.
                 Use :meth:`Open` to open the session.

        If this method is executed, all received data since the last time it was
        called is returned. If more data is still flowing in from the network, the rest
        of the data will be returned the next time the receive method is executed.

        .. warning::  When contacting a non-existing or unreachable Telnet server, this
                      method will not provide an error. When the TCP handshake fails 
                      (probably due to timeout), TCP will move (incorrectly) to 
                      finished after a while. None of the traffic sent at layer 5 will
                      be received by the Telnet server.

        Example

        This example shows the response received from the Telnet server after sending
        the 'uname -a' command.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Receive(self)

    def Close(self):
        r"""

        Closes the Telnet session with the server and stops the Telnet client.

        The TCP session will be closed and reset, so a new session can be opened.

        If no Telnet session is open, nothing is done.

        Example

        This command closes the Telnet session if one is active.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Close(self)

    def ConnectionStateGet(self):
        r"""

        Returns the current TCP connection state.

        :rtype: TCPConnectionState

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_ConnectionStateGet(self)

# Register TelnetClient in _byteblower:
_byteblower.TelnetClient_swigregister(TelnetClient)
class PhysicalInterface(AbstractObject):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IdGet(self):
        r"""

        Returns the ID for this Physical Interface

        :rtype: int


        """
        return _byteblower.PhysicalInterface_IdGet(self)

    def NameGet(self):
        return _byteblower.PhysicalInterface_NameGet(self)

    def TypeGet(self):
        r"""

        Returns the name for this Physical Interface

        :rtype: PhysicalInterfaceType


        """
        return _byteblower.PhysicalInterface_TypeGet(self)

    def MacAddressGet(self):
        r"""

        Returns the MAC Address of this Physical Interface

        :rtype: str


        """
        return _byteblower.PhysicalInterface_MacAddressGet(self)

    def ByteBlowerInterfaceGet(self):
        r"""

        Returns ByteBlower Interfaces on this Physical Interface

        :rtype: ByteBlowerInterfaceList


        """
        return _byteblower.PhysicalInterface_ByteBlowerInterfaceGet(self)

    def ByteBlowerInterfaceCountGet(self):
        r"""

        Returns the number of ByteBlower Interfaces on this Physical Interface

        :rtype: int


        """
        return _byteblower.PhysicalInterface_ByteBlowerInterfaceCountGet(self)

    def LinkStatusGet(self):
        r"""

        Returns the physical link status of this Physical Interface

        :rtype: LinkStatus


        """
        return _byteblower.PhysicalInterface_LinkStatusGet(self)

    def LinkTypeGet(self):
        r"""

        Returns the physical link type of this Physical Interface

        :rtype: LinkType


        """
        return _byteblower.PhysicalInterface_LinkTypeGet(self)

    def VendorNameGet(self):
        r"""

        Returns the VendorName of the NIC on the server

        :rtype: str


        """
        return _byteblower.PhysicalInterface_VendorNameGet(self)

    def ProductNameGet(self):
        r"""

        Returns the ProductName of the NIC on the server

        :rtype: str


        """
        return _byteblower.PhysicalInterface_ProductNameGet(self)

# Register PhysicalInterface in _byteblower:
_byteblower.PhysicalInterface_swigregister(PhysicalInterface)
class Layer2Configuration(AbstractObject):
    r"""

    Base class for the allowed Layer2 configuration objects


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register Layer2Configuration in _byteblower:
_byteblower.Layer2Configuration_swigregister(Layer2Configuration)
EthernetEncoding_SNAP = _byteblower.EthernetEncoding_SNAP
EthernetEncoding_DIX = _byteblower.EthernetEncoding_DIX

def ConvertEthernetEncodingToString(inEthernetEncoding):
    return _byteblower.ConvertEthernetEncodingToString(inEthernetEncoding)

def ParseEthernetEncoding(inEthernetEncoding):
    return _byteblower.ParseEthernetEncoding(inEthernetEncoding)
class EthernetConfiguration(Layer2Configuration):
    r"""

    EthernetII provides an interface for the Ethernet configuration on a ByteBlower port.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TypeGet(self):
        r"""

        Returns the layer 2 encoding scheme.

        :return: The layer 2 encoding scheme.
        :rtype: EthernetEncoding

        Example

        This example returns the layer 2 encoding scheme.

        .. code-block:: python
           :emphasize-lines: 1

           print(ethernetConf.TypeGet())


        """
        return _byteblower.EthernetConfiguration_TypeGet(self)

    def TypeSet(self, inEthernetEncoding):
        r"""

        Sets the layer 2 encoding scheme.

        :param encoding: Currently supported encodings are SNAP and DIX.
        :type encoding: EthernetEncoding

        Example

        This example sets the layer 2 encoding scheme.

        .. code-block:: python
           :emphasize-lines: 1

           print(ethernetConf.TypeSet())


        """
        return _byteblower.EthernetConfiguration_TypeSet(self, inEthernetEncoding)

    def MacSet(self, inMacAddress):
        return _byteblower.EthernetConfiguration_MacSet(self, inMacAddress)

    def MacGet(self):
        return _byteblower.EthernetConfiguration_MacGet(self)

    @staticmethod
    def IsValidMacAddress(inMacAddress):
        return _byteblower.EthernetConfiguration_IsValidMacAddress(inMacAddress)

# Register EthernetConfiguration in _byteblower:
_byteblower.EthernetConfiguration_swigregister(EthernetConfiguration)
class VLANTag(Layer25Configuration):
    r"""

    Configure the VLAN tag on a ByteBlower Port.

    IEEE 802.1Q is the networking standard that supports Virtual LANs (VLANs) on an
    Ethernet network. The standard defines a system of VLAN tagging for Ethernet
    frames and the accompanying procedures to be used by bridges and switches in
    handling such frames

    802.1Q does not actually encapsulate the original frame. Instead, for Ethernet
    frames, it adds a 32-bit field between the source MAC address and the
    EtherType/Length fields of the original frame

    TPID
        Tag Protocol Identifier - 16bits

    TCI
        Tag Control Information - 16bits

    In the latter case the TCI consists of:

    PCP
        Priority Code Point - 3bits

    DEI
        Drop Eligible Indicator - 1bit

    VID
        VLAN Identifier - 12bits


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolIDGet(self):
        r"""

        Get the VLAN Protocol ID (TPID)

        A 16-bit field specifying the VLAN Protocol ID used in the frames.

        IEEE 802.1AD specifies the VLAN C-TAG (customer tag) and S-TAG (service-provider
        tag). The C-TAG (0x8100) is used on the innermost VLAN tag, while the S-TAG
        (0x88a8) is used on all other VLAN tags.

        I.e. When a single VLAN is used on the *ByteBlowerPort*, the TPID will be
        0x8100. When VLAN stacking is used, the innermost VLAN tag (closest to the
        Ethernet payload) will use the C-TAG (0x8100) while all other VLAN tags use the
        S-TAG (0x88a8).

        :return: Returns the used Protocol ID (`TPID`) for this VLAN tag.
        :rtype: int

        Example

        Getting the vlan TPID of a ByteBlower port tagged with a single VLAN
        (0x8100 == 33024)

        .. code-block:: python
           :emphasize-lines: 1

           print(vlanTag.ProtocolIDGet())


        """
        return _byteblower.VLANTag_ProtocolIDGet(self)

    def ProtocolIDSet(self, value):
        return _byteblower.VLANTag_ProtocolIDSet(self, value)

    def IDSet(self, inId):
        r"""

        Configure the VLAN ID.

        A 12-bit field specifying the VLAN to which the frame belongs. The hexadecimal
        values of 0x000 and 0xFFF are reserved. All other values may be used as VLAN
        identifiers, allowing up to 4094 VLANs

        :param id: Your VLAN ID
        :type id: int

        Example
        Creating a VLAN tag on the your ByteBlower port

        .. code-block:: python
           :emphasize-lines: 1

           vlanTag.IDSet(2)


        """
        return _byteblower.VLANTag_IDSet(self, inId)

    def IDGet(self):
        r"""

        Get the VLANID.

        A 12-bit field specifying the VLAN to which the frame belongs. The hexadecimal
        values of 0x000 and 0xFFF are reserved. All other values may be used as VLAN
        identifiers, allowing up to 40094 VLANs.

        Default value: 0

        :return: the configured VLAN ID installed on this ByteBlower port.
        :rtype: int

        Example

        Getting the vlanID of a ByteBlower port tagged with VLAN Id 107

        .. code-block:: python
           :emphasize-lines: 1

           print(vlanTag.IDGet())
           #returns 107


        """
        return _byteblower.VLANTag_IDGet(self)

    def PrioritySet(self, inPriority):
        r"""

        Set the VLAN Priority.

        A 3-bit field which refers to the IEEE 802.1p priority. It indicates the frame
        priority level. Values are from 0 (best effort) to 7 (highest); 1 represents
        the lowest priority. These values can be used to prioritize different classes
        of traffic (voice, video, data, etc.).

        :param priority: The priority you want to configure: a number between 0 and 7.
        :type priority: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           vlanTag.PrioritySet(0)


        """
        return _byteblower.VLANTag_PrioritySet(self, inPriority)

    def PriorityGet(self):
        r"""

        Get the VLAN Priority.

        A 3-bit field which refers to the IEEE 802.1p priority. It indicates the frame
        priority level. Values are from 0 (best effort) to 7 (highest); 1 represents
        the lowest priority. These values can be used to prioritize different classes of
        traffic (voice, video, data, etc.).

        Default value: 0

        :return: Returns the configured priority of the VLAN protocol
        :rtype: int

        Example

        Getting the vlanID of a ByteBlower port tagged with VLAN Id 107

        .. code-block:: python
           :emphasize-lines: 1

           print(vlanTag.PriorityGet())


        """
        return _byteblower.VLANTag_PriorityGet(self)

    def DropEligibleSet(self, value):
        r"""

        Enable/Disable the Drop Eligible Indicator.

        A 1-bit field. (formerly CFI) May be used separately or in conjunction with
        PCP to indicate frames eligible to be dropped in the presence of congestion.

        :param enable: True will enable the Drop Eligible Indicator
                       False will disable the Drop Eligible Indicator.
        :type enable: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           vlanTag.DropEligibleSet(True)


        """
        return _byteblower.VLANTag_DropEligibleSet(self, value)

    def DropEligibleGet(self):
        r"""

        Returns the status of the Drop Eligible Indicator.

        A 1-bit field. (formerly CFI) May be used separately or in conjunction with PCP
        to indicate frames eligible to be dropped in the presence of congestion.

        Default value: Disabled

        :return: True if Drop Eligible Indicator is enabled, False if disabled.
        :rtype: bool


        """
        return _byteblower.VLANTag_DropEligibleGet(self)

# Register VLANTag in _byteblower:
_byteblower.VLANTag_swigregister(VLANTag)
class PPPAuthProtocol(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_PPPAuthProtocol

# Register PPPAuthProtocol in _byteblower:
_byteblower.PPPAuthProtocol_swigregister(PPPAuthProtocol)
class PAPProtocol(PPPAuthProtocol):
    r"""

    Represents the Password Authentication Protocol  

    PPP defines an extensible Link Control Protocol, which allows negotiation of an
    Authentication Protocol for authenticating its peer before allowing Network 
    Layer protocols to transmit over the link.  

    This class provides the Password Authentication protocol as described per 
    :rfc:`1334`, section 2  

    The Password Authentication Protocol (PAP) provides a simple method for the
    peer to establish its identity using a 2-way handshake. This is done only upon
    initial link establishment.  

    After the Link Establishment phase is complete, an Id/Password pair is 
    repeatedly sent by the peer to the authenticator until authentication is
    acknowledged or the connection is terminated.  

    PAP is not a strong authentication method. Passwords are sent over the circuit 
    " *in the clear* ", and there is no protection from playback or repeated 
    trial and error attacks. The peer is in control of the frequency and timing of
    the attempts.  

    By default, authentication is not mandatory. If authentication of the link is 
    desired, an implementation MUST specify the Authentication-Protocol 
    Configuration Option during Link Establishment phase.  

    .. versionadded:: 2.5.0  

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPPPProtocol(self, *args):
        return _byteblower.PAPProtocol_GetPPPProtocol(self, *args)

    def PeerIDGet(self):
        r"""

        Returns the configured Peer-ID.  

        :return:  peerID  

        Example

        .. todo:: Real Example


        """
        return _byteblower.PAPProtocol_PeerIDGet(self)

    def PeerIDSet(self, inUserId):
        r"""

        Configures the Peer-ID on the Password authentication Protocol ( PAP )  

        :param peerID: The new Peer-ID  

        .. todo:: Real Example


        """
        return _byteblower.PAPProtocol_PeerIDSet(self, inUserId)

    def PasswordGet(self):
        r"""

        Returns the configured password.  

        :return: password  
        :rtype: str

        .. todo:: Real Example


        """
        return _byteblower.PAPProtocol_PasswordGet(self)

    def PasswordSet(self, inPassword):
        r"""

        Configures the password on the Password authentication Protocol ( PAP )

        The password will be transmitted *plaintext* over the wire.  

        :param password: The password for the given Peer-ID  
        :type password: str

        .. todo:: Real Example


        """
        return _byteblower.PAPProtocol_PasswordSet(self, inPassword)

# Register PAPProtocol in _byteblower:
_byteblower.PAPProtocol_swigregister(PAPProtocol)
class CHAPProtocol(PPPAuthProtocol):
    r"""

    Represents the Challenge-Handshake Authentication Protocol  

    PPP defines an extensible Link Control Protocol, which allows negotiation of 
    an Authentication Protocol for authenticating its peer before allowing Network
    Layer protocols to transmit over the link.  

    This class provides the Password Authentication protocol as described per 
    :rfc:1334, section 3  

    The Challenge-Handshake Authentication Protocol (CHAP) is used to periodically
    verify the identity of the peer using a 3-way handshake. This is done upon 
    initial link establishment, and MAY be repeated anytime after the link has been
    established.  

    After the Link Establishment phase is complete, the authenticator sends a 
    "challenge" message to the peer. The peer responds with a value calculated
    using a "one-way hash" function. The authenticator checks the response 
    against its own calculation of the expected hash value. If the values match, 
    the authentication is acknowledged, otherwise the connection SHOULD be 
    terminated.  

    CHAP provides protection against playback attack through the use of an 
    incrementally changing identifier and a variable challenge value. The use of 
    repeated challenges is intended to limit the time of exposure to any single 
    attack. The authenticator is in control of the frequency and timing of the 
    challenges.  

    This authentication method depends upon a "*secret*" known only to the 
    authenticator and that peer. The secret is not sent over the link. This method
    is most likely used where the same secret is easily accessed from both ends of 
    the link.  

    By default, authentication is not mandatory. If authentication of the link is 
    desired, an implementation MUST specify the Authentication-Protocol 
    Configuration Option during Link Establishment phase.  

    .. versionadded:: 2.5.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPPPProtocol(self, *args):
        return _byteblower.CHAPProtocol_GetPPPProtocol(self, *args)

    def SecretSet(self, secret):
        r"""

        Configures the Secret on the Challenge Handshake Authentication Protocol (CHAP)

        :param secret: The secret for authenticating to the PPP server.  

        .. todo:: Real Example


        """
        return _byteblower.CHAPProtocol_SecretSet(self, secret)

    def SecretGet(self):
        r"""

        Returns the configured Secret.  

        :return: Secret value  

        .. todo:: Real Example


        """
        return _byteblower.CHAPProtocol_SecretGet(self)

# Register CHAPProtocol in _byteblower:
_byteblower.CHAPProtocol_swigregister(CHAPProtocol)
class PPPNetworkControlProtocol(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_PPPNetworkControlProtocol

# Register PPPNetworkControlProtocol in _byteblower:
_byteblower.PPPNetworkControlProtocol_swigregister(PPPNetworkControlProtocol)
class IPv4CPProtocol(PPPNetworkControlProtocol):
    r"""

    Internet Protocol Control Protocol.  

    Internet Protocol Control Protocol (IPCP) is a network control protocol for 
    establishing and configuring Internet Protocol over a Point-to-Point Protocol
    link. IPCP is responsible for configuring, enabling, and disabling the IP 
    protocol modules on both ends of the point-to-point link. IPCP uses the same
    packet exchange mechanism as the Link Control Protocol.

    The implementation is conform :rfc:1332  

    .. note:: The RFC deprecated the `IP-Addresses` configuration option. 
              ByteBlower does not provide the (optional) backward compatibility for
              this option.  
    .. note:: IP compression is not supported.  

    .. versionadded:: 2.5.0  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IpAddressGet(self):
        r"""

        Returns local the IPv4 address.  

        This method returns the IP address to be used at the local end of the link. 
        Before the IPCP protocol negotiated the IP address, this method will return the
        value configured with :meth:`IpAddressSet`. After IP address negotiation with
        the remote peer, the method will return the IP address negotiated with the 
        remote peer.  

        The latter will be either:

        - the same as the value configured with :meth:`IpAddressSet`

          - if the remote peer accepted that address.

        - the address imposed by the remote peer:
          - if we requested that the peer provides the address

          - when the remote peer did not accept the requested IP address.

        :return: The IP address to be used by the local peer.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressGet(self)

    def IpAddressSet(self, inIPAddress):
        r"""

        Configures the IPv4 address to be used at the local end of the link.  

        During IP address negotiation, the given address will be proposed to the remote
        end of the link.  

        :param ipAddress: The IPv4 address to be used during negotiation at the local 
                          peer.  

        .. note:: The IPv4 address '0.0.0.0' has a special meaning: 
                  This will request the remote peer to provide an IP address. 
                  See also :meth:`IpAddressPeerProvided` for a convenience method.  

        :raises: BadIPv4Address - When an incorrect IPv4 address string was provided.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressSet(self, inIPAddress)

    def IpAddressRemoteGet(self):
        r"""

        Returns the IP address of the remote peer.  

        This method will return the IP address which has been requested by the remote
        peer during (the last) address negotiation.  

        :return: IP address of the remote peer of the last address negotiation. 
                 '0.0.0.0' if no negotiation took place yet.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressRemoteGet(self)

    def IpAddressPeerProvided(self):
        r"""

        Request the peer to provide an IP address.  

        During IP address negotiation, we will request to peer to provide an IP 
        address.

        .. note:: This method call will have the same effect as calling 
                 :meth:`IpAddressSet` with *<ipAddress>* set to '0.0.0.0'.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressPeerProvided(self)

    def Open(self):
        r"""

        Perform an administrative open on the IPCP protocol.  

        This event indicates that the link is administratively available for traffic.

        In the opened state, the protocol will come up when the PPP session is 
        established. When the PPP/IPCP session was already established, the IPCP will 
        start negotiation.  

        See also :rfc:1661, section 4.3 for detailed information about the Open event.  

        """
        return _byteblower.IPv4CPProtocol_Open(self)

    def Close(self):
        r"""

        Perform an administrative close on the IPCP protocol.  

        This event indicates that the link is not available for traffic.  

        In the closed state, the protocol will not come up when the PPP session is 
        established. When the PPP/IPCP session was already established, the IPCP 
        session will properly terminate the network layer.   

        See also :rfc:1661, section 4.3 for detailed information about the Close event.


        """
        return _byteblower.IPv4CPProtocol_Close(self)

# Register IPv4CPProtocol in _byteblower:
_byteblower.IPv4CPProtocol_swigregister(IPv4CPProtocol)
class IPv6CPProtocol(PPPNetworkControlProtocol):
    r"""

    IP version 6 over PPPoE.  

    IPv6 Control Protocol (IPv6CP) is a network control protocol for establishing 
    and configuring the IPv6 (see also Layer3.IPv6) over PPP . It forms IPv6 
    link-local addresses on PPP links. The IPv6 Control Protocol (IPV6CP) is 
    responsible for configuring, enabling, and disabling the IPv6 protocol modules
    on both ends of the point-to-point link. IPV6CP uses the same packet exchange
    mechanism as the Link Control Protocol (LCP).  

    The implementation is conform :rfc:2472  

    .. versionadded:: 2.5.0  

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterfaceIdentifierGet(self):
        r"""

        Returns the local IPv6 interface identifier.  

        This method returns the IPv6 interface identifier to be used at the local end 
        of the link. The initial value is based on the local MAC address (from 
        :meth:`.EthernetConfiguration.MacGet`).  

        After IPv6 interface identifier negotiation with the remote peer, the method 
        will return the IPv6 interface identifier negotiated with the remote peer.  

        The latter will be either:

        - the initial value if the remote peer accepted that address.
        - the address imposed by the remote peer when the remote peer did not accept 
          the requested address.

        :return: The IPv6 interface identifier to be used by the local peer.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv6CPProtocol_InterfaceIdentifierGet(self)

    def InterfaceIdentifierRemoteGet(self):
        r"""

        Returns the IPv6 interface identifier of the remote peer.  

        This method will return the IPv6 interface identifier which has been requested 
        by the remote peer during (the last) address negotiation.  

        :return: IPv6 interface identifier of the remote peer of the last address 
                 negotiation.  '00:00:00:00:00:00:00:00' if no negotiation took place 
                 yet.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv6CPProtocol_InterfaceIdentifierRemoteGet(self)

    def Open(self):
        r"""

        Perform an administrative open on the IPv6CP protocol.  

        This event indicates that the link is administratively available for traffic.  

        In the opened state, the protocol will come up when the PPP session is 
        established. When the PPP/IPv6CP session was already established, the IPv6CP 
        will start negotiation.  

        See also :rfc:1661, section 4.3 for detailed information about the Open event.


        """
        return _byteblower.IPv6CPProtocol_Open(self)

    def Close(self):
        r"""

        Perform an administrative close on the IPv6CP protocol.  

        This event indicates that the link is not available for traffic.  

        In the closed state, the protocol will not come up when the PPP session is 
        established. When the PPP/IPv6CP session was already established, the IPv6CP 
        session will properly terminate the network layer.  

        See also :rfc:1661, section 4.3 for detailed information about the Close event.  

        """
        return _byteblower.IPv6CPProtocol_Close(self)

# Register IPv6CPProtocol in _byteblower:
_byteblower.IPv6CPProtocol_swigregister(IPv6CPProtocol)
class PPPProtocol(AbstractObject):
    r"""

    The Point-to-Point Protocol (PPP) provides a standard method for transporting 
    multi-protocol datagrams over point-to-point links. PPP is comprised of three
    main components:  

    1.  A method for encapsulating multi-protocol datagrams.  
    2.  A Link Control Protocol (LCP) for establishing, configuring, and testing the data-link connection.   
    3.  A family of Network Control Protocols (NCPs) for establishing and configuring different network-layer protocols.  

    The implementation is conform :rfc:`1661`.  

    .. versionadded:: 2.5.0  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self, *args):
        return _byteblower.PPPProtocol_PortGet(self, *args)

    def AuthProtocolPapAdd(self):
        r"""

        This method will add the Password Authentication Protocol.  

        :rtype: PAPProtocol


        """
        return _byteblower.PPPProtocol_AuthProtocolPapAdd(self)

    def AuthProtocolPapGet(self):
        r"""

        This method will return the current configured Password Authentication Protocols.  

        :rtype: PAPProtocolList


        """
        return _byteblower.PPPProtocol_AuthProtocolPapGet(self)

    def AuthProtocolChapAdd(self):
        r"""

        This method will add the Challenge-handshake Authentication Protocol.

        :rtype: CHAPProtocol


        """
        return _byteblower.PPPProtocol_AuthProtocolChapAdd(self)

    def AuthProtocolChapGet(self):
        r"""

        This method will return the current configured Challenge-Handshake Authentication Protocols.

        :rtype: CHAPProtocolList


        """
        return _byteblower.PPPProtocol_AuthProtocolChapGet(self)

    def NcpIpcpAdd(self):
        r"""

        This method will add support for an IPv6 Control Protocol.  

        IPCP is the Internet Protocol Control Protocol.  

        :return: The IPCP NCP object is returned. The object types is 
                 Layer2.Ppp.NetworkControl.Ipcp.  

        Example

        .. todo:: Real Example


        """
        return _byteblower.PPPProtocol_NcpIpcpAdd(self)

    def NcpIpcpGet(self):
        r"""

        This method will return the current configured Internet Protocol Control Protocols (IPCP).  

        :rtype: IPv4CPProtocol

        Example

        .. todo:: Real Example


        """
        return _byteblower.PPPProtocol_NcpIpcpGet(self)

    def NcpIpv6cpAdd(self):
        r"""

        This method will add support for an IPv4 Control Protocol.  

        IPv6CP is the Internet Protocol Control Protocol for IPv6.  

        :rtype: IPv6CPProtocol

        Example

        .. todo:: Real Example


        """
        return _byteblower.PPPProtocol_NcpIpv6cpAdd(self)

    def NcpIpv6cpGet(self):
        r"""

        This method will return the current configured IPv6 Control Protocols (IPv6CP).  

        :rtype: IPv6CPProtocol

        .. todo:: Real Example


        """
        return _byteblower.PPPProtocol_NcpIpv6cpGet(self)

# Register PPPProtocol in _byteblower:
_byteblower.PPPProtocol_swigregister(PPPProtocol)
PPPoEStatus_Initial = _byteblower.PPPoEStatus_Initial
PPPoEStatus_Discovering = _byteblower.PPPoEStatus_Discovering
PPPoEStatus_Requesting = _byteblower.PPPoEStatus_Requesting
PPPoEStatus_SessionActive = _byteblower.PPPoEStatus_SessionActive
PPPoEStatus_Terminated = _byteblower.PPPoEStatus_Terminated

def ConvertPPPoEStatusToString(inPPPoEStatus):
    return _byteblower.ConvertPPPoEStatusToString(inPPPoEStatus)
class PPPoEClient(Layer25Configuration):
    r"""

    A PPPoE client which allows you to setup Layer3 connectivity.  

    PPP over Ethernet (PPPoE) provides the ability to connect a network of hosts 
    over a simple bridging access device to a remote Access Concentrator.  

    The client implements the PPPoE protocol as per :rfc:`2516`.  

    The associated PPP Protocol has support for multiple authentication protocols.
    Layer3 connectivity includes IPv4 and IPv6 .  

    .. versionadded:: 2.5.0  


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PppGet(self):
        r"""

        Returns the associated PPP Protocol object.  

        Returns the PPP ( Point-to-Point ) Protocol which is transmitted over Ethernet 
        ( PPPoE ). Through this object, you can configure the AuthProtocol. 

        :rtype: PPPProtocol

        Example

        .. code-block:: python

           # TODO


        """
        return _byteblower.PPPoEClient_PppGet(self)

    def ServiceNameSet(self, inServiceName):
        r"""

        This method will set the Requested Service Name for the PPPoE client.  

        :param serviceName: PPPoE Service Name which the client requests.
        :type serviceName: str

        Example

        .. todo:: Real Example


        """
        return _byteblower.PPPoEClient_ServiceNameSet(self, inServiceName)

    def ServiceNameGet(self):
        r"""

        This method will return the Requested Service Name for the PPPoE client.  

        :return: PPPoE Service Name which the client requests.  
        :rtype: str

        .. todo:: Real Example


        """
        return _byteblower.PPPoEClient_ServiceNameGet(self)

    def SessionIdGet(self):
        r"""

        This method will return the PPPoE SessionID of the last started PPPoE Session. 

        :return: False if No session started yet, else the PPPoE SessionID of the last 
                 started session. 


        """
        return _byteblower.PPPoEClient_SessionIdGet(self)

    def Start(self):
        r"""

        This will Start the PPPoE client.  

        This method will start the PPPoE session, setup PPP, authenticate using the
        configured authentication protocol and setup the currently configured network
        control protocols.  

        :raises: SessionUnavailable - When something unexpectedly happened during PPPoE
                 session initiation.  

        :raises: LinkEstablishmentTimeout - When PPP network layer was not configured
                 within reasonable timeout.  

        :return: PPPoE Session ID  

        .. todo:: Real Example


        """
        return _byteblower.PPPoEClient_Start(self)

    def StartAsync(self):
        r"""

        Starts the PPPoE client.  

        This call will initiate the start of the PPPoE client but will not wait for the
        result.


        """
        return _byteblower.PPPoEClient_StartAsync(self)

    def Terminate(self):
        r"""

        This will Terminate the PPPoE client.  

        Termination will properly terminate all PPPoE and PPP related protocols, from 
        higher-layers to lower-layers, starting from the network control protocol 
        (i.e. IPCP  or IPv6CP ).  

        """
        return _byteblower.PPPoEClient_Terminate(self)

    def StatusGet(self):
        r"""

        Returns the current status of the PPPoE connection.  

        Possible states are: 

        Initial
            PPPoE not yet started  

        Discovering
            PPPoE discovery message sent  

        Requesting
            PPPoE request sent  

        SessionActive
            PPPoE session is active  

        Terminated
            PPPoE session has been terminated  

        :return: Current PPPoE Status  

        Example

        .. code-block:: python

           # TODO


        """
        return _byteblower.PPPoEClient_StatusGet(self)

    def ServerGet(self):
        return _byteblower.PPPoEClient_ServerGet(self)

# Register PPPoEClient in _byteblower:
_byteblower.PPPoEClient_swigregister(PPPoEClient)
class PAPProtocolList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.PAPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.PAPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.PAPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.PAPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.PAPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.PAPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.PAPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.PAPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.PAPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.PAPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.PAPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.PAPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.PAPProtocolList_empty(self)

    def size(self):
        return _byteblower.PAPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.PAPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.PAPProtocolList_begin(self)

    def end(self):
        return _byteblower.PAPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.PAPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.PAPProtocolList_rend(self)

    def clear(self):
        return _byteblower.PAPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.PAPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.PAPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.PAPProtocolList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.PAPProtocolList_swiginit(self, _byteblower.new_PAPProtocolList(*args))

    def push_back(self, x):
        return _byteblower.PAPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.PAPProtocolList_front(self)

    def back(self):
        return _byteblower.PAPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.PAPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.PAPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.PAPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.PAPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.PAPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_PAPProtocolList

# Register PAPProtocolList in _byteblower:
_byteblower.PAPProtocolList_swigregister(PAPProtocolList)
class CHAPProtocolList(object):
    r"""

    This is a List of multiple CHAPProtocol objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CHAPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CHAPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CHAPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.CHAPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CHAPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CHAPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CHAPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CHAPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CHAPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CHAPProtocolList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.CHAPProtocolList_swiginit(self, _byteblower.new_CHAPProtocolList(*args))
    __swig_destroy__ = _byteblower.delete_CHAPProtocolList

# Register CHAPProtocolList in _byteblower:
_byteblower.CHAPProtocolList_swigregister(CHAPProtocolList)
class IPCPProtocolList(object):
    r"""

    This is a List of multiple IPv4CPProtocol objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IPCPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IPCPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IPCPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.IPCPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IPCPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IPCPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IPCPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IPCPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IPCPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IPCPProtocolList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.IPCPProtocolList_swiginit(self, _byteblower.new_IPCPProtocolList(*args))
    __swig_destroy__ = _byteblower.delete_IPCPProtocolList

# Register IPCPProtocolList in _byteblower:
_byteblower.IPCPProtocolList_swigregister(IPCPProtocolList)
class IPv6CPProtocolList(object):
    r"""

    This is a List of multiple IPv6CPProtocol objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IPv6CPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IPv6CPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IPv6CPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.IPv6CPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IPv6CPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IPv6CPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IPv6CPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.IPv6CPProtocolList_swiginit(self, _byteblower.new_IPv6CPProtocolList(*args))
    __swig_destroy__ = _byteblower.delete_IPv6CPProtocolList

# Register IPv6CPProtocolList in _byteblower:
_byteblower.IPv6CPProtocolList_swigregister(IPv6CPProtocolList)
class Layer3Configuration(AbstractObject):
    r"""

    Base class for the allowed Layer3 configuration objects


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register Layer3Configuration in _byteblower:
_byteblower.Layer3Configuration_swigregister(Layer3Configuration)
class IPv4Configuration(Layer3Configuration):
    r"""

    Provides an interface for the IPv4 configuration on a ByteBlower port.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IpSet(self, inIPv4Address):
        r"""

        Sets the IP address of the ByteBlower port.

        :param ipAddress: IP address string. You can use "slash notation"
                          (e.g. 10.1.1.2/24) to simulateously specify the address and
                          netmask.
        :type ipAddress: str

        :raises ConfigError: When an invalid IPv4 address is being set.

        Example

        This example sets the IP address on a ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_IpSet(self, inIPv4Address)

    def IpGet(self):
        r"""

        Retrieves the Ip address of the ByteBlower port.

        :return: The IP address of the ByteBlower port.
        :rtype: str

        Example

        This example returns the IP address on a ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_IpGet(self)

    def GatewaySet(self, inGateway):
        r"""

        Sets the default gateway of the ByteBlower port.

        :param gateway: Gateway address string
        :type gateway: str

        :raises ConfigError: When an invalid IPv4 address is being set.

        Example

        This example sets the gateway of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_GatewaySet(self, inGateway)

    def GatewayGet(self):
        r"""

        Returns the default gateway of the ByteBlower port.

        :return:  Default gateway of the ByteBlower port.
        :rtype: str

        Example

        This example gets the gateway of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_GatewayGet(self)

    def NetmaskSet(self, inNetMask):
        r"""

        Sets the netmask of the ByteBlower port.

        :param netmask: Netmask address string
        :type netmask: str

        Example

        This example sets the netmask of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_NetmaskSet(self, inNetMask)

    def NetmaskGet(self):
        r"""

        Gets the netmask of the ByteBlower port.

        :return:  Netmask of the ByteBlower port.
        :rtype: str

        Example

        This example gets the netmask of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_NetmaskGet(self)

    def ProtocolArp(self, inIPAddress):
        r"""

        Performs MAC address resolution for a given IP address.

        :param ipAddress: IPv4 address to resolve
        :type ipAddress: str

        :return: Resolved MAC address
        :rtype: str

        :raises ConfigError: When an unusable IP address was given.
        :raises AddressResolutionFailed: When the address could not be resolved.

        Sends an ARP request for the specified IP address, and returns the answer if an
        answer is  received.

        .. note:: This call does not make use of the an ARP cache. If you are only
                  interested in resolving an IP then please use :meth:`Resolve` which
                  also makes use of the ARP cache.

        Example

        This example gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolArp(self, inIPAddress)

    def ProtocolArpAsync(self, inIPAddress):
        r"""

        Starts MAC address resolution for a given IP address.

        .. versionadded:: 2.2.0

        :param ip_address: IPv4 address to resolve
        :type ip_address: str

        :raises ConfigError: When an unusable IP address was given.

        Sends an ARP request for the specified IP address, and returns immediately. To
        obtain the results of the ARP resolution, you can use :meth:`ProtocolArp`.

        .. note:: This call does not make use of the an ARP cache. If you are only
                  interested in resolving an IP then please use :meth:`ResolveAsync`
                  which also makes use of the ARP cache.

        Example

        This example triggers ARP resolution gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolArpAsync(self, inIPAddress)

    def ProtocolGratuitousArpRequest(self):
        r"""

        Sends a Gratuitous ARP (GARP) request.

        .. versionadded:: 2.5.0

        The GARP Request can be used for host presence announcement. This way, other
        devices on the network can learn the Layer2 and Layer3 information of the host.
        This GARP Request is preferred over the GARP Reply

        Example

        This example sends a Gratuitous ARP request

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolGratuitousArpRequest(self)

    def ProtocolGratuitousArpReply(self):
        r"""

        Sends a Gratuitous ARP (GARP) request.

        .. versionadded:: 2.5.0

        The GARP Request can be used for host presence announcement. This way, other
        devices on the network can learn the Layer2 and Layer3 information of the host

        Example

        This example sends a Gratuitous ARP request

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolGratuitousArpReply(self)

    def Resolve(self, inIPAddress):
        r"""

        Resolve the MAC address for a given IP address.

        :param ipAddress: IPv4 address to resolve
        :type ipAddress: str

        :return: Resolved MAC address
        :rtype: str

        :raises ConfigError: When an unusable IP address was given.
        :raises AddressResolutionFailed: When the address could not be resolved.

        The ByteBlower server stores an ARP cache per ByteBlower port. Resolving the IP
        for a port will search the ARP cache first. If no entry was found then an
        actual ARP request is performed. An entry in the ARP cache remains valid for
        120 seconds.

        Example

        This example gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_Resolve(self, inIPAddress)

    def ResolveAsync(self, inIPAddress):
        r"""

        Start MAC address resolution for a given destination IP address.

        .. versionadded:: 2.2.0

        :param ipaddress: IPv4 address to resolve
        :type ipaddress: str

        :raises ConfigError: When an unusable IP address was given.

        The ByteBlower server stores an ARP cache per ByteBlower port. Resolving the IP
        for a port will search the ARP cache first. If no entry was found then an
        actual ARP request is performed. An entry in the ARP cache remains valid for
        120 seconds.

        This methods initiates the MAC address resolution. To obtain the actual results
        of the address resolution, please use :meth:`Resolve`.

        Example

        This example triggers address resolution gets the MAC address for the given IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ResolveAsync(self, inIPAddress)

    def ProtocolIcmpGet(self):
        r"""

        Returns the ICMP protocol.

        :rtype: ICMPProtocol

        Example This example gets the ICMP protocol object.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolIcmpGet(self)

    def ProtocolDhcpGet(self):
        r"""

        Returns the DHCP protocol.

        :rtype: DHCPv4Protocol

        Example

        This example gets the DHCP protocol object.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolDhcpGet(self)

    def ProtocolIgmpGet(self):
        r"""

        Returns the IGMP protocol.

        :rtype: IGMPProtocol

        Example

        This example gets the IGMP protocol object.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolIgmpGet(self)

# Register IPv4Configuration in _byteblower:
_byteblower.IPv4Configuration_swigregister(IPv4Configuration)
class IPv6Configuration(Layer3Configuration):
    r"""

    A class representing the IPv6 protocol that allows managing IPv6 settings,
    running IPv6 commands and accessing attached protocols.

    Each ByteBlowerPort must be configured with a layer 3 protocol through the
    method :meth:`ByteBlowerPort.Layer3IPv6Set`. If the IPv6 protocol is selected,
    this object is returned.
    Through it, the IPv6 protocol instance on that port can be configured.

    It provides the following functionality:

    - Configure and read various IPv6 settings and values such as the IP address.
    - Execute IPv6 commands such as resolving IPv6 addresses (through NDP).
    - Access protocols attached to the IPv6 protocol such as DHCPv6 and ICMPv6 on
      which other settings can be configured and other commands can be executed.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IpManualAdd(self, inIPv6Address):
        r"""

        Adds a manual IPv6 address to the port.

        .. versionadded:: 2.1.0

        :param address: The IPv6 address you want to add. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... A custom prefix length can be provided by
                        appending this argument with `/<prefix length>`, where
                        *<prefix length>* can be a number between 0 and 128.
                        If no such prefix length is appended, the default length of 64
                        is taken.
        :type address: str

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method adds such a manual IP address to the port. Note this method also
        adds the prefix derived from the specified address to the list of on-link
        prefixes.

        If the IPv6 protocol is not yet initialized, calling this method the first time
        will do so. This initialization causes the host's link-local address to be
        generated and looks for router advertisements to set the default gateway. If no
        router advertisement occurs, the gateway is set to the null address (::).

        Example

        This examples adds a global address address using default prefix length 64.

        .. code-block:: python
           :emphasize-lines: 2

            bbPort1_l3 = port1.Layer3IPv6Set()
            bbPort1_l3.IpManualAdd('3000:3128::24/64')


        """
        return _byteblower.IPv6Configuration_IpManualAdd(self, inIPv6Address)

    def IpManualRemove(self, inIPv6Address):
        r"""

        Removes a specified manually added IP address from this port.

        .. versionadded:: 2.1.0

        :param address: The IPv6 address you want to remove. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... No prefix length suffix (e.g. '/64')
                        may be included!
        :type address: str

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method removes the specified IPv6 address from the port if it was added
        manually before. If the address was not added manually, nothing is done.

        Example

        This example removes the specified address from the port if it was previously
        added.

        .. code-block:: python
           :emphasize-lines: 1

            port_layer3_config.IpManualRemove('3000:3128::23/64')


        """
        return _byteblower.IPv6Configuration_IpManualRemove(self, inIPv6Address)

    def IpManualClear(self):
        r"""

        Removes all manually added IP addresses from this port.

        .. versionadded:: 2.1.0

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method removes all addresses in the first category.

        Example

        This example removes all manually added addresses from the port.

        .. code-block:: python
           :emphasize-lines: 2

            port_layer3_config = self.port.Layer3IPv6Get()
            port_layer3_config.IpManualClear()


        """
        return _byteblower.IPv6Configuration_IpManualClear(self)

    def IpManualGet(self):
        r"""

        Returns all IPv6 addresses that where manually added by the user.

        :return: A list of manually added IPv6 addresses is returned. These addresses
                 are returned using the full (i.e. uncompressed) representation and
                 appended with their prefix lengths (see example). An empty list
                 (i.e. empty string) is returned if no addresses were added yet.
        :rtype: StringList

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all manual IPv6 addresses on the port.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: Prints a list of manual IPv6 addresses

            port_layer3_config = self.port.Layer3IPv6Get()
            list = port_layer3_config.IpManualGet()
            for ip in list:
                print(ip)


        """
        return _byteblower.IPv6Configuration_IpManualGet(self)

    def IpStatelessGet(self):
        r"""

        Returns all IPv6 addresses that where obtained by stateless autoconfiguration.

        :return: A list of IPv6 addresses obtained during stateless autoconfiguration
                 (SLAAC) is returned. These addresses are returned using the full (i.e.
                 uncompressed) representation and appended with their prefix lengths
                 (see example). An empty list (i.e. empty string) is returned if no
                 autoconfiguration was performed yet or if it did not provided any IP
                 addresses.
        :rtype: StringList

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all SLAAC IPv6 addresses on the port. They are configured
        by calling the :meth:`StatelessAutoconfiguration` function.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.
        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: prints the list of SLAAC-obtained IPv6 addresses

            bbPort1_l3.StatelessAutoconfiguration()
            statelessList = bbPort1_l3.IpStatelessGet()
            for ips in statelessList:
                print(ips)


        """
        return _byteblower.IPv6Configuration_IpStatelessGet(self)

    def IpDhcpGet(self):
        r"""

        Returns all IPv6 addresses that where obtained by the DHCPv6 protocol.

        :return: A list of IPv6 addresses obtained during DHCP is returned. These
                 addresses are returned using the full (i.e. uncompressed)
                 representation and appended with their prefix lengths (see example).
                 An empty list (i.e. empty string) is returned if no DHCP was performed
                 yet or if it did not provided any IP addresses.
        :rtype: StringList

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all DHCP IPv6 addresses on the port. They are configured by
        retrieving the DHCP protocol using :meth:`ProtocolDhcpGet` and executing
        :meth:`.DHCPv6Protocol.Perform`.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: prints a list of DHCP-obtained IPv6 addresses.

            dhcpList = bbPort1_l3.IpDhcpGet()
            for ip_dhcp in dhcpList:
                print(ip_dhcp)


        """
        return _byteblower.IPv6Configuration_IpDhcpGet(self)

    def GatewaySet(self, inGateway):
        r"""

        Configures the manual gateway.

        .. versionadded:: 2.1.0

        .. deprecated:: 2.22.0


        """
        return _byteblower.IPv6Configuration_GatewaySet(self, inGateway)

    def GatewayGet(self):
        r"""

        Returns the current manual configured gateway of this IPv6 protocol...

        .. versionadded:: 2.1.0

        .. deprecated:: 2.22.0


        """
        return _byteblower.IPv6Configuration_GatewayGet(self)

    def GatewayManualSet(self, inGateway):
        r"""

        configures the manual gateway.

        .. versionadded:: 2.22.0

        :param gateway: Gateway to set
        :type gateway: str

        :raises ConfigError: Setting one of the port's own IP addresses as gateway is not possible and causes this exception.

        The current IPv6 implementation is limited to a single gateway. This is the
        preferred gateway. This may change in the future.

        Example

        This example sets the current gateway.

        .. code-block:: python
           :emphasize-lines: 1

            port_layer3_config.GatewayManualSet('fe80:0000:0000:0000:0290:0eff:fe1c:e44d')


        """
        return _byteblower.IPv6Configuration_GatewayManualSet(self, inGateway)

    def GatewayManualGet(self):
        r"""

        Returns the current manual configured gateway of this IPv6 protocol...

        .. versionadded:: 2.22.0

        :rtype: str

        Example

        This example retrieves the current gateway.

        .. code-block:: python
           :emphasize-lines: 1

           print(port_layer3_config.GatewayManualGet())


        """
        return _byteblower.IPv6Configuration_GatewayManualGet(self)

    def GatewayAdvertisedGet(self):
        r"""

        Returns the current (preferred) gateway of this IPv6 protocol, set either
        manually or by performing DHCP or SLAAC.

        .. versionadded:: 2.1.0

        :rtype: StringList

        The first time an IP address is added (either manually or by performing DHCP or
        SLAAC) the preferred gateway is also automatically detected. From that moment
        on, it can be retrieved by this method.

        When no gateway is found when the IP is set (manually, through DHCP or SLAAC)
        the gateway is set to the null address (::). Every time this getter is called,
        IPv6 will look for router advertisements. If one is found, it will be updated
        automatically.

        Once the preferred gateway is set using :meth:`GatewayManualSet`, this value
        remains the preferred gateway until it is explicitly replaced. Performing DHCP
        or SLAAC again will not replace the manually set value. This may change in the
        future.

        Example

        This example retrieves the current gateway.

        .. code-block:: python
           :emphasize-lines: 3

            port_layer3_config = self.port.Layer3IPv6Get()
            for link in port_layer3_config.GatewayAdvertisedGet():
                print(link)


        """
        return _byteblower.IPv6Configuration_GatewayAdvertisedGet(self)

    def IpLinkLocalGet(self):
        r"""

        Returns the linklocal address which is based on the MAC address of the port.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns the link-local IPv6 address on the port. It uses the
        dedicated fe80::/64 prefix as the first half of the address and the modified
        EUI-64 number (based on the Ethernet MAC address) as the last half of the
        address.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        irst time when calling this method, the gateway property will be set updated
        automatically.

        :return: The linklocal IPv6 address is returned. This address does always
                 exist, even if no IPv6 gateway is present. The address is returned
                 using the full (i.e. uncompressed) representation. The prefix length
                 suffix ('/64') is omitted!
        :rtype: str

        Example

        This example returns the link-local address of a port.

        .. code-block:: python
           :emphasize-lines: 2

            bbPort1_l3 = port1.Layer3IPv6Set()
            print(bbPort1_l3.IpLinkLocalGet())


        """
        return _byteblower.IPv6Configuration_IpLinkLocalGet(self)

    def StatelessAutoconfiguration(self):
        r"""

        Performs stateless address autoconfiguration (SLAAC) to configure IPv6 with,
        among others, a global IPv6 address.

        The stateless address autoconfiguration (SLAAC) is done in an asynchronous
        manner. It works through the IPv6 Neighbor Discovery Protocol (NDP). It creates
        an IP address based on the prefix information from incoming router
        advertisements (first 64 bits) and the hosts MAC address (last 64 bits).

        .. note:: SLAAC and the NDP is also used to create the link-local IP address.
                  This address has a fixed prefix (fe80::/64) and the same host part.
                  This address is immediately generated when the IPv6 protocol is
                  initialized and is not part of this call.

        If the IPv6 protocol is not yet initialized, calling this method the first time
        will do so. This initialization sets the link-local address described above and
        listens for router advertisements to set the default gateway. If no router
        advertisement occurs, the gateway is set to the null address (::).

        When no routing advertisement is found, no address is added.

        Example

        This example performs stateless address autoconfiguration on this host.

        .. code-block:: python
           :emphasize-lines: 2

            bbPort1_l3 = port1.Layer3IPv6Set()
            bbPort1_l3.StatelessAutoconfiguration()


        """
        return _byteblower.IPv6Configuration_StatelessAutoconfiguration(self)

    def StatelessAutoconfigurationAsync(self):
        r"""

        Performs stateless address autoconfiguration (SLAAC) to configure IPv6 with,
        among others, a global IPv6 address.

        .. versionadded:: 2.3.0

        This is a asynchronous call so it will return immediately. If you want to wait
        until it has finished then call the :meth:`StatelessAutoconfiguration` method
        after having called this method. This will also rethrow any exceptions that may
        have occured on the server side.

        This method returns immediately.

        Example

        This example performs stateless address autoconfiguration on this host.

        .. code-block:: python
           :emphasize-lines: 1

            port_layer3_config.StatelessAutoconfigurationAsync()


        """
        return _byteblower.IPv6Configuration_StatelessAutoconfigurationAsync(self)

    def NeighborDiscovery(self, inIPv6Address):
        r"""

        Resolves a destination IPv6 address by explicitly performing Neighbor Discovery.

        :param address: The IPv6 address that must be resolved. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, ...
                        No prefix length suffix (e.g. '/64') may be included!

        :return: The layer 2 MAC address found for the provided IPv6 address.
        :rtype: str

        :raises AddressResolutionFailed: When nobody replies to the Neighbour Discovery 
                                         request (i.e. neither the host itself or a
                                         forwarding router), this exception is thrown.

        To use the neighbor cache first when resolving an IPv6 address, execute the
        :meth:`Resolve` method. This may return significantly faster then this method.

        Example

        This simple example resolves a link-local IPv6 address. This example clearly
        shows that the host part of a link-local address is based on its layer 2
        MAC address.

        .. code-block:: python
           :emphasize-lines: 1

            port_layer3_config.NeighborDiscovery('fe80:0000:0000:0000:02ff:25ff:fe00:0001')


        """
        return _byteblower.IPv6Configuration_NeighborDiscovery(self, inIPv6Address)

    def Resolve(self, inIPv6Address):
        r"""

        Resolves a destination IPv6 address by looking in the neighbour cache or
        performing Neighbor Discovery.

        :param address: The IPv6 address that must be resolved. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... No prefix length suffix (e.g. '/64') may
                        be included!
        :type address: str

        :return: The layer 2 MAC address found for the provided IPv6 address.
        :rtype: str

        :raises AddressResolutionFailed: When the item is not present in the neighbor 
                                         cache and nobody replies to the Neighbour 
                                         Discovery request (i.e. neither the host 
                                         itself or a forwarding router), this 
                                         exception is thrown.

        To force this host to perform the Neighbor Discovery algorithm and thus bypass
        the cache, execute the :meth:`NeighborDiscovery` method.

        Example

        This simple example resolves a link-local IPv6 address. This example clearly
        shows that the host part of a link-local address is based on its layer 2 MAC
        address.

        .. code-block:: python
           :emphasize-lines: 4

            dhcpv6 = port_l3.ProtocolDhcpGet()
            dhcpv6.Perform()
            port = port_l3.IpDhcpGet()
            dst_mac = self.port_1.Layer3IPv6Get().Resolve(port)


        """
        return _byteblower.IPv6Configuration_Resolve(self, inIPv6Address)

    def SelectSourceAddressFor(self, destination_ip):
        r"""

        Selects an appropriate IPv6 source address for a given destination address.

        .. versionadded:: 2.21.0

        :param address: The destination address for which we want to select an
                        appropriate source address.
        :type address: str

        :return: The appropriate source address for the given destination address.
        :rtype: str

        The ByteBlower implements source address selection according to the rules
        specified in RFC 6724 Section 5.

        Example

        Here we select a source address for a given IPv6 destination. The dst_ip
        and src_ip variables are strings representing an IPv6 address.

        .. code-block:: python
           :emphasize-lines: 1

           src_ip = ipv6.SelectSourceAddressFor(dst_ip)


        """
        return _byteblower.IPv6Configuration_SelectSourceAddressFor(self, destination_ip)

    def ProtocolIcmpGet(self):
        r"""

        Returns the ICMPv6 protocol attached to this protocol that allows starting ICMP sessions.

        :rtype: ICMPv6Protocol

        See :class:`ICMPv6Protocol` for more information on creating ICMP sessions.

        Example

        This example returns the ICMP object.

        .. code-block:: python
           :emphasize-lines: 2

           bbPort1_l3 = port1.Layer3IPv6Set()
           protocol = bbPort1_l3.ProtocolIcmpGet()


        """
        return _byteblower.IPv6Configuration_ProtocolIcmpGet(self)

    def ProtocolDhcpGet(self):
        r"""

        Returns the DHCPv6 protocol attached to this protocol through which DHCP can be performed.

        :rtype: DHCPv6Protocol

        See :class:`.DHCPv6Protocol` for more configuration options.
        To actually perform DHCP, execute the :meth:`.DHCPv6Protocol.Perform` method on
        the returned object.

        If the IPv6 protocol is not yet initialized, performing DHCP the first time
        will do so. This initialization causes the host's link-local address to be
        generated and looks for router advertisements to set the default gateway. If no
        router advertisement occurs, the gateway is set to the null address (::) and no
        address is set.

        Example

        This example returns the DHCP object.

        .. code-block:: python
           :emphasize-lines: 2

            port_layer3_config = self.port.Layer3IPv6Get()
            protocolDhcp = port_layer3_config.ProtocolDhcpGet()


        """
        return _byteblower.IPv6Configuration_ProtocolDhcpGet(self)

    def ProtocolMldGet(self):
        r"""

        Returns the MLD protocol attached to the IPv6 protocol that allows multicast

        :rtype: MLDProtocol

        See :class:`MLDProtocol` for more information.

        Example

        This example returns the MLD Protocol.

        .. code-block:: python
           :emphasize-lines: 2

           bbPort1_l3 = port1.Layer3IPv6Set()
           protocol = bbPort1_l3.ProtocolMldGet()


        """
        return _byteblower.IPv6Configuration_ProtocolMldGet(self)

# Register IPv6Configuration in _byteblower:
_byteblower.IPv6Configuration_swigregister(IPv6Configuration)
ModifierType_GrowingSize = _byteblower.ModifierType_GrowingSize
ModifierType_RandomSize = _byteblower.ModifierType_RandomSize
ModifierType_MultiBurst = _byteblower.ModifierType_MultiBurst
ModifierType_NormalDistributionTiming = _byteblower.ModifierType_NormalDistributionTiming
class AbstractModifier(AbstractObject):
    r"""

    Base class for most ByteBlower Modifiers


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register AbstractModifier in _byteblower:
_byteblower.AbstractModifier_swigregister(AbstractModifier)
class StreamGrowingSizeModifier(object):
    r"""

    A frame size modifier which will increase the size of the frame between a minimum and maximum value.

    .. deprecated 2.3.0
       This functionality is replaced by the :class:`.FrameSizeModifierGrowing`,
       see :meth:`.Frame.ModifierSizeGrowingSet` for more information.

    ByteBlower allows different modifiers on a flow.
    Some modifiers work on the timing parameters of a frame, others on the size
    or content. The :class:`StreamGrowingSizeModifier` is a modifier which modifies
    the size of the frames added to the :class:`.Stream` on which this Modifier is
    added.

    A :class:`.StreamGrowingSizeModifier` will increment the frame size with a
    configured amount of bytes. The following parameters can be configured:

    Minimum size
        the minimum frame size. This size will be used when the Stream is started.

    Maximum size
        the maximum frame size. It this limit isreached, the modifier will return
        to the minimum size again.

    Step size
        the amount of bytes the size will increase. By default, a frame will grow
        with one byte but this parameter allows larger step sizes.

    Iteration
        this paramter defines the number of times the same frame size is iterated
        before increasing to the next frame size.

    So, a stream with a StreamModifierGrowingSize installed, will start sending
    frames with a *<Minimum size>* size, will send this size *<Iteration>* times,
    increase the size with *<Step size>* bytes until the *<Maximum size>* is
    reached.

    If the maximum size is reached, the next size is calculated as follows:

        *<next size>* = *<Minimum size>*
                      + ( *<current size>* + *<Step size>* - *<Maximum size>* )

    All sizes define a frame size, excluding the 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. It the original frame size is longer, the size will truncated to
    the requested frame size. If automatic checksum calculations have been enabled
    on the Frame, they will be recalculated. This depends on the configuration of
    the Frame. See the Frame documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    If multiple frames are added to a TxStream which is configured with a
    StreamModifierGrowingSize, the frames are sent alternately, while the modifier
    is applied on all of them. E.g.

        {Frame A , size X},
        {Frame B, size X},
        {Frame A, size X+1},
        {Frame B, size X+1}, ...

    .. note:: It is possible that the maximum size is never reached. Depending on
              both the *<Step size>* and the TxStream configuration
              (NumberOfFrames), the maximum size will never be used.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

           print(growingSizeModifier.MaximumGet())


        """
        return _byteblower.StreamGrowingSizeModifier_MaximumGet(self)

    def MaximumSet(self, inMaxSize):
        r"""

        Sets the maximum size of a Frame of a growing size flow. This defines the
        maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame.
                        This value must be at least 61 bytes, and maximum 8192. The
                        value must also be bigger than the *<Minimum size>* configured.
                        Default: `1514`

        :raises: python_error - Maximum too big or too small.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

           growingSizeModifier.MaximumSet(128)


        """
        return _byteblower.StreamGrowingSizeModifier_MaximumSet(self, inMaxSize)

    def MinimumGet(self):
        r"""

        Method to get the current configured minimum frame size.

        :return: The minimum frame size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

           print(growingSizeModifier.MinimumGet())


        """
        return _byteblower.StreamGrowingSizeModifier_MinimumGet(self)

    def MinimumSet(self, inMinSize):
        r"""

        Sets the Minimum size of a Frame of a growing size flow.

        This defines the minimal frame size of the stream. This frame size will be used
        when a Tx.Stream is started.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.    Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

           print(growingSizeModifier.MinimumSet(128))


        """
        return _byteblower.StreamGrowingSizeModifier_MinimumSet(self, inMinSize)

    def StepGet(self):
        r"""

        Method to get the current configured step size.

        :return: The step size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current step size.

        .. code-block:: python
           :emphasize-lines: 1

           print(growingSizeModifier.StepGet())


        """
        return _byteblower.StreamGrowingSizeModifier_StepGet(self)

    def StepSet(self, inStep):
        r"""

        Sets the number of bytes a frame will grow in one step.

        Each time the modifier needs to adapt the size of the frame, the size will be
        incremented with *<Step size>* bytes.

        :param step: This parameter defines the amount of bytes the frame will grow.
                     Default: `1`

        :raises: python_error - An error is returned when the value is less than 1.

        Example

        This example demonstrates a step size of 10 bytes:

        .. code-block:: python
           :emphasize-lines: 1

           growingSizeModifier.StepSet(10)


        """
        return _byteblower.StreamGrowingSizeModifier_StepSet(self, inStep)

    def IterationGet(self):
        r"""

        Method to get the current configured iteration.

        :return: The iteration which will be used for a growing size flow.

        Example

        This example show how to retrieve the current iteration.

        .. code-block:: python
           :emphasize-lines: 1

           print(growingSizeModifier.IterationGet())


        """
        return _byteblower.StreamGrowingSizeModifier_IterationGet(self)

    def IterationSet(self, inIteration):
        r"""

        Sets the number of times the same frame size will be used.

        A Frame can be sent with the same frame size multiple times before the size is
        increased to the next value. This parameter defines the iteration count.

        :param iteration: Number of times the same frame size will be used before the
                          frame size is increased to the next value.   Default: `1`

        Example

        This example demonstrates an iteration of 10, before going to the next frame
        size.

        .. code-block:: python
           :emphasize-lines: 1

           growingSizeModifier.IterationSet(10)


        """
        return _byteblower.StreamGrowingSizeModifier_IterationSet(self, inIteration)

    def ReCommitValues(self, inFrame):
        return _byteblower.StreamGrowingSizeModifier_ReCommitValues(self, inFrame)

# Register StreamGrowingSizeModifier in _byteblower:
_byteblower.StreamGrowingSizeModifier_swigregister(StreamGrowingSizeModifier)
class MultipleBurstModifier(AbstractModifier):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterBurstGapGet(self):
        r"""

        Returns the time (ns) between the end of start of the next burst.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: Get the gap between 2 bursts

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_InterBurstGapGet(self)

    def InterBurstGapSet(self, inInterBurstGap):
        r"""

        Sets the time (ns) between the end of one burst and the start of the next burst.

        :param interburstgap: The gap between 2 burst in ns
        :type interburstgap: int

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: Set the gap at 1ms

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        .. code-block:: python
           :emphasize-lines: 3
           :caption: Set the gap at 10ms

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_InterBurstGapSet(self, inInterBurstGap)

    def BurstSizeGet(self):
        r"""

        Retrieves the number of frames in one burst.

        :return: Returns the number of frames in one burst
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: retrieve the burstsize

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_BurstSizeGet(self)

    def BurstSizeSet(self, inBurstSize):
        r"""

        Sets the number of frames to send in one burst.

        :param burstsize: the size of the burst
        :type burtsize: int

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: Set the burstsize to 100

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_BurstSizeSet(self, inBurstSize)

# Register MultipleBurstModifier in _byteblower:
_byteblower.MultipleBurstModifier_swigregister(MultipleBurstModifier)
class NormalDistributionTimingModifier(AbstractModifier):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VarianceSet(self, inVariance):
        r"""

        Sets the variance of the normal distribution

        :param variance: the number of frames in one burst
        :type variance: int


        """
        return _byteblower.NormalDistributionTimingModifier_VarianceSet(self, inVariance)

    def VarianceGet(self):
        r"""

        Retrieves the variance of the normal distribution

        :return:  Returns the number of frames in one burst
        :rtype: int


        """
        return _byteblower.NormalDistributionTimingModifier_VarianceGet(self)

# Register NormalDistributionTimingModifier in _byteblower:
_byteblower.NormalDistributionTimingModifier_swigregister(NormalDistributionTimingModifier)
class StreamRandomSizeModifier(object):
    r"""

    A frame size modifier which will change the size of the frame randomly between
    a minimum and maximum value.

    .. deprecated:: 2.3.0
       This functionality is replaced by the :class:`.FrameSizeModifierRandom`, see
       :meth:`.Frame.ModifierSizeRandomSet` for more information.

    ByteBlower allows different modifiers on a flow. Some modifiers work on the
    timing parameters of a frame, others on the size or content. The
    StreamModifierRandomSize is a modifier which modifies the size of the frames
    added to the Stream on which this Modifier is added.

    A StreamModifierRandomSize will change the frame size randomly. The following
    parameters can be configured:

    Minimum size
        the minimum frame size.

    Maximum size
        the maximum frame size.

    So, a stream with a StreamModifierRandomSize installed, will start sending
    frames with a size randomly chosen between *<Minimum size>* size and
    *<Maximum size>* size. Each time a frame is sent, a new size is selected.

    All sizes are without the additional 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. If the original frame size is bigger, the size will truncated to the
    requested frame size. If automatic checksum calculations have been enabled on
    the Frame, they will be recalculated. This depends on the configuration of the
    Frame. See the :class:`Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    If multiple frames are added to a TxStream which is configured with a
    StreamModifierRandomSize, the frames are sent alternately, while the modifier
    is applied on all of them.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MinimumSet(self, inMinimum):
        r"""

        Sets the Minimum size of a Frame of a flow with StreamModifierRandomSize.

        This defines the minimal frame size of the stream.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.    Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

           RandomSizeModifier.MinimumSet(128)


        """
        return _byteblower.StreamRandomSizeModifier_MinimumSet(self, inMinimum)

    def MinimumGet(self):
        r"""

        Method to get the currently configured minimum frame size.

        :return:  The minimum frame size which will be used for a random size flow.

        Example

        This example show how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

           print(RandomSizeModifier.MinimumGet())


        """
        return _byteblower.StreamRandomSizeModifier_MinimumGet(self)

    def MaximumSet(self, inMaximum):
        r"""

        Sets the Maximum size of a Frame of a flow with StreamModifierRandomSize.

        This defines the maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.   Default: `1514`

        :raises: python_error: Maximum too small or too big.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

           RandomSizeModifier.MaximumSet(128)


        """
        return _byteblower.StreamRandomSizeModifier_MaximumSet(self, inMaximum)

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a random size flow.

        Example

        This example show how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

           print(RandomSizeModifier.MaximumGet())


        """
        return _byteblower.StreamRandomSizeModifier_MaximumGet(self)

# Register StreamRandomSizeModifier in _byteblower:
_byteblower.StreamRandomSizeModifier_swigregister(StreamRandomSizeModifier)
class FrameFieldModifier(AbstractObject):
    r"""

    Abstract Base Class for Frame Field Modifiers

    .. versionadded:: 2.3.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FrameGet(self):
        r"""


        :meta private:


        """
        return _byteblower.FrameFieldModifier_FrameGet(self)

    def OffsetGet(self):
        r"""

        Method to get the current configured field offset within the frame content.

        The field offset is the absolute offset from the start of the frame.

        :return: The field offset which will be used for this incremental value field
                 modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current field offset.

        .. code-block:: python
           :emphasize-lines: 1

           print(frameModifier.OffsetGet())


        """
        return _byteblower.FrameFieldModifier_OffsetGet(self)

    def OffsetSet(self, inOffset):
        r"""

        Sets the offset of the frame field within the frame content.

        :param offset: Offset of the frame field within the frame content. This value
                       is relative to the start of the frame. The value must be greater
                       or equal than zero and must be smaller than the ByteBlowerPort
                       MDL
                       Default: `56`
        :type offset: int

        :raises ConfigError: When the field offset is out of valid range.

        Example

        This example will set the offset to 88.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifier.OffsetSet(88)


        """
        return _byteblower.FrameFieldModifier_OffsetSet(self, inOffset)

    def LengthGet(self):
        r"""

        Method to get the current configured field length.

        :return: The field length which will be used for this field modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current field length.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifier.LengthGet())


        """
        return _byteblower.FrameFieldModifier_LengthGet(self)

    def LengthSet(self, inLength):
        r"""

        Sets the length of the frame field.

        :param length: Length of the frame field. The value must be greater than zero
                       and smaller than 8 (as for server version 2.3.x)
                       Default: `2`
        :type length: int

        :raises ConfigError:  When the field length is not supported by the server.

        Example

        This example will set the field length to 4.

        .. code-block:: python
           :emphasize-lines: 1

           frameModifier.LengthSet(4)


        """
        return _byteblower.FrameFieldModifier_LengthSet(self, inLength)

# Register FrameFieldModifier in _byteblower:
_byteblower.FrameFieldModifier_swigregister(FrameFieldModifier)
class FrameFieldModifierIncremental(FrameFieldModifier):
    r"""

    A frame field modifier which will increase the value of the frame field between a minimum and maximum value.

    .. versionadded:: 2.3.0

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The :class:`.FrameFieldModifierIncremental`
    is a modifier which modifies a certain field in the frame content.

    A frame field is a number of subsequent bytes in the frame content. The value
    is defined as host-ordering signed integer and will be written to the frame
    content as network-ordering signed integer.

    A FrameFieldModifierIncremental will increment the value in a frame field with
    a configured amount. The following parameters can be configured:

    1. Parameters related to the location of the field in the frame:

       Field offset
           Offset of the field counted in bytes from the start of the frame.

       Field length
           Length of the field counted in bytes. Minimum: 1Byte. Maximum: 8Bytes (
           depends on server version).

       The field cannot overwrite the 4 bytes Ethernet checksum. The allowed range
       for offset is 0 ... *<ByteBlowerPort MDL>*.

       - When the field offset is greater or equal than the actual frame size,
         nothing will be written to the frame.

       - When the field offset is smaller than the actual frame size, but the
         field offset + field length exceeds the frame size.
         Then the LSB part of the field will be written to the frame.

       Please note that in both cases the field value
       will still move on to the next value.

    2. Parameters related to the value written to the field:

       Minimum value
           The minimum field value.

       Maximum value
           The maximum field value.

       Value step
           The amount the value will increase. By default, the value will grow with
           one but this parameter allows larger value steps. The step can be
           positive or negative but cannot be zero.

       Initial value
           This field value will bewritten to the frame contents when the
           :class:`.Stream` is started.

       The field value range is defined by the minimum and maximum value (both
       valuesinclusive).

       - Positive value step
         A frame with a FrameFieldModifierIncremental installed, will start
         sending frames with field value *<Initial value>*, increase the value
         with *<Value step>* until the *<Maximum value>* is reached.

         When maximum value is reached, the modifier will return to the minimum
         value again. So if the *<Maximum value>* is reached, the next value will
         be the *<Minimum value>*.

       - Negative value step
         A frame with a FrameFieldModifierIncremental installed, will start sending
         frames with field value *<Initial value>*, increase the value with (the
         *negative*) *<Value step>* (thus *decrease* the value) until the
         *<Minimum value>* is reached.

         When the minimum value is reached, the modifier will return to the maximum
         value again. So if the *<Minimum value>* is reached, the next value will
         be the *<Maximum value>*.

    .. note:: When the *<Initial value>* is smaller than the *<Minimum value>*
              when the stream is started, then the minimum value will be used as
              initial value. When the *<Initial value>* is greater than the
              *<Maximum value>* when the stream is started, then the maximum value
              will be used as initial value.

    .. note:: If automatic checksum and/or length calculations have been enabled
              on the Frame and the frame field overlaps one or more of those. Then
              the automatic fields will overrule the field modifier value. This
              depends on the configuration of the Frame. See the Frame
              documentation on how this can be done.

    .. note:: It is possible that the maximum value is never reached. Depending on
              the *<Value step>* and the Stream configuration (*<NumberOfFrames>*),
              the maximum value will never be reached.

    .. code-block:: python
       :emphasize-lines: 2

        frameModifierIncr = frame.ModifierFieldIncrementalAdd()
        frameModifierIncr.MinimumSet(500)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def OffsetGet(self):
        r"""

        Method to get the current configured field offset within the frame content.

        The field offset is the absolute offset from the start of the frame.

        :return: The field offset which will be used for this incremental value field
                 modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current field offset.

        .. code-block:: python
           :emphasize-lines: 1

           print(frameModifier.OffsetGet())


        """
        return _byteblower.FrameFieldModifierIncremental_OffsetGet(self)

    def OffsetSet(self, inOffset):
        r"""

        Sets the offset of the frame field within the frame content.

        :param offset: Offset of the frame field within the frame content. This value
                       is relative to the start of the frame. The value must be greater
                       or equal than zero and must be smaller than the ByteBlowerPort
                       MDL
                       Default: `56`
        :type offset: int

        :raises ConfigError: When the field offset is out of valid range.

        Example

        This example will set the offset to 88.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifier.OffsetSet(88)


        """
        return _byteblower.FrameFieldModifierIncremental_OffsetSet(self, inOffset)

    def LengthGet(self):
        r"""

        Method to get the current configured field length.

        :return: The field length which will be used for this field modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current field length.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifier.LengthGet())


        """
        return _byteblower.FrameFieldModifierIncremental_LengthGet(self)

    def LengthSet(self, inLength):
        r"""

        Sets the length of the frame field.

        :param length: Length of the frame field. The value must be greater than zero
                       and smaller than 8 (as for server version 2.3.x)
                       Default: `2`
        :type length: int

        :raises ConfigError:  When the field length is not supported by the server.

        Example

        This example will set the field length to 4.

        .. code-block:: python
           :emphasize-lines: 1

           frameModifier.LengthSet(4)


        """
        return _byteblower.FrameFieldModifierIncremental_LengthSet(self, inLength)

    def InitialValueGet(self):
        r"""

        Method to get the current configured initial field value.

        :return: The initial field value which will be used for this incremental value
                 field modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current initial field value.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifierIncr.InitialValueGet())


        """
        return _byteblower.FrameFieldModifierIncremental_InitialValueGet(self)

    def InitialValueSet(self, inInitialValue):
        r"""

        Sets the initial value of the frame field.

        :param initial: Initial value of the frame field. When the initial value is
                        smaller than the *<Minimum value>* when the stream is started,
                        then the minimum value will be used as initial value. When the
                        initial value is greater than the *<Maximum value>* when the
                        stream is started, then the maximum value will be used as
                        initial value.
                        Default: `0`
        :type initial: int

        This value will be used when a Stream is started.

        Example

        This example will set the initial value to 1024.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.InitialValueSet(1024)


        """
        return _byteblower.FrameFieldModifierIncremental_InitialValueSet(self, inInitialValue)

    def MinimumGet(self):
        r"""

        Method to get the current configured minimum field value.

        :return: The minimum field value which will be used for this incremental value
                 field modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current minimum field value.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifierIncr.MinimumGet())


        """
        return _byteblower.FrameFieldModifierIncremental_MinimumGet(self)

    def MinimumSet(self, inMinValue):
        r"""

        Sets the Minimum value of the frame field for an incremental value field modifier.

        :param minimum: Minimum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be less than
                        the *<Maximum value>* configured.
                        Default: `0`
        :type minimum: int

        :raises ConfigError: Minimum too small or too big.

        Example

        This example will set the minimum value to 512.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.MinimumSet(512)


        """
        return _byteblower.FrameFieldModifierIncremental_MinimumSet(self, inMinValue)

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum field value.

        :return: The maximum field value which will be used for this incremental value
                 field modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current maximum field value.

        .. code-block:: python
           :emphasize-lines: 1

           print(frameModifierIncr.MaximumGet())


        """
        return _byteblower.FrameFieldModifierIncremental_MaximumGet(self)

    def MaximumSet(self, inMaxValue):
        r"""

        Sets the maximum value of the frame field for an incremental value field modifier.

        :param maximum: Maximum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be greater
                        than the *<Minimum value>* configured.
                        Default: `65535`
        :type maximum: int

        :raises ConfigError: Maximum too big or too small.

        Example

        This example will set the maximum value to 16383 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.MaximumSet(16383)


        """
        return _byteblower.FrameFieldModifierIncremental_MaximumSet(self, inMaxValue)

    def StepGet(self):
        r"""

        Method to get the current configured value step.

        :return: The value step which will be used for an incremental value field
                 modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current value step.

        .. code-block:: python
           :emphasize-lines: 1

           print(frameModifierIncr.StepGet())


        """
        return _byteblower.FrameFieldModifierIncremental_StepGet(self)

    def StepSet(self, inStep):
        r"""

        Sets the value a field value will grow in one step.

        Each time the modifier needs to adapt the value of the frame field, it will be
        incremented with *<Value step>*.

        :param step: This parameter defines the amount the field value will grow. This
                     value can be positive or negative.
                     Default: `1`
        :type step: int

        :raises ConfigError: An error is returned when the value is zero.

        Example

        This example demonstrates a value step of 10:

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.StepSet(10)

        This example demonstrates a negative value step of 2:

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.StepSet(-2)


        """
        return _byteblower.FrameFieldModifierIncremental_StepSet(self, inStep)

# Register FrameFieldModifierIncremental in _byteblower:
_byteblower.FrameFieldModifierIncremental_swigregister(FrameFieldModifierIncremental)
class FrameFieldModifierRandom(FrameFieldModifier):
    r"""

    A frame field modifier which will change the field value of the frame randomly
    between a minimum and maximum value.

    .. versionadded:: 2.3.0

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The FrameFieldModifierRandom is a modifier
    which modifies a certain field in the frame content.

    A frame field is a number of subsequent bytes in the frame content. The value
    is defined as host-ordering signed integer and will be written to the frame
    content as network-ordering signed integer.

    A FrameFieldModifierRandom will change the value in the frame field randomly.
    The following parameters can be configured:

    1. Parameters related to the location of the field in the frame:

       Field offset
           Offset of the field counted in bytes from the start of the frame.

       Field length
           Length of the field counted in  bytes. Minimum: 1Byte. Maximum: 8Bytes
           (depends on server version).

       The field cannot overwrite the 4 bytes Ethernet checksum. The allowed range
       for offset is 0 ... *<ByteBlowerPort MDL>*.

       - When the field offset is greater or equal than the actual frame size,
         nothing will be written to the frame.

       - When the field offset is smaller than the actual frame size, but the
         field offset + field length exceeds the frame size.

         Then the LSB part of the field will be written to the frame.

       Please note that in both cases the field value will still move on to the next value.

    2. Parameters related to the value written to the field:

       Minimum value
           The minimum field value.

       Maximum value
           The maximum field value.

       The field value range is defined by the minimum and maximum value (both
       values inclusive).

       So, a frame with a FrameFieldModifierRandom installed, will start sending
       frames with field values randomly chosen between *<Minimum value>* and
       *<Maximum value>*. Each time a frame is sent, a new value is selected.

    .. note:: If automatic checksum and/or length calculations have been enabled on
              the Frame and the frame field overlaps one or more of those. Then the
              automatic fields will overrule the field modifier value. This depends
              on the configuration of the Frame. See the :class:`.Frame`
              documentation on how this can be done.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def OffsetGet(self):
        r"""

        Method to get the current configured field offset within the frame content.

        The field offset is the absolute offset from the start of the frame.

        :return: The field offset which will be used for this incremental value field
                 modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current field offset.

        .. code-block:: python
           :emphasize-lines: 1

           print(frameModifier.OffsetGet())


        """
        return _byteblower.FrameFieldModifierRandom_OffsetGet(self)

    def OffsetSet(self, inOffset):
        r"""

        Sets the offset of the frame field within the frame content.

        :param offset: Offset of the frame field within the frame content. This value
                       is relative to the start of the frame. The value must be greater
                       or equal than zero and must be smaller than the ByteBlowerPort
                       MDL
                       Default: `56`
        :type offset: int

        :raises ConfigError: When the field offset is out of valid range.

        Example

        This example will set the offset to 88.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifier.OffsetSet(88)


        """
        return _byteblower.FrameFieldModifierRandom_OffsetSet(self, inOffset)

    def LengthGet(self):
        r"""

        Method to get the current configured field length.

        :return: The field length which will be used for this field modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current field length.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifier.LengthGet())


        """
        return _byteblower.FrameFieldModifierRandom_LengthGet(self)

    def LengthSet(self, inLength):
        r"""

        Sets the length of the frame field.

        :param length: Length of the frame field. The value must be greater than zero
                       and smaller than 8 (as for server version 2.3.x)
                       Default: `2`
        :type length: int

        :raises ConfigError:  When the field length is not supported by the server.

        Example

        This example will set the field length to 4.

        .. code-block:: python
           :emphasize-lines: 1

           frameModifier.LengthSet(4)


        """
        return _byteblower.FrameFieldModifierRandom_LengthSet(self, inLength)

    def MinimumGet(self):
        r"""

        Method to get the current configured minimum field value.

        :return: The minimum field value which will be used for this random value field
                 modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current minimum field value.

        .. code-block:: python
           :emphasize-lines: 1

           print(frameModifierRnd.MinimumGet())


        """
        return _byteblower.FrameFieldModifierRandom_MinimumGet(self)

    def MinimumSet(self, inMinValue):
        r"""

        Sets the Minimum value of the frame field for a random value field modifier.

        :param minimum: Minimum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be less than
                        the *<Maximum value>* configured.
                        Default: `0`
        :rtype: int
        :raises ConfigError: Minimum too small or too big.

        Example

        This example will set the minimum value to 512.

        .. code-block:: python
           :emphasize-lines: 1

           frameModifierRnd.MinimumSet(512)


        """
        return _byteblower.FrameFieldModifierRandom_MinimumSet(self, inMinValue)

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum field value.

        :return: The maximum field value which will be used for this random value field
                 modifier.
        :rtype: int

        Example

        This example shows how to retrieve the current maximum field value.

        .. code-block:: python
           :emphasize-lines: 1

           print(frameModifierRnd.MaximumGet())


        """
        return _byteblower.FrameFieldModifierRandom_MaximumGet(self)

    def MaximumSet(self, inMaxValue):
        r"""

        Sets the maximum value of the frame field for a random value field modifier.

        :param maximum: Maximum value for the frame field. This value is limited to
                        64-bit signed integer range. Thevalue must always be greater
                        than the *<Minimum value>* configured.
                        Default: `65535`
        :type maximum: int

        :raises ConfigError: Maximum too big or too small.

        Example

        This example will set the maximum value to 16383 bytes.

        .. code-block:: python
           :emphasize-lines: 1

           frameModifierRnd.MaximumSet(16383)


        """
        return _byteblower.FrameFieldModifierRandom_MaximumSet(self, inMaxValue)

# Register FrameFieldModifierRandom in _byteblower:
_byteblower.FrameFieldModifierRandom_swigregister(FrameFieldModifierRandom)
class FrameSizeModifierResultSnapshot(AbstractRefreshableResult):
    r"""

    A collection of statistics containing the results of a frame size modifier.

    There are currently 2 frame size modifiers available:

    - The :class:`FrameSizeModifierGrowing`, which is the Growing Size modifier
    - The :class:`FrameSizeModifierRandom`, which is the Random Size modifier.

    Example

    This example shows how to retrieve the number of packets handled by a
    FrameSizeModifierGrowing

    .. code-block:: python

       resultSnapshot = sizeModifierRandom.ResultGet()
       print(resultSnapshot.PacketCountGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: The timestamp of this snapshot in nanoseconds since epoch
        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :return: The timestamp of the first transmitted frame in nanoseconds since epoch
        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampFirstGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the timestamp [NS] of the last packet in this snapshot.

        :return: The timestamp of the last transmitted frame in nanoseconds since epoch
        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampLastGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampLastGet(self)

    def ByteCountGet(self):
        r"""

        Returns the number of transmitted bytes.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.ByteCountGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Returns the size of the biggest transmitted frame.

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.FramesizeMaximumGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Returns the size of the smallest transmitted frame.

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.FramesizeMinimumGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountGet(self, *args):
        r"""

        Returns the number of transmitted packets.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.PacketCountGet())


        Returns the number of transmitted packets.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.PacketCountGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountGet(self, *args)

    def PacketCountBelowMinimumGet(self):
        r"""

        Returns the number of transmitted packets with a smaller size than configured.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.PacketCountBelowMinimumGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        r"""

        Returns the number of transmitted packets with a size larger than maximally configured.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.PacketCountAboveMaximumGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountAboveMaximumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        :return: the duration of this sample in nanoseconds
        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.IntervalDurationGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :return: The timestamp in nanoseconds when the counters were last refreshed
                 in nanoseconds since epoch
        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.RefreshTimestampGet())


        """
        return _byteblower.FrameSizeModifierResultSnapshot_RefreshTimestampGet(self)

# Register FrameSizeModifierResultSnapshot in _byteblower:
_byteblower.FrameSizeModifierResultSnapshot_swigregister(FrameSizeModifierResultSnapshot)
class FrameSizeModifier(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DEFAULT_MIN_SIZE = _byteblower.FrameSizeModifier_DEFAULT_MIN_SIZE
    DEFAULT_MAX_SIZE = _byteblower.FrameSizeModifier_DEFAULT_MAX_SIZE

    def ResultGet(self):
        r"""

        Returns the accumulated counters.

        :rtype: FrameSizeModifierResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultSnapshot = sizeModifierRandom.ResultGet()


        """
        return _byteblower.FrameSizeModifier_ResultGet(self)

    def FrameGet(self):
        r"""


        :meta private:


        """
        return _byteblower.FrameSizeModifier_FrameGet(self)

# Register FrameSizeModifier in _byteblower:
_byteblower.FrameSizeModifier_swigregister(FrameSizeModifier)
class FrameSizeModifierGrowing(FrameSizeModifier):
    r"""

    A frame size modifier which will increase the size of the frame between a minimum and maximum value.

    .. versionadded:: 2.3.0

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The :class:`FrameSizeModifierGrowing` is a
    modifier which modifies the size of the frame.

    A FrameSizeModifierGrowingSize will increment the frame size with a configured
    amount of bytes. The following parameters can be configured:

    Minimum size
        the minimum frame size. This size will be used when the Stream is started.

    Maximum size
        the maximum frame size. It this limit is reached, the modifier will return
        to the minimum size again.

    Step size
        the amount of bytes the size will increase. By default, a frame will grow
        with one byte but this parameter allows larger step sizes.

    Iteration
        this parameter defines the number of times the same frame size is iterated
        before increasing to the next frame size.

    So, a frame with a FrameSizeModifierGrowingSize installed, will start sending
    frames with a *<Minimum size>* size, will send this size *<Iteration>* times,
    increase the size with *<Step size>* bytes until the *<Maximum size>* is
    reached.

    If the maximum size is reached, the next size is calculated as follows:

        *<next size>* = *<Minimum size>* + ( *<current size>* + *<Step size>* - *<Maximum size>* )

    All sizes define a frame size, excluding the 4 bytes Ethernet checksum.

    The frame size modifier will change the size of the Frame. If the original
    frame size is longer, the size will truncated to the requested frame size. If
    automatic checksum calculations have been enabled on the Frame, they will be
    recalculated. This depends on the configuration of the Frame. See the
    :class:`.Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    .. note:: It is possible that the maximum size is never reached. Depending on
              both the  *<Step size>* and the Stream configuration
              (NumberOfFrames), the maximum size will never be used.
    Example

    This example will set the minimum frame size to 128 bytes.

    .. code-block:: python
       :emphasize-lines: 2

       sizeModifierGrowing = frame.ModifierSizeGrowingSet()
       sizeModifierGrowing.MinimumSet(128)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DEFAULT_ITERATION = _byteblower.FrameSizeModifierGrowing_DEFAULT_ITERATION
    DEFAULT_STEP_SIZE = _byteblower.FrameSizeModifierGrowing_DEFAULT_STEP_SIZE

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a growing size flow.
        :rtype: int

        Example

        This example shows how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.MaximumGet())


        """
        return _byteblower.FrameSizeModifierGrowing_MaximumGet(self)

    def MaximumSet(self, inMaxSize):
        r"""

        Sets the maximum size of a Frame of a growing size flow. This defines the maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.
                        Default: 1514
        :type maximum: int

        :raises: python_error Maximum too big or too small.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.MaximumSet(128)


        """
        return _byteblower.FrameSizeModifierGrowing_MaximumSet(self, inMaxSize)

    def MinimumGet(self):
        r"""

        Method to get the current configured minimum frame size.

        :return: The minimum frame size which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.MinimumGet())


        """
        return _byteblower.FrameSizeModifierGrowing_MinimumGet(self)

    def MinimumSet(self, inMinSize):
        r"""

        Sets the Minimum size of a Frame of a growing size flow.

        This defines the minimal frame size of the stream. This frame size will be used
        when a Stream is started.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.
                        Default: 60
        :type minimum: int

        :raises ConfigError: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.MinimumSet(128)


        """
        return _byteblower.FrameSizeModifierGrowing_MinimumSet(self, inMinSize)

    def StepGet(self):
        r"""

        Method to get the current configured step size.

        :return: The step size which will be used for a growing size flow.
        :rtype: int

        Example

        This example shows how to retrieve the current step size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.StepGet())


        """
        return _byteblower.FrameSizeModifierGrowing_StepGet(self)

    def StepSet(self, inStep):
        r"""

        Sets the number of bytes a frame will grow in one step.

        :param step: This parameter defines the amount of bytes the frame will grow. Default: `1`
        :type step: int

        :raises: python_error: An error is returned when the value is less than 1.

        Each time the modifier needs to adapt the size of the frame, the size will be
        incremented with *<Step size>* bytes.

        Example

        This example demonstrates a step size of 10 bytes:

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.StepSet(2)


        """
        return _byteblower.FrameSizeModifierGrowing_StepSet(self, inStep)

    def IterationGet(self):
        r"""

        Method to get the current configured iteration.

        :return:  The iteration which will be used for a growing size flow.
        :rtype: int

        Example

        This example shows how to retrieve the current iteration.

        .. code-block:: python
           :emphasize-lines: 1

            iteration = sizeModifierGrowing.IterationGet()


        """
        return _byteblower.FrameSizeModifierGrowing_IterationGet(self)

    def IterationSet(self, inIteration):
        r"""

        Sets the number of times the same frame size will be used.

        :param iteration: Number of times the same frame size will be used before the
                          frame size is increased to the next value. Default: `1`
        :type iteration: int

        A Frame can be sent with the same frame size multiple times before the size is
        increased to the next value. This parameter defines the iteration count.

        Example

        This example demonstrates an iteration of 10, before going to the next frame
        size.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.IterationSet(10)


        """
        return _byteblower.FrameSizeModifierGrowing_IterationSet(self, inIteration)

# Register FrameSizeModifierGrowing in _byteblower:
_byteblower.FrameSizeModifierGrowing_swigregister(FrameSizeModifierGrowing)
class FrameSizeModifierRandom(FrameSizeModifier):
    r"""

    A frame size modifier which will change the size of the frame randomly between a minimum and maximum value.

    .. versionadded:: 2.3.0

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The FrameModifierRandomSize is a modifier
    which modifies the size of the frame.

    A FrameModifierRandomSize will change the frame size randomly. The following
    parameters can be configured:

    Minimum size
        the minimum frame size.

    Maximum size
        the maximum frame size.

    So, a stream with a FrameModifierRandomSize installed, will start sending
    frames with a size randomly chosen between *<Minimum size>* size and
    *<Maximum size>* size. Each time a frame is sent, a new size is selected.

    All sizes are without the additional 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. If the original frame size is bigger, the size will truncated to the
    requested frame size. If automatic checksum calculations have been enabled on
    the Frame, they will be recalculated. This depends on the configuration of the
    Frame. See the :class:`.Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    This example will set the maximum frame size to 128 bytes.

    .. code-block:: python

        sizeModifierRandom = frame.ModifierSizeRandomSet()
        sizeModifierRandom.MaximumSet(128)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def StreamGet(self):
        r"""


        :meta private:


        """
        return _byteblower.FrameSizeModifierRandom_StreamGet(self)

    def MinimumSet(self, inMinimum):
        r"""

        Sets the Minimum size of a Frame of a flow with FrameModifierRandomSize.

        This defines the minimal frame size of the stream.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.
                        Default: 60
        :type minimum: int

        :raises ConfigError: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierRandom.MinimumSet(128)


        """
        return _byteblower.FrameSizeModifierRandom_MinimumSet(self, inMinimum)

    def MinimumGet(self):
        r"""

        Method to get the currently configured minimum frame size.

        :return: The minimum frame size which will be used for a random size flow.
        :rtype: int

        Example

        This example shows how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierRandom.MinimumGet())


        """
        return _byteblower.FrameSizeModifierRandom_MinimumGet(self)

    def MaximumSet(self, inMaximum):
        r"""

        Sets the Maximum size of a Frame of a flow with FrameModifierRandomSize.

        This defines the maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.
                        Default: 1514
        :type maximum: int

        :raises ConfigError: Minimum too small or too big.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierRandom.MaximumSet(128)


        """
        return _byteblower.FrameSizeModifierRandom_MaximumSet(self, inMaximum)

    def MaximumGet(self):
        r"""

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a random size flow.
        :rtype: int

        Example

        This example shows how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierRandom.MaximumGet())


        """
        return _byteblower.FrameSizeModifierRandom_MaximumGet(self)

# Register FrameSizeModifierRandom in _byteblower:
_byteblower.FrameSizeModifierRandom_swigregister(FrameSizeModifierRandom)
class FrameResultData(AbstractObject):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampGet())


        """
        return _byteblower.FrameResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets  the timestamp [NS] of the first packet in this snapshot.

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampFirstGet())


        """
        return _byteblower.FrameResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampLastGet())


        """
        return _byteblower.FrameResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the transmitted packets.

        :rtype: int

        Example

        This example gets the transmitted packets

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.PacketCountGet())


        """
        return _byteblower.FrameResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current transmitted bytes.

        :rtype: int

        Example

        This example gets the transmitted bytes

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.ByteCountGet())


        """
        return _byteblower.FrameResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame transmitted in this snapshot.

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the largest framesize transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.FramesizeMaximumGet())


        """
        return _byteblower.FrameResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame transmitted in this snapshot.

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the smallest framesize transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.FramesizeMinimumGet())


        """
        return _byteblower.FrameResultData_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

           print(frameData.IntervalDurationGet())


        """
        return _byteblower.FrameResultData_IntervalDurationGet(self)

# Register FrameResultData in _byteblower:
_byteblower.FrameResultData_swigregister(FrameResultData)
class FrameResultSnapshot(AbstractRefreshableResult):
    r"""


    .. todo:: add documentation


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        Example

        :rtype: int

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampGet())


        """
        return _byteblower.FrameResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampFirstGet())


        """
        return _byteblower.FrameResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampLastGet())


        """
        return _byteblower.FrameResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the transmitted packets.

        Example

        This example gets the transmitted packets

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.PacketCountGet())


        """
        return _byteblower.FrameResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current transmitted bytes.

        Example

        This example gets the transmitted bytes

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.ByteCountGet())


        """
        return _byteblower.FrameResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame transmitted in this snapshot.

        .. versionadded:: 2.5.0

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the largest frame size transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.FramesizeMaximumGet())


        """
        return _byteblower.FrameResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame transmitted in this snapshot.

        .. versionadded:: 2.5.0

        :rtype: int
        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the smallest frame size transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.FramesizeMinimumGet())


        """
        return _byteblower.FrameResultSnapshot_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        :return: The duration of this interval in nanoseconds
        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.IntervalDurationGet())


        """
        return _byteblower.FrameResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameSnapshot.RefreshTimestampGet()


        """
        return _byteblower.FrameResultSnapshot_RefreshTimestampGet(self)

# Register FrameResultSnapshot in _byteblower:
_byteblower.FrameResultSnapshot_swigregister(FrameResultSnapshot)
class FrameResultDataList(object):
    r"""

    This is a List of multiple FrameResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.FrameResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameResultDataList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.FrameResultDataList_swiginit(self, _byteblower.new_FrameResultDataList(*args))
    __swig_destroy__ = _byteblower.delete_FrameResultDataList

# Register FrameResultDataList in _byteblower:
_byteblower.FrameResultDataList_swigregister(FrameResultDataList)
class FrameResultHistory(AbstractRefreshableResult):
    r"""

    Sender-side frame transmission result history.

    .. versionadded:: 2.1.0

    The history contains the sender information in time since the object is
    created or refreshed.

    .. note:: The information is not updated until :obj:`~.AbstractObject.Refresh` 
              is called on this object.

    A Frame history result object can be created via

    - Frame, using :meth:`.Frame.ResultHistoryGet`

    - FrameMobile, using :meth:`.FrameMobile.ResultHistoryGet`

    .. note:: See History result for more information

    Example

    Get the counters per *sampling interval* for the frame result history.

    .. code-block:: python
       :emphasize-lines: 1

        print(frameData.FrameResultHistory())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Removes the locally stored history snapshots.

        This can be used to save memory in long tests where the results are requested
        at regular intervals.

        .. warning:: Any interval or cumulative result object returned from this
                     history object before calling Clear will be destoyed and thus
                     become unusable.

        """
        return _byteblower.FrameResultHistory_Clear(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Returns the duration of the interval used for the history snapshots.

        The returned duration is in nanoseconds

        :return: interval in nanoseconds used by the server
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.SamplingIntervalDurationGet())


        """
        return _byteblower.FrameResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. versionadded:: 2.3.0

        .. warning:: The previously collected historywill be invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameHistory.SamplingIntervalDurationSet(1000)


        """
        return _byteblower.FrameResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthGet(self):
        r"""

        Returns the number of the snapshots to keep in the history.

        :return: number of snapshots to keep in the history
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.SamplingBufferLengthGet())


        """
        return _byteblower.FrameResultHistory_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, inCount):
        r"""

        Sets the number of samples to keep in the buffer.

        .. versionadded:: 2.3.0

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameHistory.SamplingBufferLengthSet(100)


        """
        return _byteblower.FrameResultHistory_SamplingBufferLengthSet(self, inCount)

    def CumulativeGet(self):
        r"""

        Returns a list of available accumulated results.

        :rtype: FrameResultDataList

        Example

        This example gets the available accumulated results

        .. code-block:: python
           :emphasize-lines: 1

            historyList = frameHistory.CumulativeGet()


        """
        return _byteblower.FrameResultHistory_CumulativeGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        :rtype: FrameResultDataList

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGet().DescriptionGet())


        """
        return _byteblower.FrameResultHistory_IntervalGet(self)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(frameHistory.CumulativeLengthGet())


        """
        return _byteblower.FrameResultHistory_CumulativeLengthGet(self)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalLengthGet())


        """
        return _byteblower.FrameResultHistory_IntervalLengthGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a list of available cumulative counters.

        :rtype: FrameResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.CumulativeGetByIndex(0))


        """
        return _byteblower.FrameResultHistory_CumulativeGetByIndex(self, index)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a list of available interval counters.

        :type index: int

        :rtype: FrameResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGetByIndex(0).DescriptionGet())


        """
        return _byteblower.FrameResultHistory_IntervalGetByIndex(self, index)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        :type interval: int

        :rtype: FrameResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(CumulativeGetByTime(timestamp))


        """
        return _byteblower.FrameResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        :type timestamp: int

        :rtype: FrameResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGetByTime(timestamp))


        """
        return _byteblower.FrameResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :rtype: FrameResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.CumulativeLatestGet())


        """
        return _byteblower.FrameResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :rtype: FrameResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalLatestGet().DescriptionGet())


        """
        return _byteblower.FrameResultHistory_IntervalLatestGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the latest timestamp when the history was refreshed.

        :return:  Timestamp in nanoseconds (since epoch)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.RefreshTimestampGet())


        """
        return _byteblower.FrameResultHistory_RefreshTimestampGet(self)

# Register FrameResultHistory in _byteblower:
_byteblower.FrameResultHistory_swigregister(FrameResultHistory)
class Frame(AbstractObject):
    r"""

    Class: Frame

    A ByteBlower Frame is an object representing a Frame which can be used in a
    :class:`Stream` for transmission by a ByteBlower Port.

    A Frame is used in stateless traffic testing. It will be sent by a
    ByteBlowerPort. For each Frame, different options can be enabled:

    1. Tagging

       - Sequence: Defines if a sequence number must be set. This is used for
         out-of-sequence detection.

       - Timestamping: Defines if the timestamp of transmission must be set in the
         frame. This is used for latency measurements.

    2. Checksumming

       - L3: IPv4/IPv6 automatic header checksumming.

       - L4: UDP/TCP automatic checksumming.

    3. Length field correction

       - L3: Automatic correction of the IPv4 length field. This is usefull when
         using a FrameSizeModifier.

       - L7: Automatic correction of the UDP/TCP length field. This is usefull
         when using a FrameSizeModifier.

    Also the frame can be modified during the test
    using modifiers:

    1. Field

       - Incremental: A field in the frame will be incremented every time the frame
         is sent out. The field's position and size is configurable.

       - Random: A field in the frame will be a random value every time the frame
         is sent out. The field's position and size is configurable.

    2. Size

       - GrowingSize: The frame will grow between a minimum and a maximum value.
         When the maximum value is reached, the frame resizes to the given minimum.

       - RandomSize: The frame will have a different size every time it is sent
         out. The sizes will be random between a given minimum and maximum size.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BytesSet(self, frameString):
        r"""

        A method which sets the content of a Frame in a hexadecimal format.

        :param bytes: Bytes can be of any of the formats mentioned above.
                      The length must be at least 60 bytes
        :type bytes: str

        :raises ConfigError: When the frame is too small (<60 bytes) or when the frame is too big (>8192)
        :raises ConfigError: When the value does contain non-hexadecimal characters or when the length is not even.

        This method will change the content of a Frame. A ByteBlower Frame is an
        Ethernet Frame excluding the four CRC bytes. The value can be in different
        formats, e.g.

        1. 0x01 0x02 0x03 0x04 0x05 ...

        2. 0001020304050607

        3. 00 01 02 03 04 05 ...

        .. note:: You can call this method even during transmission of a flow, the
                  value will be updated in real-time.

        Example

        .. code-block:: python
           :caption: Set the content for a frame

           # Layer2 (without CRC) size.
           frame_size = 1000  # bytes

           # Add a frame
           frame = stream.FrameAdd()

           # create some payload, we need scapy for that

           # frame_size is ethernet length, we substract the length of the
           # ethernet, IP and UDP header
           payload = 'a' * (frame_size - 42)

           from scapy.layers.inet import Raw
           scapy_udp_payload = Raw(payload.encode('ascii', 'strict'))

           payload_array = bytearray(bytes(scapy_udp_payload))

           # The API expects a 'str', so we need to make a string of the payload
           payload_str = ''.join((format(b, '02x') for b in payload_array)

           frame.BytesSet(payload_str)


        """
        return _byteblower.Frame_BytesSet(self, frameString)

    def BytesGet(self):
        r"""

        A method which returns the current content of a Frame in a hexadecimal format.

        This method will return the current content of a Frame. A ByteBlower Frame is an
        Ethernet Frame, excluding the frame check sequence ( aka CRC ).

        .. note:: The real content of a Frame can differ if Modifiers such as the
                  FrameSizeModifier are applied on the Flow containing this Frame.

        :return: This method returns the content in a hexadecimal string. All bytes are
                 concatenated into one string.

        Example

        The current content of a frame can be requested like this:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.BytesGet())


        """
        return _byteblower.Frame_BytesGet(self)

    def FrameTagTimeGet(self):
        r"""

        Returns the FrameTagTx object related to the timestamp injection for this frame.

        .. versionadded:: 1.8.18

        :return: TimeTag injection configuration for this frame.
        :rtype: FrameTagTx

        Each frame can be enabled to have a timestamp inserted into the frame.

        The :class:`FrameTagTx` object which is returned by this method represents the
        current configuration of the TimeTag injection. This object can be used to
        configure the TimeTag injection.

        For more detailed information about Frame tagging, you can also take a look at
        ByteBlower API Knowledgebase: Background: Adding FrameTags to your ByteBlower
        frame - structure and behaviour

        .. warning:: On older ByteBlower servers, this requires a lot of resources, so
                     this option must be used with care.

        Example

        In this example, we will retrieve the FrameTagTx object for the TimeTag:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.FrameTagTimeGet().DescriptionGet())


        """
        return _byteblower.Frame_FrameTagTimeGet(self)

    def FrameTagSequenceGet(self):
        r"""

        Returns the FrameTag.Tx object related to the sequence number injection for this frame.

        .. versionadded:: 1.8.18

        :rtype: FrameTagTx

        Each frame can be enabled to have a sequence number inserted into the frame.

        The :class:`.FrameTagTx` object which is returned by this method represents
        the current configuration of the SequenceTag injection. This object can be
        used to configure the SequenceTag injection.

        .. warning:: On older ByteBlower servers, this requires a lot of resources, so
                     this option must be used with care.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.FrameTagSequenceGet().DescriptionGet())


        """
        return _byteblower.Frame_FrameTagSequenceGet(self)

    def L3AutoChecksumEnable(self, value):
        r"""

        Enable or disable the automatic checksum calculation of the Layer3 header of this frame.

        :param enable: True will enable the automatic Layer3 checksum calculation. 
                       False will disable the automatic Layer3 checksum calculation.
                       (Default: False/Disabled)
        :type enable: bool

        This method provides the possibility to automatically recalculate the Layer3
        checksum. Currently, only IPv4 is supported ( IPv6 has no header checksum ).
        This calculation will be done at the server side, just before transmitting the
        frame.

        By default, the Layer3 checksum will not be calculated automatically.

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier or with a FrameTag. In such a
                  situation, the length or content of the Frame will change each time
                  the frame has been sent, so the checksum must be calculated at the
                  server side.

        Example

        This example will enable the automatic Layer3 checksum calculation:

        .. code-block:: python
           :emphasize-lines: 1

           frame.L3AutoChecksumEnable(True)


        """
        return _byteblower.Frame_L3AutoChecksumEnable(self, value)

    def L3AutoChecksumGet(self):
        r"""

        Method returning the current configuration of the automatic checksum calculation option.

        :return: True if enabled, False if disabled. (Default: False/Disabled)
        :rtype: bool

        This method returns the current configuration of the automatic Layer3 checksum
        calculation.

        See :meth:`.Frame.L3AutoChecksumEnable` on how to enable this feature.

        Example

        This examples shows the result when the Layer3 automatic checksum calculation
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.L3AutoChecksumGet())


        """
        return _byteblower.Frame_L3AutoChecksumGet(self)

    def L3AutoLengthEnable(self, value):
        r"""

        Enable or disable the automatic Layer3 header length field calculation of this frame.

        :param enable: True will enable the automatic Layer3 length field adaption. 
                       False will disable the automatic Layer3 length field adaption.
                       (Default: False/Disabled)
        :type enable: bool

        This method provides the possibility to automatically recalculate the Layer3
        length field. This calculation will be done at the server side, just before
        transmitting the frame.

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the :class:`.FrameSizeModifier`. In such a situation,
                  the length of the Frame can change each time the frame has been sent,
                  so the length field must be adapted at the server side.

        Example

        This example will enable the automatic Layer3 length field adaption: This
        example will disable the automatic Layer3 length field adaption:

        .. code-block:: python
           :emphasize-lines: 1

           frame.L3AutoLengthEnable(True)


        """
        return _byteblower.Frame_L3AutoLengthEnable(self, value)

    def L3AutoLengthGet(self):
        r"""

        Method returning the current configuration of the automatic Layer3 length field adaption option.

        This method returns the current configuration of the automatic Layer3 length
        field adaption.

        See :meth:`.Frame.L3AutoLengthEnable` on how to enable this option.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the automatic Layer3 length field
        adaption option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.L3AutoLengthGet())


        """
        return _byteblower.Frame_L3AutoLengthGet(self)

    def L4AutoChecksumEnable(self, value):
        r"""

        Enable or disable the automatic Layer4 checksum calculation of this frame.

        :param enable: True will enable the automatic Layer4 checksum calculation. 
                       False will enable the automatic Layer4 checksum calculation.
                       (Default: False/Disabled)
        :type enable: bool

        This method provides the possibility to automatically recalculate the Layer4
        (UDP or TCP) checksum. This calculation will be done at the server side, just
        before transmitting the frame.

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier or FrameTag. In such a situation,
                  the length or content of the Frame can change each time the frame has
                  been sent, so the checksum must be recalculated at the server side.

        Example

        This example will enable the automatic Layer4 checksum calculation:  This
        example will disable the automatic Layer3 checksum calculation:

        .. code-block:: python
           :emphasize-lines: 1

           frame.L4AutoChecksumEnable(True)


        """
        return _byteblower.Frame_L4AutoChecksumEnable(self, value)

    def L4AutoChecksumGet(self):
        r"""

        Method returning the current configuration of the automatic Layer4 checksum recalculation option.

        :return: True if enabled, False if disabled. (Default: False/Disabled)
        :rtype: bool

        This method returns the current configuration of the automatic Layer4 checksum
        recalculation.

        See :meth:`.Frame.L4AutoChecksumEnable` on how to enable this option.

        Example

        This examples shows the result when the automatic Layer4 checksum recalculation
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.L4AutoChecksumGet()


        """
        return _byteblower.Frame_L4AutoChecksumGet(self)

    def L4AutoLengthEnable(self, value):
        r"""

        Enable or disable the automatic Layer4 header length field calculation of this frame.

        :param enable: True will enable the automatic Layer4 length field adaption.  
                       False will enable the automatic Layer4 length field adaption.
                       (Default: Disabled/False)
        :type enable: bool

        This method provides the possibility to automatically recalculate the Layer4
        (UDP or TCP) length field. This calculation will be done at the server side,
        just before transmitting the frame.

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier. In such a situation, the length
                  of the Frame can change each time the frame has been sent, so the
                  length field must be adapted at the server side.
        Example

        This example will enable the automatic Layer4 length field adaption:

        .. code-block:: python
           :emphasize-lines: 1

           frame.L4AutoLengthEnable(True)


        """
        return _byteblower.Frame_L4AutoLengthEnable(self, value)

    def L4AutoLengthGet(self):
        r"""

        Method returning the current configuration of the automatic Layer4 length field adaption option.

        :return: True if enabled, False if disabled.  (Default: False/Disabled)
        :rtype: bool

        This method returns the current configuration of the automatic Layer4 length
        field adaption.

        See :meth:`L4AutoLengthEnable` on how to enable this option.

        Example

        This examples shows the result when the automatic Layer4 length field adaption
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.L4AutoLengthGet())


        """
        return _byteblower.Frame_L4AutoLengthGet(self)

    def StreamGet(self):
        r"""


        :meta private:


        """
        return _byteblower.Frame_StreamGet(self)

    def SetL3AutoChecksum(self, b):
        r"""


        :meta private:


        """
        return _byteblower.Frame_SetL3AutoChecksum(self, b)

    def SetL3AutoLength(self, set):
        r"""


        :meta private:


        """
        return _byteblower.Frame_SetL3AutoLength(self, set)

    def SetL4AutoChecksum(self, set):
        r"""


        :meta private:


        """
        return _byteblower.Frame_SetL4AutoChecksum(self, set)

    def SetL4AutoLength(self, set):
        r"""


        :meta private:


        """
        return _byteblower.Frame_SetL4AutoLength(self, set)

    def IsL3AutoChecksumEnabled(self):
        r"""


        :meta private:


        """
        return _byteblower.Frame_IsL3AutoChecksumEnabled(self)

    def IsL3AutoLengthEnabled(self):
        r"""


        :meta private:


        """
        return _byteblower.Frame_IsL3AutoLengthEnabled(self)

    def IsL4AutoChecksumEnabled(self):
        r"""


        :meta private:


        """
        return _byteblower.Frame_IsL4AutoChecksumEnabled(self)

    def IsL4AutoLengthEnabled(self):
        r"""


        :meta private:


        """
        return _byteblower.Frame_IsL4AutoLengthEnabled(self)

    def ModifierFieldIncrementalAdd(self):
        r"""

        Adds an incremental frame field modifier.

        .. versionadded:: 2.5.0

        :rtype: FrameFieldModifierIncremental

        Example

        This example adds an incremental value frame field modifier.

        .. code-block:: python
           :emphasize-lines: 1

           frame.ModifierFieldIncrementalAdd()


        """
        return _byteblower.Frame_ModifierFieldIncrementalAdd(self)

    def ModifierFieldIncrementalGet(self):
        r"""

        Returns the active incremental frame field modifier(s).

        .. versionadded:: 2.5.0

        :rtype: FrameFieldModifierIncremental

        Example

        This example retrieves the current applied field modifiers.

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierFieldIncrementalGet()[0].DescriptionGet())


        """
        return _byteblower.Frame_ModifierFieldIncrementalGet(self)

    def ModifierFieldIncrementalDestroy(self, inModifier):
        r"""

        Returns the active incremental frame field modifier(s).

        .. versionadded:: 2.5.0

        :type modifier: FrameFieldModifierIncremental

        Example

        This example retrieves the current applied field modifiers.

        .. code-block:: python
           :emphasize-lines: 1

           frame.ModifierFieldIncrementalDestroy(modifier)


        """
        return _byteblower.Frame_ModifierFieldIncrementalDestroy(self, inModifier)

    def ModifierFieldRandomAdd(self):
        r"""

        Adds a random frame field modifier.

        .. versionadded:: 2.5.0

        :rtype: FrameFieldModifierRandom

        Example

        This example adds a random value frame field modifier.

        .. code-block:: python
           :emphasize-lines: 1

           frameFieldModifierRandom = frame.ModifierFieldRandomAdd()


        """
        return _byteblower.Frame_ModifierFieldRandomAdd(self)

    def ModifierFieldRandomGet(self):
        r"""

        Returns the active random frame field modifier(s).

        .. versionadded:: 2.5.0

        :rtype: FrameFieldModifierRandom

        Example

        This example retrieves the current applied field modifiers.

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierFieldRandomGet()[0].DescriptionGet())


        """
        return _byteblower.Frame_ModifierFieldRandomGet(self)

    def ModifierFieldRandomDestroy(self, inModifier):
        r"""

        Removes the given Field modifier.

        .. versionadded:: 2.5.0

        :type modifier: FrameFieldModifierRandom

        Example

        .. code-block:: python
           :emphasize-lines: 1

           frame.ModifierFieldRandomDestroy(modifier)


        """
        return _byteblower.Frame_ModifierFieldRandomDestroy(self, inModifier)

    def ModifierSizeGet(self):
        r"""

        Returns the active frame size modifier.

        .. versionadded:: 2.5.0

        :rtype:FrameSizeModifierGrowing|FrameSizeModifierRandom

        Example

        This example gets the current applied growing size modifier

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierSizeGet().DescriptionGet())


        """
        return _byteblower.Frame_ModifierSizeGet(self)

    def ModifierSizeGrowingSet(self):
        r"""

        Sets a growing frame size modifier.

        .. versionadded:: 2.5.0

        :rtype: FrameSizeModifierGrowing

        Example

        This example sets a growing size frame modifier.

        .. code-block:: python
           :emphasize-lines: 1

           growSizeMod = frame.ModifierSizeGrowingSet()


        """
        return _byteblower.Frame_ModifierSizeGrowingSet(self)

    def ModifierSizeRandomSet(self):
        r"""

        Sets a random frame size modifier.

        .. versionadded:: 2.5.0

        :rtype: FrameSizeModifierRandom

        Example

        This example sets a random size frame modifier.

        .. code-block:: python
           :emphasize-lines: 1

           frame.ModifierSizeRandomSet()


        """
        return _byteblower.Frame_ModifierSizeRandomSet(self)

    def ModifierSizeGrowingGet(self):
        r"""

        Returns the active frame growing size modifier.

        .. versionadded:: 2.5.0

        :rtype:FrameSizeModifierGrowing

        Example

        This example gets the current applied growing size modifier

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierSizeGrowingGet().DescriptionGet())


        """
        return _byteblower.Frame_ModifierSizeGrowingGet(self)

    def ModifierSizeRandomGet(self):
        r"""

        Returns the active frame random size modifier.

        .. versionadded:: 2.5.0

        :rtype: FrameSizeModifierRandom

        Example

        This example gets the current applied size modifier. E.g. the random

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierSizeRandomGet().DescriptionGet())


        """
        return _byteblower.Frame_ModifierSizeRandomGet(self)

    def ModifierSizeGrowingDestroy(self, arg2):
        r"""

        Removes the growing size modifier

        .. versionadded:: 2.5.0

        :param modifier: Modifier to destroy
        :type modifier: FrameSizeModifierRandom

        Example

        This example gets the current applied size modifier. E.g. the random

        .. code-block:: python
           :emphasize-lines: 1

           frame.ModifierSizeRandomDestroy(modifier)


        """
        return _byteblower.Frame_ModifierSizeGrowingDestroy(self, arg2)

    def ModifierSizeRandomDestroy(self, arg2):
        r"""

        Removes the random size modifier

        .. versionadded:: 2.5.0

        :param modifier: Modifier to destroy
        :type modifier: FrameSizeModifierRandom

        Example

        This example gets the current applied size modifier. E.g. the random

        .. code-block:: python
           :emphasize-lines: 1

           frame.ModifierSizeRandomDestroy(modifier)


        """
        return _byteblower.Frame_ModifierSizeRandomDestroy(self, arg2)

    def ResultClear(self):
        r"""

        Resets the current transmit counters to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           frame.resultClear()


        """
        return _byteblower.Frame_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current transmit counters.

        :rtype: FrameResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frame.ResultGet().DescriptionGet())


        """
        return _byteblower.Frame_ResultGet(self)

    def ResultHistoryGet(self):
        r"""


        :rtype: FrameResultHistory


        """
        return _byteblower.Frame_ResultHistoryGet(self)

# Register Frame in _byteblower:
_byteblower.Frame_swigregister(Frame)
class FrameMobile(AbstractObject):
    r"""


    .. versionadded:: 2.6.0
    A FrameMobile is an object that configures the payload of a frame belonging to a StreamMobile object.

    A FrameMobile object is used for frame blasting. It is configured by a
    :class:`.StreamMobile` object and will be transmitted by the ByteBlower 
    Endpoint.

    Example

    This example will show how to add a frame to a stream and configure the payload.

    .. code-block:: python
       :emphasize-lines: 2

       frame = stream.FrameAdd()
       frame_tag = frame.FrameTagTimeGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FrameTagTimeGet(self):
        r"""

        Returns the FrameTagTx object related to the timestamp injection for this frame.

        .. versionadded:: 2.6.0

        :rtype: FrameTagTx

        Each frame can be enabled to have a timestamp inserted into the frame.

        The :class:`.FrameTagTx` object which is returned by this method represents the
        current configuration of the TimeTag injection. This object can be used to
        configure the TimeTag injection.

        For more detailed information about Frame tagging, you can also take a look at
        ByteBlower API Knowledgebase: Background: Adding FrameTags to your ByteBlower
        frame - structure and behaviour

        .. warning:: this requires extra resources, so this option must be used with
                     care.

        Example

        In this example, we will retrieve the FrameTagTx object for the TimeTag:

        .. code-block:: python
           :emphasize-lines: 1

           frame_tag = frame.FrameTagTimeGet()


        """
        return _byteblower.FrameMobile_FrameTagTimeGet(self)

    def PayloadSet(self, payloadString):
        r"""

        A method which sets the payload of a frame.

        :param bytes: Bytes can be of any of the formats listed below.
        :type bytes: str

        This method will change the payload of the frame. The value can be in different
        formats, e.g.

        1.  0x01 0x02 0x03 0x04 0x05 ...

        2.  0001020304050607

        3.  00 01 02 03 04 05 ...

        Example

        The content of a frame can be set like this:

        .. code-block:: python
           :emphasize-lines: 1

           frame.PayloadSet('0001020304050607')


        """
        return _byteblower.FrameMobile_PayloadSet(self, payloadString)

    def PayloadGet(self):
        r"""

        A method which returns the payload of a frame.

        :return: This method returns the content in a hexadecimal string. All bytes are
                 concatenated into one string.
        :rtype: str|bytes

        This method will return the UDP payload of the frame in a hexadecimal format.

        Example

        The current content of a frame can be requested like this:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.PayloadGet())


        """
        return _byteblower.FrameMobile_PayloadGet(self)

    def StreamGet(self):
        r"""


        :meta private:


        """
        return _byteblower.FrameMobile_StreamGet(self)

    def ResultClear(self):
        r"""

        Clears the transmit counters.

        This method will clear the transmit counters for this frame.

        .. code-block:: python
           :emphasize-lines: 1

           frame.ResultClear()


        """
        return _byteblower.FrameMobile_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the transmit counters.

        :rtype: FrameResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ResultGet().DescriptionGet())


        """
        return _byteblower.FrameMobile_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current transmit history counters.

        :return: an object representing the frame result history
        :rtype: FrameResultHistory


        """
        return _byteblower.FrameMobile_ResultHistoryGet(self)

# Register FrameMobile in _byteblower:
_byteblower.FrameMobile_swigregister(FrameMobile)
class FrameTag(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeGet(self):
        r"""

        Returns the FrameTag type.

        :rtype: FrameTagType

        Currently two FrameTags are in use:

        - The TimeTag is used for latency measurements and contains a timestamp value.
          The server automatically determines it by looking at its clock for each frame
          sent in the stream.
        - The SequenceTag is used for out of sequence detection and contains a frame
          counter value.
          The server automatically increments it for each frame sent in the stream.

        Example

        This example will return the type of a Sequence Tag:

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.FrameTag_TypeGet(self)

    def FormatGet(self):
        r"""

        Method to set the format.

        :return: This defines the format of the tag
        :rtype format: FrameTagFormat

        Example

        In this example, we set the format of the timestamp to 10 nanoseconds.

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example

        See also: :meth:`FormatStringGet` for details on the tag formats.


        """
        return _byteblower.FrameTag_FormatGet(self)

    def FormatStringGet(self):
        r"""

        This returns the format string of this tag.

        The exact format of the different tags may vary between the different versions
        of the ByteBlower software. To match the receiving part of a flow with then
        transmitting part, it is necessary to configure the same format.

        Each tag format has a unique format code. The following formats are currently
        defined:

        - Sequence Tag: 

          For a Sequence Tag, the following formats exist:

          - SequenceNumber-0_CRC

            this format defines a tag of 8 bytes:

            +--------+--------+--------+--------+--------+--------+--------+--------+
            |    1   |    2   |    3   |    4   |    5   |    6   |    7   |    8   |
            +--------+--------+--------+--------+--------+--------+--------+--------+
            |          SEQUENCE NUMBER                            |       CRC       |
            +-----------------------------------------------------+-----------------+

            The sequence number is incremented for each packet leaving the ByteBlower
            server. The CRC will invert the changes in value so the checksum over the
            full payload remains constant. This makes sure other checksums (e.g. UDP)
            remain valid.

        - Time Tag

          For a Time Tag, two formats are currently defined:

          - TimeStamp-Microseconds_CRC

            .. deprecated:: 2.9.0

            This format is used on pre-1.10.16 software versions on the
            ByteBlower 1000 series. This Tag is 8 bytes long and looks like this:

            +--------+--------+--------+--------+--------+--------+--------+--------+
            |    1   |    2   |    3   |    4   |    5   |    6   |    7   |    8   |
            +--------+--------+--------+--------+--------+--------+--------+--------+
            |             TIMESTAMP MICROSECONDS                  |       CRC       |
            +-----------------------------------------------------+-----------------+

            This format carries the server timestamp when this frame was sent in units
            of  microseconds. The CRC will invert the changes in value so the checksum
            over the full payload remains constant. This makes sure other checksums
            (e.g. UDP) remain valid.

          - TimeStamp-10Nanoseconds

            This format is used by the ByteBlower 2000 series and by the 1000 series
            from version 1.10.18 onwards. This Tag is 8 bytes long, only containing the
            Timestamp in nanoseconds. It does not include a CRC compensation. This
            means that automatic checksum calculation must be enabled on the Frame or
            those CRC values will be incorrect.

        :return: One of SequenceNumber-0_CRC TimeStamp-Microseconds_CRC TimeStamp-10Nanoseconds
        :rtype: str

        Example

        This example will return the type of a Sequence

        .. code-block:: python
           :emphasize-lines: 1

           print(frame_tag.FormatStringGet())


        """
        return _byteblower.FrameTag_FormatStringGet(self)

    def MetricsGet(self):
        r"""

        Returns the FrameTagMetrics of this tag.

        :rtype: FrameTagMetrics

        The FrameTag Metrics represent the configuration like the length and alignment 
        of a tag. This method returns this information for this object.

        Example

        This example will return the FrameTagMetrics object for a sequence tag:

        .. code-block:: python
           :emphasize-lines: 2

           frameTagtx = frame.FrameTagSequenceGet()
           tagMetrics = frameTagtx.MetricsGet()


        """
        return _byteblower.FrameTag_MetricsGet(self)

    def PositionGet(self):
        r"""

        Returns the current configured location of the tag within the Frame.

        :return: Current configured position. If nothing was specified, the default
                 position chosen by the server is returned.
        :rtype: int

        A user can choose where in a the Frame a tag will be placed (TX) or looked
        for (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            +-------------------------------------------+----------------+------+
            | 0                                         |              Position |
            |                                           | <-------------------- |
            +-------------------------------------------+----------------+------+
            | Frame contents                            | TAG            |      |
            +-------------------------------------------+----------------+------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method returns the current configured value for this position.

        Default value

        - At the TX side, the default position places the tag at the end of the frame,
          without overlapping with other enabled tags.
        - At the RX side, the default position is the length of the tag. This means the
          RX side guesses the location of the tag to be at the very end of the frame.
          Note that this guess is incorrect if multiple tags are enabled on a single frame!

        Example

        This example will return the position of a
        sequence tag:

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.FrameTag_PositionGet(self)

    def PositionSet(self, newPosition):
        r"""

        Sets the location of the tag in the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            +-------------------------------------------+---------------+-------+
            |                                           |              Position |
            |                                           | <-------------------- |
            +-------------------------------------------+---------------+-------+
            | Frame contents                            | TAG           |       |
            +-------------------------------------------+---------------+-------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method allows the user to configure this value.

        :param position: The new value of the position. This value must be between
                         *<taglength>* and *<framelength>*.

        Example

        This example will sets the position of a sequence tag:

        TODO


        """
        return _byteblower.FrameTag_PositionSet(self, newPosition)

    def FormatDestroy(self):
        return _byteblower.FrameTag_FormatDestroy(self)

    def MetricsDestroy(self):
        return _byteblower.FrameTag_MetricsDestroy(self)

# Register FrameTag in _byteblower:
_byteblower.FrameTag_swigregister(FrameTag)
class FrameTagTx(FrameTag):
    r"""

    The FrameTagTx class describes the transmit configuration of a Tag in a Frame.

    ByteBlower supports optional tagging of frames. Such a tag can have different
    formats, locations, ...
    These parameters can be set and retrieved using this class.

    Currently, two different types of FrameTags are supported:

    SequenceTag
        is used for out of sequence detection and contains a frame counter value.
        The server automatically increments it for each frame sent in the stream.

    TimeTag
        is used for latency measurements and contains a timestamp value. The server
        automatically determines it by looking at its clock for each frame sent in
        the stream.

    Adding tags is a very powerful and flexible feature of ByteBlower. Please have
    a look at ByteBlower API Knowledgebase: Background: Adding FrameTags to your
    ByteBlower frame - structure and behaviour for a very detailed explanation.

    To perform latency measurements or out of sequence detection, configuration
    needs to be done both at TX and RX side:

    - At the TX side

      we need to add the FrameTag(s) to the Frame object.

    - At the RX side

      we need to create the appropriate receiver(s) on the incoming packets. This
      causes the server to read a tag from the received frames and interpret them
      (e.g. by calculating latency based on the timestamps).


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PositionGet(self):
        r"""

        Returns the current configured location of the tag within the Frame.

        :return: Current configured position. If nothing was specified, the default
                 position chosen by the server is returned.
        :rtype: int

        A user can choose where in a the Frame a tag will be placed (TX) or looked
        for (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            +-------------------------------------------+----------------+------+
            | 0                                         |              Position |
            |                                           | <-------------------- |
            +-------------------------------------------+----------------+------+
            | Frame contents                            | TAG            |      |
            +-------------------------------------------+----------------+------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method returns the current configured value for this position.

        Default value

        - At the TX side, the default position places the tag at the end of the frame,
          without overlapping with other enabled tags.
        - At the RX side, the default position is the length of the tag. This means the
          RX side guesses the location of the tag to be at the very end of the frame.
          Note that this guess is incorrect if multiple tags are enabled on a single frame!

        Example

        This example will return the position of a
        sequence tag:

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.FrameTagTx_PositionGet(self)

    def PositionSet(self, newPosition):
        r"""

        Sets the location of the tag in the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            +-------------------------------------------+---------------+-------+
            |                                           |              Position |
            |                                           | <-------------------- |
            +-------------------------------------------+---------------+-------+
            | Frame contents                            | TAG           |       |
            +-------------------------------------------+---------------+-------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method allows the user to configure this value.

        :param position: The new value of the position. This value must be between
                         *<taglength>* and *<framelength>*.

        Example

        This example will sets the position of a sequence tag:

        TODO


        """
        return _byteblower.FrameTagTx_PositionSet(self, newPosition)

    def Enable(self, set):
        r"""

        Method to enable the tag on the Frame.

        :param enable: Enable the Transmit FrameTag
                       (Default: False)
        :type enable: bool

        This will activate the tag on the Frame, and apply its configuration. As long
        as this method is not called, the tag will not be active.

        .. note:: the configuration of other enabled frames may change when this frame is
                  disabled.

        Example

        To enable the sequence tag on frame, one can do:

        .. code-block:: python
           :emphasize-lines: 1

            print(frameTagtx.Enable(True))


        """
        return _byteblower.FrameTagTx_Enable(self, set)

    def IsEnabled(self):
        r"""

        Method which will return whether a tag is activated or not.

        :return: True if enabled, false if disabled.
                 (Default: False / Disabled)
        :rtype: bool

        This method is used to retrieve the current state of the tag. If this tag is
        activated/enabled, true is returned. Otherwise, this method will return false.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: Check if a timestamp tag is enabled on a frame

           frameTagtx = frame.FrameTagSequenceGet()
           print(frameTagtx.IsEnabled())


        """
        return _byteblower.FrameTagTx_IsEnabled(self)

    def PositionAutomaticSet(self):
        r"""

        This method will use the automatic position for
        the tag.

        ByteBlower is very flexible in positioning the tag, and the combination of
        different tags. If the position of the tag is not important, the automatic
        positioning of tags is the easiest way for the user and is enabled by default

        .. note:: The automatic position is used by default. This method is only useful
                  when you want to reset positions that were previously set by the user.

        Automatic placement of FrameTags has multiple advantages:

        1. it shields the API user from the complexity described above

        2. it makes sure the requirements are respected:

           the position will always be larger than the tag length and multiple tags
           will never overlap

        3. it places the tags as close towards the end as possible to allow tagging
           small frames without overwriting frame headers

        Tags are automatically placed at the end of the frame. If both Tags are enabled
        and have an automatic position, the SequenceTag is placed in front of the
        TimeTag.

        If a tag has an explicit position, this is always respected. The automatic
        position will adapt to it as follows:

        1. If there is enough place after the fixed tag to fit the automatic tag, the
           automatic tag is placed behind it (at the end of the frame).

        2. If there is not enough place after the fixed tag to fit the automatic tag,
           the automatic tag is placed right in front of the fixed tag.

        Example

        In this example, we will reset the position of the sequence tag to automatic.

        .. code-block:: python
           :emphasize-lines: 1

            frameTagtx.PositionAutomaticSet()


        """
        return _byteblower.FrameTagTx_PositionAutomaticSet(self)

# Register FrameTagTx in _byteblower:
_byteblower.FrameTagTx_swigregister(FrameTagTx)
class FrameTagFormat(AbstractObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TypeGet(self):
        return _byteblower.FrameTagFormat_TypeGet(self)

    def TimeStampFormatGet(self):
        return _byteblower.FrameTagFormat_TimeStampFormatGet(self)

    def SequenceNumberFormatGet(self):
        return _byteblower.FrameTagFormat_SequenceNumberFormatGet(self)

    def FormatStringGet(self):
        return _byteblower.FrameTagFormat_FormatStringGet(self)

# Register FrameTagFormat in _byteblower:
_byteblower.FrameTagFormat_swigregister(FrameTagFormat)
class FrameTagMetrics(AbstractObject):
    r"""

    Class which represents the metrics of a FrameTag.

    The metrics of a tag are parameters describing the length and byte alignment of
    a frame.

    The metrics can only be read, because they are determined by the tag format and
    the server type.

    .. code-block:: python
       :emphasize-lines: 2

       metric = frameTagtx.MetricsGet()
       print(metric.AlignmentGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LengthGet(self):
        r"""

        Returns the length of the tag.

        :return: The length of the tag in bytes.
        :rtype: int

        The number of bytes in a Frame that will be overwritten by this tag.

        .. note:: This byte range does not need to be contiguous! More specifically,
                  if the tag alignment is larger than one, a single byte containing
                  the offset to the aligned tag may be stored separately.

        Example

        This example shows the how to retrieve the length of a sequence tag:

        .. code-block:: python
           :emphasize-lines: 1

            print(metric.LengthGet())


        """
        return _byteblower.FrameTagMetrics_LengthGet(self)

    def AlignmentGet(self):
        r"""

        Returns the alignment value for this tag.

        :return: The alignment value of this tag.
        :rtype: int

        Some frame tags must be aligned with the start of a frame. This means the tag
        must start at a multiple of *<x>* bytes within a frame, where *<x>* is the
        alignment value. The default value is one.

        Frame alignment requirements are caused by hardware limitations as a new tag
        must be included in every frame that is sent.

        Example

        This example illustrates how the alingment value of a timestamp tag can be retrieved;

        .. code-block:: python
           :emphasize-lines: 1

            print(metric.AlignmentGet())


        """
        return _byteblower.FrameTagMetrics_AlignmentGet(self)

    def FrameTagGet(self):
        r"""


        :meta private:


        """
        return _byteblower.FrameTagMetrics_FrameTagGet(self)

# Register FrameTagMetrics in _byteblower:
_byteblower.FrameTagMetrics_swigregister(FrameTagMetrics)
class FrameTagRx(FrameTag):
    r"""

    The FrameTagRx class describes the receive configuration of a Tag in a Frame.

    ByteBlower supports optional tagging of frames. Such a tag can have different
    formats, locations, ... These parameters can be set and retrieved using this
    class.

    Currently, two different types of FrameTags are supported:

    - Sequence Number: A tag which contains the sequence number within the stream.
    - Timestamp: A tag containing the timestamp this frame has left the transmit
      interface.

    Adding tags is a very powerful and flexible feature of ByteBlower. Please have
    a look at ByteBlower API Knowledgebase:
    Background: Adding FrameTags to your ByteBlower frame - structure and behaviour
    for a detailed explanation.

    This class is represents the :class:`.FrameTag` configuration at the receiving
    side of the flow.

    In typical situations this configuration must not be changed.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PositionGet(self):
        r"""

        Returns the current configured location of the tag within the Frame.

        :return: Current configured position. If nothing was specified, the default
                 position chosen by the server is returned.
        :rtype: int

        A user can choose where in a the Frame a tag will be placed (TX) or looked
        for (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            +-------------------------------------------+----------------+------+
            | 0                                         |              Position |
            |                                           | <-------------------- |
            +-------------------------------------------+----------------+------+
            | Frame contents                            | TAG            |      |
            +-------------------------------------------+----------------+------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method returns the current configured value for this position.

        Default value

        - At the TX side, the default position places the tag at the end of the frame,
          without overlapping with other enabled tags.
        - At the RX side, the default position is the length of the tag. This means the
          RX side guesses the location of the tag to be at the very end of the frame.
          Note that this guess is incorrect if multiple tags are enabled on a single frame!

        Example

        This example will return the position of a
        sequence tag:

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.FrameTagRx_PositionGet(self)

    def PositionSet(self, newPosition):
        r"""

        Sets the location of the tag in the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            +-------------------------------------------+---------------+-------+
            |                                           |              Position |
            |                                           | <-------------------- |
            +-------------------------------------------+---------------+-------+
            | Frame contents                            | TAG           |       |
            +-------------------------------------------+---------------+-------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method allows the user to configure this value.

        :param position: The new value of the position. This value must be between
                         *<taglength>* and *<framelength>*.

        Example

        This example will sets the position of a sequence tag:

        TODO


        """
        return _byteblower.FrameTagRx_PositionSet(self, newPosition)

    def FormatSet(self, fromFrameTagFormat):
        r"""

        Method to set the format.

        :param format: This defines the format of the tag, the following format strings
                       are currently  supported:

                       TimeStamp-Microseconds_CRC Timestamp in microseconds followed by
                       a CRC. Not supported since 2.9.0
        :type format: FrameTagFormat

        Example

        In this example, we set the format of the timestamp to 10 nanoseconds.

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example

        See also: :obj:`.FrameTag.FormatStringGet` for details on the tag formats.


        """
        return _byteblower.FrameTagRx_FormatSet(self, fromFrameTagFormat)

    def FormatSetFromString(self, formatString):
        r"""

        Method to set the format by name.

        This method allows to set the format by name.

        See also: :obj:`.FrameTag.FormatStringGet` for details on the tag formats.

        :param format: This defines the format of the tag, the following format strings
                       are currently  supported:

                       TimeStamp-Microseconds_CRC Timestamp in microseconds followed by
                       a CRC. Not supported since 2.9.0

        Valid Options

        TimeStamp-10Nanoseconds 

           Timestamp in nanoseconds.

        SequenceNumber-0_CRC 

           Sequence number followed by a CRC.

        Example

        In this example, we set the format of the timestamp to 10 nanoseconds.

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.FrameTagRx_FormatSetFromString(self, formatString)

    def FormatDefaultSet(self):
        r"""

        Sets the format to the native, default format.

        This method sets the format to the default value.
        The default value depends on server type:

        For sequence tags, the default value is the same for all systems
        *<SequenceNumber-0_CRC>*.

        For time tags, the default value is *<TimeStamp-10Nanoseconds>*. However, on
        1000 series servers with a software version before 1.10.18, the
        *<TimeStamp-Microseconds_CRC>* format is used instead.

        :raises: ByteBlower.Rx.Counter.Unsupported -  The format string is a valid
                 value, but is not supported by the server.
        :raises: <python_error> - The format string is not a valid value.

        Example
        In this example, we restore the format of a sequence tag to the default format:

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        .. todo:: Real Example


        """
        return _byteblower.FrameTagRx_FormatDefaultSet(self)

    def MetricsSet(self, fromFrameTagMetrics):
        r"""

        Sets the metric of the tag.

        This method allows to copy the metrics of a FrameTagTx to the receive side of a flow.

        Note that it is often better to copy the complete TX tag configuration to the
        receive side of a flow. See :obj:`.TaggedRx.FrameTagSet` for an example.

        :param metrics: This parameter is an object of type :class:`.FrameTagMetrics` .

        Example

        This example demonstrates how you can set the metrics of a frame on the
        receiving object. The configuration is simply copied from the TX side.

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.FrameTagRx_MetricsSet(self, fromFrameTagMetrics)

    def MetricsDefaultSet(self):
        r"""

        Sets the metrics to the default values.

        This method restores the metrics to the default value.

        Currently, both the sequence tag and time tag have metrics with an alignment of
        1 bytes and a size of 8 bytes on all servers types and versions.

        Example

        This example restores the default metrics of a sequence tag.

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.FrameTagRx_MetricsDefaultSet(self)

    def PositionDefaultSet(self):
        r"""

        This restores the position to the default value.

        This method restores the default value for the position. By default, the tag is
        put at the end of the frame. This will restore the position of the receiving
        object to its default.

        Example

        This example restores the position of the sequence tag to the default value.

        .. code-block:: python

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')

        .. todo:: Real Example


        """
        return _byteblower.FrameTagRx_PositionDefaultSet(self)

# Register FrameTagRx in _byteblower:
_byteblower.FrameTagRx_swigregister(FrameTagRx)
class Trigger(Rx):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register Trigger in _byteblower:
_byteblower.Trigger_swigregister(Trigger)
class TriggerBasicResultSnapshot(AbstractRefreshableResult):
    r"""

    Receive-side trigger result set.  

    A basic trigger result snapshot object can be created via a 
    :class:`.TriggerBasic`, using :meth:`.TriggerBasic.ResultGet`

    The result set contains the trigger information of since the object is created
    or refreshed.  

    .. note:: The information is not updated until 
              :obj:`~.AbstractObject.Refresh` is called on this object

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.  

    .. code-block:: python

       result = trigger.ResultGet()
       print(result.PacketCountGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].  

        :return: Timestamp of snapshot in nanoseconds since epoch
        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :return: Timestamp of the first received packet in nanoseconds since epoch
        :rtype: int

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampFirstGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the timestamp [NS] of the last packet in this snapshot.  

        :return: Timestamp in nanoseconds since epoch when the last frame arrived in 
                 this snapshot.
        :rtype: int

        Example

        This example gets the timestamp [NS] of the last received packet in this 
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampLastGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.  

        :return: received packets  
        :rtype: int

        Example

        This example gets the received packet counter  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.PacketCountGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.  

        :return: received bytes
        :rtype: int

        Example

        This example gets the received bytes counter  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.ByteCountGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.  

        .. versionadded:: 2.5.0  

        :return: Largest received frame size in bytes of this snapshot
        :rtype: int

        Example

        This example gets the largest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.FramesizeMaximumGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.  

        .. versionadded:: 2.5.0  

        :return: Smallest received frame size in bytes of this snapshot  
        :rtype: int

        Example

        This example gets the smallest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.FramesizeMinimumGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.IntervalDurationGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed. 

        :return: RefreshTimestamp in nanoseconds since epoch
        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_RefreshTimestampGet(self)

# Register TriggerBasicResultSnapshot in _byteblower:
_byteblower.TriggerBasicResultSnapshot_swigregister(TriggerBasicResultSnapshot)
class TriggerBasicResultData(AbstractObject):
    r"""

    Receive-side trigger result set.  

    The result set contains the trigger information of since the object is created
    or refreshed.

    .. note:: See What's new in API v2 for more information.  

    A basic trigger result data snapshot object can be created via a 
    :class:`.TriggerBasicResultHistory`, using 
    :obj:`TriggerBasic.ResultHistoryGet`

    .. note:: The information is not updated until "Refresh" is called on the 
              :class:`TriggerBasicResultHistory`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or 
    destination port 67.  

    .. code-block:: python
       :emphasize-lines: 3

       port = bbServer.PortCreate('trunk-1-2')
       trigger = port.RxTriggerBasicAdd()
       bpf_filter = 'udp port 67'
       trigger.FilterSet(bpf_filter)
       historyResult = trigger.ResultHistoryGet()
       resultData = historyResult.CumulativeLatestGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :return: The timestamp in nanoseconds since epoch when this snapshot was 
                 created
        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

           print(dataResult.TimestampGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :return: The timestamp in nanoseconds since epoch when the first frame in this
                 snapshot was received

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this 
        snapshot 

        .. code-block:: python
           :emphasize-lines: 1

           print(dataResult_Get.TimestampFirstGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.  

        :return: The timestamp in nanoseconds since epoch when the last frame in this
                 snapshot was received
        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this 
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           print(dataResult_Get.TimestampLastGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.  

        :rtype: int

        Example

        This example gets the received packet counter  

        .. code-block:: python
           :emphasize-lines: 1

           print(dataResult_Get.PacketCountGet())


        """
        return _byteblower.TriggerBasicResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.  

        :rtype: int

        Example

        This example gets the received bytes counter  

        .. code-block:: python
           :emphasize-lines: 1

           print(dataResult.ByteCountGet())


        """
        return _byteblower.TriggerBasicResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.  

        :return: Largest received frame size in bytes of this snapshot  
        :rtype: int

        .. versionadded:: 2.5.0  

        Example

        This example gets the largest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

           print(dataResult.FramesizeMaximumGet())


        """
        return _byteblower.TriggerBasicResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.  

        .. versionadded:: 2.5.0  

        :return: Smallest received frame size in bytes of this snapshot
        :rtype: int

        Example

        This example gets the smallest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

           print(dataResult.FramesizeMinimumGet())


        """
        return _byteblower.TriggerBasicResultData_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS] 

        .. code-block:: python
           :emphasize-lines: 1

           print(dataResult_Get.IntervalDurationGet())


        """
        return _byteblower.TriggerBasicResultData_IntervalDurationGet(self)

    def TypeGet(self):
        return _byteblower.TriggerBasicResultData_TypeGet(self)

# Register TriggerBasicResultData in _byteblower:
_byteblower.TriggerBasicResultData_swigregister(TriggerBasicResultData)
class TriggerBasicResultDataList(object):
    r"""

    This is a List of multiple TriggerBasicResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___setitem__(self, *args)

    def empty(self):
        return _byteblower.TriggerBasicResultDataList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.TriggerBasicResultDataList_size(self)

    def __init__(self, *args):
        _byteblower.TriggerBasicResultDataList_swiginit(self, _byteblower.new_TriggerBasicResultDataList(*args))
    __swig_destroy__ = _byteblower.delete_TriggerBasicResultDataList

# Register TriggerBasicResultDataList in _byteblower:
_byteblower.TriggerBasicResultDataList_swigregister(TriggerBasicResultDataList)
class TriggerBasicResultHistory(AbstractRefreshableResult):
    r"""

    Receive-side trigger result history.  

    .. versionadded:: 2.1.0  

    A basic trigger history result object can be created via a 
    :class:`.TriggerBasic`, using :meth:`.TriggerBasic.ResultHistoryGet` 

    The history contains the trigger information in time since the object is 
    created or refreshed.  

    .. note:: The information is not updated until :obj:`~.AbstractObject.Refresh` 
              is called on this object  

    .. note:: See History result for more information  

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or 
    destination port 67.  

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clear the history.  

        With each Refresh interval and cumulative counters are transferred from Server 
        to the Client. To remove all counter-objects in this history, one can execute 
        this method. Both Interval and Cumulative counter lists will be cleared.

        Example

        Clear the History.  

        .. code-block:: python
           :emphasize-lines: 1

           historyResult.Clear()


        """
        return _byteblower.TriggerBasicResultHistory_Clear(self)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.  

        :return: a list of :class:`.TriggerBasicResultData` objects containing the 
                 Cumulative counters
        :rtype: TriggerBasicResultDataList

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`

        Example

        This example gets the available cumulative results  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeGet()[0].DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.  

        :param index: index
        :type index: int

        :return: An object containing the cumulative counters at the given index
        :rtype: TriggerBasicResultData

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeGetByIndex(0).DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.  

        :return: The length of the cumulative list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeLengthGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        :return: The length of the server sample buffer  
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.SamplingBufferLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.  

        :return: Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.SamplingIntervalDurationGet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.  

        .. versionadded:: 2.3.0  

        :param interval: Duration in nanoseconds a sample should be.
        :type interval: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.SamplingIntervalDurationSet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.   

        .. versionadded:: 2.3.0  

        :param length: The number of samples the ByteBlower server should keep
        :type length: int

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           historyResult.SamplingBufferLengthSet(10)


        """
        return _byteblower.TriggerBasicResultHistory_SamplingBufferLengthSet(self, inLength)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.  

        :return: A list of :class:`.TriggerBasicResultData` objects containing all 
                interval counters.
        :rtype: TriggerBasicResultDataList

        Each result object contains interval counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`    

        Example

        This example gets the available interval results  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.IntervalGet()[0].DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.  

        :param index: index
        :type index: int

        :return: interval counter object at the specified index
        :rtype: TriggerBasicResultData

        Example

        This example gets the available interval counters at index 1  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.IntervalGetByIndex(0).DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.  

        :return: The length of the interval list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.IntervalLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the results in this history were last refreshed.

        :return: Timestamp in nanoseconds since epoch when the results were last 
                 retrieved from the server.
        :rtype: int

        Example

        This example refreshes the history results with the results available on the 
        server

        .. code-block:: python
           :emphasize-lines: 1

           historyResult.Refresh()


        """
        return _byteblower.TriggerBasicResultHistory_RefreshTimestampGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.  

        .. versionadded:: 2.2.0  

        :param timestamp: timestamp in nanoseconds since epoch
        :type timestamp: int

        :return: The cumulative data at the given point in time.
        :rtype: TriggerBasicResultData

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeGetByTime(1432805398000000000).DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp.  

        .. versionadded:: 2.2.0  

        :param timestamp: timestamp in nanoseconds  
        :type timestamp: int

        :return: The interval counters at the given time.
        :rtype: TriggerBasicResultData

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns  

        .. code-block:: python
           :emphasize-lines: 1

           interval = historyResult.IntervalGetByTime(1432805398000000000)


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.  

        .. versionadded:: 2.2.0  

        :return: The last cumulative snapshot which has been closed.
        :rtype: TriggerBasicResultData

        Example

        This example gets the latest closed Cumulative counter object  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeLatestGet().DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.  

        .. versionadded:: 2.2.0  

        :rtype: TriggerBasicResultData

        Example

        This example gets the latest closed Interval counter object  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.IntervalLatestGet().DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalLatestGet(self)

# Register TriggerBasicResultHistory in _byteblower:
_byteblower.TriggerBasicResultHistory_swigregister(TriggerBasicResultHistory)
class TriggerBasic(Trigger):
    r"""

    Receive-side packet processor which counts the incoming frames, matching a filter.

    This trigger is always active and starts counting frames as soon as it is
    created. Counting continues until the trigger is destructed.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              `meth``FilterSet` for filtering information.

    A basic trigger object can be created via a :class:`.ByteBlowerPort`, using
    :meth:`.ByteBlowerPort.RxTriggerBasicAdd`

    This trigger processes frames received on the ByteBlower interface where its
    parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python

       port = bbServer.PortCreate('trunk-1-2')
       trigger = port.RxTriggerBasicAdd()
       bpf_filter = 'udp port 67'
       trigger.FilterSet(bpf_filter)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        r"""

        Returns the current result counters.

        .. versionadded:: 2.1.0

        :return: The current cumulative result counters.
        :rtype: TriggerBasicResultSnapshot

        This method will return an object of :class:`.TriggerBasicResultSnapshot`.
        It will contain all the current Cumulative counters. To update the counters,
        call Refresh on :class:`.TriggerBasicResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 2

           trigger = port.RxTriggerBasicAdd()
           print(trigger.ResultGet().DescriptionGet())


        """
        return _byteblower.TriggerBasic_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        .. versionadded:: 2.1.0

        The history contains the Cumulative and the Interval counters over time. 
        Use this to create results over time.

        :rtype: TriggerBasicResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 2

           trigger = port.RxTriggerBasicAdd()
           print(trigger.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.TriggerBasic_ResultHistoryGet(self)

    def FilterSet(self, filter):
        r"""

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does reset the counter values which
                  were triggered by a previous filter string. Also the earlier 
                  collected history is invalidated.

        :param bpf: Valid BPF filter string. For creating valid BPF filter strings, 
                    please have a look at http://www.tcpdump.org/#documentation
                    for more  information.

        :type bpf: str

        :raises ConfigError: When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:
        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 3

           trigger = port.RxTriggerBasicAdd()
           bpf_filter = 'ip dst 1.1.1.2 and udp port 4096'
           trigger.FilterSet(bpf_filter)


        """
        return _byteblower.TriggerBasic_FilterSet(self, filter)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        :return: The current BPF filter string
        :rtype: str

        The filter string can be configured using :meth:`FilterSet`

        Example

        Suppose we configured the trigger with filter string:
        where `$ipv4_1` and `$ipv4_2` are :class:`IPv4Configuration` and
        `$frameSize` is the (layer2) size of the frames (without CRC!). The
        BPF filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 4

           trigger = port.RxTriggerBasicAdd()
           bpf_filter = 'ip dst 1.1.1.2 and udp port 4096'
           trigger.FilterSet(bpf_filter)   
           print(trigger.FilterGet())


        """
        return _byteblower.TriggerBasic_FilterGet(self)

    def ResultClear(self):
        r"""

        Resets the counter values to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 2

           trigger = port.RxTriggerBasicAdd()
           trigger.ResultClear()


        """
        return _byteblower.TriggerBasic_ResultClear(self)

# Register TriggerBasic in _byteblower:
_byteblower.TriggerBasic_swigregister(TriggerBasic)
class TriggerBasicMobile(Trigger):
    r"""

    Receive-side packet processor on a WirelessEndpoint that counts all incoming
    frames that match a filter.

    All triggers are started after calling :meth:`.WirelessEndpoint.Start` on the
    parent WirelessEndpoint object.

    A basic trigger object can be created by calling
    :obj:`.WirelessEndpoint.RxTriggerBasicAdd`

    As opposed to the ByteBlowerPort, Triggers on ByteBlower Endpoint do not support
    custom filters with BPF syntax.

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        return _byteblower.TriggerBasicMobile_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        :rtype: TriggerBasicResultHistory

        This method returns a TriggerBasicResultHistory Object. This will contain the
        Cumulative and the Interval counters over time. Use this to create results over
        time.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.ResultHistoryGet())


        """
        return _byteblower.TriggerBasicMobile_ResultHistoryGet(self)

    def FilterSourceAddressGet(self):
        r"""

        Returns the source (source) address field of the packet filter.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.FilterSourceAddressGet())


        """
        return _byteblower.TriggerBasicMobile_FilterSourceAddressGet(self)

    def FilterSourceAddressSet(self, inAddress):
        r"""

        Sets the source (source) address field of the packet filter.

        :param address: Source IP address on which the Endpoint must filter.
        :type address: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger.FilterSourceAddressSet('1.1.1.1')


        """
        return _byteblower.TriggerBasicMobile_FilterSourceAddressSet(self, inAddress)

    def FilterUdpSourcePortGet(self):
        r"""

        Returns the source (source) port field of the packet filter.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.FilterUdpSourcePortGet())


        """
        return _byteblower.TriggerBasicMobile_FilterUdpSourcePortGet(self)

    def FilterUdpSourcePortSet(self, inPort):
        r"""

        Sets the source (source) port field of the packet filter.

        :param port: UDP source port number for which the Endpoint must listen
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger.FilterUdpSourcePortSet(4096)


        """
        return _byteblower.TriggerBasicMobile_FilterUdpSourcePortSet(self, inPort)

    def FilterUdpDestinationPortGet(self):
        r"""

        Returns the destination (destination) port field of the packet filter.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.FilterUdpDestinationPortGet())


        """
        return _byteblower.TriggerBasicMobile_FilterUdpDestinationPortGet(self)

    def FilterUdpDestinationPortSet(self, inPort):
        r"""

        Sets the destination (destination) port field of the packet filter.

        :param port: UDP destination port number on which the Endpoint must listen
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger.FilterUdpDestinationPortSet(4096)


        """
        return _byteblower.TriggerBasicMobile_FilterUdpDestinationPortSet(self, inPort)

    def DurationGet(self):
        r"""

        Returns the duration for which the trigger will be active.

        :return: the duration in nanoseconds for which the trigger should listen.
                 By default it will listen during the full Scenario Duration.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.DurationGet())


        """
        return _byteblower.TriggerBasicMobile_DurationGet(self)

    def DurationSet(self, inDuration):
        r"""

        Sets the duration for which the trigger will be active.

        :param duration: Number of nanoseconds the Trigger should listen for incoming frames
                         The default value is the length of the full scenario.
        :type duration: int

        Configures how long the trigger will listen for incoming packets.

        Example

        Listen for 10 minutes

        .. code-block:: python
           :emphasize-lines: 1

           trigger.DurationSet(10000)


        """
        return _byteblower.TriggerBasicMobile_DurationSet(self, inDuration)

    def FilterGet(self):
        r"""

        The BPF style filter based on the UDP source and destination configuration 

        :rtype: str


        """
        return _byteblower.TriggerBasicMobile_FilterGet(self)

    def ResultClear(self):
        r"""

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger.ResultClear()


        """
        return _byteblower.TriggerBasicMobile_ResultClear(self)

# Register TriggerBasicMobile in _byteblower:
_byteblower.TriggerBasicMobile_swigregister(TriggerBasicMobile)
class TriggerSizeDistributionResultSnapshot(AbstractRefreshableResult):
    r"""

    Contains the results for the size distribution.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.TimestampGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first received packet.

        :return: The timestamp in nanoseconds since epoch for the first received packet.
        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.TimestampFirstGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last received packet.

        :return: The timestamp in nanoseconds since epoch for the last received packet.
        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.TimestampLastGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampLastGet(self)

    def ByteCountGet(self):
        r"""

        Gets the number of received bytes.

        :rtype: int

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.ByteCountGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.5.0

        :return: Largest received frame size in bytes of this snapshot
        :rtype: int

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.FramesizeMaximumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        .. versionadded:: 2.5.0

        :return: Smallest received frame size in bytes of this snapshot
        :rtype: int

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.FramesizeMinimumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountGet(self, *args):
        r"""

        Gets the number received packets. Or if provided with a size, the number of
        packets received of that size.

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.PacketCountGet())


        Gets the number received packets. Or if provided with a size, the number of
        packets received of that size.

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.PacketCountGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountGet(self, *args)

    def PacketCountBelowMinimumGet(self):
        r"""

        Gets number of received packets that are too small.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.PacketCountBelowMimumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        r"""

        Gets number of received packets in this snapshot that are too big.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(snaphot.PacketCountAboveMaximumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountAboveMaximumGet(self)

    def RefreshTimestampGet(self):
        r"""

        Gets the timestamp when the results were last refreshed.

        :return: The timestamp in nanoseconds since epoch when the results were last refreshed
        :rtype: int


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_RefreshTimestampGet(self)

# Register TriggerSizeDistributionResultSnapshot in _byteblower:
_byteblower.TriggerSizeDistributionResultSnapshot_swigregister(TriggerSizeDistributionResultSnapshot)
class TriggerSizeDistribution(Trigger):
    r"""

    Receive-side packet processor which counts the incoming frames, frame rate and
    frames per size, matching a filter.

    The size distribution trigger extends the basic trigger. It provides additional
    information like total number of bytes and frame rate. See :meth:`ResultGet`
    for more information.

    This trigger is always active and starts counting frames as soon as it is
    created. Counting continues until the trigger is destructed.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for filtering information.

    A size distribution trigger object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxTriggerSizeDistributionAdd`

    This trigger processes frames received on the ByteBlower interface where its
    parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 49576.

    .. code-block:: python

       trig = port.RxTriggerSizeDistributionAdd()
       trig.FilterSet('ip && dst port 49576')
       ...
       print(trig.ResultGet().DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        r"""

        Returns the current cumulative result for this trigger.

        .. versionadded:: 2.1.0

        :rtype: TriggerSizeDistributionResultSnapshot

        The snapshot contains byte counters and time values.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trig.ResultGet().DescriptionGet())


        """
        return _byteblower.TriggerSizeDistribution_ResultGet(self)

    def ResultClear(self):
        r"""

        Resets the counter values to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trig.ResultClear()


        """
        return _byteblower.TriggerSizeDistribution_ResultClear(self)

    def FilterSet(self, inFilter):
        r"""

        Sets a BPF filter on a RX object.

        :param bpf: Valid BPF filter string. For creating valid BPF filter strings, 
                    please have a look at http://www.tcpdump.org/#documentation
                    for more  information.

        :type bpf: str

        :raises ConfigError: When an invalid BPF filter string is given.

        .. note:: Configuring a new filter string does reset the counter values which
                  were triggered by a previous filter string. Also the earlier 
                  collected history is invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 3

           trig = port.RxTriggerSizeDistributionAdd()
           # lets assume traffic is sent to UDP port 9000
           trig.FilterSet('ip && dst port 9000')

        This will filter only UDP traffic.  Set the filter on packets that match:
        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)


        """
        return _byteblower.TriggerSizeDistribution_FilterSet(self, inFilter)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        :return: The current BPF filter string
        :rtype: str

        The filter string can be configured using :meth:`FilterSet`

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 2

           trig.FilterSet('ip && dst port 9000')
           print(trig.FilterGet())


        """
        return _byteblower.TriggerSizeDistribution_FilterGet(self)

# Register TriggerSizeDistribution in _byteblower:
_byteblower.TriggerSizeDistribution_swigregister(TriggerSizeDistribution)
class OutOfSequenceResultSnapshot(AbstractRefreshableResult):
    r"""

    Refreshable object containing the out-of-sequence results.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.TimestampGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.TimestampFirstGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.TimestampLastGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        :rtype: int

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.PacketCountGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        :rtype: int

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.ByteCountGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        :rtype: int

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.FramesizeMaximumGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        .. versionadded:: 2.6.4

        :rtype: int

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.FramesizeMinimumGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountOutOfSequenceGet(self):
        r"""

        Gets the received packet count which were out of sequence.

        :rtype: int

        Example

        This example gets the received out of sequence packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.PacketCountOutOfSequenceGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountOutOfSequenceGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count for packets which were not corrupted.

        :rtype: int

        Example

        This example gets the valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.PacketCountValidGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count for the invalid/corrupted packets.

        :rtype: int

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.PacketCountInvalidGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountInvalidGet(self)

    def PacketCountMissingGet(self):
        r"""

        Gets the number of missing packets (missing sequence numbers) in this snapshot.

        .. versionadded:: 2.21.0

        :rtype: int

        This can be used as an indicator of packet loss.


        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountMissingGet(self)

    def BiggestSequenceNumberGapGet(self):
        r"""

        Gets the largest burst of consecutive missing packets for this snapshot.

        .. versionadded:: 2.21.0

        :rtype: int


        """
        return _byteblower.OutOfSequenceResultSnapshot_BiggestSequenceNumberGapGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.IntervalDurationGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceResult.RefreshTimestampGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_RefreshTimestampGet(self)

# Register OutOfSequenceResultSnapshot in _byteblower:
_byteblower.OutOfSequenceResultSnapshot_swigregister(OutOfSequenceResultSnapshot)
class OutOfSequenceResultData(AbstractObject):
    r"""

    Non-refreshable object containing the out-of-sequence results.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.TimestampGet())


        """
        return _byteblower.OutOfSequenceResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.TimestampFirstGet())


        """
        return _byteblower.OutOfSequenceResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.PacketCountGet())


        """
        return _byteblower.OutOfSequenceResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        :rtype: int

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.PacketCountGet())


        """
        return _byteblower.OutOfSequenceResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        :rtype: int

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.ByteCountGet())


        """
        return _byteblower.OutOfSequenceResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        :rtype: int

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.FramesizeMaximumGet())


        """
        return _byteblower.OutOfSequenceResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        .. versionadded:: 2.6.4

        :rtype: int

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.FramesizeMinimumGet())


        """
        return _byteblower.OutOfSequenceResultData_FramesizeMinimumGet(self)

    def PacketCountOutOfSequenceGet(self):
        r"""

        Gets the received packet count which were out of sequence.

        :rtype: int

        Example

        This example gets the received out of sequence packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.PacketCountOutOfSequenceGet())


        """
        return _byteblower.OutOfSequenceResultData_PacketCountOutOfSequenceGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count which for packets which were not corrupted.

        :rtype: int

        Example

        This example gets the valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.PacketCountValidGet())


        """
        return _byteblower.OutOfSequenceResultData_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count for the invalid/corrupted packets.

        :rtype: int

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.PacketCountInvalidGet())


        """
        return _byteblower.OutOfSequenceResultData_PacketCountInvalidGet(self)

    def PacketCountMissingGet(self):
        r"""

        Gets the number of missing packets (missing sequence numbers) in this snapshot.

        .. versionadded:: 2.21.0

        :rtype: int

        This can be used as an indicator of packet loss.


        """
        return _byteblower.OutOfSequenceResultData_PacketCountMissingGet(self)

    def BiggestSequenceNumberGapGet(self):
        r"""

        Gets the largest burst of consecutive missing packets for this snapshot.

        .. versionadded:: 2.21.0

        :rtype: int


        """
        return _byteblower.OutOfSequenceResultData_BiggestSequenceNumberGapGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceresultData.IntervalDurationGet())


        """
        return _byteblower.OutOfSequenceResultData_IntervalDurationGet(self)

# Register OutOfSequenceResultData in _byteblower:
_byteblower.OutOfSequenceResultData_swigregister(OutOfSequenceResultData)
class OutOfSequenceResultDataList(object):
    r"""

    This is a List of multiple OutOfSequenceResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.OutOfSequenceResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.OutOfSequenceResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.OutOfSequenceResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.OutOfSequenceResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.OutOfSequenceResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.OutOfSequenceResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.OutOfSequenceResultDataList_swiginit(self, _byteblower.new_OutOfSequenceResultDataList(*args))
    __swig_destroy__ = _byteblower.delete_OutOfSequenceResultDataList

# Register OutOfSequenceResultDataList in _byteblower:
_byteblower.OutOfSequenceResultDataList_swigregister(OutOfSequenceResultDataList)
class OutOfSequenceResultHistory(AbstractRefreshableResult):
    r"""

    Receive-side out-of-sequence result history.

    .. versionadded:: 2.1.0

    .. note:: The information is not updated until :obj:`~.AbstractObject.Refresh`
              is called on this object.

    .. note:: See History result for more information

    A OutOfSequence history result object can be created via a
    :class:`OutOfSequence`, using :meth:`.OutOfSequence.ResultHistoryGet`

    Example

    Receive all frames and check sequence on "trunk-1-2" of some server, matching
    UDP source or destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       outOfSequence_trigger = port.RxOutOfSequenceBasicAdd()
       outOfSequence_trigger.FilterSet('udp port 4096')
       #...
       outOfSequenceHistoryResult= outOfSequence_trigger.ResultHistoryGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clear the history.

        With each Refresh interval and cumulative counters are transferred
        from Server to the Client. To remove all counter-objects in this history, you
        can execute this method. Both Interval and Cumulative counter lists will be
        cleared.

        Example

        Clear the History.

        .. code-block:: python
           :emphasize-lines: 1

           outOfSequenceHistoryResult.Clear()


        """
        return _byteblower.OutOfSequenceResultHistory_Clear(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return: Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

              print(outOfSequenceHistoryResult.SamplingIntervalDurationGet())


        """
        return _byteblower.OutOfSequenceResultHistory_SamplingIntervalDurationGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the server sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.SamplingBufferLengthGet())


        """
        return _byteblower.OutOfSequenceResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. versionadded:: 2.3.0

        :param interval: Duration of a sample in nanosconds
        :type interval: int

        .. warning:: The previously collected history will be invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.SamplingIntervalDurationSet(1000000000))


        """
        return _byteblower.OutOfSequenceResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        .. versionadded:: 2.3.0

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           outOfSequenceHistoryResult.SamplingBufferLengthGet(6)


        """
        return _byteblower.OutOfSequenceResultHistory_SamplingBufferLengthSet(self, inLength)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.

        :return: list of :class:`.OutOfSequenceResultData` containing the Cumulative counters
        :rtype: OutOfSequenceResultDataList

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.CumulativeGet()[0].DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: index
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: OutOfSequenceResultData

        Example
        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.CumulativeGetByIndex(0).DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return: The length of the cumulative list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.CumulativeLengthGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeLengthGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        Each result object contains interval counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: a list of :class:`.OutOfSequenceResultData` containing the Interval counters
        :rtype: OutOfSequenceResultDataList

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.IntervalGet()[0].DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: index
        :type index: int

        :return: interval counter object at the specified index
        :rtype: OutOfSequenceResultData

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.IntervalGetByIndex(0).DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return: The length of the interval list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(outOfSequenceHistoryResult.IntervalLengthGet())


        """
        return _byteblower.OutOfSequenceResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history was refreshed.

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        This is the timestamp on the server when the last time 
        :obj:`~.AbstractObject.Refresh` was called on this object.

        Example

        This example gets the Refresh timestamp

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.RefreshTimestampGet())


        """
        return _byteblower.OutOfSequenceResultHistory_RefreshTimestampGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.

        .. versionadded:: 2.2.0

        :param timestamp: timestamp in nanoseconds
        :type timestamp: int

        :rtype: OutOfSequenceResultData

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.CumulativeGetByTime(1432805398000000000).DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp.

        :param timestamp: timestamp in nanoseconds
        :type timestamp: int

        :rtype: OutOfSequenceResultData

        .. versionadded:: 2.2.0

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           interval = outOfSequenceHistoryResult.IntervalGetByTime(1432805398000000000)


        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        .. versionadded:: 2.2.0

        :rtype: OutOfSequenceResultData

        Example

        This example gets the latest closed Cumulative counter object

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.CumulativeLatestGet().DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        .. versionadded:: 2.2.0

        :rtype: OutOfSequenceResultData

        Example

        This example gets the latest closed Interval counter object

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.IntervalLatestGet())


        """
        return _byteblower.OutOfSequenceResultHistory_IntervalLatestGet(self)

# Register OutOfSequenceResultHistory in _byteblower:
_byteblower.OutOfSequenceResultHistory_swigregister(OutOfSequenceResultHistory)
class OutOfSequence(TaggedRx):
    r"""

    Receive-side packet processor which checks out-of-sequence on the incoming frames, matching a filter.

    This out-of-sequence detection is always active and starts processing frames as
    soon as it is created. Processing continues until the packet processor is
    destructed.

    The sequence number of a packet is obtained from an out-of-sequence tag in the
    frame. This tag is configured on the :class:`FrameTagTx`, which can be obtained
    via :meth:`.Frame.FrameTagSequenceGet`.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for filtering information.

    A basic out-of-sequence object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxOutOfSequenceBasicAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-33" of some server, matching UDP source or
    destination port 123.

    .. code-block:: python

       outOfSequence_trigger = port.RxOutOfSequenceBasicAdd()
       outOfSequence_trigger.FilterSet('udp port 4096')


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        r"""

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultHistory = outOfSequence_trigger.ResultClear()


        """
        return _byteblower.OutOfSequence_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current accumulated trigger results.

        :return: The current cumulative snapshot contianing the latest counters.
        :rtype: OutOfSequenceResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequence_trigger.ResultGet().DescriptionGet())


        """
        return _byteblower.OutOfSequence_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the history of the results.

        :return: The history is returned containing the cumulative and interval trigger
                 counters of the last 5 seconds.
        :rtype: OutOfSequenceResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultHistory = outOfSequence_trigger.ResultHistoryGet()


        """
        return _byteblower.OutOfSequence_ResultHistoryGet(self)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        :return: The current BPF filter string
        :rtype: str

        The filter string can be configured using :meth:`FilterSet`

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequence_trigger.FilterGet())


        """
        return _byteblower.OutOfSequence_FilterGet(self)

    def FilterSet(self, arg2):
        r"""

        Sets a BPF filter on a RX object.

        :param bpf: Valid BPF filter string. For creating valid BPF filter strings, 
                    please have a look at http://www.tcpdump.org/#documentation
                    for more  information.

        :type bpf: str

        :raises ConfigError: When an invalid BPF filter string is given.

        .. note:: Configuring a new filter string does reset the counter values which
                  were triggered by a previous filter string. Also the earlier 
                  collected history is invalidated.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

           outOfSequence_trigger.FilterSet('ip dst 1.1.1.1 and udp port 4096')


        """
        return _byteblower.OutOfSequence_FilterSet(self, arg2)

# Register OutOfSequence in _byteblower:
_byteblower.OutOfSequence_swigregister(OutOfSequence)
class Latency(TaggedRx):
    r"""

    Base class for Latency receive side triggers.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register Latency in _byteblower:
_byteblower.Latency_swigregister(Latency)
class LatencyBasicResultSnapshot(AbstractRefreshableResult):
    r"""

    Receive-side latency result set.

    :rtype: int

    The result set contains the latency information of since the object is created
    or refreshed.

    .. note:: The information is not updated until :obj:`~.AbstractObject.Refresh`
              is called on this object

    .. note:: See What's new in API v2 for more information.

    A basic latency result snapshot object can be created via a
    :class:`.LatencyBasic`, using :meth:`.LatencyBasic.ResultGet`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or destination
    port 67.

    .. code-block:: python

       latencyTrigger = port.RxLatencyBasicAdd()
       latency_result = latencyTrigger.ResultGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.TimestampGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.TimestampFirstGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.TimestampLastGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        :rtype: int

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.PacketCountGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        :rtype: int

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.ByteCountGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        :rtype: int

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.FramesizeMaximumGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        .. versionadded:: 2.6.4

        :rtype: int

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.FramesizeMaximumGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count of valid packets.

        :rtype: int

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.PacketCountValidGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count of invalid packets.

        :rtype: int

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.PacketCountInvalidGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountInvalidGet(self)

    def LatencyMinimumGet(self):
        r"""

        Gets the minimum latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.LatencyMinimumGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyMinimumGet(self)

    def LatencyMaximumGet(self):
        r"""

        Gets the maximum latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.LatencyMaximumGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyMaximumGet(self)

    def LatencyAverageGet(self):
        r"""

        Gets the average latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.LatencyAverageGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyAverageGet(self)

    def JitterGet(self):
        r"""

        Gets the jitter [ns] measured in this snapshot.

        :rtype: int

        The jitter is defined as the standard deviation of the measured latency.

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.JitterGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_JitterGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        :rtype: int

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.IntervalDurationGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_result.RefreshTimestampGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_RefreshTimestampGet(self)

# Register LatencyBasicResultSnapshot in _byteblower:
_byteblower.LatencyBasicResultSnapshot_swigregister(LatencyBasicResultSnapshot)
class LatencyBasicResultData(AbstractObject):
    r"""

    Receive-side latency result set.

    The result set contains the latency information of since the object is created
    or refreshed.

    A basic trigger result data snapshot object can be created via a
    :class:`.LatencyBasicResultHistory`, using
    :obj:`LatencyBasic.ResultHistoryGet`

    .. note:: The information is not updated until
              :obj:`~.AbstractObject.Refresh` is called.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       latencyTrigger = port.RxLatencyBasicAdd()
       latencyTrigger.FilterSet('udp port 67')
       #...
       latencyResultData = latencyTrigger.ResultHistoryGet().CumulativeLatestGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(latencyResultData.TimestampGet())


        """
        return _byteblower.LatencyBasicResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.TimestampFirstGet())


        """
        return _byteblower.LatencyBasicResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.TimestampLastGet())


        """
        return _byteblower.LatencyBasicResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        :rtype: int

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.PacketCountGet())


        """
        return _byteblower.LatencyBasicResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        :rtype: int

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.ByteCountGet())


        """
        return _byteblower.LatencyBasicResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the size (in bytes) of the largest frame received in this snapshot.

        :rtype: int

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.FramesizeMaximumGet())


        """
        return _byteblower.LatencyBasicResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        :rtype: int

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.FramesizeMinimumGet())


        """
        return _byteblower.LatencyBasicResultData_FramesizeMinimumGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count of valid packets.

        :rtype: int

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.PacketCountValidGet())


        """
        return _byteblower.LatencyBasicResultData_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count of invalid packets.

        :rtype: int

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.PacketCountInvalidGet())


        """
        return _byteblower.LatencyBasicResultData_PacketCountInvalidGet(self)

    def LatencyMinimumGet(self):
        r"""

        Gets the minimum latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.LatencyMinimumGet())


        """
        return _byteblower.LatencyBasicResultData_LatencyMinimumGet(self)

    def LatencyMaximumGet(self):
        r"""

        Gets the maximum latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.LatencyMaximumGet())


        """
        return _byteblower.LatencyBasicResultData_LatencyMaximumGet(self)

    def LatencyAverageGet(self):
        r"""

        Gets the average latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.LatencyAverageGet())


        """
        return _byteblower.LatencyBasicResultData_LatencyAverageGet(self)

    def JitterGet(self):
        r"""

        Gets the jitter [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.JitterGet())


        """
        return _byteblower.LatencyBasicResultData_JitterGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot [NS].

        :rtype: int

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyResultData.IntervalDurationGet())


        """
        return _byteblower.LatencyBasicResultData_IntervalDurationGet(self)

# Register LatencyBasicResultData in _byteblower:
_byteblower.LatencyBasicResultData_swigregister(LatencyBasicResultData)
class LatencyBasicResultDataList(object):
    r"""

    This is a List of multiple LatencyBasicResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyBasicResultDataList_swiginit(self, _byteblower.new_LatencyBasicResultDataList(*args))
    __swig_destroy__ = _byteblower.delete_LatencyBasicResultDataList

# Register LatencyBasicResultDataList in _byteblower:
_byteblower.LatencyBasicResultDataList_swigregister(LatencyBasicResultDataList)
class LatencyBasicResultHistory(AbstractRefreshableResult):
    r"""

    Receive-side latency result history.

    The history contains the latency information in time since the object is
    created or refreshed.

    .. note:: The information is not updated until :obj:`~.AbstractObject.Refresh`
              is called on this object.

    .. note:: See History result for more information.

    A basic latency result snapshot object can be created via a
    :class:`.LatencyBasic`, using :meth:`.LatencyBasic.ResultHistoryGet`

    .. versionadded:: 2.1.0

    Example

    Receive all frames on "trunk-1-2" of some server

    .. code-block:: python

       latencyTrigger = port.RxLatencyBasicAdd()
       latency_historyResult.latencyTrigger.ResultHistoryGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clear the history.

        With each Refresh, interval and cumulative counters are transferred from Server 
        to the Client. To remove all counter-objects in this history, you can execute 
        this method. Both Interval and Cumulative counter lists will be cleared.

        Example

        Clear the History.

        .. code-block:: python
           :emphasize-lines: 1

           latency_historyResult.Clear()


        """
        return _byteblower.LatencyBasicResultHistory_Clear(self)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.

        :return: a list of :class:`LatencyBasicResultData` objects
        :rtype: LatencyBasicResultDataList

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

           counterList = latency_historyResult.CumulativeGet()


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: index
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: LatencyBasicResultData

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           resultData = latency_historyResult.CumulativeGetByIndex(0)


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.CumulativeLengthGet())


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeLengthGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.SamplingIntervalDurationGet())


        """
        return _byteblower.LatencyBasicResultHistory_SamplingIntervalDurationGet(self)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        :return: The length of the server sample buffer
        :rtype: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.SamplingBufferLengthGet())


        """
        return _byteblower.LatencyBasicResultHistory_SamplingBufferLengthGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. versionadded:: 2.3.0

        :param duration: Duration in nanoseconds per sample
        :type duration: int

        .. warning :: The previously collected history will be invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latency_historyResult.SamplingIntervalDurationSet(1000000000)


        """
        return _byteblower.LatencyBasicResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        .. versionadded:: 2.3.0

        :param length: Number of samples to keep in the server-side buffer
        :type length: int

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultData = latency_historyResult.SamplingBufferLengthSet(6)


        """
        return _byteblower.LatencyBasicResultHistory_SamplingBufferLengthSet(self, inLength)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        :return: list of :class:`.LatencyBasicResultData` objects containing the Interval counters
        :rtype: LatencyBasicResultDataList

        Each result object contains interval counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

           listInterval = latency_historyResult.IntervalGet()


        """
        return _byteblower.LatencyBasicResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: index
        :type index: int

        :return: interval counter object at the specified index
        :rtype: LatencyBasicResultData

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           latencyData = latency_historyResult.IntervalGetByIndex(0)


        """
        return _byteblower.LatencyBasicResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.IntervalLengthGet())


        """
        return _byteblower.LatencyBasicResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history was refreshed.

        This is the timestamp on the server when the last time
        :obj:`~.AbstractObject.Refresh` was called on this object.

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        This example gets the Refresh timestamp

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.RefreshTimestampGet())


        """
        return _byteblower.LatencyBasicResultHistory_RefreshTimestampGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.

        .. versionadded:: 2.2.0

        :param timestamp: timestamp in nanoseconds
        :type timestamp: int
        :rtype: LatencyBasicResultData

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           result_data = latency_historyResult.CumulativeGetByTime(timestamp)


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp.

        .. versionadded:: 2.2.0

        :param timestamp: timestamp in nanoseconds
        :type timestamp: int

        :rtype: LatencyBasicResultData

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           interval = latency_historyResult.IntervalGetByTime(timestamp)


        """
        return _byteblower.LatencyBasicResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        .. versionadded:: 2.2.0

        :rtype: LatencyBasicResultData

        Example

        This example gets the latest closed Cumulative counter object

        .. code-block:: python
           :emphasize-lines: 1

           resultData = latency_historyResult.CumulativeLatestGet()


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        .. versionadded:: 2.2.0

        :rtype: LatencyBasicResultData

        Example

        This example gets the latest closed Interval counter object

        .. code-block:: python
           :emphasize-lines: 1

           interval = latency_historyResult.IntervalLatestGet()


        """
        return _byteblower.LatencyBasicResultHistory_IntervalLatestGet(self)

# Register LatencyBasicResultHistory in _byteblower:
_byteblower.LatencyBasicResultHistory_swigregister(LatencyBasicResultHistory)
class LatencyBasic(Latency):
    r"""

    Receive-side packet processor which calculates latency on the incoming frames,
    matching a filter.

    The basic latency processor extends the basic trigger. It provides additional
    information like latency and jitter. See :meth:`ResultGet` for more
    information.

    This latency calculation is always active and starts processing frames as soon
    as it is created. Processing continues until the packet processor is destructed.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the :class:`.FrameTagTx`, which can be obtained via
    :meth:`.Frame.FrameTagTimeGet`.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for     filtering information.

    A basic latency object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxLatencyBasicAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-45" of some server, matching UDP source or
    destination port 49523.

    .. code-block:: python
       :emphasize-lines: 2

       latencyTrigger = port.RxLatencyBasicAdd()
       latencyTrigger.FilterSet('ip dst 1.1.1.2 and udp port 4096')


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        r"""

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latencyTrigger.ResultClear()


        """
        return _byteblower.LatencyBasic_ResultClear(self)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :rtype: LatencyBasicResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           result = latencyTrigger.ResultGet()


        """
        return _byteblower.LatencyBasic_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current trigger history counters.

        :rtype: LatencyBasicResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultHistory = latencyTrigger.ResultHistoryGet()


        """
        return _byteblower.LatencyBasic_ResultHistoryGet(self)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyTrigger.FilterGet())


        """
        return _byteblower.LatencyBasic_FilterGet(self)

    def FilterSet(self, arg2):
        r"""

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does reset the counter values which
                  were triggered by a previous filter string. Also the earlier 
                  collected history is invalidated.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

           latencyTrigger.FilterSet('ip dst 1.1.1.2 and udp port 4096')


        """
        return _byteblower.LatencyBasic_FilterSet(self, arg2)

# Register LatencyBasic in _byteblower:
_byteblower.LatencyBasic_swigregister(LatencyBasic)
class LatencyBasicMobile(Latency):
    r"""

    Receive-side packet processor which calculates latency on the incoming frames,
    matching a filter.

    .. versionadded:: 2.6.0

    The basic latency processor extends the basic trigger. It provides additional
    information like latency and jitter. See :meth:`ResultGet` for more
    information.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the :class:`FrameTagTx`, which can be obtained via
    :meth:`.Frame.FrameTagTimeGet`.

    A basic latency object can be created via a WirelessEndpoint, using
    :meth:`.WirelessEndpoint.RxLatencyBasicAdd`

    Example

    .. code-block:: python
       :emphasize-lines: 1

       latencyTrigger = wirelessEndpoint.RxLatencyBasicAdd()
       latencyTrigger.FilterUdpSourcePortSet(4096)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        r"""

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latencyMobileTrigger.ResultClear()


        """
        return _byteblower.LatencyBasicMobile_ResultClear(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current History counters.

        This method returns a :class:`.LatencyBasicResultHistory` Object. This will
        contain the Cumulative and the Interval counters over time. Use this to create
        results over time.

        :rtype: LatencyBasicResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultHistory = latencyMobileTrigger.ResultHistoryGet()


        """
        return _byteblower.LatencyBasicMobile_ResultHistoryGet(self)

    def ResultGet(self):
        r"""

        Returns the current result counters.

        This method will return an object of :class:`LatencyBasicResultSnapshot`.
        It will contain all the current Cumulative counters. To update the counters,
        call :obj:`~.AbstractObject.Refresh` on this object.

        :rtype: LatencyBasicResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latencyMobileTrigger.ResultGet()


        """
        return _byteblower.LatencyBasicMobile_ResultGet(self)

    def FilterSourceAddressGet(self):
        r"""

        Returns the source address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyMobileTrigger.FilterSourceAddressGet())


        """
        return _byteblower.LatencyBasicMobile_FilterSourceAddressGet(self)

    def FilterSourceAddressSet(self, inAddress):
        r"""

        Sets the source address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latencyMobileTrigger.FilterSourceAddressSet('10.8.1.2')


        """
        return _byteblower.LatencyBasicMobile_FilterSourceAddressSet(self, inAddress)

    def FilterUdpSourcePortGet(self):
        r"""

        Returns the source port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyMobileTrigger.FilterUdpSourcePortGet())


        """
        return _byteblower.LatencyBasicMobile_FilterUdpSourcePortGet(self)

    def FilterUdpSourcePortSet(self, inPort):
        r"""

        Sets the source port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latencyMobileTrigger.FilterUdpSourcePortSet(4096)


        """
        return _byteblower.LatencyBasicMobile_FilterUdpSourcePortSet(self, inPort)

    def FilterUdpDestinationPortGet(self):
        r"""

        Returns the destination port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyMobileTrigger.FilterUdpDestinationPortGet())


        """
        return _byteblower.LatencyBasicMobile_FilterUdpDestinationPortGet(self)

    def FilterUdpDestinationPortSet(self, inPort):
        r"""

        Sets the destination port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latencyMobileTrigger.FilterUdpDestinationPortSet(4096)


        """
        return _byteblower.LatencyBasicMobile_FilterUdpDestinationPortSet(self, inPort)

    def DurationGet(self):
        r"""

        Returns the duration for which the trigger will be active.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyMobileTrigger.DurationGet())


        """
        return _byteblower.LatencyBasicMobile_DurationGet(self)

    def DurationSet(self, inDuration):
        r"""

        Sets the duration for which the trigger will be active.

        Configures how long the trigger will listen for incoming packets.

        Example

        Listen for 10 minutes

        .. code-block:: python
           :emphasize-lines: 1

           latencyMobileTrigger.DurationSet(10*1000000000)


        """
        return _byteblower.LatencyBasicMobile_DurationSet(self, inDuration)

    def FilterGet(self):
        r""":meta private:"""
        return _byteblower.LatencyBasicMobile_FilterGet(self)

    def FilterSet(self, arg2):
        r""":meta private:"""
        return _byteblower.LatencyBasicMobile_FilterSet(self, arg2)

# Register LatencyBasicMobile in _byteblower:
_byteblower.LatencyBasicMobile_swigregister(LatencyBasicMobile)
class LatencyDistributionResultSnapshot(AbstractRefreshableResult):
    r"""

    The latency distribution result.

    .. note:: The information is not updated until :obj:`~.AbstractObject.Refresh` 
              is called on this object

    .. note:: See What's new in API v2 for more information.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.TimestampGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.TimestampFirstGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.TimestampLastGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        :rtype: int

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        :rtype: int

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.ByteCountGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest frame size received in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.FramesizeMaximumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the smallest frame size received in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.FramesizeMinimumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_FramesizeMinimumGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count of valid packets.

        :rtype: int

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountValidGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count of invalid packets.

        :rtype: int

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountInvalidGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountInvalidGet(self)

    def LatencyMinimumGet(self):
        r"""

        Gets the minimum latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.LatencyMinimumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyMinimumGet(self)

    def LatencyMaximumGet(self):
        r"""

        Gets the maximum latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.LatencyMaximumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyMaximumGet(self)

    def LatencyAverageGet(self):
        r"""

        Gets the average latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.LatencyAverageGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyAverageGet(self)

    def JitterGet(self):
        r"""

        Gets the jitter [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.JitterGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_JitterGet(self)

    def RangeMinimumGet(self):
        r"""

        Returns the inclusive minimum of the range configured.

        :rtype: int

        :return: The lower bound of the configured range on the
                 :class:`.LatencyDistribution` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.RangeMinimumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        r"""

        Returns the exclusive maximum of the range configured.

        :return: The lower bound of the configured range for this Latency Distribution
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.RangeMaximumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_RangeMaximumGet(self)

    def BucketWidthGet(self):
        r"""

        Returns the width in nanoseconds of a bucket.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.BucketWidthGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_BucketWidthGet(self)

    def BucketCountGet(self):
        r"""

        Returns the number of buckets in which the range is divided.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.BucketCountGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_BucketCountGet(self)

    def PacketCountBelowMinimumGet(self):
        r"""

        Returns the number of packets arrived with a latency below the given range.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountBelowMinimumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        r"""

        Returns the number of packets arrived with a latency above the given range.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountAboveMaximumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountAboveMaximumGet(self)

    def PacketCountBucketsGet(self):
        r"""

        Returns the number of packets received per bucket.

        :rtype: Int64List

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountBucketsGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountBucketsGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp when the counters of this object where last refreshed.

        :rtype: int

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.RefreshTimestampGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_RefreshTimestampGet(self)

# Register LatencyDistributionResultSnapshot in _byteblower:
_byteblower.LatencyDistributionResultSnapshot_swigregister(LatencyDistributionResultSnapshot)
class LatencyDistribution(Latency):
    r"""

    Receive-side packet processor which calculates distribution of latency on the
    incoming frames, matching a filter.

    This latency distribution calculation is always active and starts processing
    frames as soon as it is created. Processing continues until the packet
    processor is destructed.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the FrameTag.Tx, which can be obtained via
    :meth:.Frame.FrameTagTimeGet`.

    .. note:: The initial (empty) filter string accepts all incoming frames.
              See :meth:`FilterSet` for filtering information.

    A latency distribution object can be created via a :class:`.ByteBlowerPort`,
    using :meth:`.ByteBlowerPort.RxLatencyDistributionAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-45" of some server, matching UDP source or
    destination port 49523.

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        r"""

        Returns the current result counters.

        :rtype: LatencyDistributionResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           snapshot = trigger.ResultGet()


        """
        return _byteblower.LatencyDistribution_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the current result counters over time.

        :rtype: LatencyDistributionResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latencyDistributionHistory = trigger.ResultHistoryGet()


        """
        return _byteblower.LatencyDistribution_ResultHistoryGet(self)

    def BucketCountGet(self):
        r"""

        Return the number of buckets which will count in the range.

        :rtype: int

        The bucket count is 1000 by default.  When the range spans less than 1000ns,
        the number of buckets will be reduced.


        """
        return _byteblower.LatencyDistribution_BucketCountGet(self)

    def BucketWidthGet(self):
        r"""

        Return the size of the of buckets which are in the range.

        :rtype: int

        The range is divided into a 1000 buckets.  A bucket cannot be less than 1 
        nanosecond in size.  When this would happen, the number of buckets is reduced
        accordingly.


        """
        return _byteblower.LatencyDistribution_BucketWidthGet(self)

    def RangeMinimumGet(self):
        r"""

        Returns the current configured minimum of range for the latency distribution.

        :rtype: int

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.RangeMinimumGet())


        """
        return _byteblower.LatencyDistribution_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        r"""

        Returns the current configured maximum of range for the latency distribution.

        :rtype: int

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.RangeMaximumGet())


        """
        return _byteblower.LatencyDistribution_RangeMaximumGet(self)

    def RangeSet(self, rangeStartNs, rangeEndNs):
        r"""

        Configures the range for which the Latency Distribution will measure the latency and create a distribution.

        :param range: A tuple consisting of the minimum and maximum value for the range.  
                      The unit is in nanoseconds.  The Maximum value is excluded in the range.
        :type range: Int64Pair

        :raises ConfigError: 'LAT001': When trying to configure an invalid range.

        Default value: [0, 1s[

        .. note:: Nanosecond resolution is supported for versions 1.8.24 and beyond
                  (older versions only supported up to microsecond resolution).

        Bug

        An incorrect exception is thrown when an invalid range is given.

        Example

        This will set the range from 0 to 5seconds.

        .. code-block:: python
           :emphasize-lines: 1

           trigger.RangeSet(0, 100)


        """
        return _byteblower.LatencyDistribution_RangeSet(self, rangeStartNs, rangeEndNs)

    def RangeGet(self):
        r"""

        Returns the current configured range for the latency distribution.

        :return: A tuple of the minimum and maximum value for the range.
        :rtype: Int64Pair

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.RangeGet())


        """
        return _byteblower.LatencyDistribution_RangeGet(self)

    def ResultClear(self):
        r"""

        Resets the counter values to zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger.ResultClear()


        """
        return _byteblower.LatencyDistribution_ResultClear(self)

    def FilterSet(self, inFilter):
        r"""

        Sets a BPF filter on a RX object.

        :param bpf: Valid BPF filter string. For creating valid BPF filter strings, 
                    please have a look at http://www.tcpdump.org/#documentation
                    for more  information.
        :type bpf: str

        :raises ConfigError: When an invalid BPF filter string is given.

        .. note:: Configuring a new filter string does reset the counter values which
                  were triggered by a previous filter string. Also the earlier 
                  collected history is invalidated.

        Example
        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address

        - UDP traffic with given destination and source UDP port

        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

           bpf_filter = 'ip dst {} and udp port {}'.format(dst_ip, udp_dest)
           trigger.FilterSet(bpf_filter)


        """
        return _byteblower.LatencyDistribution_FilterSet(self, inFilter)

    def FilterGet(self):
        r"""

        Returns the current installed BPF filter string.

        :return: The current BPF filter string
        :rtype: str

        The filter string can be configured using :meth:`FilterSet`

        Example

        Suppose we configured the trigger with filter string:
        where `ipv4_1` and `ipv4_2` are :class:`IPv4Configuration` objects and
        `frameSize` is the (layer2) size of the frames (without CRC!). The
        BPF filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.FilterGet())


        """
        return _byteblower.LatencyDistribution_FilterGet(self)

    def FrameTagSet(self, fromFrameTagTx):
        r"""

        Configure the FrameTag.Rx to match the given FrameTagTx.

        .. versionadded:: 1.8.18

        :param tag: The FrameTagTx to obtain the metrics and format configuration from.
        :type tag: FrameTagTx

        :raises: ByteBlower.Server.NotSupported - Unsupported Server Capability:
                 'Manage TX/RX Frame Tag placement': When a transmitted frame tag with
                 unsupported metrics and/or format is given.

        :raises: python_error - "FrameTag is of incorrect Type": When a transmitted
                 frame tag of invalid type is given (sequence vs. time)

        This method takes a :class:`FrameTagTx` and applies its metrics and format
        configuration on this trigger's :class:`.FrameTagRx`.

        .. note:: The transmitted frame tag type (sequence number, time stamp, ...)
                  must match the receiver frame tag type that is used for this trigger.

        The transmitted frame tag (sequence number, timestamp) can be obtained from the
        Frame (:meth:`Frame.FrameTagSequenceGet`, resp. :meth:`Frame.FrameTagTimeGet`)

        Example

        This example applies the transmitted time tag configuration on the receiver's
        time tag:

        .. code-block:: python
           :emphasize-lines: 1

              outOfSequence_trigger.FrameTagSet(frameTag)


        """
        return _byteblower.LatencyDistribution_FrameTagSet(self, fromFrameTagTx)

# Register LatencyDistribution in _byteblower:
_byteblower.LatencyDistribution_swigregister(LatencyDistribution)
class LatencyDistributionResultData(AbstractObject):
    r"""

    The latency distribution result.

    .. versionadded:: 2.20.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp [NS].

        :rtype: int

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.TimestampGet())


        """
        return _byteblower.LatencyDistributionResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp [NS] of the first packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.TimestampFirstGet())


        """
        return _byteblower.LatencyDistributionResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.TimestampLastGet())


        """
        return _byteblower.LatencyDistributionResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        :rtype: int

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountGet())


        """
        return _byteblower.LatencyDistributionResultData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        :rtype: int

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.ByteCountGet())


        """
        return _byteblower.LatencyDistributionResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest frame size received in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.FramesizeMaximumGet())


        """
        return _byteblower.LatencyDistributionResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the smallest frame size received in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.FramesizeMinimumGet())


        """
        return _byteblower.LatencyDistributionResultData_FramesizeMinimumGet(self)

    def PacketCountValidGet(self):
        r"""

        Gets the received packet count of valid packets.

        :rtype: int

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountValidGet())


        """
        return _byteblower.LatencyDistributionResultData_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        r"""

        Gets the received packet count of invalid packets.

        :rtype: int

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountInvalidGet())


        """
        return _byteblower.LatencyDistributionResultData_PacketCountInvalidGet(self)

    def LatencyMinimumGet(self):
        r"""

        Gets the minimum latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.LatencyMinimumGet())


        """
        return _byteblower.LatencyDistributionResultData_LatencyMinimumGet(self)

    def LatencyMaximumGet(self):
        r"""

        Gets the maximum latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.LatencyMaximumGet())


        """
        return _byteblower.LatencyDistributionResultData_LatencyMaximumGet(self)

    def LatencyAverageGet(self):
        r"""

        Gets the average latency [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.LatencyAverageGet())


        """
        return _byteblower.LatencyDistributionResultData_LatencyAverageGet(self)

    def JitterGet(self):
        r"""

        Gets the jitter [ns] measured in this snapshot.

        :rtype: int

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.JitterGet())


        """
        return _byteblower.LatencyDistributionResultData_JitterGet(self)

    def RangeMinimumGet(self):
        r"""

        Returns the inclusive minimum of the range configured.

        :rtype: int

        :return: The lower bound of the configured range on the
                 :class:`.LatencyDistribution` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.RangeMinimumGet())


        """
        return _byteblower.LatencyDistributionResultData_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        r"""

        Returns the exclusive maximum of the range configured.

        :return: The lower bound of the configured range for this Latency Distribution
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.RangeMaximumGet())


        """
        return _byteblower.LatencyDistributionResultData_RangeMaximumGet(self)

    def BucketWidthGet(self):
        r"""

        Returns the width in nanoseconds of a bucket.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.BucketWidthGet())


        """
        return _byteblower.LatencyDistributionResultData_BucketWidthGet(self)

    def BucketCountGet(self):
        r"""

        Returns the number of buckets in which the range is divided.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.BucketCountGet())


        """
        return _byteblower.LatencyDistributionResultData_BucketCountGet(self)

    def PacketCountBelowMinimumGet(self):
        r"""

        Returns the number of packets arrived with a latency below the given range.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountBelowMinimumGet())


        """
        return _byteblower.LatencyDistributionResultData_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        r"""

        Returns the number of packets arrived with a latency above the given range.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountAboveMaximumGet())


        """
        return _byteblower.LatencyDistributionResultData_PacketCountAboveMaximumGet(self)

    def PacketCountBucketsGet(self):
        r"""

        Returns the number of packets received per bucket.

        :rtype: Int64List

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.PacketCountBucketsGet())


        """
        return _byteblower.LatencyDistributionResultData_PacketCountBucketsGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns the duration of this snapshot in nanoseconds

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.IntervalDurationGet())


        """
        return _byteblower.LatencyDistributionResultData_IntervalDurationGet(self)

# Register LatencyDistributionResultData in _byteblower:
_byteblower.LatencyDistributionResultData_swigregister(LatencyDistributionResultData)
class LatencyDistributionResultDataList(object):
    r"""

    This is a List of multiple LatencyDistributionResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyDistributionResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyDistributionResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyDistributionResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyDistributionResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyDistributionResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyDistributionResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyDistributionResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyDistributionResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyDistributionResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyDistributionResultDataList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyDistributionResultDataList_swiginit(self, _byteblower.new_LatencyDistributionResultDataList(*args))
    __swig_destroy__ = _byteblower.delete_LatencyDistributionResultDataList

# Register LatencyDistributionResultDataList in _byteblower:
_byteblower.LatencyDistributionResultDataList_swigregister(LatencyDistributionResultDataList)
class LatencyDistributionResultHistory(AbstractRefreshableResult):
    r"""

    Receive-side latency result history.

    The history contains the latency information in time since the object is
    created or refreshed.

    .. note:: The information is not updated until :obj:`~.AbstractObject.Refresh` 
              is called on this object.

    .. note:: See History result for more information

    A basic latency result snapshot object can be created via a
    :class:`.LatencyBasic`, using :meth:`.LatencyBasic.ResultHistoryGet`

    .. versionadded:: 2.1.0

    Example

    Receive all frames on "trunk-1-2" of some server

    .. code-block:: python

       latencyTrigger = port.RxLatencyDistributionAdd()
       latency_historyResult.latencyTrigger.ResultHistoryGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clear the history.

        With each Refresh, interval and cumulative counters are transferred from Server 
        to the Client. To remove all counter-objects in this history, you can execute
        this method. Both Interval and Cumulative counter lists will be cleared.

        Example

        Clear the History.

        .. code-block:: python
           :emphasize-lines: 1

           latency_historyResult.Clear()


        """
        return _byteblower.LatencyDistributionResultHistory_Clear(self)

    def IntervalCompletedGet(self):
        return _byteblower.LatencyDistributionResultHistory_IntervalCompletedGet(self)

    def CumulativeCompletedGet(self):
        return _byteblower.LatencyDistributionResultHistory_CumulativeCompletedGet(self)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: a list of :class:`LatencyDistributionResultData` objects
        :rtype: LatencyDistributionResultDataList

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

           counterList = latency_historyResult.CumulativeGet()


        """
        return _byteblower.LatencyDistributionResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: index
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: LatencyDistributionResultData

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           resultData = latency_historyResult.CumulativeGetByIndex(0)


        """
        return _byteblower.LatencyDistributionResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.CumulativeLengthGet())


        """
        return _byteblower.LatencyDistributionResultHistory_CumulativeLengthGet(self)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp.

        :param timestamp: timestamp  in nanoseconds

        :rtype: LatencyDistributionResultData

        .. versionadded:: 2.2.0

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           result_data = latency_historyResult.CumulativeGetByTime(timestamp)


        """
        return _byteblower.LatencyDistributionResultHistory_CumulativeGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        :rtype: LatencyDistributionResultData

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Cumulative counter object

        .. code-block:: python
           :emphasize-lines: 1

           resultData = latency_historyResult.CumulativeLatestGet()


        """
        return _byteblower.LatencyDistributionResultHistory_CumulativeLatestGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval results.

        Each result object contains interval counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: list of :class:`.LatencyDistributionResultData` objects containing the Interval counters
        :rtype: LatencyDistributionResultDataList

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

           listInterval = latency_historyResult.IntervalGet()


        """
        return _byteblower.LatencyDistributionResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: index
        :type index: int

        :return: interval counter object at the specified index
        :rtype: LatencyDistributionResultData

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           latencyData = latency_historyResult.IntervalGetByIndex(0)


        """
        return _byteblower.LatencyDistributionResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.IntervalLengthGet())


        """
        return _byteblower.LatencyDistributionResultHistory_IntervalLengthGet(self)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp.

        :param timestamp: timestamp in nanoseconds
        :type timestamp: int

        :rtype: LatencyDistributionResultData

        .. versionadded:: 2.2.0

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           interval = latency_historyResult.IntervalGetByTime(timestamp)


        """
        return _byteblower.LatencyDistributionResultHistory_IntervalGetByTime(self, timestamp)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        :rtype: LatencyDistributionResultData

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Interval counter object

        .. code-block:: python
           :emphasize-lines: 1

           Interval = latency_historyResult.IntervalLatestGet()


        """
        return _byteblower.LatencyDistributionResultHistory_IntervalLatestGet(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.SamplingIntervalDurationGet())


        """
        return _byteblower.LatencyDistributionResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. warning :: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latency_historyResult.SamplingIntervalDurationSet(1000000000)


        """
        return _byteblower.LatencyDistributionResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the server sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.SamplingBufferLengthGet())


        """
        return _byteblower.LatencyDistributionResultHistory_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, inLength):
        r"""

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultData = latency_historyResult.SamplingBufferLengthSet(6)


        """
        return _byteblower.LatencyDistributionResultHistory_SamplingBufferLengthSet(self, inLength)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history was refreshed.

        This is the timestamp on the server when the last time
        :obj:`~.AbstractObject.Refresh` was called on this object.

        :return: Timestamp in nanoseconds since epoch

        Example

        This example gets the Refresh timestamp

        .. code-block:: python
           :emphasize-lines: 1

           print(latency_historyResult.RefreshTimestampGet())


        """
        return _byteblower.LatencyDistributionResultHistory_RefreshTimestampGet(self)

# Register LatencyDistributionResultHistory in _byteblower:
_byteblower.LatencyDistributionResultHistory_swigregister(LatencyDistributionResultHistory)
class LatencyDistributionMobile(Latency):
    r"""

    Receive-side packet processor which calculates distribution of latency on the
    incoming frames, matching a filter.

    .. versionadded:: 2.13.0

    This latency distribution calculation is always active and starts processing
    frames as soon as it is created. Processing continues until the packet
    processor is destructed.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the FrameTag.Tx, which can be obtained via
    :meth:.Frame.FrameTagTimeGet`.

    A latency distribution object can be created via a :class:`.WirelessEndpoint`,
    using :meth:`.WirelessEndpoint.RxLatencyDistributionAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent WirelessEndpoint is located.

    Example

    Receive all frames on "trunk-1-45" of some server, matching UDP source or
    destination port 49523.

    .. code-block:: python
       :emphasize-lines: 4

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       wireless_endpoint = server.DeviceGet('aa-89bb54-c04')
       trigger = wireless_endpoint.RxLatencyDistributionAdd()
       # Do the rest of the test
       # ...
       result = trigger.ResultGet()
       # parse the results
       # ...
       wireless_endpoint.RxLatencyDistributionRemove(trigger)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        r"""

        Returns the cumulative result.

        :rtype: LatencyDistributionResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.ResultGet())


        """
        return _byteblower.LatencyDistributionMobile_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the interval and cumulative results over time..

        .. versionadded:: 2.20.0

        :rtype: LatencyDistributionResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.ResultHistoryGet())


        """
        return _byteblower.LatencyDistributionMobile_ResultHistoryGet(self)

    def BucketCountGet(self):
        r"""

        Return the number of buckets which will count in the range.

        :rtype: int

        The bucket count is 1000 by default.  When the range spans less than 1000ns,
        the number of buckets will be reduced.


        """
        return _byteblower.LatencyDistributionMobile_BucketCountGet(self)

    def BucketWidthGet(self):
        r"""

        Return the size of the of buckets which are in the range.

        :rtype: int

        The range is divided into a 1000 buckets.  A bucket cannot be less than 1 
        nanosecond in size.  When this would happen, the number of buckets is reduced
        accordingly.


        """
        return _byteblower.LatencyDistributionMobile_BucketWidthGet(self)

    def RangeGet(self):
        r"""

        Returns the current configured range for the latency distribution.

        :return: A tuple of the minimum and maximum value for the range.
        :rtype: Int64Pair

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.RangeGet())


        """
        return _byteblower.LatencyDistributionMobile_RangeGet(self)

    def RangeMinimumGet(self):
        r"""

        Returns the current configured minimum of range for the latency distribution.

        :rtype: int

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.RangeMinimumGet())


        """
        return _byteblower.LatencyDistributionMobile_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        r"""

        Returns the current configured maximum of range for the latency distribution.

        :rtype: int

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.RangeMaximumGet())


        """
        return _byteblower.LatencyDistributionMobile_RangeMaximumGet(self)

    def RangeSet(self, rangeStartNs, rangeEndNs):
        r"""

        Configures the range for which the Latency Distribution will measure the latency and create a distribution.

        :param range: A tuple consisting of the minimum and maximum value for the range.  
                      The unit is in nanoseconds.  The Maximum value is excluded in the range.
        :type range: Int64Pair

        :raises ConfigError: 'LAT001': When trying to configure an invalid range.

        Default value: [0, 1s[

        Bug

        An incorrect exception is thrown when an invalid range is given.

        Example

        This will set the range from 0 to 5seconds.

        .. code-block:: python
           :emphasize-lines: 1

           trigger.RangeSet(0, 5000000000)


        """
        return _byteblower.LatencyDistributionMobile_RangeSet(self, rangeStartNs, rangeEndNs)

    def ResultClear(self):
        r"""

        Resets the counter values to zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger.ResultClear()


        """
        return _byteblower.LatencyDistributionMobile_ResultClear(self)

    def FilterSet(self, arg2):
        r""":meta private:"""
        return _byteblower.LatencyDistributionMobile_FilterSet(self, arg2)

    def FilterGet(self):
        r"""

        The BPF style filter based on the UDP source and destination configuration 

        :rtype: str


        """
        return _byteblower.LatencyDistributionMobile_FilterGet(self)

    def FilterSourceAddressGet(self):
        r"""

        Returns the source (source) address field of the packet filter.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.FilterSourceAddressGet())


        """
        return _byteblower.LatencyDistributionMobile_FilterSourceAddressGet(self)

    def FilterSourceAddressSet(self, inAddress):
        r"""

        Sets the source (source) address field of the packet filter.

        :param address: Source IP address on which the Endpoint must filter.
        :type address: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger.FilterSourceAddressSet('1.1.1.1')


        """
        return _byteblower.LatencyDistributionMobile_FilterSourceAddressSet(self, inAddress)

    def FilterUdpSourcePortGet(self):
        r"""

        Returns the source (source) port field of the packet filter.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.FilterUdpSourcePortGet())


        """
        return _byteblower.LatencyDistributionMobile_FilterUdpSourcePortGet(self)

    def FilterUdpSourcePortSet(self, inPort):
        r"""

        Sets the source (source) port field of the packet filter.

        :param port: UDP source port number for which the Endpoint must listen
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           triggerMobile.FilterUdpSourcePortSet(4096)


        """
        return _byteblower.LatencyDistributionMobile_FilterUdpSourcePortSet(self, inPort)

    def FilterUdpDestinationPortGet(self):
        r"""

        Returns the destination (destination) port field of the packet filter.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trigger.FilterUdpDestinationPortGet())


        """
        return _byteblower.LatencyDistributionMobile_FilterUdpDestinationPortGet(self)

    def FilterUdpDestinationPortSet(self, inPort):
        r"""

        Sets the destination (destination) port field of the packet filter.

        :param port: UDP destination port number on which the Endpoint must listen
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           triggerMobile.FilterUdpDestinationPortSet(4096)


        """
        return _byteblower.LatencyDistributionMobile_FilterUdpDestinationPortSet(self, inPort)

    def DurationGet(self):
        r"""

        Returns the duration for which the trigger will be active.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyMobileTrigger.DurationGet())


        """
        return _byteblower.LatencyDistributionMobile_DurationGet(self)

    def DurationSet(self, inDuration):
        r"""

        Sets the duration for which the trigger will be active.

        :param duration:  Duration in nanoseconds for which this trigger should listen
        :type duration: int

        Configures how long the trigger will listen for incoming packets.

        Example

        Listen for 10 minutes

        .. code-block:: python
           :emphasize-lines: 1

           latencyMobileTrigger.DurationSet(10*1000000000)


        """
        return _byteblower.LatencyDistributionMobile_DurationSet(self, inDuration)

# Register LatencyDistributionMobile in _byteblower:
_byteblower.LatencyDistributionMobile_swigregister(LatencyDistributionMobile)
class ServiceInfo(AbstractObject):
    r"""

    This class is an abstract base class to hold specific ServiceInfo objects


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeGet(self):
        r"""

        Retrieves the type of the ByteBlower service.

        :return: The ByteBlower service type
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.TypeGet())
           # prints "MeetingPoint"


        """
        return _byteblower.ServiceInfo_TypeGet(self)

    def SeriesGet(self):
        r"""

        Returns the series of the connected chassis.

        :return: A string '*<X>*', where *<X>* is the series value (e.g. 1000).
        :rtype: str

        .. note:: For a ByteBlower MeetingPoint, this method will always return "1000"

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.SeriesGet())


        """
        return _byteblower.ServiceInfo_SeriesGet(self)

    def VersionGet(self):
        r"""

        Returns the software version of the connected service daemon.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.VersionGet())


        """
        return _byteblower.ServiceInfo_VersionGet(self)

    def MachineIDGet(self):
        r"""

        Returns a unique identifier for the machine where the connected service runs on.

        :rtype:str

        The machineID is a unique ID for the machine (the physical server), and 
        generated at install time. If the server is re-installed, a new ID will be 
        generated.

        If both a ByteBlower Server and ByteBlower MeetingPoint service are running on
        the same physical server, this call will return the same ID.

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(service_info.MachineIDGet())


        """
        return _byteblower.ServiceInfo_MachineIDGet(self)

    def ServiceIDGet(self):
        r"""

        Returns a unique service identifier for the connected service.

        :rtype: str

        The serviceID is a unique ID for the service and is generated when the service 
        boots for the first time. If one doesn't re-install the system, the ID will be
        the same. 
        It's persistent across reboots. A physical server can have other services 
        running. With this ID one can identify each service and together with the 
        MachineID one can see if those services are running on the same Physical 
        Server.

        Both the ByteBlower Server and ByteBlower MeetingPoint service do have a 
        ServiceID, which are different from each other.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(service_info.ServiceIDGet())


        """
        return _byteblower.ServiceInfo_ServiceIDGet(self)

# Register ServiceInfo in _byteblower:
_byteblower.ServiceInfo_swigregister(ServiceInfo)
class PacketDump(AbstractObject):
    r"""

    Utility for dumping ByteBlower network traffic to a pcap file.

    .. versionadded: 2.9.0

    A PacketDump object is created for a ByteBlower interface and can be configured
    with a BPF filter and a maximum snapshot length.

    Example

    .. code-block:: python

       packetDump = interface.PacketDumpCreate()
       packetDump.Start('packetDump.pcap')
       while (packetDump.FileSizeGet()) < 1000000000:
           time.sleep(10)
       packetDump.Stop()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Start(self, filename):
        r"""

        Start capturing packets.

        :param filename: Location of where the pcap file should be stored.

        .. note:: if the file already existsit will be overwritten.

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.Start('packetDump.pcap')


        """
        return _byteblower.PacketDump_Start(self, filename)

    def Stop(self):
        r"""

        Stop capturing packets.

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.Stop()


        """
        return _byteblower.PacketDump_Stop(self)

    def FilterGet(self):
        r"""

        Returns the BPF filter.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FilterGet())


        """
        return _byteblower.PacketDump_FilterGet(self)

    def FilterSet(self, value):
        r"""

        Configures a BPF filter so that only packets that match the filter will be
        captured.

        :param filter: BPF filter
        :type filter: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.FilterSet('udp port 4096')


        """
        return _byteblower.PacketDump_FilterSet(self, value)

    def SnapshotLengthGet(self):
        r"""

        Returns the maximum number of bytes that can be captured for each packet.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.SnapshotLengthGet())


        """
        return _byteblower.PacketDump_SnapshotLengthGet(self)

    def SnapshotLengthSet(self, value):
        r"""

        Configure the maximum number of bytes that can be captured for each packet.

        :param length: Maximum number of bytes per captured packet
        :type length: int

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.SnapshotLengthSet(100000)


        """
        return _byteblower.PacketDump_SnapshotLengthSet(self, value)

    def FileNameGet(self):
        r"""

        Returns file name of the target pcap file.

        :rtype: str

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FileNameGet())


        """
        return _byteblower.PacketDump_FileNameGet(self)

    def FileSizeGet(self):
        r"""

        Returns current size of the target pcap file.

        :return: The current size of the captured file in bytes.
        :rtype: int

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FileSizeGet())


        """
        return _byteblower.PacketDump_FileSizeGet(self)

# Register PacketDump in _byteblower:
_byteblower.PacketDump_swigregister(PacketDump)
class ByteBlowerPort(AbstractObject):
    r"""

    Logical representation of a network host docked somewhere in the :term:`NUT`, 
    which can transmit or schedule network traffic, process incoming traffic and 
    run stateful network applications.  

    A ByteBlowerPort is physically connected (or 'attached') to the :term:`NUT` 
    through the physical ByteBlower interface on which it is created. See 
    :meth:`.ByteBlowerServer.PortCreate` for more information.  

    Multiple ports may be created on the same physical interface. From a network 
    view, they are just different (simulated) hosts within a shared (datalink or 
    layer 2) subnet. This means traffic to one port created on an interface is seen
    by all ports on that interface.  

    Most test scenarios start with one or more ByteBlower ports that are configured
    to do the following things:

    * become part of the network (layer2, layer3, perform DHCP, 
      join multicast groups, ...)
    * schedule network traffic streams for transmission (TX objects)
    * configure incoming packet processors (RX objects) that look for matching 
      packets and e.g. count them
    * start network applications such as HTTP servers
    * schedule network application actions (called 'schedulable objects') such an 
      HTTP client application sending out an HTTP request

    When such ports are subsequently activated, the scheduled streams and network 
    actions are performed at the configured time.  

    From that moment, relevant result data may be pulled from those streams (TX 
    statistics), incoming packet processors (RX statistics) and network 
    applications (application and session statistics).  

    Destroying a port will clean up everything that is configured on that port in a
    clean way:

    * streams, incoming packet processors and network applications are teared down,
      their results are gone
    * the port leaves all multicast groups of which it is part (but doesn't wait 
      for confirmation)
    * the port releases its DHCP lease (but doesn't wait for confirmation)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        r"""


        :meta private:


        """
        return _byteblower.ByteBlowerPort_ServerGet(self)

    def InterfaceNameGet(self):
        r"""

        Returns physical ByteBlower interface code.  

        :return: String code representing the physical interface name (e.g. trunk-1-4 
                 or nontrunk-1).  
        :rtype: str

        Each ByteBlower port is created on a physical ByteBlower interface of a server.
        This interface determines where the port will be 'attached' to the :term:`NUT`.  

        See :meth:`.ByteBlowerServer.PortCreate` for more information and to see how
        an interface name is structured.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port.InterfaceNameGet())
           # prints trunk-1-1


        """
        return _byteblower.ByteBlowerPort_InterfaceNameGet(self)

    def InterfaceSpeedGet(self):
        r"""

        Returns physical ByteBlower interface speed.  

        :return: The maximum speed in bits per second a ByteBlower Interface can 
                 transmit. This does not take any VLAN overhead into account!  
        :rtype: int

        See :meth:`.ByteBlowerServer.PortCreate` for more information and to see how an
        interface name is structured.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port.InterfaceSpeedGet())
           # prints 1000000000


        """
        return _byteblower.ByteBlowerPort_InterfaceSpeedGet(self)

    def InterfaceSwitchIdGet(self):
        r"""

        Returns the ID of the switch where the ByteBlower Port resides

        :return: Id of the switch where the ByteBlower Interface is connected
        :rtype: int


        """
        return _byteblower.ByteBlowerPort_InterfaceSwitchIdGet(self)

    def MDLMaximumGet(self):
        r"""

        Returns the port's highest allowed Maximum Data Length (MDL) value, which is limited by the physical interface.  

        :return: Physical upper bound for the MDL in bytes.  
        :rtype: int

        The MDL of a ByteBlower port places a limit on the size of ethernet frames that may be sent on that port. It can be modified by the user through :meth:`MDLSet`. The MDL value (in bytes) covers the whole ethernet packet, but excluding CRC, preamble and interframe gap.  

        The physical ByteBlower interface (e.g. nontrunk-1) on which a port is created places an upper bound on the allowed MDL values. Through this method, this property can be retrieved at runtime.  

        The typical value of the maximum MDL is 9014 on non-trunking interfaces and 9010 on trunking interfaces.  

        .. note:: On trunking interfaces the ByteBlower server adds a temporary VLAN automatically, to select an interface (e.g. trunk-1-10) on the ByteBlower switch. This is hidden from the user. However, it also means that from a user perspective, the maximum MDL value of the same physical interface is 4 bytes less when it's configured as a trunking interface.  

        Example

        Typical values for a trunking and a non-trunking
        port.  

        .. code-block:: python
           :emphasize-lines: 1

           print(port1.MDLMaximumGet())


        """
        return _byteblower.ByteBlowerPort_MDLMaximumGet(self)

    def MDLGet(self):
        r"""

        Returns the port's current Maximum Data Length (MDL), the maximum ethernet frame size that can be transmitted.  

        :return: Current MDL value in bytes.  
        :rtype: int

        The MDL is the maximum size (in bytes) for any ethernet packet leaving the 
        port. It includes the ethernet header, but excludes CRC, preamble and 
        interframe gap. To calculate the maximum size of the layer 2 *payload*, 
        substract the 14 bytes of the ethernet header.   

        This payload may be a layer 3 IP packet, a layer 2.5 VLAN tag followed by such 
        a layer 3 IP packet or anything else.  

        The MDL value defaults to 1514, which corresponds with a layer 2 payload of 
        1500 bytes.  

        This value is used by the protocol stack. For example, the announced 
        TCP Maximum Segment Size (MSS) is based on this MDL value. This value also 
        limits the number of bytes that can be placed in a Frame when calling 
        :meth:`.Frame.BytesSet`.  

        .. note:: For ports without layer 2.5 configurations, the default MDL of 
                1514 will also lead to a maximum layer 3 packet size of 1500. 
                This value is often called the Maximum Transmission Unit or MTU of an
                interface. When a port has a VLAN configuration however, the MTU will
                only be 1496 by default! Consider increasing the MDL to 1518 in such 
                cases to simulate typical real-world behavior.  

        .. note:: On trunking interfaces the ByteBlower server adds a temporary VLAN 
                automatically, to select an interface (e.g. trunk-1-10) on the 
                ByteBlower switch. This is hidden from the user and has no influence 
                on the MDL value. See ByteBlowerPort::MDLMaximumGet for more 
                information.  

        Example

        Typical values for a trunking and non-trunking
        port.  

        .. code-block:: python
           :emphasize-lines: 1

           print(port1.MDLGet())


        """
        return _byteblower.ByteBlowerPort_MDLGet(self)

    def MDLSet(self, mdl):
        r"""

        Sets the port's Maximum Data Length (MDL), the maximum ethernet frame size that
        can be transmitted.  

        :param mdl: New MDL value in bytes. Should be less then the value returned by 
                    :meth:`MDLMaximumGet`.  
        :type mdl: int

        :raises TypeError: When the value is is not an integer.  
        :raises ConfigError: When the provided value was larger than the maximum supported MDL. 

        See :meth:`MDLGet` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port.MDLSet(1350)
           print(port.MDLGet())
           # prints 1350


        """
        return _byteblower.ByteBlowerPort_MDLSet(self, mdl)

    def CapabilityListGet(self):
        r"""

        Returns a list of Capability objects.  

        .. versionadded:: 2.6.0  

        :return: An object representing a list of known capabilities
        :rtype: CapabilityList

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example shows how to query the capabilities on a ByteBlowerPort

           capability_list = port.CapabilityListGet()

           for capability in capability_list:
              print(capability.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_CapabilityListGet(self)

    def CapabilityGetByName(self, name):
        r"""

        Returns a Capability object by its name.  

        .. versionadded:: 2.6.0  

        :return: An object representing the requested capability
        :rtype: Capability

        :raises ConfigError: UnsupportedConfig error message when the Capability is not
                             supported

        Example

        .. code-block:: python
           :emphasize-lines: 1

           capability = port.CapabilityGetByName('IPv4')
           print(capability.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_CapabilityGetByName(self, name)

    def CapabilityIsSupported(self, name):
        r"""

        Checks whether a capability is supported.  

        .. versionadded:: 2.6.0  

        :return: True if it is supported, False if not  
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port.CapabilityIsSupported('IPv4')
           # prints True


        """
        return _byteblower.ByteBlowerPort_CapabilityIsSupported(self, name)

    def Layer2EthIISet(self):
        r"""

        Sets the layer 2 configuration of this port.  

        .. versionadded: 2.5.0  

        :rtype: EthernetConfiguration

        :raises ConfigError: When the layer 2 configuration is already set.  

        Once the layer 2 configuration is set, it cannot be destroyed or overwritten.  

        Example

        Configure the Port's network connection as an Ethernet interface and add MAC address.  

        .. code-block:: python
           :emphasize-lines: 1

           port.Layer2EthIISet().MacSet('00bb1b000001')


        """
        return _byteblower.ByteBlowerPort_Layer2EthIISet(self)

    def Layer2EthIIGet(self):
        r"""

        Returns the layer 2 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: The ethernet configuration of the ByteBlower port
        :rtype: EthernetConfiguration

        :raises ConfigError: When the layer 2 configuration is not yet set.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           eth_conf = port.Layer2EthIIGet()


        """
        return _byteblower.ByteBlowerPort_Layer2EthIIGet(self)

    def Layer25VlanAdd(self):
        r"""

        Adds a layer 2.5 VLAN to this port.  

        .. versionchanged:: 2.3.0
           Support for stacking multiple VLAN tags. Adding a second VLAN tag on an 
           older server will throw a technical exception.  

        .. versionchanged:: 2.5.0  
           Multiple layer 2.5 configurations can be added. They will be stacked on top 
           each other in the the port's network stack from the bottom up.  

        :return: Created VLAN configuration object.  
        :rtype: VLANTag

        :raises ConfigError: When an underlying layer 2 or layer 2.5 configuration is not yet fully configured.  

        Once a layer 2.5 configuration is added to a port, it cannot be destroyed or 
        removed.  

        Example

        Configure the Port's network connection as a VLAN-enabled virtual interface.  

        .. code-block:: python
           :emphasize-lines: 1

           vlan_tag = port.Layer25VlanAdd()
           vlan_tag.IDSet(20)


        """
        return _byteblower.ByteBlowerPort_Layer25VlanAdd(self)

    def Layer25VlanGet(self):
        r"""

        Returns the ordered list of layer 2.5 Vlan objects of this port.  

        .. versionadded:: 2.5.0  
           VLAN  objects can be added by :meth:`Layer25VlanAdd`.

        :rtype: Layer25VlanList

        Example

        Reading the number of `.VLANTag` objects of `port`
        Configure the Port's network connection as a VLAN-enabled virtual interface.  

        .. code-block:: python
           :emphasize-lines: 1

           vlan_list = port.Layer25VlanGet()


        """
        return _byteblower.ByteBlowerPort_Layer25VlanGet(self)

    def Layer25VlanRemove(self, inVlanTag):
        r"""


        :meta private:


        """
        return _byteblower.ByteBlowerPort_Layer25VlanRemove(self, inVlanTag)

    def Layer25PPPoEAdd(self):
        r"""

        Adds a layer 2.5 PPPoE Client to this port.  

        .. versionadded:: 2.5.0  

        :return: an object representing an PPPoE client
        :rtype: PPPoEClient

        :raises ConfigError: When an underlying layer 2 or layer 2.5 configuration is 
                            not yet fully configured.  

        Once a layer 2.5 configuration is added to a port, it cannot be destroyed or
        removed.  

        Example

        Configure the Port's network connection as a PPPoE-enabled virtual interface.  

        .. code-block:: python
           :emphasize-lines: 1

           # set an PPPoE client
           client = port.Layer25PPPoEAdd()
           print(client.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_Layer25PPPoEAdd(self)

    def Layer25PPPoEGet(self):
        r"""

        Returns the ordered list of layer 2.5 PPPoE objects of this port.  

        .. versionadded:: 2.5.0  
           PPPoE objects can be added by :meth:`.ByteBlowerPort.Layer25PPPoEAdd`

        :return: A list with all the PPPoE clients created
        :rtype: Layer25PPPoEList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           layer25PPPoEGet = port.Layer25PPPoEGet()


        """
        return _byteblower.ByteBlowerPort_Layer25PPPoEGet(self)

    def Layer25PPPoERemove(self, inPPPoEClient):
        r"""


        :meta private:


        """
        return _byteblower.ByteBlowerPort_Layer25PPPoERemove(self, inPPPoEClient)

    def Layer3IPv4Set(self):
        r"""

        Sets the layer 3 IPv4 configuration of this port.  

        .. versionadded:: 2.5.0  

        :return: an object representing the IPv4 configuration for the ByteBlower port
        :rtype: IPv4Configuration

        :raises ConfigError: When an underlying layer 2 or layer 2.5 configuration is 
                             not yet fully configured.  
        :raises ConfigError: When the layer 3 configuration is already set.  

        Once a layer 3 configuration is set, it cannot be destroyed or overwritten.  

        Both IPv4 and IPv6 are supported. Dual stack is not available on a single port,
        but can be achieved by creating 2 separate ports with identical layer 2 and 
        (possibly) layer 2.5 configurations.  

        Example

        Configure the Port's network connection as an IPv4 host.  

        .. code-block:: python
           :emphasize-lines: 1

           ipv4_config = port.Layer3IPv4Set()


        """
        return _byteblower.ByteBlowerPort_Layer3IPv4Set(self)

    def Layer3IPv4Get(self):
        r"""

        Returns the layer 3 IPv4 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: A created IPv4 configuration object
        :rtype: IPv4Configuration

        :raises ConfigError: When the layer 3 configuration is not yet set.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           ipv4_config = port.Layer3IPv4Get()
           print(ipv4_config.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_Layer3IPv4Get(self)

    def Layer3IPv6Set(self):
        r"""

        Sets the layer 3 IPv6 configuration of this port.  

        .. versionadded:: 2.5.0  

        :rtype: IPv6Configuration

        :raises ConfigError: When an underlying layer 2 or layer 2.5 configuration is not yet fully configured.  
        :raises ConfigError: When the layer 3 configuration is already set.  

        Once a layer 3 configuration is set, it cannot be destroyed or overwritten.  

        Both IPv4 and IPv6 are supported. Dual stack is not available on a single port,
        but can be achieved by creating 2 separate ports with identical layer 2 and 
        (possibly) layer 2.5 configurations.  

        Example

        Configure the Port's network connection as an IPv6 host.  

        .. code-block:: python   
           :emphasize-lines: 1

           bbPort1_l3 = port1.Layer3IPv6Set().IpManualAdd('3000:3128::24/64')


        """
        return _byteblower.ByteBlowerPort_Layer3IPv6Set(self)

    def Layer3IPv6Get(self):
        r"""

        Returns the layer 3 IPv6 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: An object with the IPv6 configuration of the ByteBlower Port
        :rtype: IPv6Configuration

        :raises ConfigError: When the layer 3 configuration is not yet set.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           l3_config = port.Layer3IPv6Get()


        """
        return _byteblower.ByteBlowerPort_Layer3IPv6Get(self)

    def ProtocolHttpServerAdd(self):
        r"""

        Creates a HTTP server application to run on this port.  

        :return: an object representing an HTTP Server object.
        :rtype: HTTPServer

        An HTTP Server application is a customized HTTP server that is typically used 
        to emulate a TCP connection.  

        It listens for special HTTP requests (sent by :class:`.HTTPClient` 
        applications) and responds in the desired way. For example, an HTTP request may
        ask (GET) for a response of a specified size and the HTTP server will emulate 
        sending such a file back.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server = port.ProtocolHttpServerAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpServerAdd(self)

    def ProtocolHttpServerGet(self):
        r"""

        Returns the list of all HTTP server applications created on this port.  

        See :meth:`ProtocolHttpServerAdd` for more information.  

        :return: A list of HTTP Server objects.
        :rtype: HTTPServerList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port.ProtocolHttpServerGet())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpServerGet(self)

    def ProtocolHttpServerRemove(self, arg2):
        r"""

        Removes a HTTP server application to from this port.  

        :param server: HTTP Server object to remove
        :type server: HTTPServer


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpServerRemove(self, arg2)

    def ProtocolHttpClientAdd(self):
        r"""

        Creates a HTTP client application to run on this port.  

        :rtype: HTTPClient

        A ::class:`.HTTPClient` application can initiate customized HTTP sessions that 
        are typically used to emulate a TCP connection.  

        It allows configuring the special HTTP requests to which a running 
        :class:`.HTTPServer` application responds. For example, an HTTP client can ask 
        (GET) for a response of a specified size or time or may send (PUT) a payload of
        a specified size or time itself.  

        Besides constructing such special HTTP requests, the HTTP client can interact 
        with any normal webserver by configuring its URL.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient = port.ProtocolHttpClientAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpClientAdd(self)

    def ProtocolHttpClientGet(self):
        r"""

        Returns the list of all HTTP client applications created on this port.  

        :return: returns a list of created :class:`.HTTPClient` objects
        :rtype: HTTPClientList

        See :meth:`ProtocolHttpClientAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           all_clients = port.ProtocolHttpClientGet()
           print(all_clients.size())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpClientGet(self)

    def ProtocolHttpClientRemove(self, arg2):
        r"""

        Removes the HTTP Client application from this port

        :param client: The client to remove
        :type client: HTTPClient


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpClientRemove(self, arg2)

    def ProtocolHttpMultiServerAdd(self):
        r"""

        Creates a HTTP MultiServer application on this port.  

        :rtype: HTTPMultiServer

        Example

        .. code-block:: python
           :emphasize-lines: 1

           # create the HTTP client
           httpServer = port.ProtocolHttpMultiServerAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerAdd(self)

    def ProtocolHttpMultiServerGet(self):
        r"""

        Returns the list of :class:`.HTTPMultiServer` objects on this port.  

        :rtype: HTTPMultiServerList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port.ProtocolHttpMultiServerGet())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerGet(self)

    def ProtocolHttpMultiServerRemove(self, arg2):
        r"""

        Removes a HTTP MultiServer application from this port

        :param server: The HTTP MultiServer object to remove
        :type server: HTTPMultiServer


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerRemove(self, arg2)

    def ProtocolHttpMultiClientAdd(self):
        r"""

        Creates a Multi Client application on this port.  

        :rtype: HTTPMultiClient

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpClient = port.ProtocolHttpMultiClientAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientAdd(self)

    def ProtocolHttpMultiClientGet(self):
        r"""

        Returns the list of a :class:`.HTTPMultiClient` objects on this port.  

        :rtype: HTTPMultiClientList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port.ProtocolHttpMultiClientGet())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientGet(self)

    def ProtocolHttpMultiClientRemove(self, arg2):
        r"""

        Removes a HTTP Multiclient application from this port

        :param client: The HTTP MultiClient to remove
        :type client: HTTPMultiClient


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientRemove(self, arg2)

    def TunnelTcpAdd(self):
        r"""

        Creates a TCP tunnel object.  

        :return: The created tunnel.  This object can be used to configure the tunnel
        :rtype: TCPTunnel

        A TCP Tunnel  can be used to configure TCP port forwarding between the
        user's office network and the lab network.  

        Through the protocol, a client can requesting dynamic changes to the firewall 
        or NAT port forwarding settings of a (PCP-enabled) gateway.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tunnel = port.TunnelTcpAdd()
           print(tunnel.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_TunnelTcpAdd(self)

    def TunnelTcpGet(self):
        r"""

        Returns a list of all TCP Tunnel objects created on this port.  

        :rtype: TCPTunnelList

        See :meth:`TunnelTcpAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tunnelTcp = port.TunnelTcpGet()


        """
        return _byteblower.ByteBlowerPort_TunnelTcpGet(self)

    def TunnelTcpRemove(self, arg2):
        r"""

        Removes the given TCP Tunnel application from this port

        :param tunnel: TCP Tunnel to remove
        :type tunnel: TCPTunnel


        """
        return _byteblower.ByteBlowerPort_TunnelTcpRemove(self, arg2)

    def ProtocolTelnetClientAdd(self):
        r"""

        Creates a Telnet client application to run on this port.  

        .. versionadded:: API 2.2.0  

        :rtype: TelnetClient

        A Telnet Client application can contact and interact with an external Telnet server.  

        Apart from simulating such scenarios for its own sake, this application can be used to contact important nodes within the :term:`NUT` (e.g. a router) and retrieve relevant statistics from it.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           protocolTelnetClient = port.ProtocolTelnetClientAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientAdd(self)

    def ProtocolTelnetClientGet(self):
        r"""

        Returns the list of all Telnet client applications created on this port.  

        .. versionadded:: API 2.2.0  

        :rtype: TelnetClientList

        See :meth:`ProtocolTelnetClientAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           protocolTelnetClient = port.ProtocolTelnetClientGet()


        """
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientGet(self)

    def ProtocolTelnetClientRemove(self, arg2):
        r"""

        Removes a Telnet client application from this port

        :param client: Telnet client to remove
        :type client: TelnetClient


        """
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientRemove(self, arg2)

    def TxStreamAdd(self):
        r"""

        Creates a transmit stream, which can be configured to blast layer 2 frames traffic from this port in a stateless way.  

        :return: an object representing a pure frame blasting stream.
        :rtype: Stream

        Initially, a stream does not contain any traffic. It must still be configured 
        by adding content (in the form of Frame objects) and timing information 
        (especially the interframe gap).

        A :class:`.Stream` can be compared to the transmitting part of a frame blasting
        flow in the GUI.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream = port.TxStreamAdd()


        """
        return _byteblower.ByteBlowerPort_TxStreamAdd(self)

    def TxStreamRemove(self, inStream):
        r"""

        Removes a created ByteBlower Stream from a port

        :param stream: Stream object to remove
        :type stream: Stream


        """
        return _byteblower.ByteBlowerPort_TxStreamRemove(self, inStream)

    def TxStreamGet(self):
        r"""

        Returns a list of transmit streams created on this port.  

        :return: A list with all created :class:`.Stream` objects
        :rtype: StreamList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           streams = port.TxStreamGet()
           print(streams.size())
           # prints 1


        """
        return _byteblower.ByteBlowerPort_TxStreamGet(self)

    def RxTriggerBasicAdd(self):
        r"""

        Creates a basic receive trigger, whose counters are updated for each received frame (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        :return: A basic trigger object, which allows to configure the trigger and 
                 getting the results
        :rtype: TriggerBasic

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        The receive trigger is activated as soon as it is created, so don't forget to 
        reset its counters after setting the filter and initializing your test.  

        See the class documentation of the returned types for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger = port.RxTriggerBasciAdd()


        """
        return _byteblower.ByteBlowerPort_RxTriggerBasicAdd(self)

    def RxTriggerBasicGet(self):
        r"""

        Returns the list of receive triggers created on this port.  

        .. versionadded:: 2.5.0  

        :return: an object representing a list of create basic triggers
        :rtype: TriggerBasicList

        See :meth:`RxTriggerBasicAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           all_triggers = port.RxTriggerBasicGet()
           print(all_triggers.size())
           # prints 1  

        """
        return _byteblower.ByteBlowerPort_RxTriggerBasicGet(self)

    def RxTriggerBasicRemove(self, arg2):
        r"""

        Removes a created basic trigger

        :param trigger: Trigger to remove
        :type trigger: TriggerBasic


        """
        return _byteblower.ByteBlowerPort_RxTriggerBasicRemove(self, arg2)

    def RxTriggerSizeDistributionAdd(self):
        r"""

        Creates a size distribution receive trigger, whose counters are updated for each received frame (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        :rtype: TriggerSizeDistribution

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        The receive trigger is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See the class documentation of the returned types for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger = port.RxTriggerSizeDistributionAdd()


        """
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionAdd(self)

    def RxTriggerSizeDistributionGet(self):
        r"""

        Returns the list of receive triggers created on this port.  

        .. versionadded:: 2.5.0  

        :return: A list with all the sizedistribution triggers created
        :rtype: TriggerSizeDistributionList

        See :meth:`RxTriggerSizeDistributionAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           all_size_dists = port.RxTriggerSizeDistributionGet()
           print(all_size_dists.size())
           # prints 1


        """
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionGet(self)

    def RxTriggerSizeDistributionRemove(self, arg2):
        r"""

        Removes a created size distribution trigger

        :param trigger: Trigger to remove
        :type trigger: TriggerSizeDistribution


        """
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionRemove(self, arg2)

    def RxLatencyBasicAdd(self):
        r"""

        Creates a latency calculator, which computes latency measurements based on timestamps in received frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        :rtype: LatencyBasic

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        Typically, the filter should limit the matching traffic to the Tx.Stream whose transmitted frames actually contain the required timestamps!  

        The latency calculator is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See :class:`.Frame` for information on timestamping.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latency = port.RxLatencyBasicAdd()


        """
        return _byteblower.ByteBlowerPort_RxLatencyBasicAdd(self)

    def RxLatencyBasicRemove(self, inLatency):
        r"""

        Removes a Basic Latency Trigger from this port

        :param trigger: Trigger object to remove
        :type trigger: LatencyBasic


        """
        return _byteblower.ByteBlowerPort_RxLatencyBasicRemove(self, inLatency)

    def RxLatencyBasicGet(self):
        r"""

        Returns the list of latency calculators created on this port.  

        .. versionadded:: 2.5.0  

        :rtype: LatencyBasicList

        See :meth:`RxLatencyBasicAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           all_latency = port.RxLatencyBasicGet()
           print(all_latency.size())
           # prints 1


        """
        return _byteblower.ByteBlowerPort_RxLatencyBasicGet(self)

    def RxLatencyDistributionAdd(self):
        r"""

        Creates a latency calculator, which computes latency measurements based on timestamps in received frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        :rtype: LatencyDistribution

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        Typically, the filter should limit the matching traffic to the Tx.Stream whose transmitted frames actually contain the required timestamps!  

        The latency calculator is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See :class:`.Frame` for information on timestamping.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           distribution = port.RxLatencyDistributionAdd()


        """
        return _byteblower.ByteBlowerPort_RxLatencyDistributionAdd(self)

    def RxLatencyDistributionRemove(self, inLatency):
        r"""

        Removes a Latency Distribution trigger from this port

        :param trigger: Trigger to remove
        :type trigger: LatencyDistribution


        """
        return _byteblower.ByteBlowerPort_RxLatencyDistributionRemove(self, inLatency)

    def RxLatencyDistributionGet(self):
        r"""

        Returns the list of latency calculators created on this port.  

        .. versionadded:: 2.5.0  

        :rtype: LatencyDistributionList

        See :meth:`.RxLatencyDistributionAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           all_latency = port.RxLatencyDistributionGet()


        """
        return _byteblower.ByteBlowerPort_RxLatencyDistributionGet(self)

    def RxOutOfSequenceBasicAdd(self):
        r"""

        Creates an out-of-sequence detector, which counts such cases based on sequence numbers in received frames (possibly restricted by a filter).

        .. versionadded:: 2.5.0  

        :return: Created out-of-sequence detector object.
        :rtype: OutOfSequence

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        Typically, the filter should limit the matching traffic to the :class:`.Stream`
        whose transmitted frames actually contain the required sequence numbers!   

        The out-of-sequence detector is activated as soon as it is created, so don't 
        forget to reset its counters after setting the filter and initializing your 
        test.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           out_of_sequence = port.RxOutOfsequenceBasicAdd()
           # lets assume traffic is sent to UDP port 9000
           out_of_sequence.FilterSet('ip && dst port 9000')
           print(out_of_sequence.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicAdd(self)

    def RxOutOfSequenceBasicRemove(self, inOutOfSequence):
        r"""

        Removes an Out-of-Sequence trigger from the port

        :param trigger: Trigger to remove
        :type trigger: OutOfSequence


        """
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicRemove(self, inOutOfSequence)

    def RxOutOfSequenceBasicGet(self):
        r"""

        Returns the list of out-of-sequence detectors created on this port.  

        .. versionadded:: 2.5.0  

        :return: A list of created objects
        :rtype: OutOfSequenceList

        See :meth:`RxOutOfSequenceBasicAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           all_oos = port.RxOutOfSequenceBasicGet()
           print(all_oos.size())
           # prints 1


        """
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicGet(self)

    def Start(self):
        r"""

        Starts all transmit streams and schedulable objects configured on this port.  

        See :obj:`ByteBlower.PortsStart`, which does the same for a set of ports, for
        more information.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port.Start()


        """
        return _byteblower.ByteBlowerPort_Start(self)

    def Stop(self):
        r"""

        Stops all transmit streams and schedulable objects configured on this port.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port.Stop()


        """
        return _byteblower.ByteBlowerPort_Stop(self)

    def ResultGet(self):
        r"""

        Returns the result object.  

        :return: A result object which contains the packet count, byte count etc for 
                 this ByteBlower port. 
        :rtype: ByteBlowerPortResultSnapshot

        Example

        .. code-block:: python
           :emphasize-lines: 1

           result = port.ResultGet()
           print(result.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_ResultGet(self)

    def ResultHistoryGet(self):
        r"""

        Returns the history for the counters for the ByteBlower port.  

        :return: An object representing the history of the counters of the ByteBlower Port
        :rtype: ByteBlowerPortResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

           historyResult = port.ResultHistoryGet()
           print(historyResult.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_ResultHistoryGet(self)

    def ResultClear(self):
        r"""

        Clears the counters for the ByteBlower port and empties the :class:`.ByteBlowerPortResultHistory`.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port.ResultClear()


        """
        return _byteblower.ByteBlowerPort_ResultClear(self)

    def RxCaptureBasicAdd(self):
        r"""

        Creates a capture tool, which captures the data and metadata of incoming frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        :return: An object representing the servers implementation of the capture
                 functionality
        :rtype: CaptureRawPacket

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        Typically, the filter should limit the matching packets to the interesting 
        traffic, especially since capturing all incoming bytes at high rates may place
        a heavy load on the server.  

        .. note:: Unlike other Rx objects, the capture tool is not activated as soon as
           it is created.  See the class documentation of the returned types for more 
           information.  

        .. warning:: Using this tool requires a lot of system resources. Try to avoid 
           capturing at high rates or for a long time. Set the capture filter as strict
           as possible to avoid unwanted traffic. When too much incoming traffic must 
           be processed, the ByteBlower server may become unstable.  

        .. note:: It is also possible to log in to the server and capture there. Note
           that when capturing a trunking interface (i.e. connected to a switch) you 
           will see an extra VLAN tag that shows to or from which interface the traffic
           goes. This is currently *only* possible on the 1x00 series, where the
           Linux `tcpdump` tool can sniff the server's (native) data interfaces.  

        .. note:: This functionality is also available with a stand-alone command-line
           tool. It can be found and downloaded on our support portal.  

        The returned capture tool is a basic capture tool stores both the frame data 
        and some metadata.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           captureTool = port.RxCaptureBasicAdd()
           captureTool.Start()


        """
        return _byteblower.ByteBlowerPort_RxCaptureBasicAdd(self)

    def RxCaptureBasicRemove(self, inCapture):
        r"""

        Removes a capture

        :param capture: The object returned by :meth:`RxCaptureBasicAdd` or :meth:`RxCaptureBasicGet`
        :type capture: CaptureRawPacket


        """
        return _byteblower.ByteBlowerPort_RxCaptureBasicRemove(self, inCapture)

    def RxCaptureBasicGet(self):
        r"""

        Returns the list of capture tools created on this port.  

        .. versionadded: 2.5.0  

        :rtype: CaptureRawPacketList

        See :meth:`RxCaptureBasicAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           tools = port.RxCaptureBasicGet()


        """
        return _byteblower.ByteBlowerPort_RxCaptureBasicGet(self)

# Register ByteBlowerPort in _byteblower:
_byteblower.ByteBlowerPort_swigregister(ByteBlowerPort)
class ByteBlowerPortResultRxData(AbstractObject):
    r"""

    ByteBlower port counter result set.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or :class:`.ByteBlowerPortResultSnapshot`

    .. note:: See What's new in API v2 for more information.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       rx_result=port_result.RxAllGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    CounterType_RxBroadcast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxBroadcast
    CounterType_RxUnicast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxUnicast
    CounterType_RxAll = _byteblower.ByteBlowerPortResultRxData_CounterType_RxAll

    def TimestampFirstGet(self):
        r"""

        Gets the timestamp of the first packet in this snapshot.

        :return: The timestamp in nanoseconds since epoch when the first packet in this
                 was counted        
        :rtype: int

        :raises DomainError: When no frames are  received, this counter is unavailable

        Example

        This example gets the timestamp of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.TimestampFirstGet())


        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        r"""

        Gets the current timestamp of the last packet in this snapshot.

        :return: The timestamp in nanoseconds of the last packet in this sample
        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the timestamp of the last received packet in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.TimestampLastGet())


        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampLastGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp.

        :return: The timestamp in nanoseconds since epoch when this sample was created
        :rtype: int 

        Example

        This example gets the snapshot timestamp.

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.TimestampGet()) 

        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampGet(self)

    def PacketCountGet(self):
        r"""

        Gets the received packet count.

        :rtype: int

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.PacketCountGet())


        """
        return _byteblower.ByteBlowerPortResultRxData_PacketCountGet(self)

    def ByteCountGet(self):
        r"""

        Gets the current received bytes counter.

        :rtype: int

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.ByteCountGet())


        """
        return _byteblower.ByteBlowerPortResultRxData_ByteCountGet(self)

    def ByteCountWithCRCGet(self):
        r"""

        Gets the current received bytes counter with the CRC.

        :rtype: int

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.ByteCountWithCRCGet())


        """
        return _byteblower.ByteBlowerPortResultRxData_ByteCountWithCRCGet(self)

    def FramesizeMinimumGet(self):
        r"""

        Gets the smallest frame size received in this snapshot.

        :rtype: int

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.FramesizeMinimumGet())


        """
        return _byteblower.ByteBlowerPortResultRxData_FramesizeMinimumGet(self)

    def FramesizeMaximumGet(self):
        r"""

        Gets the largest frame size received in this snapshot.

        :rtype: int 

        :raises DomainError: When no frames are received, this counter is unavailable

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.FramesizeMaximumGet())


        """
        return _byteblower.ByteBlowerPortResultRxData_FramesizeMaximumGet(self)

    def IntervalDurationGet(self):
        r"""

        Returns the duration of this sample

        :return: The duration in nanoseconds
        :rtype: int


        """
        return _byteblower.ByteBlowerPortResultRxData_IntervalDurationGet(self)

# Register ByteBlowerPortResultRxData in _byteblower:
_byteblower.ByteBlowerPortResultRxData_swigregister(ByteBlowerPortResultRxData)

def ConvertCounterType(inType):
    return _byteblower.ConvertCounterType(inType)
class ByteBlowerPortResultData(AbstractObject):
    r"""

    ByteBlower port counter result set.

    The result set contains three different counters:

    - a Unicast counter, which counts all received unicast Ethernet frames.
    - a Broadcast counter, which counts all received broadcast Ethernet frames.
    - an All counter, which counts all received Ethernet frames.

    .. note:: The 'all' counter can be seen as the combination of the unicast and
              the broadcast counter.

    .. note:: See What's new in API v2 for more information.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or ByteBlowerPort.ResultSnapshot

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 2

       result = port.ResultHistoryGet()
       resultData = result.CumulativeLatestGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxUnicastGet(self):
        r"""

        Gets the received unicast counters for the port.

        :return: a statistics object which contain all unicast counters from a port. 
                 This will only contain the broadcast unicast received on the port.
        :rtype: ByteBlowerPortResultRxData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.RxUnicastGet().DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultData_RxUnicastGet(self)

    def RxBroadcastGet(self):
        r"""

        Gets the received broadcast counters for the port.

        :return: A statistics object which contain all counters from a port. 
                 This will only contain the broadcast packets received on the port.
        :rtype: ByteBlowerPortResultRxData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.RxBroadcastGet().DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultData_RxBroadcastGet(self)

    def RxAllGet(self):
        r"""

        Gets the received counters for the port.

        :return: a statistics object which contains all counters from a port
        :rtype: ByteBlowerPortResultRxData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.RxAllGet().DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultData_RxAllGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp.

        :return: the snapshot timestamp in nanoseconds from epoch when this snapshot was created.
        :rtype: int

        Example

        This example gets the snapshot timestamp.

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.TimestampGet())


        """
        return _byteblower.ByteBlowerPortResultData_TimestampGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot.

        .. versionadded:: 2.3.0

        :return: The interval duration for this sample in nanoseconds
        :rtype: int

        Example

        This example gets interval duration of this result snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(resultData.IntervalDurationGet())


        """
        return _byteblower.ByteBlowerPortResultData_IntervalDurationGet(self)

# Register ByteBlowerPortResultData in _byteblower:
_byteblower.ByteBlowerPortResultData_swigregister(ByteBlowerPortResultData)
class ByteBlowerPortResultSnapshot(AbstractRefreshableResult):
    r"""

    ByteBlower port counter result set.

    The result set contains three different counters:

    - a Unicast counter, which counts all received unicast Ethernet frames.
    - a Broadcast counter, which counts all received broadcast Ethernet frames.
    - an All counter, which counts all received Ethernet frames.

    .. note:: The "all" counter can be seen as the combination of the unicast
              and the broadcast counter.

    .. note:: See What's new in API v2 for more information.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or :class:`.ByteBlowerPortResultSnapshot`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       port_result = port.ResultGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Resets all counters back to 0


        """
        return _byteblower.ByteBlowerPortResultSnapshot_Clear(self)

    def RxUnicastGet(self):
        r"""

        Gets the received unicast counters for the port. 

        :return: a statistics object which contain all unicast counters from a port. 
                 This will only contain the broadcast unicast received on the port.
        :rtype: ByteBlowerPortResultRxData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_result.RxUnicastGet.DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxUnicastGet(self)

    def RxBroadcastGet(self):
        r"""

        Gets the received broadcast counters for the port. 

        :return: A statistics object which contain all counters from a port. 
                 This will only contain the broadcast packets received on the port.
        :rtype: ByteBlowerPortResultRxData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_result.RxBroadcastGet.DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxBroadcastGet(self)

    def RxAllGet(self):
        r"""

        Gets the received counters for the port. 

        :return: a statistics object which contain all counters from a port.
        :rtype: ByteBlowerPortResultRxData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_result.RxAllGet.DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxAllGet(self)

    def TimestampGet(self):
        r"""

        Gets the snapshot timestamp.

        :return: Timestamp on the server when the current snapshot is created in
                 nanoseconds since epoch
        :rtype: int

        Example

        This example gets the snapshot timestamp.

        .. code-block:: python
           :emphasize-lines: 1

           print(port_result.TimestampGet())


        """
        return _byteblower.ByteBlowerPortResultSnapshot_TimestampGet(self)

    def IntervalDurationGet(self):
        r"""

        Gets the *configured* duration of this results snapshot.

        .. versionadded:: 2.3.0

        :return: The duration of this sample in nanoseconds
        :rtype: int

        Example

        This example gets interval duration of this result snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(port_result.IntervalDurationGet())


        """
        return _byteblower.ByteBlowerPortResultSnapshot_IntervalDurationGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current snapshot is requested.

        :return: Timestamp on the server when the current snapshot is requested in
                 nanoseconds since epoch
        :rtype: int

        When the snapshot is part of a history, the refresh timestamp will be the same
        as refresh timestamp of the History object.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_result.RefreshTimestampGet())


        """
        return _byteblower.ByteBlowerPortResultSnapshot_RefreshTimestampGet(self)

# Register ByteBlowerPortResultSnapshot in _byteblower:
_byteblower.ByteBlowerPortResultSnapshot_swigregister(ByteBlowerPortResultSnapshot)
class ByteBlowerPortResultDataList(object):
    r"""

    This is a List of multiple ByteBlowerPortResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerPortResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerPortResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerPortResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerPortResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerPortResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerPortResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.ByteBlowerPortResultDataList_swiginit(self, _byteblower.new_ByteBlowerPortResultDataList(*args))
    __swig_destroy__ = _byteblower.delete_ByteBlowerPortResultDataList

# Register ByteBlowerPortResultDataList in _byteblower:
_byteblower.ByteBlowerPortResultDataList_swigregister(ByteBlowerPortResultDataList)
class ByteBlowerPortResultHistory(AbstractRefreshableResult):
    r"""

    Port counter result history.

    The port counter history is - as always - available in two flavors: the
    cumulative and the interval results

    .. note:: The information is not updated until :obj:`~.AbstractObject.Refresh`
              is called on this object.

    .. note:: See History result for more information.

    A result history object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.ResultHistoryGet`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       port_resultHistory = port.ResultHistoryGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Removes the locally stored history snapshots.

        This can be used to save memory in long tests where the results are requested
        at regular intervals.

        .. warning:: Any interval or cumulative result object returned from this
                     history object before calling :meth:`Clear` will be destroyed and
                     thus become unusable.


        """
        return _byteblower.ByteBlowerPortResultHistory_Clear(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Duration of one sampling interval in nanoseconds.

        :return: Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.SamplingIntervalDurationGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one sampling interval.

        .. versionadded:: 2.3.0

        :param duration: New duration for a new snapshot interval expressed in nanoseconds
        :type duration: int

        .. warning:: This affects all users on the same ByteBlower interface.

        .. warning:: The previously collected history will be invalidated.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port1_resultHistory.SamplingIntervalDurationGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthGet(self):
        r"""

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the sample buffer
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.SamplingBufferLengthGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, inCount):
        r"""

        Sets the number of samples to keep in the buffer.

        .. versionadded:: 2.3.0

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :param length: New number of samples to store.
        :type length: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port_resultHistory.SamplingBufferLengthSet(10)


        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingBufferLengthSet(self, inCount)

    def CumulativeGet(self):
        r"""

        Returns a list of available cumulative counters.

        :return: a list containing the Interval counters
        :rtype: ByteBlowerPortResultDataList

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           for results in port_resultHistory.CumulativeGet():
                print(results.DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGet(self)

    def IntervalGet(self):
        r"""

        Returns a list of available interval counters.

        :return: a list containing the Interval counters
        :rtype: ByteBlowerPortResultDataList

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           for i in resultHistory.IntervalGet():
                print(i.DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGet(self)

    def CumulativeGetByIndex(self, index):
        r"""

        Returns a single item of the cumulative list.

        :param index: Index of the cumulative snapshot to query
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: ByteBlowerPortResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(resultHistory.CumulativeGetByIndex(0).DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGetByIndex(self, index)

    def IntervalGetByIndex(self, index):
        r"""

        Returns a single item of the interval list.

        :param index: Index of the interval to query
        :type index: int

        :return: interval counter object at the specified index
        :rtype: ByteBlowerPortResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalGetByIndex(0).DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGetByIndex(self, index)

    def CumulativeGetByTime(self, timestamp):
        r"""

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        .. versionadded:: 2.2

        :param timestamp: timestamp in nanoseconds since epoch identifying the snapshot
        :type timestamp: int

        :return: The queried snapshot
        :rtype: ByteBlowerPortResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeGetByTime(timestamp).DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGetByTime(self, timestamp)

    def IntervalGetByTime(self, timestamp):
        r"""

        Returns a single item of the interval list using a timestamp in nanoseconds.

        .. versionadded:: 2.2

        :rtype: ByteBlowerPortResultRxData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           interval = port_resultHistory.IntervalGetByTime(timestamp)


        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        r"""

        Returns latest closed item of the cumulative list.

        .. versionadded:: 2.2

        :return: The last closed cumulative counter object.
        :rtype: ByteBlowerPortResultData

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeLatestGet.DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeLatestGet(self)

    def IntervalLatestGet(self):
        r"""

        Returns the latest closed item of the interval list.

        .. versionadded:: 2.2

        :return: The last closed interval counter object.
        :rtype: ByteBlowerPortResultData

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalLatestGet.DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalLatestGet(self)

    def CumulativeLengthGet(self):
        r"""

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeLengthGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeLengthGet(self)

    def IntervalLengthGet(self):
        r"""

        Returns the size of the interval list.

        :return: The length of the interval list
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalLengthGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Returns the timestamp on the server when the current history is requested.

        :return: Timestamp on the server when the current history is requested in
                 nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.RefreshTimestampGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_RefreshTimestampGet(self)

# Register ByteBlowerPortResultHistory in _byteblower:
_byteblower.ByteBlowerPortResultHistory_swigregister(ByteBlowerPortResultHistory)
class ByteBlowerServer(AbstractObject):
    r"""

    Representation of a client connection to a shared,  physical ByteBlower server, 
    which can send and receive network traffic through its interfaces.  

    Using this class, ByteBlower ports (logical network hosts) can be docked to a 
    :term:`NUT` at a specific place.  

    Furthermore, information about a shared ByteBlower Server, such as the 
    available interfaces and the current connections can be retrieved.  

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PhysicalInterfacesGet(self):
        r"""

        Gets a list of Physical Interfaces

        :rtype: PhysicalInterfaceList


        """
        return _byteblower.ByteBlowerServer_PhysicalInterfacesGet(self)

    def PhysicalInterfacesGetByType(self, inPhysicalInterfaceType):
        r"""

        Gets a list of Physical Interfaces for a given type

        :param type: Type to filter on
        :type type: PhysicalInterfaceType

        :rtype: PhysicalInterfaceList


        """
        return _byteblower.ByteBlowerServer_PhysicalInterfacesGetByType(self, inPhysicalInterfaceType)

    def InterfaceGetByName(self, name):
        r"""

        Gets a specific ByteBlower Interface

        :param name: Name of the interface to fetch
        :type name: str

        :rtype: ByteBlowerInterface

        Example

        .. code-block:: python

           interface = server.InterfaceGetByName('trunk-1-1')


        """
        return _byteblower.ByteBlowerServer_InterfaceGetByName(self, name)

    def InterfaceNamesGet(self):
        r"""

        Shows the available physical ByteBlower interfaces on the ByteBlower server.  

        :return: A list of all available physical interfaces on this server.  
        :rtype: StringList

        The available interfaces on a server depend on the static server configuration. 
        Only the presence of USB interfaces can change dynamically (using ::Update).  

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        This format is used as keys in the key-value pair list returned by :meth:`UsersGet`.
        It is also the format that should be passed to :meth:`PortCreate` method as 
        argument.

        Example

        Assume `server` has a single 48-port trunking interface and a single 
        non-trunking interface.

        .. code-block:: python
           :emphasize-lines: 1

           server.InterfaceNamesGet()
           # Returns ['trunk-1-1', 'trunk-1-2', 'trunk-1-3', ... , 'trunk-1-48', 'nontrunk-1']

        """
        return _byteblower.ByteBlowerServer_InterfaceNamesGet(self)

    def PacketDumpCreate(self, *args):
        r"""

        Creates a PacketDump object on the specified ByteBlower interface.  

        .. versionadded:: 2.9.0

        :param interface: Interface name of the ByteBlower interface
        :type interface: str

        :rtype: PacketDump

        :raises ConfigError: UnknownByteBlowerInterface 
                             When the specified interface name does not exist on the 
                             connected server.  

        The PacketDump API allows to capture all incoming and outgoing network traffic 
        on a ByteBlower interface.  

        Example

        Create a PacketDump object on trunk-1-1  

        .. code-block:: python
           :emphasize-lines: 1

           dump = server.PacketDumpCreate('trunk-1-1')


        Creates a PacketDump object on the specified ByteBlower interface.  

        .. versionadded:: 2.9.0

        :param interface: ByteBlower Interface to create a dump on
        :type interface: ByteBlowerInterface

        :rtype: PacketDump

        :raises ConfigError: UnknownByteBlowerInterface 
                             When the specified interface name does not exist on the 
                             connected server.  

        The PacketDump API allows to capture all incoming and outgoing network traffic 
        on a ByteBlower interface.  

        Example

        Create a PacketDump object on trunk-1-1  

        .. code-block:: python
           :emphasize-lines: 2

           interface = server.InterfaceGetByName('trunk-1-1')
           dump = server.PacketDumpCreate(interface)


        """
        return _byteblower.ByteBlowerServer_PacketDumpCreate(self, *args)

    def PacketDumpDestroy(self, packet_dump):
        r"""

        Removes a created packetdump

        :type dump: PacketDump


        """
        return _byteblower.ByteBlowerServer_PacketDumpDestroy(self, packet_dump)

    def PortCreate(self, *args):
        r"""

        Creates a new ByteBlower port on the specified ByteBlower interface.  

        :param interface: String code for the ByteBlower interface on which to create the port.  
        :type interface: str

        :rtype: ByteBlowerPort

        :raises ConfigError: UnknownByteBlowerInterface 
                             When the specified interface name does not exist on the 
                             connected server.  

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfaceNamesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortCreate('trunk-1-1')


        Creates a new ByteBlower port on the specified ByteBlower interface.  

        :param interface: The ByteBlower interface to create the port on.  
        :type interface: ByteBlowerInterface

        :rtype: ByteBlowerPort

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfaceNamesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           interface = server.InterfaceGetByName('trunk-1-1')
           port = server.PortCreate(interface)


        Creates a new ByteBlower port on the specified ByteBlower interface.  

        :param interface: The ByteBlower Physical interface to create the port on.  
        :type interface: PhysicalInterface
        :param portId: Number of the interface on which to create the port on
        :type portId: int

        :rtype: ByteBlowerPort

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfaceNamesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortCreate(physical, 1)


        """
        return _byteblower.ByteBlowerServer_PortCreate(self, *args)

    def PortDestroy(self, inPort):
        r"""

        Remmoves a ByteBlower Port from the server.

        :param port: ByteBlower Port to remove
        :type port: ByteBlowerPort

        This will stop the ByteBlower Port and remove all configured items on this
        ByteBlower Port


        """
        return _byteblower.ByteBlowerServer_PortDestroy(self, inPort)

    def PortGet(self):
        r"""

        Returns a list of all ByteBlower ports created through this server connection.  

        :return: A list of :class:`ByteBlowerPort` objects
        :rtype: ByteBlowerPortList

        Only ports created through the connection represented by this object are 
        returned, not those created by other client instances (either GUI or API) or 
        those created by other server connections within this API instance! See 
        :meth:`UsersGet` to see the interfaces on which other users have created ports.

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortGet()


        """
        return _byteblower.ByteBlowerServer_PortGet(self)

    def UsersGet(self):
        r"""

        Shows which physical interfaces of the (shared) physical ByteBlower server are currently used by which clients.  

        :return:  A list of :class:`User` objects, one for each physical ByteBlower 
                  interface with one or more ports configured on it. The name is the 
                  string representation of the interface, the value is a list of the 
                  server connections (represented by their client's hostname) which 
                  have created ports on that interface.  
        :rtype: UserList

        This method gives an overview of how a ByteBlower server is currently used. 
        It displays which client connections (whether from GUI scenario runs or API
        sessions) have created ByteBlowerPort objects on which of the server's physical
        ByteBlower interfaces.  

        Such a client connection to a server is represented by this very 
        ByteBlowerServer type! As soon as some client instance (e.g. a TCL shell, 
        python interpreter or a GUI) on some client computer creates such server 
        object, a  connection is established to that shared server.  

        Multiple client instances can be active on the same host. For example, a single
        host may be running a GUI scenario, two python scripts and an interactive Tcl 
        session at the same time.
        Similarly, a single client instance may have multiple parallel connections to 
        the same server, by calling :meth:`.ByteBlower.ServerAdd` multiple times for 
        the same server URL or IP.

        The server's physical interfaces are statically configured on the server 
        machine and can be retrieved using :meth:`PhysicalInterfacesGet`. They are shared 
        among all connected clients.

        Client connections are identified by the client's hostname. This means that all
        server connections from all client instances on a single host will all be
        different 'users', but will have the same string representation. If they use 
        the same interfaces, that hostname will simply appear multiple times.  

        As soon as a specific ByteBlowerServer (representing a client connection) 
        creates a first ByteBlowerPort on some interface, it is 'using' that interface.
        The interface is no longer used when all all ports created by that server on 
        it are destroyed. Ports can be destroyed in the following ways:

        * Explicitly, by calling :meth:`PortDestroy` on the ByteBlowerServer
        * By destroying the ByteBlowerServer for that port. This is also what happens 
          when a GUI finishes or cancels a scenario.
        * By destroying that client instances root ByteBlower object. This is also what
          happens when a client process (GUI or API) is killed.

        Example

        Assume three client instances are currently connected to this server. The first
        runs on John's PC, the second runs on Jane's PC and the last one is a second 
        client instance connecting John's PC. Note the non-trunking interface is used 
        by multiple client instances!  

        .. code-block:: python
           :emphasize-lines: 1

           userList = server.UsersGet()


        """
        return _byteblower.ByteBlowerServer_UsersGet(self)

    def Update(self):
        r"""

        Updates dynamic interfaces (e.g. USB) on the connected server.  

        .. deprecated:: 2.0
           Since 2.0 are USB interfaces not supported anymore

        :raises TechnicalError: This method is not implemented anymore at the 
                                ByteBlower Server

        This methods looks for attached USB interfaces and updates its available 
        interfaces. If USB interfaces are attached, they will be returned by
        :meth:`PhysicalInterfacesGet` after this running this method.  


        """
        return _byteblower.ByteBlowerServer_Update(self)

    def TimestampGet(self):
        r"""

        Returns the current timestamp on the server.  

        .. versionadded:: 2.3.0

        Retrieves the current timestamp of the server in nanoseconds. This can be used
        to calculate the offset between two servers to compare results.  

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        Example

        Assume the client is connected (through this object) to a server:  

        .. code-block:: python
           :emphasize-lines: 1

           server.TimestampGet()
           # :return: 1432805398000000000 


        """
        return _byteblower.ByteBlowerServer_TimestampGet(self)

    def PortsStart(self, inPorts):
        r"""

        Starts all ByteBlower Port objects on this server.

        :param ports: List of :class:`ByteBlowerPort` objects to start
        :type ports: ByteBlowerPortList

        See :obj:`ByteBlowerPort.Start` for more information


        """
        return _byteblower.ByteBlowerServer_PortsStart(self, inPorts)

    def PortsStop(self, inPorts):
        r"""

        Stops all ByteBlower Port objects on this server.

        :param ports: List of :class:`ByteBlowerPort` objects to stop
        :type ports: ByteBlowerPortList

        See :obj:`ByteBlowerPort.Stop` for more information


        """
        return _byteblower.ByteBlowerServer_PortsStop(self, inPorts)

    def PortsStartAll(self):
        r"""

        Starts all ByteBlower Port objects on this server.

        See :obj:`ByteBlowerPort.Start` for more information


        """
        return _byteblower.ByteBlowerServer_PortsStartAll(self)

    def PortsStopAll(self):
        r"""

        Stops all ByteBlower Port objects on this server.

        See :obj:`ByteBlowerPort.Stop` for more information


        """
        return _byteblower.ByteBlowerServer_PortsStopAll(self)

    def ServiceInfoGet(self):
        r"""

        Returns the service information of the ByteBlower server daemon.  

        .. versionadded:: 2.6.0  

        :rtype: ByteBlowerServerServiceInfo

        .. code-block:: python
           :emphasize-lines: 1

           server.ServiceInfoGet()


        """
        return _byteblower.ByteBlowerServer_ServiceInfoGet(self)

    def ResultsRefreshAll(self):
        r"""

        Refreshes all result objects created on this ByteBlower Server


        """
        return _byteblower.ByteBlowerServer_ResultsRefreshAll(self)

# Register ByteBlowerServer in _byteblower:
_byteblower.ByteBlowerServer_swigregister(ByteBlowerServer)
class ByteBlowerServerServiceInfo(ServiceInfo):
    r"""

    This class contains information on the ByteBlower System.

    .. versionadded:: 2.6.0

    With this object you can get information concerning the Type / version / IP or hostname etc... information.

    Example

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       service_info = server.ServiceInfoGet()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LicenseGet(self):
        r"""

        Returns the License information for this ByteBlower server.

        .. versionadded:: 2.6.0

        .. deprecated:: 2.10

        :rtype: ByteBlowerLicense

        Each physical ByteBlower server (represented by this type of object) has a
        specific ByteBlower License.


        """
        return _byteblower.ByteBlowerServerServiceInfo_LicenseGet(self)

    def ManagementIPAddressGet(self):
        r"""

        Returns all management IP addresses of the connected ByteBlower server.

        .. versionadded:: 2.6.0

        :return: List of management IP addresses
        :rtype: StringList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ManagementIPAddressGet())


        """
        return _byteblower.ByteBlowerServerServiceInfo_ManagementIPAddressGet(self)

    def ConnectionHostGet(self):
        r"""

        Returns the host (either registered name or IP address) used to connect to the
        ByteBlower server.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ConnectionHostGet())
           # prints 'bytblower-1.lab.byteblower.com'

        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionHostGet(self)

    def ConnectionIPAddressGet(self):
        r"""

        Returns the IP address used to connect to the ByteBlower server.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 5

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           server.PortCreate('trunk-1-1')
           service_info = server.ServiceInfoGet()
           print(service_info.ConnectionIPAddressGet())
           # prints ip address


        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionIPAddressGet(self)

    def ConnectionPortNumberGet(self):
        r"""

        Returns the TCP port number of the connected ByteBlower server.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ConnectionPortNumberGet())


        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionPortNumberGet(self)

# Register ByteBlowerServerServiceInfo in _byteblower:
_byteblower.ByteBlowerServerServiceInfo_swigregister(ByteBlowerServerServiceInfo)
class ByteBlowerLicense(AbstractObject):
    r"""

    This class represents the license information of your connected server.

    .. versionadded:: 2.6.0
    .. deprecated:: 2.10.0

    The license is defined by the security key hardware on your ByteBlower server.

    Example

    .. code-block:: python
       :emphasize-lines: 2

       license = serverServiceInfo.LicenseGet()
       print(license.TimeAllowedGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VersionGet(self):
        r"""

        Gets the version of the license.

        :return: the version of the license
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(license.VersionGet())


        """
        return _byteblower.ByteBlowerLicense_VersionGet(self)

    def SerialGet(self):
        r"""

        Retrieves the serial number.

        This serial number is the serial number of the hardware containing the license.
        This is handy info when contacting the ByteBlower support department.

        :return: the serial number of the hardware containing the license
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(license.SerialGet())


        """
        return _byteblower.ByteBlowerLicense_SerialGet(self)

    def NumberOfNonTrunksGet(self):
        r"""

        The maximum number of non-trunking interfaces allowed by the license

        :return: number of nontrunks
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(license.NumberOfNonTrunksGet())


        """
        return _byteblower.ByteBlowerLicense_NumberOfNonTrunksGet(self)

    def NumberOfTrunksGet(self):
        r"""

        The maximum number of trunking interfaces allowed by the license

        :return: number of trunking interfaces
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(license.NumberOfTrunksGet())


        """
        return _byteblower.ByteBlowerLicense_NumberOfTrunksGet(self)

    def NumberOfTrunkPortsGet(self, index):
        r"""

        The maximum number of ByteBlower Interfaces that can reside at the given trunk
        interface.

        :param index: Index of the trunk interface to obtain the value for.
        :type index: int

        :return: Allowed number of ByteBlower Interfaces on the physical interface
        :rtype int:

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(license.NumberOfTrunkPortsGet())


        """
        return _byteblower.ByteBlowerLicense_NumberOfTrunkPortsGet(self, index)

    def TimeConsumedGet(self):
        r"""

        The number of minutes the ByteBlower server has run on the license.

        This value has only a meaning when the license is a temporary (demo) license.

        :return: Number of minutes the ByteBlower server has used of the maximum allowed
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(license.TimeConsumedGet())


        """
        return _byteblower.ByteBlowerLicense_TimeConsumedGet(self)

    def TimeAllowedGet(self):
        r"""

        The number of minutes the ByteBlower server can run on the license.

        If the value is set to 4294967295, the license is permanent and the number
        should be treated as infinity.

        :return: Number of minutes the ByteBlower server can run.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(license.TimeAllowedGet())


        """
        return _byteblower.ByteBlowerLicense_TimeAllowedGet(self)

# Register ByteBlowerLicense in _byteblower:
_byteblower.ByteBlowerLicense_swigregister(ByteBlowerLicense)
class GroupSchedulableObject(object):
    r"""



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_GroupSchedulableObject

    def SetScheduleGroup(self, group):
        r"""


        :meta private:


        """
        return _byteblower.GroupSchedulableObject_SetScheduleGroup(self, group)

    def UnsetScheduleGroup(self):
        r"""


        :meta private:


        """
        return _byteblower.GroupSchedulableObject_UnsetScheduleGroup(self)

# Register GroupSchedulableObject in _byteblower:
_byteblower.GroupSchedulableObject_swigregister(GroupSchedulableObject)
class AbstractObjectList(object):
    r"""

    This is a List of multiple AbstractObject objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.AbstractObjectList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.AbstractObjectList___nonzero__(self)

    def __bool__(self):
        return _byteblower.AbstractObjectList___bool__(self)

    def __len__(self):
        return _byteblower.AbstractObjectList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.AbstractObjectList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.AbstractObjectList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.AbstractObjectList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.AbstractObjectList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.AbstractObjectList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.AbstractObjectList___setitem__(self, *args)

    def append(self, x):
        return _byteblower.AbstractObjectList_append(self, x)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')

        :meta private:


        """
        return _byteblower.AbstractObjectList_size(self)

    def __init__(self, *args):
        _byteblower.AbstractObjectList_swiginit(self, _byteblower.new_AbstractObjectList(*args))
    __swig_destroy__ = _byteblower.delete_AbstractObjectList

# Register AbstractObjectList in _byteblower:
_byteblower.AbstractObjectList_swigregister(AbstractObjectList)
ScheduleGroupStatus_Configuration = _byteblower.ScheduleGroupStatus_Configuration
ScheduleGroupStatus_Prepared = _byteblower.ScheduleGroupStatus_Prepared
ScheduleGroupStatus_Started = _byteblower.ScheduleGroupStatus_Started
ScheduleGroupStatus_Stopped = _byteblower.ScheduleGroupStatus_Stopped
ScheduleGroupStatus_Error = _byteblower.ScheduleGroupStatus_Error
class ScheduleGroup(AbstractObject):
    r"""

    A collection of schedulable objects that can be started.

    Schedulable items are:

    - HTTPClient
    - ICMPEchoSession
    - ICMPv6EchoSession
    - Igmp Join
    - Igmp Leave
    - Igmp IpMulticastListen
    - Mld StartListening
    - Mld StopListening
    - Mld Ipv6MulticastListen
    - Stream

    Example

    remove all members from the group

    .. code-block:: python

        scheduleGroup = bbInstance.ScheduleGroupCreate()
        scheduleGroup.MembersAdd(httpClient)


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MembersGet(self):
        r"""

        Returns a list of ToopOIDs of the members of this group.

        :return: List of schedulable objects in order of addition. Possible empty.
                 Their individual object types depend on the types used in :meth:`MembersAdd`:
        :rtype: AbstractObjectList

        Example

        return the ObjectID of the members

        .. code-block:: python
           :emphasize-lines: 1

           print(scheduleGroup.MembersGet()[0].DescriptionGet())


        """
        return _byteblower.ScheduleGroup_MembersGet(self)

    def MembersLengthGet(self):
        r"""

        This method returns the number of members in the scheduleGroup.

        :return: Size of memberlist
        :rtype: int

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           print(scheduleGroup.MembersLengthGet())


        """
        return _byteblower.ScheduleGroup_MembersLengthGet(self)

    def MembersAdd(self, *args):
        r"""

        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: The schedule to add to the ScheduleGroup.
        :type schedulableObject: Schedule | HTTPClient | Stream

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)

        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: The schedule to add to the ScheduleGroup.
        :type schedulableObject: Schedule | HTTPClient | Stream

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)

        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: The schedule to add to the ScheduleGroup.
        :type schedulableObject: Schedule | HTTPClient | Stream

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)

        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.ScheduleGroup_MembersAdd(self, *args)

    def MembersRemove(self, *args):
        r"""

        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.
        :type object: Schedule | GroupSchedulableObject | HTTPClient | Stream

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Removing an IGMP from a ScheduleGroup

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.
        :type object: Schedule | GroupSchedulableObject | HTTPClient | Stream

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Removing an IGMP from a ScheduleGroup

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.
        :type object: Schedule | GroupSchedulableObject | HTTPClient | Stream

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Removing an IGMP from a ScheduleGroup

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.
        :type object: Schedule | GroupSchedulableObject | HTTPClient | Stream

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Removing an IGMP from a ScheduleGroup

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.ScheduleGroup_MembersRemove(self, *args)

    def MembersClear(self):
        r"""

        This method will remove all members from the schedulegroup.

        Example

        remove all members from the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersClear()


        """
        return _byteblower.ScheduleGroup_MembersClear(self)

    def Prepare(self):
        r"""

        This method will prepare all the schedules, but NOT start them.

        :raises: If - one of the Schedules fail to prepare, the others are canceled and
                 an exception is thrown. This exception will contain onformation about
                 the object which caused it.

        Example

        Preparing the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.Prepare()


        """
        return _byteblower.ScheduleGroup_Prepare(self)

    def Start(self):
        r"""

        Start the schedules. 

        The Schedules must be in the prepared state.

        :raises ConfigError: ScheduleNotPrepared
                             The schedulegroup must be prepared before it can be started.

        Example

        Start the ScheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.Start()


        """
        return _byteblower.ScheduleGroup_Start(self)

    def Stop(self):
        r"""

        This method will stop the schedules.

        :raises ConfigError: ScheduleNotRunning 
                             One can only stop a schedule that is running.

        Example

        Stop the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.stop()


        """
        return _byteblower.ScheduleGroup_Stop(self)

    def StatusGet(self):
        r"""

        Returns the status of the ScheduleGroup.

        :return: The status
        :rtype: ScheduleGroupStatus

        Example

        Start the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           print(scheduleGroup.StatusGet())


        """
        return _byteblower.ScheduleGroup_StatusGet(self)

# Register ScheduleGroup in _byteblower:
_byteblower.ScheduleGroup_swigregister(ScheduleGroup)

def ConvertScheduleGroupStatusToString(inStatus):
    return _byteblower.ConvertScheduleGroupStatusToString(inStatus)
class ScheduleGroupList(object):
    r"""

    This is a List of multiple ScheduleGroup objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ScheduleGroupList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ScheduleGroupList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ScheduleGroupList___bool__(self)

    def __len__(self):
        return _byteblower.ScheduleGroupList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ScheduleGroupList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ScheduleGroupList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ScheduleGroupList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ScheduleGroupList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ScheduleGroupList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ScheduleGroupList___setitem__(self, *args)

    def append(self, x):
        return _byteblower.ScheduleGroupList_append(self, x)

    def __init__(self, *args):
        _byteblower.ScheduleGroupList_swiginit(self, _byteblower.new_ScheduleGroupList(*args))
    __swig_destroy__ = _byteblower.delete_ScheduleGroupList

# Register ScheduleGroupList in _byteblower:
_byteblower.ScheduleGroupList_swigregister(ScheduleGroupList)
class MeetingPoint(AbstractObject):
    r"""

    A MeetingPoint is a server that controls a set of ByteBlower Endpoints.

    .. versionadded 2.6.0

    ByteBlower Endpoints can connect to a MeetingPoint by using the
    ByteBlower Endpoint App.

    Example

    .. code-block:: python
       :caption: Typical usage flow

       instance = ByteBlower.InstanceGet()

       meetingpoint = instance.MeetingPointAdd('byteblower-1.byteblower.com')

       device = meetingpoint.DeviceGet('1234-1345-123')

       stream = device.TxStreamAdd()
       # ...

       device.Lock(True)
       device.Prepare()
       # ...


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def DeviceListLengthGet(self):
        r"""

        Returns the number of devices that are connected to the MeetingPoint.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 2

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           meetingpoint.DeviceListLengthGet()


        """
        return _byteblower.MeetingPoint_DeviceListLengthGet(self)

    def DeviceGet(self, mobileDeviceId):
        r"""

        Returns the Endpoint that matches the given Endpoint UUID.

        :param endpoint_uuid: The UUID of the ByteBlower Endpoint to fetch.
        :type endpoint_uuid: str

        :return: The ByteBlower Endpoint proxy object for the Endpoint identified by the given UUID
        :rtype: WirelessEndpoint

        :raises ConfigError: When no Endpoint is known with the given UUID

        Example

        .. code-block:: python
           :emphasize-lines: 2

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           endpoint = meetingpoint.DeviceGet('1189-456dad-45654')


        """
        return _byteblower.MeetingPoint_DeviceGet(self, mobileDeviceId)

    def DeviceListGet(self):
        r"""

        Returns the list of devices that are connected to the MeetingPoint.

        :return: A list with all known WirelessEndpoints
        :rtype: WirelessEndpointList

        Example

        .. code-block:: python
           :emphasize-lines: 2

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           endpointlist = meetingpoint.DeviceListGet()
           for endpoint in endpointlist:
               print(endpoint.DescriptionGet())


        """
        return _byteblower.MeetingPoint_DeviceListGet(self)

    def DeviceDestroy(self, device):
        r"""

        Destroys the representation for a given Endpoint object.

        :param endpoint: Endpoint to release
        :type endpoint: WirelessEndpoint

        Example

        .. code-block:: python
           :emphasize-lines: 4

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           endpoint = meetingpoint.DeviceGet('1189-456dad-45654')

           meetingpoint.DeviceDestroy(endpoint)

           # the endpoint variable is invalid now
           del(endpoint)


        """
        return _byteblower.MeetingPoint_DeviceDestroy(self, device)

    def DeviceIdentifiersGet(self):
        r"""

        Returns the list of device identifiers of the Endpoints connected to the MeetingPoint.

        :return: A list of device identifiers
        :rtype: StringList

        Example

        .. code-block:: python
           :emphasize-lines: 2

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           device_list = meetingpoint.DeviceIdentifiersGet()


        """
        return _byteblower.MeetingPoint_DeviceIdentifiersGet(self)

    def TimestampGet(self):
        r"""

        Returns the current timestamp on the server.

        :return: Timestamp in nanoseconds since epoch.
        :rtype: int

        .. versionadded:: 2.3.0

        Retrieves the current timestamp of the server in nanoseconds. This can be used
        to calculate the offset between two servers to compare results.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: Get the current time from a MeetingPoint

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           print(meetingpoint.TimestampGet())
           # Returns 1432805398000000000


        """
        return _byteblower.MeetingPoint_TimestampGet(self)

    def ServiceInfoGet(self):
        r"""

        Returns the service information of the MeetingPoint daemon.

        .. versionadded:: 2.6.0

        :return: An object representing the service information
        :rtype: MeetingPointServiceInfo

        Example

        .. code-block:: python
           :emphasize-lines: 2

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           info = meetingpoint.ServiceInfoGet()
           print(info.DescriptionGet())


        """
        return _byteblower.MeetingPoint_ServiceInfoGet(self)

    def UsersGet(self):
        r"""

        Shows which ByteBlower Endpoints of the (shared) MeetingPoint are currently used by which clients.

        :return: A list of :class:`.UserMobile` objects
        :rtype: UserMobileList

        This method gives an overview of how a MeetingPoint is currently used. It
        displays which client connections (whether from GUI scenario runs or API
        sessions) have created :class:`WirelessEndpoint` objects.

        Such a client connection to a meetingpoint is represented by this very
        :class:`MeetingPoint` type! As soon as some client instance (e.g. a Tcl shell
        or a GUI) on some client computer creates such meetingpoint object, a
        connection is established to that shared server.

        Multiple client instances can be active on the same host. For example, a single
        host may be running a GUI scenario, two Tcl scripts and an interactive Tcl
        session at the same time.  Similarly, a single client instance may have
        multiple parallel connections to the same server, by calling
        :meth:`ByteBlower.MeetingPointAdd` multiple times for the same server URL or IP.

        Client connections are identified by the client's hostname. This means that all
        server connections from all client instances on a single host will all be
        different 'users', but will have the same string representation. If they use
        the same ByteBlower Endpoints, that hostname will simply appear multiple times.

        As soon as a specific MeetingPoint (representing a client connection) creates a
        first WirelessEndpoint, it is 'using' that WirelessEndpoint. The
        MeetingPoint is no longer used when all ByteBlower Endpoints created by that
        server on it are destroyed. Ports can be destroyed in the following ways:

        * Explicitly, by calling :meth:`DeviceDestroy`.
        * By destroying the :class:`.MeetingPoint` for that port. This is also what
          happens when a GUI finishes or cancels a scenario.
        * By destroying that client instances root :class:`.ByteBlower` object. This is
          also what happens when a client process (GUI or API) is killed.

        Example

        Assume three client instances are currently connected to this server. The first
        runs on John's PC, the second runs on Jane's PC and the last one is a second
        client instance connecting John's PC. Note the non-trunking interface is used
        by multiple client instances!

        .. code-block:: python
           :emphasize-lines: 1

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           users = meetingpoint.UsersGet()


        """
        return _byteblower.MeetingPoint_UsersGet(self)

    def ResultsRefreshAll(self):
        r"""

        Refreshes all configured objects on this MeetingPoint.

        Refreshing will transfer all known data from the ByteBlower MeetingPoint 
        towards this API instance.

        .. note:: This will not request the results to be transferred from ByteBlower 
                  Endpoints to the ByteBlower MeetingPoint. 


        """
        return _byteblower.MeetingPoint_ResultsRefreshAll(self)

    def DevicesStart(self, inDevices):
        r"""

        Starts all the given ByteBlower Endpoints.

        :param endpoints: a list on which to start the traffic, triggers and HTTPClients
        :type endpoints: WirelessEndpointList

        :return: Timestamp when the Endpoints will start in nanoseconds since epoch
        :rtype: int

        The timestamp returned is in the clock domain of the ByteBlower MeetingPoint.
        In order to correctly compare the timestamps, one should compare it with the
        value returnd by :meth:`TimestampGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 12

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           device_1 = meetingpoint.DeviceGet('123-123-1')
           device_2 = meetingpoint.DeviceGet('123-123-2')

           # Configure the devices
           #...

           device_list = WirelessEndpointList()
           device_list.append(device_1)
           device_list.append(device_2)

           start_time meetingpoint.DevicesStart(device_list)


        """
        return _byteblower.MeetingPoint_DevicesStart(self, inDevices)

    def DevicesPrepare(self, inDevices):
        r"""

        Prepare all the given ByteBlower Endpoints.

        :param endpoints: a list of Endpoints to start.
        :type endpoints: WirelessEndpointList

        Example

        .. code-block:: python
           :emphasize-lines: 9

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           device_1 = meetingpoint.DeviceGet('123-123-1')
           device_2 = meetingpoint.DeviceGet('123-123-2')

           device_list = WirelessEndpointList()
           device_list.append(device_1)
           device_list.append(device_2)

           meetingpoint.device_list()


        """
        return _byteblower.MeetingPoint_DevicesPrepare(self, inDevices)

    def DevicesPrepareAsync(self, inDevices):
        r"""

        Prepares all the given ByteBlower Endpoints.

        :param endpoints: A list of ByteBlower Endpoints to prepare.
        :type endpoints: WirelessEndpointList

        After the MeetingPoint is informed about the wish to prepare the endpoints the
        API directly returns. Call :meth:`DevicesPrepare` to wait until all devices are
        prepared.

        Example

        .. code-block:: python
           :emphasize-lines: 5-7,9
           :caption: Prepare a set of ByteBlower Endpoints at once.

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           device_1 = meetingpoint.DeviceGet('123-123-1')
           device_2 = meetingpoint.DeviceGet('123-123-2')

           device_list = WirelessEndpointList()
           device_list.append(device_1)
           device_list.append(device_2)

           meetingpoint.DevicesPrepareAsync(device_list)

           # do something else
           # ...

           # Wait for the preparation to complete...
           meetingpoint.DevicesPrepare(device_list)

           # ... continue


        """
        return _byteblower.MeetingPoint_DevicesPrepareAsync(self, inDevices)

    def DevicesStartAll(self):
        r"""

        Starts all the known ByteBlower Endpoints.

        :return: Timestamp in nanoseconds since epoch
        :rtype: int

        The timestamp returned is in the clock domain of the ByteBlower MeetingPoint.
        In order to correctly compare the timestamps, one should compare it with the
        value returnd by :meth:`TimestampGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.byteblower.com')
           # Configure some Endpoints
           # ...
           start_time = meetingpoint.DevicesStartAll()


        """
        return _byteblower.MeetingPoint_DevicesStartAll(self)

# Register MeetingPoint in _byteblower:
_byteblower.MeetingPoint_swigregister(MeetingPoint)
class MeetingPointServiceInfo(ServiceInfo):
    r"""


    This class contains information on the MeetingPoint System.

    With this object you can get information concerning the Type / version / IP or hostname etc... information.

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       service_info = meetingpoint.ServiceInfoGet()
       print(service_info.DescriptionGet())

    .. versionadded:: 2.6.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LicenseGet(self):
        r"""

        Returns a license object for the MeetingPoint.

        :rtype: MeetingPointLicense

        Each physical ByteBlower Meetingpoint (represented by this type of object) has a specific ByteBlower License.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           license = meetingpointService.LicenseGet()
           print(license.DescriptionGet())


        """
        return _byteblower.MeetingPointServiceInfo_LicenseGet(self)

    def ManagementIPAddressGet(self):
        r"""

        Returns all management IP addresses of the MeetingPoint.

        :return:  List of management IP addresses
        :rtype: StringList

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ManagementIPAddressGet()[0])


        """
        return _byteblower.MeetingPointServiceInfo_ManagementIPAddressGet(self)

    def ConnectionHostGet(self):
        r"""

        Returns the host (either registered name or IP address) used to connect to the MeetingPoint.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(service_info.ConnectionHostGet())


        """
        return _byteblower.MeetingPointServiceInfo_ConnectionHostGet(self)

    def ConnectionIPAddressGet(self):
        r"""

        Returns the MeetingPoint management IP address used in this connection 

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ConnectionIPAddressGet())


        """
        return _byteblower.MeetingPointServiceInfo_ConnectionIPAddressGet(self)

    def ConnectionPortNumberGet(self):
        r"""

        Returns the TCP port number of the MeetingPoint service daemon.

        :return: The TCP Port number used by the daemon
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ConnectionPortNumberGet())


        """
        return _byteblower.MeetingPointServiceInfo_ConnectionPortNumberGet(self)

# Register MeetingPointServiceInfo in _byteblower:
_byteblower.MeetingPointServiceInfo_swigregister(MeetingPointServiceInfo)
class MeetingPointLicense(AbstractObject):
    r"""

    This class represents the license information of the connected MeetingPoint.

    .. versionadded:: 2.6.0

    The license is configured onto the security hardware at installation or during 
    a license upgrade procedure.  
    It contains information about allowed features and persistence of the license.

    Example

    .. code-block:: python
       :caption: Querying the MeetingPoint license through the API.

       from byteblowerll import byteblower as api

       api_instance = api.ByteBlower.InstanceGet()
       meetingpoint = api_instance.MeetingPointAdd('byteblower-1.excentis.com')
       service_info = meetingpoint.ServiceInfoGet()

       license_info = service_info.LicenseGet()

       print(license_info.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VersionGet(self):
        r"""

        Retrieves the version number of the MeetingPoint license

        :return:  the version of the license
        :rtype: int

        To support more features, the license formats can change.  In order to 
        differentiate between the formats, this version number is used.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(meetingpointLicense.VersionGet())


        """
        return _byteblower.MeetingPointLicense_VersionGet(self)

    def SerialGet(self):
        r"""

        Retrieves the serial number of the security module. 

        :return: The serial number of the ByteBlower security module.
        :rtype: str

        The Security Serial number is one of the unique identifiers for a ByteBlower
        Server chassis.  When reaching out to ByteBlower Support, this number might be
        requested the query regards the ByteBlower server.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(meetingpointLicense.SerialGet())


        """
        return _byteblower.MeetingPointLicense_SerialGet(self)

    def NumberOfWirelessEndpointsGet(self):
        r"""

        The maximum number of ByteBlower Endpoints that can be used simultaneously

        :return: number of ByteBlower Endpoints
        :rtype: int

        An Endpoint is considered being in use when it is owned by an API instance.
        This is typically the case when the Endpoint is being prepared to run a test.

        .. code-block:: python
           :emphasize-lines: 1

           print(meetingpointLicense.NumberOfWirelessEndpointsGet())


        """
        return _byteblower.MeetingPointLicense_NumberOfWirelessEndpointsGet(self)

    def TimeConsumedGet(self):
        r"""

        The number of minutes the MeetingPoint has run on the license. 

        :return: Number of minutes the MeetingPoint has used of the maximum allowed
        :rtype: int

        This value has only a meaning when the license is a temporary (demo) license.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(meetingpointLicense.TimeConsumedGet())


        """
        return _byteblower.MeetingPointLicense_TimeConsumedGet(self)

    def TimeAllowedGet(self):
        r"""

        The number of minutes the MeetingPoint can run on the license. 

        :return: Number of minutes the MeetingPoint can run.
        :rtype: int

        If the value is set to 4294967295, the license is permanent and the number 
        should be treated as infinity.
        The TimeUsed counter will not increase.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(meetingpointLicense.TimeAllowedGet())


        """
        return _byteblower.MeetingPointLicense_TimeAllowedGet(self)

# Register MeetingPointLicense in _byteblower:
_byteblower.MeetingPointLicense_swigregister(MeetingPointLicense)
LogLevel_Debug = _byteblower.LogLevel_Debug
LogLevel_Info = _byteblower.LogLevel_Info
LogLevel_Warning = _byteblower.LogLevel_Warning
LogLevel_Error = _byteblower.LogLevel_Error
LogLevel_Critical = _byteblower.LogLevel_Critical
DeviceStatus_Unavailable = _byteblower.DeviceStatus_Unavailable
DeviceStatus_Available = _byteblower.DeviceStatus_Available
DeviceStatus_Reserved = _byteblower.DeviceStatus_Reserved
DeviceStatus_Starting = _byteblower.DeviceStatus_Starting
DeviceStatus_Running = _byteblower.DeviceStatus_Running

def ConvertLogLevelFromString(inLevel):
    return _byteblower.ConvertLogLevelFromString(inLevel)

def ConvertToString(inLevel):
    return _byteblower.ConvertToString(inLevel)
class WirelessEndpoint(AbstractObject):
    r"""

    A WirelessEndpoint is a handle to a ByteBlower Endpoint.

    .. versionadded:: 2.6.0

    Example

    This example shows how to obtain a WirelessEndpoint object from a
    :class:`MeetingPoint` and configure a simple trigger.

    .. code-block:: python
       :caption: Typical flow to create a trigger on a ByteBlower Endpoint

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       endpoint = meetingpoint.DeviceGet('00ff11-234-234')

       endpoint.Lock(True)

       trigger = endpoint.RxTriggerBasicAdd()
       trigger.FilterSourceAddressSet('10.2.3.5')
       trigger.FilterUdpSourcePortSet(5000)
       trigger.FilterUdpDestinationPortSet(10000)

       # scenario duration is 10 seconds
       endpoint.ScenarioDurationSet(int(10*1e9))

       # Configure the Endpoint application with the just configured
       # trigger and duration
       endpoint.Prepare()

       start_time = endpoint.Start()
       current_time = meetingpoint.TimestampGet()

       # wait for the Endpoint to run a test
       time.sleep(10 + (start_time - current_time) / 1e9)   

       # Request the Endpoint to send its (stored) results to the MeetingPoint.
       # Since MeetingPoint 2.20 this is not necessary anymore.
       endpoint.ResultGet()

       trigger.Refresh()
       # ...


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MeetingPointGet(self):
        r"""

        Retrieves the ByteBlower MeetingPoint from which this object is obtained

        :rtype: MeetingPoint


        """
        return _byteblower.WirelessEndpoint_MeetingPointGet(self)

    def AppVersionGet(self):
        r"""

        Returns the App version.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(endpoint.AppVersionGet())


        """
        return _byteblower.WirelessEndpoint_AppVersionGet(self)

    def DeviceIdentifierGet(self):
        r"""

        Returns device identifier.

        The Device Identifier is an UUID which MUST be unique per instance of the 
        Application.  A UUID is unique and is used for all MeetingPoint-Endpoint 
        communication.  This allows duplicate Endpoint Device names to happen and still
        be able to address the correct Endpoint.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.DeviceIdentifierGet())


        """
        return _byteblower.WirelessEndpoint_DeviceIdentifierGet(self)

    def CapabilityListGet(self):
        r"""

        Returns a list of capabilities.

        .. versionadded:: 2.6.0

        :return: A list of :class:`.Capability` objects
        :rtype: CapabilityList

        See the Capability Feature documentation for more information

        Example

        .. code-block:: python
           :emphasize-lines: 1

            capabilityList = endpoint.CapabilityListGet()


        """
        return _byteblower.WirelessEndpoint_CapabilityListGet(self)

    def CapabilityGetByName(self, name):
        r"""

        Returns a Capability object by its name.

        .. versionadded:: 2.6.0

        :param name: Name of the Capability to retrieve
        :type name: str

        :rtype: Capability

        :raises ConfigError: UnsupportedConfig error message when the Capability is not supported

        See the Capability Feature documentation for more information

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.CapabilityGetByName('Tcp.Restart').DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_CapabilityGetByName(self, name)

    def CapabilityIsSupported(self, name):
        r"""

        Checks whether a capability is supported.

        .. versionadded:: 2.6.0

        :return: True if it is supported, False if not
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(endpoint.CapabilityIsSupported('Tcp.Restart'))


        """
        return _byteblower.WirelessEndpoint_CapabilityIsSupported(self, name)

    def DeviceInfoGet(self):
        r"""

        Returns an object with the Endpoint Device Info.

        .. versionadded:: 2.6.0

        :rtype: DeviceInfo

        Device information contains information about:

        - The app version
        - The device network information
        - The device hostname or the user configured name
        - The device OS

        Example

        .. code-block:: python
           :emphasize-lines: 1

           device_info = endpoint.DeviceInfoGet()
           print(device_info.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_DeviceInfoGet(self)

    def HeartbeatCountGet(self):
        r"""

        Returns the number of communication attempts performed by the Endpoint.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.HeartbeatCountGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatCountGet(self)

    def HeartbeatIntervalGet(self):
        r"""

        Returns the communication interval.

        :return: The number of nanoseconds between 2 consecutive communication attempts
        :rtype: int

        Default value is 1 second

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.HeartbeatIntervalGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatIntervalGet(self)

    def HeartbeatIntervalSet(self, arg2):
        r"""

        Sets the heartbeat interval.

        :param interval: The number of nanoseconds between 2 communication attempts 
                         when not running a scenario.
                         (Default: 1 second)
        :type interval: int

        A ByteBlower Endpoint does not have a permanent communication channel towards
        the ByteBlower MeetingPoint.  Instead, the application will attempt to 
        communicate on set intervals.  Since this feels a bit like the beating of a
        heart, this is called the Heartbeat Mechanism.

        The Heartbeat mechanism has a few parameters:

        - Heartbeat Interval: 

          The interval configured here

        - Scenario Heartbeat Interval 

          The heartbeat mechanism is disabled by default during test execution.
          Configuring this parameter allows the Endpoint to send updates during the 
          test.  See :meth:`ScenarioHeartbeatIntervalSet`

        - Heartbeat MaxFail count

          When a certain amount of communication attempts fail, the Endpoint app
          will consider the communication with the MeetingPoint broken.  
          In that case, the Endpoint will revert back to it initial state.

          See :meth:`HeartbeatMaxFailcountSet`

        This method allows to configure the interval betweeen the start of 2 attempts.

        .. note:: When setting the Heartbeat Interval to a value lower than supported 
          by the device, will set the interval to the lowest supported value.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.HeartbeatIntervalSet(50000000000)


        """
        return _byteblower.WirelessEndpoint_HeartbeatIntervalSet(self, arg2)

    def HeartbeatMaxFailcountGet(self):
        r"""

        Returns the maximum number of communication attempts that may fail before the Endpoint considers the communication broken.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.HeartbeatMaxFailcountGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatMaxFailcountGet(self)

    def HeartbeatMaxFailcountSet(self, arg2):
        r"""

        Sets the maximum number of heartbeats that may fail before the Endpoint considers the communication broken.

        :param max_attempts: Number of communication attemts allowed to fail
        :type max_attempts: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.HeartbeatMaxFailcountSet(3)


        """
        return _byteblower.WirelessEndpoint_HeartbeatMaxFailcountSet(self, arg2)

    def HeartbeatTimestampLastGet(self):
        r"""

        Returns the timestamp of the last received communication attempt.

        :return: Nanoseconds since epoch when the last communication attempt was made.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.HeartbeatTimestampLastGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatTimestampLastGet(self)

    def Lock(self, arg2):
        r"""

        Locks or unlocks the endpoint for exclusive access.

        :param lock: True to lock, False to unlock
        :type lock: bool

        The Endpoint application uses the network stack of the operating system on 
        on which the application runs.  This means that a ByteBlower Endpoint only can
        run a single scenario at a given moment in time.

        By requiring the Endpoint being locked before a Scenario is pushed to the 
        Endpoint, it is made sure that Scenario configuration changing API calls
        are blocked by the MeetingPoint when the API instance does not own the lock.

        This ensures the correct execution of the given Scenario.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.Lock(True)

           endpoint.Prepare()
           endpoint.Start()

           # Scenario done
           endpoint.Lock(False)


        """
        return _byteblower.WirelessEndpoint_Lock(self, arg2)

    def LockGet(self):
        r"""

        Indicates whether or not the Endpoint is locked.

        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.LockGet())


        """
        return _byteblower.WirelessEndpoint_LockGet(self)

    def LockOwnerGet(self):
        r"""

        Returns the name of the current lock owner.

        :return: The name of this API instance.
        :rtype: str

        See :meth:`Lock` to get more information about why locking is necessary.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.LockOwnerGet())
           # prints "username@laptop.excentis.com"


        """
        return _byteblower.WirelessEndpoint_LockOwnerGet(self)

    def LockIsOwner(self):
        r"""

        Indicates whether or not the current API instance owns the Endpoint.

        :return: True when this API instance has the lock.
        :rtype: bool

        See :meth:`Lock` to get more information about why locking is necessary.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.LockIsOwner())


        """
        return _byteblower.WirelessEndpoint_LockIsOwner(self)

    def LockTry(self, lock, expected):
        r"""

        Tries to lock the Endpoint.

        :param lock: Whether to lock the device or not
        :type lock: bool

        :param expected_state: The state the device currently should be in
        :type expected_state: bool

        :return: True if the operation succeeded, False if the operation failed
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.LockTry(False, True)


        """
        return _byteblower.WirelessEndpoint_LockTry(self, lock, expected)

    def LogGet(self):
        r"""

        Returns the ByteBlower Endpoint log messages.

        These log messages might be useful for debugging specific issues.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(endpoint.LogGet())


        """
        return _byteblower.WirelessEndpoint_LogGet(self)

    def LogClear(self):
        r"""

        Clears the (debug) log messages on the Endpoint.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.LogGet()


        """
        return _byteblower.WirelessEndpoint_LogClear(self)

    def LogLevelGet(self):
        r"""

        Gets the log level on the Endpoint.

        :rtype: LogLevel

        Example

        .. code-block:: python
           :emphasize-lines: 6

           from byteblowerll.byteblower import ByteBlower
           from byteblowerll.byteblower import LogLevel

           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           endpoint = meetingpoint.DeviceGet('uuid')
           loglevel = endpoint.LogLevelGet()

           if (loglevel = LogLevel.Info):
               print('Log Level is set to INFO')


        """
        return _byteblower.WirelessEndpoint_LogLevelGet(self)

    def LogLevelSet(self, l):
        r"""

        Sets the log level on the Endpoint.

        :param level: Level to set the Endpoint log level to.
        :type level: LogLevel

        Example

        .. code-block:: python
           :emphasize-lines: 6

           from byteblowerll.byteblower import ByteBlower
           from byteblowerll.byteblower import LogLevel
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           endpoint = meetingpoint.DeviceGet('some-uuid'

           endpoint.LogLevelSet(LogLevel.Info)

           assert endpoint.LogLevelGet() == LogLevel.Info


        """
        return _byteblower.WirelessEndpoint_LogLevelSet(self, l)

    def ProtocolHttpClientAdd(self):
        r"""

        Adds a httpClient to this Endpoint.

        :return: an object representing the HTTP Client
        :rtype: HTTPClientMobile

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client = endpoint.ProtocolHttpClientAdd()


        """
        return _byteblower.WirelessEndpoint_ProtocolHttpClientAdd(self)

    def ProtocolHttpClientGet(self):
        r"""

        Returns the list of HTTP client applications created on this Endpoint.

        :return: A list of configured HTTP clients on the Endpoint.
        :rtype: HTTPClientMobileList

        Example

        .. code-block:: python
           :emphasize-lines: 3

           client = endpoint.ProtocolHttpClientAdd()
           # configure the client ...

           known_clients = endpoint.ProtocolHttpClientGet()
           for http_client in known_clients:
               print(http_client.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_ProtocolHttpClientGet(self)

    def ProtocolHttpClientRemove(self, arg2):
        r"""

        Removes a given HTTP Client to this Endpoint.

        :param client: A configured HTTP Client to remove
        :type client: HTTPClientMobile

        Example

        .. code-block:: python
           :emphasize-lines: 2

           http_client = endpoint.ProtocolHttpClientAdd()
           endpoint.ProtocolHttpClientRemove(http_client)


        """
        return _byteblower.WirelessEndpoint_ProtocolHttpClientRemove(self, arg2)

    def RxTriggerBasicAdd(self):
        r"""

        Adds a basic trigger for FrameBlasting to this Endpoint.

        :return: The created Trigger object.
        :rtype: TriggerBasicMobile

        A basic trigger gathers statistics about incoming frames onto a specific UDP
        endpoint.  

        Examples of statistics gathered.

        - Number of packets received
        - Number of bytes received
        - Size of the largest and smallest frame
        - Timestamp of the first and last frame

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger = endpoint.RxTriggerBasicAdd()

        .. code-block:: python
           :caption: Calculating loss over a frameblasting flow.

           stream_result = stream.ResultGet()
           stream_result.Refresh()

           trigger_result = trigger.ResultGet()
           trigger_result.Refresh()

           transmitted_packets: int = stream_result.PacketCountGet()
           received_packets: int = trigger_result.PacketCountGet()

           lost_packets = transmitted_packets - received_packets
           loss = lost_packets * 100.0 / transmitted_packtes

           print(f'This flow lost {loss:.1f}% of traffic.  This is {lost_packets} frames.')

        """
        return _byteblower.WirelessEndpoint_RxTriggerBasicAdd(self)

    def RxTriggerBasicGet(self):
        r"""

        Returns the list of receive triggers created on this Endpoint.

        :return: a list containing the configured :class:`.TriggerBasicMobile` objects
        :rtype: TriggerBasicMobileList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.RxTriggerBasicGet()[0])


        """
        return _byteblower.WirelessEndpoint_RxTriggerBasicGet(self)

    def RxTriggerBasicRemove(self, arg2):
        r"""

        Removes a basic trigger for FrameBlasting from this Endpoint.

        :param trigger: The Trigger object to remove.
        :type trigger: TriggerBasicMobile

        See :meth:`RxTriggerBasicAdd` for more information about the receive triggers

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trigger = endpoint.RxTriggerBasicAdd()
           endpoint.RxTriggerBasicRemove(trigger)


        """
        return _byteblower.WirelessEndpoint_RxTriggerBasicRemove(self, arg2)

    def RxLatencyBasicAdd(self):
        r"""

        Adding a Latency Basic receive trigger to this Endpoint.

        :rtype: LatencyBasicMobile

        A latency basic trigger will calculate latency over the matched incoming 
        frames.  
        Using these latency values, the trigger will calculate some statistics:

        - Minimum latency
        - Average latency
        - Maximum latency
        - Jitter

        In order to calculate the correct latency values, the transmitting side of the
        flow, must inject the correct timestamps.

        See :class:`.FrameMobile` for information on timestamping.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           latencyTrigger = endpoint.RxLatencyBasicAdd()


        """
        return _byteblower.WirelessEndpoint_RxLatencyBasicAdd(self)

    def RxLatencyBasicGet(self):
        r"""

        Returns the list of latency triggers created on this Endpoint.

        :return: A list of :class:`.LatencyBasicMobile` objects configured on the Endpoint.
        :rtype: LatencyBasicMobileList

        See :meth:`RxLatencyBasicAdd` for more information about Latency Basic triggers

        Example

        .. code-block:: python
           :emphasize-lines: 3

            trigger = endpoint.RxLatencyBasicAdd()

            known_triggers = endpoint.RxLatencyBasicGet() 

            for rxLatency in known_triggers:
              print(rxLatency.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_RxLatencyBasicGet(self)

    def RxLatencyBasicRemove(self, arg2):
        r"""

        Adding a RxLatency to this Endpoint.

        :param item: Latency Basic Trigger to remove from this scenario
        :type item: LatencyBasicMobile

        See :meth:`RxLatencyBasicAdd` for more information about Latency Basic triggers

        Example

        .. code-block:: python
           :emphasize-lines: 2

           latencyTrigger = endpoint.RxLatencyBasicAdd()
           endpoint.RxLatencyBasicRemove(latencyTrigger)


        """
        return _byteblower.WirelessEndpoint_RxLatencyBasicRemove(self, arg2)

    def RxLatencyDistributionAdd(self):
        r"""

        Creates a latency histogram receive trigger.

        .. versionadded:: 2.12.16  

        :rtype: LatencyDistributionMobile

        A latency histogram trigger will calculate latency over the matched 
        incoming frames.  
        Using these latency values, the trigger will calculate some statistics:

        - Minimum latency
        - Average latency
        - Maximum latency
        - Jitter

        Next to these basic statistics, this trigger will also keep track of 
        a latency histogram.

        In order to calculate the correct latency values, the transmitting side of the
        flow, must inject the correct timestamps.

        See :class:`.FrameMobile` for information on timestamping.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

           distribution = endpoint.RxLatencyDistributionAdd()


        """
        return _byteblower.WirelessEndpoint_RxLatencyDistributionAdd(self)

    def RxLatencyDistributionGet(self):
        r"""

        Returns the list of latency distribution triggers created on this Endpoint.  

        .. versionadded:: 2.12.16  

        :return: A list of :class:`.LatencyDistributionMobile` objects configured on 
                 the Endpoint
        :rtype: LatencyDistributionMobileList

        See :meth:`.RxLatencyDistributionAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           trigger = endpoint.RxLatencyDistributionAdd()

           all_latency = endpoint.RxLatencyDistributionGet()
           for latency in all_latency:
               print(latency.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_RxLatencyDistributionGet(self)

    def RxLatencyDistributionRemove(self, arg2):
        r"""

        Removes a given Latency Distribution trigger from the Endpoint

        .. versionadded:: 2.12.16  

        :param trigger: The Trigger to remove
        :type trigger: LatencyDistributionMobile

        See :meth:`.RxLatencyDistributionAdd` for more information.  

        Example

        .. code-block:: python
           :emphasize-lines: 3
           :caption: Cleanup of all Latency Distribution triggers

           trigger = endpoint.RxLatencyDistributionAdd()
           # ... 
           endpoint.RxLatencyDistributionRemove(trigger)


        """
        return _byteblower.WirelessEndpoint_RxLatencyDistributionRemove(self, arg2)

    def TxStreamAdd(self):
        r"""

        Adds a Stream for Frame-Blasting to this Endpoint.

        :return: an object representing a Stream.
        :rtype: StreamMobile

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream = endpoint.TxStreamAdd()


        """
        return _byteblower.WirelessEndpoint_TxStreamAdd(self)

    def TxStreamGet(self):
        r"""

        Returns the list of streams created on this Endpoint.

        :return: A list of streams configured on the Endpoint.
        :rtype: StreamMobileList

        Example

        .. code-block:: python
           :emphasize-lines: 5

           endpoint.TxStreamAdd()
           # configure this stream

           # Print the current streams.
           for stream in device.TxStreamGet():
               print(stream.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_TxStreamGet(self)

    def TxStreamRemove(self, arg2):
        r"""

        Removes a Stream for Frame-Blasting from this Endpoint.

        :param stream: an object representing a Stream.
        :type stream: StreamMobile

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream = endpoint.TxStreamAdd()
           endpoint.TxStreamRemove(stream)


        """
        return _byteblower.WirelessEndpoint_TxStreamRemove(self, arg2)

    def Prepare(self):
        r"""

        Prepare the Endpoint

        Preparing the Endpoint requires the user to have a lock on the Endpoint.
        Using this process, the configured scenario is validated and configured on the
        application by the MeetingPoint.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.Prepare()


        """
        return _byteblower.WirelessEndpoint_Prepare(self)

    def PrepareAsync(self):
        r"""

        Signal the ByteBlower Endpoint to prepare the scenario, but do not wait for the confirmation.

        See :meth:`Prepare` for more information about Preparation

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.PrepareAsync()
           # Do some time consuming stuff
           endpoint.Prepare()


        """
        return _byteblower.WirelessEndpoint_PrepareAsync(self)

    def Start(self):
        r"""

        Start the configured Scenario on the Endpoint. 

        :return: Time in nanoseconds since epoch on which the Endpoint will start.
        :rtype: int

        Since the Endpoint does not have a fixed communication channel towards the 
        ByteBlower MeetingPoint.  This method schedules a start at a small amount of
        time in the future, so the ByteBlower Endpoint application is able to fetch the
        assignment and prepare for execution.  

        The return value is the timestamp in the MeetingPoint's clock domain on which 
        the Endpoint really should start. This value can be compared to the value 
        reported by :obj:`MeetingPoint.TimestampGet`.

        Example

        .. code-block:: python
           :emphasize-lines: 5

           # Send the scenario to the Endpoint
           endpoint.Prepare()

           # Start the Scenario on the Endpoint
           start_time = endpoint.Start()

           mp_time = meetingpoint.TimestampGet()
           time.sleep((start_time - mp_time) / 1e9)


        """
        return _byteblower.WirelessEndpoint_Start(self)

    def StartAsync(self):
        r"""

        Signal the endpoint to start the scenario, but do not wait for confirmation.

        See :meth:`Start` for more information

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.StartAsync()

           # Do some time consuming work
           # ...

           start_time = endpoint.Start()


        """
        return _byteblower.WirelessEndpoint_StartAsync(self)

    def Stop(self):
        r"""

        Signal the Endpoint to stop the scenario.

        When stop is invoked, the ByteBlower MeetingPoint will signal the ByteBlower
        Endpoint as soon as possible to stop the current test.

        Since the ByteBlower Endpoint only communicates once every communication 
        interval (see: :meth:`ScenarioHeartbeatIntervalGet`), this operation might take
        up to 4 times this interval duration.

        When the call is not allowed to block for such an amount of time, 
        :meth:`StopAsync` might be used to signal the stop command.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.Stop()


        """
        return _byteblower.WirelessEndpoint_Stop(self)

    def StopAsync(self):
        r"""

        Signal the Endpoint to stop the scenario, but do not wait for confirmation.

        See :meth:`Stop` for more information.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.StopAsync()
           # do some time consuming work
           endpoint.Stop()


        """
        return _byteblower.WirelessEndpoint_StopAsync(self)

    def ResultGet(self):
        r"""

        Request the results.

        .. deprecated:: 2.20.0
           Since ByteBlower 2.20.0, the ByteBlower MeetingPoint will request the results 
           automatically after a test, rendering this method deprecated. 

        Requests the result and waits for the reply. If a previous call to 
        :meth:`ResultAsyncGet` was made then this call does not trigger a new request and
        instead waits for the async result.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.ResultGet())


        """
        return _byteblower.WirelessEndpoint_ResultGet(self)

    def ResultAsyncGet(self):
        r"""

        Request the results without waiting for the reply.

        .. deprecated:: 2.20.0
           Since ByteBlower 2.20.0, the ByteBlower MeetingPoint will request the results 
           automatically after a test, rendering this method deprecated. 

        Example

        .. code-block:: python
           :emphasize-lines: 14

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           endpoint = meetingpoint.DeviceGet('some-uuid')
           endpoint.Lock(True)

           # some configuration

           endpoint.Prepare()
           endpoint.Start()

           # Wait for endpoint to be finished

           # Request the results
           endpoint.ResultAsyncGet()

           # do some time consuming work.

           # wait until the results are in.
           endpoint.ResultGet()

           # process the results
           # ...


        """
        return _byteblower.WirelessEndpoint_ResultAsyncGet(self)

    def ResultClear(self):
        r"""

        Clears the results for the ByteBlower Endpoint.

        This clears all results on the ByteBlower MeetingPoint and ByteBlower Endpoint.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: typical usecase

           endpoint.Prepare()
           endpoint.ResultClear()
           endpoint.Start()


        """
        return _byteblower.WirelessEndpoint_ResultClear(self)

    def StatusGet(self):
        r"""

        Returns the device status.

        The status indicates the current state of the Endpoint application.
        States are used to indicate whether the application is available for use, or 
        e.g. running a test.

        :rtype: DeviceStatus

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.StatusGet())


        """
        return _byteblower.WirelessEndpoint_StatusGet(self)

    def ScenarioDurationGet(self):
        r"""

        Returns the total duration of the scenario.

        :rtype: int


        """
        return _byteblower.WirelessEndpoint_ScenarioDurationGet(self)

    def ScenarioDurationSet(self, arg2):
        r"""

        Configures the total duration of the scenario.  

        This is especially useful when the Endpoint must stay in running longer than
        the configured scenario objects require it to be.  

        :param duration: Duration in nanoseconds
        :type duration: int


        """
        return _byteblower.WirelessEndpoint_ScenarioDurationSet(self, arg2)

    def ScenarioHeartbeatIntervalGet(self):
        r"""

        Returns the communication interval used while running a scenario.

        :return: The number of nanoseconds between communication attempts
        :rtype: int

        Default value is 10 seconds.  Setting it to a large value means disabled.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(endpoint.ScenarioHeartbeatIntervalGet())


        """
        return _byteblower.WirelessEndpoint_ScenarioHeartbeatIntervalGet(self)

    def ScenarioHeartbeatIntervalSet(self, arg2):
        r"""

        Sets the heartbeat interval to be used when a scenario is running.

        :param interval: The number of nanoseconds between 2 communication attempts 
                         during a scenario.
        :type interval: int

        The allowed value range is 0 (disabled, default) and maximum 86400000000000 (1 day).

        When a value is below the minimum value supported by a specific Endpoint 
        device, the supported value is taken.
        When a value is above the upper threshold of 1 day, 1 day will be used.

        .. note:: A value of max int64 (9223372036854775807) will disable heartbeating 
                  during scenarios.  From 2.22.0 on, this value will be a normal valid
                  value.

        See :meth:`HeartbeatIntervalSet` for more information about the Heartbeat 
        intervals

        Example

        .. code-block:: python
           :emphasize-lines: 1

           endpoint.ScenarioHeartbeatIntervalSet(50000000000)


        """
        return _byteblower.WirelessEndpoint_ScenarioHeartbeatIntervalSet(self, arg2)

# Register WirelessEndpoint in _byteblower:
_byteblower.WirelessEndpoint_swigregister(WirelessEndpoint)
class MeetingPointList(object):
    r"""

    This is a List of multiple MeetingPoint objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.MeetingPointList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.MeetingPointList___nonzero__(self)

    def __bool__(self):
        return _byteblower.MeetingPointList___bool__(self)

    def __len__(self):
        return _byteblower.MeetingPointList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.MeetingPointList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.MeetingPointList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.MeetingPointList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.MeetingPointList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.MeetingPointList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.MeetingPointList___setitem__(self, *args)

    def append(self, x):
        return _byteblower.MeetingPointList_append(self, x)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')

        :meta private:


        """
        return _byteblower.MeetingPointList_size(self)

    def __init__(self, *args):
        _byteblower.MeetingPointList_swiginit(self, _byteblower.new_MeetingPointList(*args))
    __swig_destroy__ = _byteblower.delete_MeetingPointList

# Register MeetingPointList in _byteblower:
_byteblower.MeetingPointList_swigregister(MeetingPointList)
class WirelessEndpointList(object):
    r"""

    This is a List of multiple ByteBlower Endpoint objects.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.WirelessEndpointList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.WirelessEndpointList___nonzero__(self)

    def __bool__(self):
        return _byteblower.WirelessEndpointList___bool__(self)

    def __len__(self):
        return _byteblower.WirelessEndpointList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.WirelessEndpointList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.WirelessEndpointList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.WirelessEndpointList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.WirelessEndpointList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.WirelessEndpointList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.WirelessEndpointList___setitem__(self, *args)

    def append(self, x):
        r"""



        """
        return _byteblower.WirelessEndpointList_append(self, x)

    def empty(self):
        return _byteblower.WirelessEndpointList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            eplist = WirelessEndpointList()
            if len(eplist) == 1:
                print('list only has a single item')

        :meta private:


        """
        return _byteblower.WirelessEndpointList_size(self)

    def clear(self):
        return _byteblower.WirelessEndpointList_clear(self)

    def erase(self, *args):
        return _byteblower.WirelessEndpointList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.WirelessEndpointList_swiginit(self, _byteblower.new_WirelessEndpointList(*args))

    def push_back(self, x):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use :meth:`append`.


        """
        return _byteblower.WirelessEndpointList_push_back(self, x)
    __swig_destroy__ = _byteblower.delete_WirelessEndpointList

# Register WirelessEndpointList in _byteblower:
_byteblower.WirelessEndpointList_swigregister(WirelessEndpointList)
class CapabilityValue(AbstractObject):
    r"""

    The Capability Value class.

    A capability ( Capability ) can have a different type of value (INTEGER,
    BOOLEAN, STRING). Using :meth:`TypeGet` you can discover the value-type and
    then use the corresponding getter to get the real value


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Type_BOOLEAN = _byteblower.CapabilityValue_Type_BOOLEAN
    Type_INTEGER = _byteblower.CapabilityValue_Type_INTEGER
    Type_STRING = _byteblower.CapabilityValue_Type_STRING

    def StringGet(self):
        r"""

        Returns the value as a string.

        :return: The capability value as a string
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 7

           capabilityType = capabilityValue.TypeGet()
           if capabilityType==0:
               print(capabilityValue.BooleanGet())
           elif capabilityType==1:
               print(capabilityValue.IntegerGet())
           else:
               print(capabilityValue.StringGet())


        """
        return _byteblower.CapabilityValue_StringGet(self)

    def IntegerGet(self):
        r"""

        Returns the value as an integer.

        :return: The value of the capability as an integer
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 5

           capabilityType = capabilityValue.TypeGet()
           if capabilityType==0:
               print(capabilityValue.BooleanGet())
           elif capabilityType==1:
               print(capabilityValue.IntegerGet())
           else:
               print(capabilityValue.StringGet())


        """
        return _byteblower.CapabilityValue_IntegerGet(self)

    def BooleanGet(self):
        r"""

        Returns the value as a boolean.

        :return: The value of the capability as a boolean (if possible)
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 3

           capabilityType = capabilityValue.TypeGet()
           if capabilityType==0:
               print(capabilityValue.BooleanGet())
           elif capabilityType==1:
               print(capabilityValue.IntegerGet())
           else:
               print(capabilityValue.StringGet())


        """
        return _byteblower.CapabilityValue_BooleanGet(self)

    def TypeGet(self):
        r"""

        Returns the type of value.

        :return: The type of the value
        :rtype: CapabilityValueType

        Example

        .. code-block:: python
           :emphasize-lines: 1

           capabilityType = capabilityValue.TypeGet()
           if capabilityType==0:
               print(capabilityValue.BooleanGet())
           elif capabilityType==1:
               print(capabilityValue.IntegerGet())
           else:
               print(capabilityValue.StringGet())


        """
        return _byteblower.CapabilityValue_TypeGet(self)

# Register CapabilityValue in _byteblower:
_byteblower.CapabilityValue_swigregister(CapabilityValue)

def __lshift__(stream, type):
    return _byteblower.__lshift__(stream, type)
class Capability(AbstractObject):
    r"""

    Represents a capability, A feature it supports or not.

    Using this class, you can check if e.g. a ByteBlower Endpoint supports latency
    measurements or not

    Available Capabilities:
    - TODO

    Example

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       port = server.PortCreate('trunk-1-1')
       capability_list = port.CapabilityListGet()
       capability = capability_list[0]
       # print version
       print(capability.VersionAddedGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_Capability

    def NameGet(self):
        r"""

        Returns a human-readable name of the capability.

        :return: The human readable name of the capability.
        :rtype str:

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(capability.NameGet())


        """
        return _byteblower.Capability_NameGet(self)

    def CapabilityDescriptionGet(self):
        r"""

        Returns a human-readable description of the capability.

        :return: A human readable description
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(capability.CapabilityDescriptionGet())


        """
        return _byteblower.Capability_CapabilityDescriptionGet(self)

    def VersionAddedGet(self):
        r"""

        Returns the ByteBlower Server/ByteBlower MeetingPoint version since when this
        capability is added.

        :return: The server/meetingpoint version the capability was added
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(capability.VersionAddedGet())


        """
        return _byteblower.Capability_VersionAddedGet(self)

    def ValueGet(self):
        r"""

        Returns a CapabilityValue object.

        :return: the value of the capability
        :rtype: CapabilityValue

        Example

        .. code-block:: python
           :emphasize-lines: 1

           capabilityValue = capability.ValueGet()


        """
        return _byteblower.Capability_ValueGet(self)

# Register Capability in _byteblower:
_byteblower.Capability_swigregister(Capability)
DeviceOsType_Android = _byteblower.DeviceOsType_Android
DeviceOsType_iOS = _byteblower.DeviceOsType_iOS
DeviceOsType_OSx = _byteblower.DeviceOsType_OSx
DeviceOsType_Linux = _byteblower.DeviceOsType_Linux
DeviceOsType_Windows = _byteblower.DeviceOsType_Windows
DeviceOsType_Unknown = _byteblower.DeviceOsType_Unknown
class DeviceInfo(AbstractObject):
    r"""

    Device information of the ByteBlower Endpoint.

    .. versionadded:: 2.6.0

    Contains all usefull device information of a ByteBlower Endpoint like OS,
    Network, Battery etc...

    Example

    .. code-block:: python
       :emphasize-lines: 4

       from byteblowerll.byteblower import ByteBlower
       meetingPoint = bb.MeetingPointAdd('byteblower-tutorial-1300.lab.byteblower.excentis.com')
       endpoint = meetingPoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
       deviceInfo = endpoint.DeviceInfoGet()
       print(deviceInfo.BatteryLevelGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BatteryLevelGet(self):
        r"""

        Returns the device's battery level.

        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = endpoint.DeviceInfoGet()
           print(deviceInfo.BatteryLevelGet())


        """
        return _byteblower.DeviceInfo_BatteryLevelGet(self)

    def GivenNameGet(self):
        r"""

        Returns the user-provided device name.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = endpoint.DeviceInfoGet()
           print(deviceInfo.GivenNameGet())


        """
        return _byteblower.DeviceInfo_GivenNameGet(self)

    def TypeGet(self):
        r"""

        Returns the type of device. I.e "iPad Air", "iPhone 6S", "Nexus 5x", etc...

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = endpoint.DeviceInfoGet()
           print(deviceInfo.TypeGet())


        """
        return _byteblower.DeviceInfo_TypeGet(self)

    def OsTypeGet(self):
        r"""

        Returns the OS type.

        :rtype: DeviceOsType

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = endpoint.DeviceInfoGet()
           print(deviceInfo.OsTypeGet())


        """
        return _byteblower.DeviceInfo_OsTypeGet(self)

    def NetworkInfoGet(self):
        r"""

        Return the networkInfoObject containing all the network information of the ByteBlower Endpoint.

        :rtype: NetworkInfo

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = endpoint.DeviceInfoGet()
           networkInfo = endpoint.NetworkInfoGet()


        """
        return _byteblower.DeviceInfo_NetworkInfoGet(self)

    def NetworkInfoMonitorAdd(self):
        r"""

        Creates a NetworkInfo monitor to be used during a scenario

        :return: The newly created NetworkInfoMonitor
        :rtype: NetworkInfoMonitor

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = endpoint.DeviceInfoGet()
           monitor = endpoint.NetworkInfoMonitorAdd()


        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorAdd(self)

    def NetworkInfoMonitorGet(self):
        r"""

        Get the created NetworkInfo monitors

        :return: A list of NetworkInfoMonitors
        :rtype: NetworkInfoMonitorList

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        Example

        .. code-block:: python
           :emphasize-lines: 3

           deviceInfo = endpoint.DeviceInfoGet()
           monitor = endpoint.NetworkInfoMonitorAdd()
           monitors = endpoint.NetworkInfoMonitorGet()


        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorGet(self)

    def NetworkInfoMonitorRemove(self, arg2):
        r"""

        Removes the specified NetworkInfoMonitor

        :param monitor: The monitor to be removed
        :type monitor: NetworkInfoMonitor

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        Example

        .. code-block:: python
           :emphasize-lines: 3

           deviceInfo = endpoint.DeviceInfoGet()
           monitor = endpoint.NetworkInfoMonitorAdd()
           endpoint.NetworkInfoMonitorRemove(monitor)


        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorRemove(self, arg2)

    def OsVersionGet(self):
        r"""

        Returns the OS version.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = endpoint.DeviceInfoGet()
           print(deviceInfo.OsVersionGet())


        """
        return _byteblower.DeviceInfo_OsVersionGet(self)

# Register DeviceInfo in _byteblower:
_byteblower.DeviceInfo_swigregister(DeviceInfo)
class NetworkInfo(AbstractObject):
    r"""

    Network information of the Endpoint.

    .. versionadded:: 2.6.0

    Contains all usefull network information of an Endpoint

    Example

    .. code-block:: python
       :emphasize-lines: 5

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       endpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
       deviceInfo = endpoint.DeviceInfoGet()
       networkInfo = deviceInfo.NetworkInfoGet()
       for interface in networkInfo.InterfacesGet():
           print(interface.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterfaceGet(self):
        r"""

        Returns a list of NetworkInterfaces 

        This list contains all the NetworkInterfaces detected on the device.
        Be aware that there are more networkinterfaces than you would expect.

        :return: a list of :class:`.NetworkInterface` objects
        :rtype: NetworkInterfaceList

        Example

        .. code-block:: python
           :emphasize-lines: 4

           endpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = endpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.InterfaceGet()[0].NameGet())


        """
        return _byteblower.NetworkInfo_InterfaceGet(self)

    def IPv4Get(self):
        r"""

        Returns a list of IPv4 addresses.

        .. deprecated:: 2.16.0

        :rtype: StringList

        This is a convenient method that will return the list of IPv4 addresses of the
        first interface. If you want the IP of a specific interface use the
        :meth:`InterfaceGet` method to retrieve them.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           endpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = endpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv4Get()[0])


        """
        return _byteblower.NetworkInfo_IPv4Get(self)

    def IPv6GlobalGet(self):
        r"""

        Returns a list of IPv6 global addresses.

        .. deprecated:: 2.16.0

        :rtype: StringList

        Example

        .. code-block:: python
           :emphasize-lines: 4

           endpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = endpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv6GlobalGet()[0])


        """
        return _byteblower.NetworkInfo_IPv6GlobalGet(self)

    def IPv6LinkLocalGet(self):
        r"""

        Returns a list of IPv6 linklocal addresses.

        .. deprecated:: 2.16.0

        :rtype: StringList

        This is a convenient method to get a list of the IPv6 linkLocal addresses.
        If your ByteBlower Endpoint has 2 active interfaces, only the first will be
        returned. One can use :meth:`InterfaceGet` to retrieve the interfaces

        Example

        .. code-block:: python
           :emphasize-lines: 4

           endpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = endpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv6LinkLocalGet()[0])


        """
        return _byteblower.NetworkInfo_IPv6LinkLocalGet(self)

    def SSIDGet(self):
        r"""

        Returns the SSID

        .. deprecated:: 2.16.0
        :rtype: str

        This is the first SSID discovered by the endpoint. If your device has more than 
        1 connected wireless interface. One of these will be shown here

        If you want to see the others, please use :meth:`InterfaceGet`

        See: :obj:`NetworkInterface.WiFiSsidGet`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           endpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = endpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.SSIDGet())


        """
        return _byteblower.NetworkInfo_SSIDGet(self)

    def BSSIDGet(self):
        r"""

        Returns the BSSID

        .. deprecated:: 2.16.0

        :rtype: str

        This is the first BSSID discovered by the endpoint. If your device has more than
        1 connected wireless interface. One of these will be shown here

        If you want to see the others, please use :meth:`InterfaceGet`

        See: :obj:`NetworkInterface.WiFiBssidGet`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           endpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = endpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.BSSIDGet())


        """
        return _byteblower.NetworkInfo_BSSIDGet(self)

# Register NetworkInfo in _byteblower:
_byteblower.NetworkInfo_swigregister(NetworkInfo)
class NetworkInfoMonitorResultData(AbstractObject):
    r"""

    Result snapshot for the network information.

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python

       deviceInfo = endpoint.DeviceInfoGet()
       monitor = deviceInfo.NetworkInfoMonitorAdd()
       history = monitor.ResultHistoryGet()
       for item in history.IntervalGet():
           print(item.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        r"""

        Time in nanoseconds when the data was retrieved

        :return: Timestamp
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(interval.TimestampGet())


        """
        return _byteblower.NetworkInfoMonitorResultData_TimestampGet(self)

    def InterfaceGet(self):
        r"""

        Returns a list of network interfaces available on the device

        :return: List of network interfaces
        :rtype: NetworkInfoMonitorResultList

        Example

        .. code-block:: python
           :emphasize-lines: 1,3

                interfaces = interval.InterfacesGet()
                for interface in interfaces:
                    print(interface.DescriptionGet()


        """
        return _byteblower.NetworkInfoMonitorResultData_InterfaceGet(self)

    def IntervalDurationGet(self):
        r"""

        Duration in nanoseconds of the interval

        :return: Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(interval.IntervalDurationGet())


        """
        return _byteblower.NetworkInfoMonitorResultData_IntervalDurationGet(self)

# Register NetworkInfoMonitorResultData in _byteblower:
_byteblower.NetworkInfoMonitorResultData_swigregister(NetworkInfoMonitorResultData)
class NetworkInfoMonitorResultList(object):
    r"""

    This is a List of multiple NetworkInfoMonitorResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.NetworkInfoMonitorResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.NetworkInfoMonitorResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.NetworkInfoMonitorResultList___bool__(self)

    def __len__(self):
        return _byteblower.NetworkInfoMonitorResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.NetworkInfoMonitorResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.NetworkInfoMonitorResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.NetworkInfoMonitorResultList_swiginit(self, _byteblower.new_NetworkInfoMonitorResultList(*args))
    __swig_destroy__ = _byteblower.delete_NetworkInfoMonitorResultList

# Register NetworkInfoMonitorResultList in _byteblower:
_byteblower.NetworkInfoMonitorResultList_swigregister(NetworkInfoMonitorResultList)
class NetworkInfoMonitorResultHistory(AbstractRefreshableResult):
    r"""

    History for the network info monitor representing the results over time

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python

       deviceInfo = endpoint.DeviceInfoGet()
       networkInfo = deviceInfo.NetworkInfoMonitorAdd()
       history = networkInfo.ResultHistoryGet()
       print(history.DescriptionGet())


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        r"""

        Clears all results of the monitor

        Example

        .. code-block:: python
           :emphasize-lines: 1

           history.Clear()


        """
        return _byteblower.NetworkInfoMonitorResultHistory_Clear(self)

    def SamplingIntervalDurationGet(self):
        r"""

        Returns the duration of one result interval

        :return: The duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(history.SamplingIntervalDurationGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        r"""

        Sets the duration of one result interval

        :param duration: The duration in nanoseconds (default: 1 second)
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           history.SamplingIntervalDurationSet(2000000000)


        """
        return _byteblower.NetworkInfoMonitorResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def IntervalGet(self):
        r"""

        Returns the collected intervals

        :return: A list of the collected :class:`NetworkInfoMonitorResultData` objects
        :rtype: NetworkInfoMonitorResultList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           history.Refresh()
           for interval in history.IntervalGet():
               print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        r"""

        Return an interval as specified by the index in the list

        :param index: number of the index in the list
        :type index: int

        :raises DomainError: When the index is out of range

        :return: The specified interval snapshot
        :rtype: NetworkInfoMonitorResultData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           history.Refresh()
           interval = history.IntervalGetByIndex(1):
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGetByIndex(self, index)

    def IntervalGetByTime(self, timestamp):
        r"""

        Return an interval as specified by the timestamp it was created

        :param timestamp: A timestamp in nanoseconds rounded to the second
        :type timestamp: int

        :raises DomainError: When the timestamp is out of range

        :return: The specified interval snapshot
        :rtype: NetworkInfoMonitorResultData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           history.Refresh()
           interval = history.IntervalGetByTime(1568194819000000000):
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGetByTime(self, timestamp)

    def IntervalLatestGet(self):
        r"""

        Return the last interval snapshot created

        :return: The specified interval snapshot
        :rtype: NetworkInfoMonitorResultData

        Example

        .. code-block:: python
           :emphasize-lines: 1

           history.Refresh()
           interval = history.IntervalLatestGet():
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalLatestGet(self)

    def IntervalLengthGet(self):
        r"""

        Returns the number of collected interval snapshots

        :return: number of interval snapshots
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           history.Refresh()
                print(history.IntervalLengthGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalLengthGet(self)

    def RefreshTimestampGet(self):
        r"""

        Time in nanoseconds when the data was last retrieved

        :return: Timestamp
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           history.Refresh()
           print(history.RefreshTimestampGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_RefreshTimestampGet(self)

# Register NetworkInfoMonitorResultHistory in _byteblower:
_byteblower.NetworkInfoMonitorResultHistory_swigregister(NetworkInfoMonitorResultHistory)
class NetworkInfoMonitor(AbstractObject):
    r"""

    Monitor to collect the NetworkInfo over time

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python

       deviceInfo = endpoint.DeviceInfoGet()
       networkInfo = deviceInfo.NetworkInfoMonitorAdd()


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultHistoryGet(self):
        r"""

        Returns the result history of the network monitor

        :return: The history object for the network monitor
        :rtype: NetworkInfoMonitorResultHistory

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(monitor.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitor_ResultHistoryGet(self)

# Register NetworkInfoMonitor in _byteblower:
_byteblower.NetworkInfoMonitor_swigregister(NetworkInfoMonitor)
NetworkInterfaceType_Unknown = _byteblower.NetworkInterfaceType_Unknown
NetworkInterfaceType_Loopback = _byteblower.NetworkInterfaceType_Loopback
NetworkInterfaceType_Ethernet = _byteblower.NetworkInterfaceType_Ethernet
NetworkInterfaceType_WiFi = _byteblower.NetworkInterfaceType_WiFi

def NetworkInterfaceTypeToString(t):
    return _byteblower.NetworkInterfaceTypeToString(t)
WiFiLinkState_Unknown = _byteblower.WiFiLinkState_Unknown
WiFiLinkState_Invalid = _byteblower.WiFiLinkState_Invalid
WiFiLinkState_Unassociated = _byteblower.WiFiLinkState_Unassociated
WiFiLinkState_Idle = _byteblower.WiFiLinkState_Idle
WiFiLinkState_Active = _byteblower.WiFiLinkState_Active
WiFiBand_Unknown = _byteblower.WiFiBand_Unknown
WiFiBand_Band_2_4_GHz = _byteblower.WiFiBand_Band_2_4_GHz
WiFiBand_Band_5_GHz = _byteblower.WiFiBand_Band_5_GHz
WiFiBand_Band_6_GHz = _byteblower.WiFiBand_Band_6_GHz
WiFiBand_Band_60_GHz = _byteblower.WiFiBand_Band_60_GHz
class WiFiLink(AbstractObject):
    r"""

    A Wi-Fi (MLO) link.  

    A link has the following properties:

    - A link ID.  0 means backwards compatibility (non-MLO)
    - The STA MAC address or the MAC address used by the station for this link.
    - The AP MAC address or the MAC address used by the access point for this link.
    - The RSSI for this link.  -127 means not available or not connected.
    - The Transmit Link speed.  The negotiated transmit speed for this link.
    - The Receive Link speed.  The negotiated receive speed for this link.

    .. versionadded:: 2.23.0


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LinkIdGet(self):
        r"""

        Returns the (MLO) Link ID as provided by the ByteBlower Endpoint.

        A link ID of 0 means that no MLO is being used and not all information will be valid.

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_LinkIdGet(self)

    def ApMacGet(self):
        r"""

        Returns the MAC address of the Access Point servicing this link.

        This is the MAC address as seen by the ByteBlower Endpoint.  
        A value of 00:00:00:00:00:00 means this information is not available.

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_ApMacGet(self)

    def StaMacGet(self):
        r"""

        Returns the MAC address of the Station side of the link.

        This is the MAC address as seen by the ByteBlower Endpoint.  
        A value of 00:00:00:00:00:00 means this information is not available.
        This can be due to the privacy rules on the given device.

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_StaMacGet(self)

    def RssiGet(self):
        r"""

        Returns the Received Signal Strength Indicator of the link.

        This value is expressed in dBm.  A value of -127 indicates no link or not available.

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_RssiGet(self)

    def ChannelGet(self):
        r"""

        Returns the Wi-Fi channel this link is on.

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_ChannelGet(self)

    def FrequencyGet(self):
        r"""

        Returns the Wi-Fi Frequency in Hertz.

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_FrequencyGet(self)

    def FrequencyBandGet(self):
        r"""

        Returns the Wi-Fi Frequency band on which the channel is on.

        :rtype: WiFiBand

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_FrequencyBandGet(self)

    def RxLinkSpeedGet(self):
        r"""

        Returns the negotiated receive link speed in bits/s.

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_RxLinkSpeedGet(self)

    def TxLinkSpeedGet(self):
        r"""

        Returns the negotiated transmit link speed in bits/s.

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_TxLinkSpeedGet(self)

    def StateGet(self):
        r"""

        Returns the state of this Wi-Fi link.

        This is only valid when the link ID is not 0.

        :rtype: WiFiLinkState

        .. versionadded:: 2.23.0


        """
        return _byteblower.WiFiLink_StateGet(self)
    __swig_destroy__ = _byteblower.delete_WiFiLink

# Register WiFiLink in _byteblower:
_byteblower.WiFiLink_swigregister(WiFiLink)
class NetworkInterface(AbstractObject):
    r"""

    NetworkInterface information of the ByteBlower Endpoint.

    Represents a network interface of a endpoint.

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python

       deviceInfo = endpoint.DeviceInfoGet()
       networkInfo = deviceInfo.NetworkInfoGet()
       networkInterface = networkInfo.InterfaceGet()[0]


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TypeGet(self):
        r"""

        Returns the type of a network interface.

        :return: The type of the network interface
        :rtype: NetworkInterfaceType

        This can be used to distinguish e.g. Wi-Fi interfaces from others

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.TypeGet() == NetworkInterfaceType.WiFi)


        """
        return _byteblower.NetworkInterface_TypeGet(self)

    def NameGet(self):
        r"""

        Returns the name of the interface.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.NameGet())


        """
        return _byteblower.NetworkInterface_NameGet(self)

    def DisplayNameGet(self):
        r"""

        Returns the display name of the interface.

        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.DisplayNameGet())


        """
        return _byteblower.NetworkInterface_DisplayNameGet(self)

    def MacGet(self):
        r"""

        Returns the MAC address of the interface.

        :rtype: str

        On some platforms (e.g. iOS) this isn't allowed so the NULL MAC address will be
        returned (00:00:00:00:00:00).

        When the Endpoint application is not allowed to query this information due to 
        the permission not granted, the returned MAC address might be the address:
        02:00:00:00:00:00

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.MacGet())


        """
        return _byteblower.NetworkInterface_MacGet(self)

    def IPv4Get(self):
        r"""

        Returns a list of IPv4 addresses of this interface.

        :rtype: StringList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.IPv4Get())


        """
        return _byteblower.NetworkInterface_IPv4Get(self)

    def IPv6GlobalGet(self):
        r"""

        Returns a list of the Global IPv6 addresses of this interface.

        :return: a list of IPv6 global IP addresses
        :rtype: StringList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.IPv6GlobalGet())


        """
        return _byteblower.NetworkInterface_IPv6GlobalGet(self)

    def IPv6LinkLocalGet(self):
        r"""

        Returns a list of the LinkLocal addresses of this interface.

        :rtype: StringList

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.IPv6LinkLocalGet())


        """
        return _byteblower.NetworkInterface_IPv6LinkLocalGet(self)

    def WiFiSsidGet(self):
        r"""

        Returns the SSID of the current Wi-Fi connection

        :return: The SSID of the network interface
        :rtype: str

        When the interface is not a Wi-Fi interface or when the interface is not 
        connected to a wireless network, the method will return an empty string

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.WiFiSsidGet())
           # Prints e.g. MyFavoriteNetwork


        """
        return _byteblower.NetworkInterface_WiFiSsidGet(self)

    def WiFiBssidGet(self):
        r"""

        Returns the BSSID of the current Wi-Fi connection

        :return: The BSSID of the network interface in colon-delimited format
        :rtype: str

        When the interface is not a Wi-Fi interface or when the interface is not 
        connected to a wireless network, the method will return the NULL MAC-
        address (00:00:00:00:00:00)

        When the location permission is not granted to the Endpoint application,
        the system can return the BSSID address of 02:00:00:00:00:00
        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.WiFiBssidGet())
           # prints e.g. 00:bb:1b:00:12:22


        """
        return _byteblower.NetworkInterface_WiFiBssidGet(self)

    def WiFiRssiGet(self):
        r"""

        Returns the RSSI of the current Wi-Fi connection

        :return: The RSSI of the network interface in dBm
        :rtype: int

        When the interface is not a Wi-Fi interface or when the interface is not 
        connected to a wireless network, the method will return -127

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.WiFiRssiGet())
           # prints e.g. -67


        """
        return _byteblower.NetworkInterface_WiFiRssiGet(self)

    def WiFiTxRateGet(self):
        r"""

        Returns the announced maximum transmit speed of the current Wi-Fi connection

        :return: The maximum transmit speed of the network interface in bits/s
        :rtype: int

        When the interface is not a Wi-Fi interface or when the interface is not 
        connected to a wireless network, the method will return -1

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.WiFiTxRateGet())
           # prints e.g. 54000000


        """
        return _byteblower.NetworkInterface_WiFiTxRateGet(self)

    def WiFiRxRateGet(self):
        r"""

        Returns the announced maximum receive speed of the current Wi-Fi connection

        :return: The maximum receive speed of the network interface in bits/s
        :rtype: int

        When the interface is not a Wi-Fi interface or when the interface is not 
        connected to a wireless network, the method will return -1

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.WiFiRxRateGet())
           # prints e.g. 54000000


        """
        return _byteblower.NetworkInterface_WiFiRxRateGet(self)

    def WiFiChannelGet(self):
        r"""

        Returns the channel of the current Wi-Fi connection

        :return: The channel of the network interface
        :rtype: int

        When the interface is not a Wi-Fi interface or when the interface is not 
        connected to a wireless network, the method will return -1

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.WiFiChannelGet())
           # prints e.g. 9


        """
        return _byteblower.NetworkInterface_WiFiChannelGet(self)

    def SpeedGet(self):
        r"""

        Returns the announced maximum speed of the interface

        :return: The link speed of the network interface in bits/s
        :rtype: int

        When the interface is down or does not have a link speed, this method will 
        return -1.

        If the interface is a Wi-Fi interface with an active connection, the transmit
        speed as given by :meth:`WiFiTxRateGet` will be returned.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(networkInterface.SpeedGet())
           # prints e.g. 1000000000


        """
        return _byteblower.NetworkInterface_SpeedGet(self)

    def WiFiLinkGet(self):
        return _byteblower.NetworkInterface_WiFiLinkGet(self)

# Register NetworkInterface in _byteblower:
_byteblower.NetworkInterface_swigregister(NetworkInterface)
class NetworkInfoMonitorList(object):
    r"""

    This is a List of multiple NetworkInfoMonitor objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.NetworkInfoMonitorList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.NetworkInfoMonitorList___nonzero__(self)

    def __bool__(self):
        return _byteblower.NetworkInfoMonitorList___bool__(self)

    def __len__(self):
        return _byteblower.NetworkInfoMonitorList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.NetworkInfoMonitorList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.NetworkInfoMonitorList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.NetworkInfoMonitorList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.NetworkInfoMonitorList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.NetworkInfoMonitorList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.NetworkInfoMonitorList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.NetworkInfoMonitorList_swiginit(self, _byteblower.new_NetworkInfoMonitorList(*args))
    __swig_destroy__ = _byteblower.delete_NetworkInfoMonitorList

# Register NetworkInfoMonitorList in _byteblower:
_byteblower.NetworkInfoMonitorList_swigregister(NetworkInfoMonitorList)
class WiFiLinkList(object):
    r"""

    This is a List of multiple WiFi link objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.WiFiLinkList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.WiFiLinkList___nonzero__(self)

    def __bool__(self):
        return _byteblower.WiFiLinkList___bool__(self)

    def __len__(self):
        return _byteblower.WiFiLinkList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.WiFiLinkList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.WiFiLinkList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.WiFiLinkList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.WiFiLinkList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.WiFiLinkList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.WiFiLinkList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.WiFiLinkList_swiginit(self, _byteblower.new_WiFiLinkList(*args))
    __swig_destroy__ = _byteblower.delete_WiFiLinkList

# Register WiFiLinkList in _byteblower:
_byteblower.WiFiLinkList_swigregister(WiFiLinkList)
class NetworkInterfaceList(object):
    r"""

    This is a List of multiple NetworkInterface objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.NetworkInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.NetworkInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.NetworkInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.NetworkInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.NetworkInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.NetworkInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.NetworkInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.NetworkInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.NetworkInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.NetworkInterfaceList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.NetworkInterfaceList_swiginit(self, _byteblower.new_NetworkInterfaceList(*args))
    __swig_destroy__ = _byteblower.delete_NetworkInterfaceList

# Register NetworkInterfaceList in _byteblower:
_byteblower.NetworkInterfaceList_swigregister(NetworkInterfaceList)
class Int64StringMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Int64StringMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Int64StringMap___nonzero__(self)

    def __bool__(self):
        return _byteblower.Int64StringMap___bool__(self)

    def __len__(self):
        return _byteblower.Int64StringMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _byteblower.Int64StringMap___getitem__(self, key)

    def __delitem__(self, key):
        return _byteblower.Int64StringMap___delitem__(self, key)

    def has_key(self, key):
        return _byteblower.Int64StringMap_has_key(self, key)

    def keys(self):
        return _byteblower.Int64StringMap_keys(self)

    def values(self):
        return _byteblower.Int64StringMap_values(self)

    def items(self):
        return _byteblower.Int64StringMap_items(self)

    def __contains__(self, key):
        return _byteblower.Int64StringMap___contains__(self, key)

    def key_iterator(self):
        return _byteblower.Int64StringMap_key_iterator(self)

    def value_iterator(self):
        return _byteblower.Int64StringMap_value_iterator(self)

    def __setitem__(self, *args):
        return _byteblower.Int64StringMap___setitem__(self, *args)

    def asdict(self):
        return _byteblower.Int64StringMap_asdict(self)

    def __init__(self, *args):
        _byteblower.Int64StringMap_swiginit(self, _byteblower.new_Int64StringMap(*args))

    def swap(self, v):
        return _byteblower.Int64StringMap_swap(self, v)

    def find(self, x):
        return _byteblower.Int64StringMap_find(self, x)

    def lower_bound(self, x):
        return _byteblower.Int64StringMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _byteblower.Int64StringMap_upper_bound(self, x)
    __swig_destroy__ = _byteblower.delete_Int64StringMap

# Register Int64StringMap in _byteblower:
_byteblower.Int64StringMap_swigregister(Int64StringMap)
class Buffer(object):
    r"""

    This is a List of multiple string objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Buffer_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Buffer___nonzero__(self)

    def __bool__(self):
        return _byteblower.Buffer___bool__(self)

    def __len__(self):
        return _byteblower.Buffer___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Buffer___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Buffer___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Buffer___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Buffer___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Buffer___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Buffer___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.Buffer_swiginit(self, _byteblower.new_Buffer(*args))
    __swig_destroy__ = _byteblower.delete_Buffer

# Register Buffer in _byteblower:
_byteblower.Buffer_swigregister(Buffer)
class Int64List(object):
    r"""

    This is a List of multiple signed integers.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Int64List_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Int64List___nonzero__(self)

    def __bool__(self):
        return _byteblower.Int64List___bool__(self)

    def __len__(self):
        return _byteblower.Int64List___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Int64List___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Int64List___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Int64List___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Int64List___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Int64List___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Int64List___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.Int64List_swiginit(self, _byteblower.new_Int64List(*args))
    __swig_destroy__ = _byteblower.delete_Int64List

# Register Int64List in _byteblower:
_byteblower.Int64List_swigregister(Int64List)
class IntegerList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IntegerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IntegerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IntegerList___bool__(self)

    def __len__(self):
        return _byteblower.IntegerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IntegerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IntegerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IntegerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IntegerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IntegerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IntegerList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.IntegerList_swiginit(self, _byteblower.new_IntegerList(*args))
    __swig_destroy__ = _byteblower.delete_IntegerList

# Register IntegerList in _byteblower:
_byteblower.IntegerList_swigregister(IntegerList)
class StringList(object):
    r"""

    This is a List of multiple string objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StringList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StringList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StringList___bool__(self)

    def __len__(self):
        return _byteblower.StringList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StringList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StringList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StringList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StringList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StringList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StringList___setitem__(self, *args)

    def append(self, x):
        return _byteblower.StringList_append(self, x)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')

        :meta private:


        """
        return _byteblower.StringList_size(self)

    def clear(self):
        return _byteblower.StringList_clear(self)

    def __init__(self, *args):
        _byteblower.StringList_swiginit(self, _byteblower.new_StringList(*args))
    __swig_destroy__ = _byteblower.delete_StringList

# Register StringList in _byteblower:
_byteblower.StringList_swigregister(StringList)
class Int64Pair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _byteblower.Int64Pair_swiginit(self, _byteblower.new_Int64Pair(*args))
    first = property(_byteblower.Int64Pair_first_get, _byteblower.Int64Pair_first_set)
    second = property(_byteblower.Int64Pair_second_get, _byteblower.Int64Pair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _byteblower.delete_Int64Pair

# Register Int64Pair in _byteblower:
_byteblower.Int64Pair_swigregister(Int64Pair)
class AbstractRefreshableResultList(object):
    r"""

    This is a List of multiple AbstractRefreshableResult objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.AbstractRefreshableResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.AbstractRefreshableResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.AbstractRefreshableResultList___bool__(self)

    def __len__(self):
        return _byteblower.AbstractRefreshableResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.AbstractRefreshableResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.AbstractRefreshableResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.AbstractRefreshableResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___setitem__(self, *args)

    def append(self, x):
        return _byteblower.AbstractRefreshableResultList_append(self, x)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')

        :meta private:


        """
        return _byteblower.AbstractRefreshableResultList_size(self)

    def __init__(self, *args):
        _byteblower.AbstractRefreshableResultList_swiginit(self, _byteblower.new_AbstractRefreshableResultList(*args))
    __swig_destroy__ = _byteblower.delete_AbstractRefreshableResultList

# Register AbstractRefreshableResultList in _byteblower:
_byteblower.AbstractRefreshableResultList_swigregister(AbstractRefreshableResultList)
class UserList(object):
    r"""

    This is a List of multiple User objects.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.UserList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.UserList___nonzero__(self)

    def __bool__(self):
        return _byteblower.UserList___bool__(self)

    def __len__(self):
        return _byteblower.UserList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.UserList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.UserList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.UserList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.UserList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.UserList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.UserList___setitem__(self, *args)

    def empty(self):
        return _byteblower.UserList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.UserList_size(self)

    def __init__(self, *args):
        _byteblower.UserList_swiginit(self, _byteblower.new_UserList(*args))
    __swig_destroy__ = _byteblower.delete_UserList

# Register UserList in _byteblower:
_byteblower.UserList_swigregister(UserList)
class UserMobileList(object):
    r"""

    This is a List of multiple UserMobile objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.UserMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.UserMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.UserMobileList___bool__(self)

    def __len__(self):
        return _byteblower.UserMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.UserMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.UserMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.UserMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.UserMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.UserMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.UserMobileList___setitem__(self, *args)

    def empty(self):
        return _byteblower.UserMobileList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.UserMobileList_size(self)

    def __init__(self, *args):
        _byteblower.UserMobileList_swiginit(self, _byteblower.new_UserMobileList(*args))
    __swig_destroy__ = _byteblower.delete_UserMobileList

# Register UserMobileList in _byteblower:
_byteblower.UserMobileList_swigregister(UserMobileList)
class ByteBlowerServerList(object):
    r"""

    This is a List of multiple ByteBlowerServer objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerServerList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerServerList___setitem__(self, *args)

    def append(self, x):
        return _byteblower.ByteBlowerServerList_append(self, x)

    def __init__(self, *args):
        _byteblower.ByteBlowerServerList_swiginit(self, _byteblower.new_ByteBlowerServerList(*args))
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerList

# Register ByteBlowerServerList in _byteblower:
_byteblower.ByteBlowerServerList_swigregister(ByteBlowerServerList)
class PhysicalInterfaceList(object):
    r"""

    This is a List of multiple PhysicalInterface objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.PhysicalInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.PhysicalInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.PhysicalInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.PhysicalInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.PhysicalInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.PhysicalInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.PhysicalInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.PhysicalInterfaceList_swiginit(self, _byteblower.new_PhysicalInterfaceList(*args))
    __swig_destroy__ = _byteblower.delete_PhysicalInterfaceList

# Register PhysicalInterfaceList in _byteblower:
_byteblower.PhysicalInterfaceList_swigregister(PhysicalInterfaceList)
class ByteBlowerInterfaceList(object):
    r"""

    This is a List of multiple ByteBlowerInterface objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.ByteBlowerInterfaceList_swiginit(self, _byteblower.new_ByteBlowerInterfaceList(*args))
    __swig_destroy__ = _byteblower.delete_ByteBlowerInterfaceList

# Register ByteBlowerInterfaceList in _byteblower:
_byteblower.ByteBlowerInterfaceList_swigregister(ByteBlowerInterfaceList)
class ByteBlowerPortList(object):
    r"""

    A list of :class:`.ByteBlowerPort` objects

    This object represents a list of :class:`.ByteBlowerPort` objects.

    The list can be accessed using the standard python `list` syntax

    .. code-block:: python

       from __future__ import print_function
       from byteblowerll.byteblower import ByteBlower
       bb = ByteBlower.InstanceGet()
       server = bb.ServerAdd('byteblower-1.lab.byteblower.excentis.com')

       # create 2 ports
       p1 = server.PortCreate('trunk-1-1')
       p2 = server.PortCreate('trunk-1-2')

       ports = server.PortGet()

       print('Number of created ports', str(len(ports)))
       # prints 'Number of created ports 2'

       for port in ports:
           print(port.InterfaceNameGet())

       # prints the following output :
       # trunk-1-1
       # trunk-1-2


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerPortList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerPortList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerPortList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerPortList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerPortList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerPortList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerPortList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerPortList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerPortList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerPortList___setitem__(self, *args)

    def append(self, x):
        r"""



        """
        return _byteblower.ByteBlowerPortList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerPortList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')

        :meta private:


        """
        return _byteblower.ByteBlowerPortList_size(self)

    def clear(self):
        return _byteblower.ByteBlowerPortList_clear(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerPortList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.ByteBlowerPortList_swiginit(self, _byteblower.new_ByteBlowerPortList(*args))

    def push_back(self, x):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use :meth:`append`.


        """
        return _byteblower.ByteBlowerPortList_push_back(self, x)
    __swig_destroy__ = _byteblower.delete_ByteBlowerPortList

# Register ByteBlowerPortList in _byteblower:
_byteblower.ByteBlowerPortList_swigregister(ByteBlowerPortList)
class Layer25VlanList(object):
    r"""

    This is a List of multiple VLANTag objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Layer25VlanList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Layer25VlanList___nonzero__(self)

    def __bool__(self):
        return _byteblower.Layer25VlanList___bool__(self)

    def __len__(self):
        return _byteblower.Layer25VlanList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Layer25VlanList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Layer25VlanList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Layer25VlanList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Layer25VlanList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Layer25VlanList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Layer25VlanList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.Layer25VlanList_swiginit(self, _byteblower.new_Layer25VlanList(*args))
    __swig_destroy__ = _byteblower.delete_Layer25VlanList

# Register Layer25VlanList in _byteblower:
_byteblower.Layer25VlanList_swigregister(Layer25VlanList)
class Layer25PPPoEList(object):
    r"""

    This is a List of multiple PPPoEClient objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Layer25PPPoEList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Layer25PPPoEList___nonzero__(self)

    def __bool__(self):
        return _byteblower.Layer25PPPoEList___bool__(self)

    def __len__(self):
        return _byteblower.Layer25PPPoEList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Layer25PPPoEList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Layer25PPPoEList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Layer25PPPoEList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Layer25PPPoEList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Layer25PPPoEList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Layer25PPPoEList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.Layer25PPPoEList_swiginit(self, _byteblower.new_Layer25PPPoEList(*args))
    __swig_destroy__ = _byteblower.delete_Layer25PPPoEList

# Register Layer25PPPoEList in _byteblower:
_byteblower.Layer25PPPoEList_swigregister(Layer25PPPoEList)
class ScheduleList(object):
    r"""

    This is a List of multiple Schedule objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ScheduleList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ScheduleList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ScheduleList___bool__(self)

    def __len__(self):
        return _byteblower.ScheduleList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ScheduleList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ScheduleList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ScheduleList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ScheduleList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ScheduleList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ScheduleList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.ScheduleList_swiginit(self, _byteblower.new_ScheduleList(*args))
    __swig_destroy__ = _byteblower.delete_ScheduleList

# Register ScheduleList in _byteblower:
_byteblower.ScheduleList_swigregister(ScheduleList)
class StreamList(object):
    r"""

    This is a List of multiple Stream objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamList___bool__(self)

    def __len__(self):
        return _byteblower.StreamList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamList___setitem__(self, *args)

    def empty(self):
        return _byteblower.StreamList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.StreamList_size(self)

    def __init__(self, *args):
        _byteblower.StreamList_swiginit(self, _byteblower.new_StreamList(*args))
    __swig_destroy__ = _byteblower.delete_StreamList

# Register StreamList in _byteblower:
_byteblower.StreamList_swigregister(StreamList)
class StreamMobileList(object):
    r"""

    This is a List of multiple StreamMobile objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamMobileList___bool__(self)

    def __len__(self):
        return _byteblower.StreamMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamMobileList___setitem__(self, *args)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.StreamMobileList_size(self)

    def __init__(self, *args):
        _byteblower.StreamMobileList_swiginit(self, _byteblower.new_StreamMobileList(*args))
    __swig_destroy__ = _byteblower.delete_StreamMobileList

# Register StreamMobileList in _byteblower:
_byteblower.StreamMobileList_swigregister(StreamMobileList)
class FrameList(object):
    r"""

    This is a List of multiple Frame objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameList___bool__(self)

    def __len__(self):
        return _byteblower.FrameList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.FrameList_swiginit(self, _byteblower.new_FrameList(*args))
    __swig_destroy__ = _byteblower.delete_FrameList

# Register FrameList in _byteblower:
_byteblower.FrameList_swigregister(FrameList)
class FrameMobileList(object):
    r"""

    This is a List of multiple FrameMobile objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameMobileList___bool__(self)

    def __len__(self):
        return _byteblower.FrameMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameMobileList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.FrameMobileList_swiginit(self, _byteblower.new_FrameMobileList(*args))
    __swig_destroy__ = _byteblower.delete_FrameMobileList

# Register FrameMobileList in _byteblower:
_byteblower.FrameMobileList_swigregister(FrameMobileList)
class FrameModifierFieldRandomList(object):
    r"""

    This is a List of multiple FrameFieldModifierRandom objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameModifierFieldRandomList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameModifierFieldRandomList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameModifierFieldRandomList___bool__(self)

    def __len__(self):
        return _byteblower.FrameModifierFieldRandomList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameModifierFieldRandomList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameModifierFieldRandomList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.FrameModifierFieldRandomList_swiginit(self, _byteblower.new_FrameModifierFieldRandomList(*args))
    __swig_destroy__ = _byteblower.delete_FrameModifierFieldRandomList

# Register FrameModifierFieldRandomList in _byteblower:
_byteblower.FrameModifierFieldRandomList_swigregister(FrameModifierFieldRandomList)
class FrameModifierFieldIncrementalList(object):
    r"""

    This is a List of multiple FrameFieldModifierIncremental objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameModifierFieldIncrementalList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameModifierFieldIncrementalList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameModifierFieldIncrementalList___bool__(self)

    def __len__(self):
        return _byteblower.FrameModifierFieldIncrementalList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameModifierFieldIncrementalList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameModifierFieldIncrementalList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.FrameModifierFieldIncrementalList_swiginit(self, _byteblower.new_FrameModifierFieldIncrementalList(*args))
    __swig_destroy__ = _byteblower.delete_FrameModifierFieldIncrementalList

# Register FrameModifierFieldIncrementalList in _byteblower:
_byteblower.FrameModifierFieldIncrementalList_swigregister(FrameModifierFieldIncrementalList)
class TriggerBasicList(object):
    r"""

    This is a List of multiple TriggerBasic objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicList___setitem__(self, *args)

    def empty(self):
        return _byteblower.TriggerBasicList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.TriggerBasicList_size(self)

    def __init__(self, *args):
        _byteblower.TriggerBasicList_swiginit(self, _byteblower.new_TriggerBasicList(*args))
    __swig_destroy__ = _byteblower.delete_TriggerBasicList

# Register TriggerBasicList in _byteblower:
_byteblower.TriggerBasicList_swigregister(TriggerBasicList)
class TriggerBasicMobileList(object):
    r"""

    This is a List of multiple TriggerBasicMobile objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicMobileList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___setitem__(self, *args)

    def empty(self):
        return _byteblower.TriggerBasicMobileList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.TriggerBasicMobileList_size(self)

    def __init__(self, *args):
        _byteblower.TriggerBasicMobileList_swiginit(self, _byteblower.new_TriggerBasicMobileList(*args))
    __swig_destroy__ = _byteblower.delete_TriggerBasicMobileList

# Register TriggerBasicMobileList in _byteblower:
_byteblower.TriggerBasicMobileList_swigregister(TriggerBasicMobileList)
class TriggerSizeDistributionList(object):
    r"""

    This is a List of multiple TriggerSizeDistribution objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerSizeDistributionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerSizeDistributionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerSizeDistributionList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerSizeDistributionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerSizeDistributionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerSizeDistributionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerSizeDistributionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___setitem__(self, *args)

    def empty(self):
        return _byteblower.TriggerSizeDistributionList_empty(self)

    def __init__(self, *args):
        _byteblower.TriggerSizeDistributionList_swiginit(self, _byteblower.new_TriggerSizeDistributionList(*args))
    __swig_destroy__ = _byteblower.delete_TriggerSizeDistributionList

# Register TriggerSizeDistributionList in _byteblower:
_byteblower.TriggerSizeDistributionList_swigregister(TriggerSizeDistributionList)
class LatencyBasicList(object):
    r"""

    This is a List of multiple LatencyBasic objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyBasicList_swiginit(self, _byteblower.new_LatencyBasicList(*args))
    __swig_destroy__ = _byteblower.delete_LatencyBasicList

# Register LatencyBasicList in _byteblower:
_byteblower.LatencyBasicList_swigregister(LatencyBasicList)
class LatencyBasicMobileList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicMobileList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyBasicMobileList_pop(self)

    def append(self, x):
        return _byteblower.LatencyBasicMobileList_append(self, x)

    def empty(self):
        return _byteblower.LatencyBasicMobileList_empty(self)

    def size(self):
        return _byteblower.LatencyBasicMobileList_size(self)

    def swap(self, v):
        return _byteblower.LatencyBasicMobileList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyBasicMobileList_begin(self)

    def end(self):
        return _byteblower.LatencyBasicMobileList_end(self)

    def rbegin(self):
        return _byteblower.LatencyBasicMobileList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyBasicMobileList_rend(self)

    def clear(self):
        return _byteblower.LatencyBasicMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyBasicMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyBasicMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyBasicMobileList_erase(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyBasicMobileList_swiginit(self, _byteblower.new_LatencyBasicMobileList(*args))

    def push_back(self, x):
        return _byteblower.LatencyBasicMobileList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyBasicMobileList_front(self)

    def back(self):
        return _byteblower.LatencyBasicMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyBasicMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyBasicMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyBasicMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyBasicMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyBasicMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyBasicMobileList

# Register LatencyBasicMobileList in _byteblower:
_byteblower.LatencyBasicMobileList_swigregister(LatencyBasicMobileList)
class LatencyDistributionList(object):
    r"""

    This is a List of multiple LatencyDistribution objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyDistributionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyDistributionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyDistributionList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyDistributionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyDistributionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyDistributionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyDistributionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyDistributionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyDistributionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyDistributionList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyDistributionList_swiginit(self, _byteblower.new_LatencyDistributionList(*args))
    __swig_destroy__ = _byteblower.delete_LatencyDistributionList

# Register LatencyDistributionList in _byteblower:
_byteblower.LatencyDistributionList_swigregister(LatencyDistributionList)
class LatencyDistributionMobileList(object):
    r"""

    This is a List of multiple LatencyDistributionMobile objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyDistributionMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyDistributionMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyDistributionMobileList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyDistributionMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyDistributionMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyDistributionMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyDistributionMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyDistributionMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyDistributionMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyDistributionMobileList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.LatencyDistributionMobileList_swiginit(self, _byteblower.new_LatencyDistributionMobileList(*args))
    __swig_destroy__ = _byteblower.delete_LatencyDistributionMobileList

# Register LatencyDistributionMobileList in _byteblower:
_byteblower.LatencyDistributionMobileList_swigregister(LatencyDistributionMobileList)
class OutOfSequenceList(object):
    r"""

    This is a List of multiple OutOfSequence objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.OutOfSequenceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.OutOfSequenceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.OutOfSequenceList___bool__(self)

    def __len__(self):
        return _byteblower.OutOfSequenceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.OutOfSequenceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.OutOfSequenceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.OutOfSequenceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.OutOfSequenceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.OutOfSequenceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.OutOfSequenceList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.OutOfSequenceList_swiginit(self, _byteblower.new_OutOfSequenceList(*args))
    __swig_destroy__ = _byteblower.delete_OutOfSequenceList

# Register OutOfSequenceList in _byteblower:
_byteblower.OutOfSequenceList_swigregister(OutOfSequenceList)
class HTTPClientList(object):
    r"""

    This is a List of multiple HTTPClient objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPClientList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPClientList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPClientList_swiginit(self, _byteblower.new_HTTPClientList(*args))
    __swig_destroy__ = _byteblower.delete_HTTPClientList

# Register HTTPClientList in _byteblower:
_byteblower.HTTPClientList_swigregister(HTTPClientList)
class HTTPMultiDataList(object):
    r"""

    This is a List of multiple HTTPMultiResultData objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiDataList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiDataList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPMultiDataList_swiginit(self, _byteblower.new_HTTPMultiDataList(*args))
    __swig_destroy__ = _byteblower.delete_HTTPMultiDataList

# Register HTTPMultiDataList in _byteblower:
_byteblower.HTTPMultiDataList_swigregister(HTTPMultiDataList)
class HTTPMultiClientList(object):
    r"""

    This is a List of multiple HTTPMultiClient objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiClientList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiClientList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPMultiClientList_swiginit(self, _byteblower.new_HTTPMultiClientList(*args))
    __swig_destroy__ = _byteblower.delete_HTTPMultiClientList

# Register HTTPMultiClientList in _byteblower:
_byteblower.HTTPMultiClientList_swigregister(HTTPMultiClientList)
class HTTPClientMobileList(object):
    r"""

    This is a List of multiple HTTPClientMobile objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPClientMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPClientMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPClientMobileList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPClientMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPClientMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPClientMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPClientMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPClientMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPClientMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPClientMobileList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPClientMobileList_swiginit(self, _byteblower.new_HTTPClientMobileList(*args))
    __swig_destroy__ = _byteblower.delete_HTTPClientMobileList

# Register HTTPClientMobileList in _byteblower:
_byteblower.HTTPClientMobileList_swigregister(HTTPClientMobileList)
class HTTPServerList(object):
    r"""

    This is a List of multiple HTTPServer objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPServerList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPServerList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPServerList_swiginit(self, _byteblower.new_HTTPServerList(*args))
    __swig_destroy__ = _byteblower.delete_HTTPServerList

# Register HTTPServerList in _byteblower:
_byteblower.HTTPServerList_swigregister(HTTPServerList)
class HTTPMultiServerList(object):
    r"""

    This is a List of multiple HTTPMultiServer objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiServerList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiServerList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.HTTPMultiServerList_swiginit(self, _byteblower.new_HTTPMultiServerList(*args))
    __swig_destroy__ = _byteblower.delete_HTTPMultiServerList

# Register HTTPMultiServerList in _byteblower:
_byteblower.HTTPMultiServerList_swigregister(HTTPMultiServerList)
class TelnetClientList(object):
    r"""

    This is a List of multiple TelnetClient objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TelnetClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TelnetClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TelnetClientList___bool__(self)

    def __len__(self):
        return _byteblower.TelnetClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TelnetClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TelnetClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TelnetClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TelnetClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TelnetClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TelnetClientList___setitem__(self, *args)

    def empty(self):
        return _byteblower.TelnetClientList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.TelnetClientList_size(self)

    def __init__(self, *args):
        _byteblower.TelnetClientList_swiginit(self, _byteblower.new_TelnetClientList(*args))
    __swig_destroy__ = _byteblower.delete_TelnetClientList

# Register TelnetClientList in _byteblower:
_byteblower.TelnetClientList_swigregister(TelnetClientList)
class TCPTunnelList(object):
    r"""

    This is a List of multiple TCPTunnel objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TCPTunnelList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TCPTunnelList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TCPTunnelList___bool__(self)

    def __len__(self):
        return _byteblower.TCPTunnelList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TCPTunnelList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TCPTunnelList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TCPTunnelList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TCPTunnelList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TCPTunnelList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TCPTunnelList___setitem__(self, *args)

    def empty(self):
        return _byteblower.TCPTunnelList_empty(self)

    def size(self):
        r"""


        .. deprecated:: 2.22.0

        This is a leaked implementation detail, please use 'len'.

        .. code-block:: python

            portlist = ByteBlowerPortList()
            if len(portlist) == 1:
                print('list only has a single item')


        """
        return _byteblower.TCPTunnelList_size(self)

    def __init__(self, *args):
        _byteblower.TCPTunnelList_swiginit(self, _byteblower.new_TCPTunnelList(*args))
    __swig_destroy__ = _byteblower.delete_TCPTunnelList

# Register TCPTunnelList in _byteblower:
_byteblower.TCPTunnelList_swigregister(TCPTunnelList)
class ICMPEchoSessionList(object):
    r"""

    This is a List of multiple ICMPEchoSession objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ICMPEchoSessionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ICMPEchoSessionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ICMPEchoSessionList___bool__(self)

    def __len__(self):
        return _byteblower.ICMPEchoSessionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ICMPEchoSessionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ICMPEchoSessionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ICMPEchoSessionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.ICMPEchoSessionList_swiginit(self, _byteblower.new_ICMPEchoSessionList(*args))
    __swig_destroy__ = _byteblower.delete_ICMPEchoSessionList

# Register ICMPEchoSessionList in _byteblower:
_byteblower.ICMPEchoSessionList_swigregister(ICMPEchoSessionList)
class ICMPv6EchoSessionList(object):
    r"""

    This is a List of multiple  ICMPv6EchoSession objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ICMPv6EchoSessionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ICMPv6EchoSessionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ICMPv6EchoSessionList___bool__(self)

    def __len__(self):
        return _byteblower.ICMPv6EchoSessionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ICMPv6EchoSessionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ICMPv6EchoSessionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.ICMPv6EchoSessionList_swiginit(self, _byteblower.new_ICMPv6EchoSessionList(*args))
    __swig_destroy__ = _byteblower.delete_ICMPv6EchoSessionList

# Register ICMPv6EchoSessionList in _byteblower:
_byteblower.ICMPv6EchoSessionList_swigregister(ICMPv6EchoSessionList)
class CaptureRawPacketList(object):
    r"""

    This is a List of multiple CaptureRawPacket objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CaptureRawPacketList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CaptureRawPacketList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CaptureRawPacketList___bool__(self)

    def __len__(self):
        return _byteblower.CaptureRawPacketList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CaptureRawPacketList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CaptureRawPacketList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CaptureRawPacketList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CaptureRawPacketList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CaptureRawPacketList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CaptureRawPacketList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.CaptureRawPacketList_swiginit(self, _byteblower.new_CaptureRawPacketList(*args))
    __swig_destroy__ = _byteblower.delete_CaptureRawPacketList

# Register CaptureRawPacketList in _byteblower:
_byteblower.CaptureRawPacketList_swigregister(CaptureRawPacketList)
class CapturedFrameList(object):
    r"""

    This is a List of multiple CapturedFrame objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CapturedFrameList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CapturedFrameList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CapturedFrameList___bool__(self)

    def __len__(self):
        return _byteblower.CapturedFrameList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CapturedFrameList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CapturedFrameList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CapturedFrameList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CapturedFrameList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CapturedFrameList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CapturedFrameList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.CapturedFrameList_swiginit(self, _byteblower.new_CapturedFrameList(*args))
    __swig_destroy__ = _byteblower.delete_CapturedFrameList

# Register CapturedFrameList in _byteblower:
_byteblower.CapturedFrameList_swigregister(CapturedFrameList)
class CapabilityList(object):
    r"""

    This is a List of multiple Capability objects.

    It can be iterated just like a normal Python list.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CapabilityList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CapabilityList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CapabilityList___bool__(self)

    def __len__(self):
        return _byteblower.CapabilityList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CapabilityList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CapabilityList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CapabilityList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CapabilityList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CapabilityList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CapabilityList___setitem__(self, *args)

    def __init__(self, *args):
        _byteblower.CapabilityList_swiginit(self, _byteblower.new_CapabilityList(*args))
    __swig_destroy__ = _byteblower.delete_CapabilityList

# Register CapabilityList in _byteblower:
_byteblower.CapabilityList_swigregister(CapabilityList)
# This file expects that the lower layer ByteBlower is included as _byteblower


class ByteBlowerPortCounterType(object):

    RxAll = _byteblower.ByteBlowerPortResultRxData_CounterType_RxAll
    """ TODO"""

    RxBroadcast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxBroadcast  # noqa: E501
    """ TODO"""

    RxUnicast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxUnicast
    """ TODO"""


class CapabilityValueType(object):
    BOOLEAN = _byteblower.CapabilityValue_Type_BOOLEAN
    """The given capability is a Boolean value, containing True or False"""

    INTEGER = _byteblower.CapabilityValue_Type_INTEGER
    """The given capability is an integer value"""

    STRING = _byteblower.CapabilityValue_Type_STRING
    """The given capability is a string value"""


class DeviceOsType(object):
    Android = _byteblower.DeviceOsType_Android
    """The Endpoint application runs on a Device running Android"""

    iOS = _byteblower.DeviceOsType_iOS
    """The Endpoint application runs on a Device running Apple iOS

    .. note: the device might be running iPadOS too.
    """

    Linux = _byteblower.DeviceOsType_Linux
    """The Endpoint application runs on a Device running a Linux distribution"""

    OSx = _byteblower.DeviceOsType_OSx
    """The Endpoint application runs on a Device running Apple macOS"""

    Unknown = _byteblower.DeviceOsType_Unknown
    """The Endpoint application runs on a Device running an unknown operating system"""

    Windows = _byteblower.DeviceOsType_Windows
    """The Endpoint application runs on a Device running Microsoft Windows"""


class DeviceStatus(object):
    Available = _byteblower.DeviceStatus_Available
    """ The Endpoint application is registered  """

    Reserved = _byteblower.DeviceStatus_Reserved
    """ The Endpoint application is locked/used by (another) user  """

    Running = _byteblower.DeviceStatus_Running
    """ The Endpoint application is currently running a test """

    Starting = _byteblower.DeviceStatus_Starting
    """ The Endpoint application will start any second now with a test"""

    Unavailable = _byteblower.DeviceStatus_Unavailable
    """The Endpoint application not available/registered"""


class EthernetEncoding(object):
    DIX = _byteblower.EthernetEncoding_DIX
    SNAP = _byteblower.EthernetEncoding_SNAP


class FrameTagType(object):
    """ The type of the FrameTag as found in a Trigger and a Frame """

    SequenceNumber = _byteblower.FrameTagType_SequenceNumber
    """This is a FrameTag with a sequence number.  """

    TimeStamp = _byteblower.FrameTagType_TimeStamp
    """This is a FrameTag with a timestamp."""


class HTTPMultiClientStatus(object):
    Configuration = _byteblower.HTTPMultiClientStatus_Configuration
    """ initial state in which the configuration takes place"""

    Finished = _byteblower.HTTPMultiClientStatus_Finished
    """ flow finished succesfully"""

    Running = _byteblower.HTTPMultiClientStatus_Running
    """ when the flow is running"""

    Scheduled = _byteblower.HTTPMultiClientStatus_Scheduled
    """ during the initial time to wait"""

    Stopped = _byteblower.HTTPMultiClientStatus_Stopped
    """ flow was stopped by user"""


class HTTPMultiServerStatus(object):
    Started = _byteblower.HTTPMultiServerStatus_Started
    """ The HTTP server is active"""
    Stopped = _byteblower.HTTPMultiServerStatus_Stopped
    """ The HTTP server is not running"""


class HTTPRequestMethod(object):
    """The HTTP Request Method of a HTTP Session

    The HTTP Request Method determines what the ByteBlower HTTP Client will
    perform.  

    HTTP supports multiple HTTP Methods:

    - Get
    - Post
    - Put
    - Delete
    - Head
    - Options
    - Trace

    But the ByteBlower HTTP Server implementations for traffic simulation 
    currently only support :attr:`Get` and :attr:`Put`
    """
    Delete = _byteblower.HTTPRequestMethod_Delete
    """Delete a resource on the server

    :meta private:
    :meta hide-value:
    """

    Get = _byteblower.HTTPRequestMethod_Get
    """ Download a resource from the Server

    :meta hide-value:
    """

    Head = _byteblower.HTTPRequestMethod_Head
    """ TODO

    :meta private:
    :meta hide-value:
    """

    Options = _byteblower.HTTPRequestMethod_Options
    """ TODO

    :meta private:
    :meta hide-value:
    """

    Post = _byteblower.HTTPRequestMethod_Post
    """ TODO

    :meta private:
    :meta hide-value:
    """

    Put = _byteblower.HTTPRequestMethod_Put
    """ Upload a resource to the server 

    :meta hide-value:
    """

    Trace = _byteblower.HTTPRequestMethod_Trace
    """ TODO


    :meta hide-value:
    :meta private:    
    """

    Undefined = _byteblower.HTTPRequestMethod_Undefined
    """ TODO

    :meta private:
    :meta hide-value:
    """


class HTTPRequestStatus(object):
    Configuration = _byteblower.HTTPRequestStatus_Configuration
    """ initial state in which the configuration takes place"""
    Connecting = _byteblower.HTTPRequestStatus_Connecting
    """ while trying to establish a connection"""
    Error = _byteblower.HTTPRequestStatus_Error
    """ if an error occurred while trying to connect or while running"""
    Finished = _byteblower.HTTPRequestStatus_Finished
    """ after the http request has completed"""
    Running = _byteblower.HTTPRequestStatus_Running
    """ while the connection is established and before http request has
    completed"""
    Scheduled = _byteblower.HTTPRequestStatus_Scheduled
    """ during the initial time to wait of a scheduled request"""
    Stopped = _byteblower.HTTPRequestStatus_Stopped
    """ after the user stopped the request"""


class HTTPRequestType(object):
    Duration = _byteblower.HTTPRequestType_Duration
    """The session is duration based and finishes after a specific duration"""
    Size = _byteblower.HTTPRequestType_Size
    """The session is size based and finishes after a specific size"""


class HTTPServerStatus(object):
    Error = _byteblower.HTTPServerStatus_Error
    """ Error occurred while initializing"""

    Running = _byteblower.HTTPServerStatus_Running
    """ The HTTP server is active"""

    Stopped = _byteblower.HTTPServerStatus_Stopped
    """ The HTTP server is not running"""

    Unknown = _byteblower.HTTPServerStatus_Unknown
    """ The server status code is not known to the client"""


class IGMPVersion(object):
    IGMPv1 = _byteblower.IGMPVersion_IGMPv1
    IGMPv2 = _byteblower.IGMPVersion_IGMPv2
    IGMPv3 = _byteblower.IGMPVersion_IGMPv3


class LinkStatus(object):
    """Link status object

    """

    Offline = _byteblower.LinkStatus_Offline
    """The ByteBlower interface is offline"""

    Online = _byteblower.LinkStatus_Online
    """ The ByteBlower interface is fully up and running"""

    Unplugged = _byteblower.LinkStatus_Unplugged
    """The ByteBlower Interface is not plugged in"""

    Unknown = _byteblower.LinkStatus_Unknown
    """ The ByteBlower Interface has an unknown status."""


class LinkType(object):
    Ethernet = _byteblower.LinkType_Ethernet
    USB = _byteblower.LinkType_USB


class LogLevel(object):
    Critical = _byteblower.LogLevel_Critical
    Debug = _byteblower.LogLevel_Debug
    Error = _byteblower.LogLevel_Error
    Info = _byteblower.LogLevel_Info
    Warning = _byteblower.LogLevel_Warning


class MLDVersion(object):
    MLDv1 = _byteblower.MLDVersion_MLDv1
    MLDv2 = _byteblower.MLDVersion_MLDv2


class ModifierType(object):
    GrowingSize = _byteblower.ModifierType_GrowingSize
    MultiBurst = _byteblower.ModifierType_MultiBurst
    NormalDistributionTiming = _byteblower.ModifierType_NormalDistributionTiming  # noqa: E501
    RandomSize = _byteblower.ModifierType_RandomSize


class MulticastSourceFilter(object):
    Exclude = _byteblower.MulticastSourceFilter_Exclude
    Include = _byteblower.MulticastSourceFilter_Include


class NetworkInterfaceType(object):
    Unknown = _byteblower.NetworkInterfaceType_Unknown

    Ethernet = _byteblower.NetworkInterfaceType_Ethernet
    """The interface is a typical 802.3 wired ethernet interface"""

    Loopback = _byteblower.NetworkInterfaceType_Loopback
    """The interface is a (software) loopback interface"""

    WiFi = _byteblower.NetworkInterfaceType_WiFi
    """The interface uses the IEEE 802.11 protocol family"""


class PhysicalInterfaceType(object):
    NonTrunk = _byteblower.PhysicalInterfaceType_NonTrunk
    NonTrunkUSB = _byteblower.PhysicalInterfaceType_NonTrunkUSB
    Trunk = _byteblower.PhysicalInterfaceType_Trunk


class PPPoEStatus(object):
    Discovering = _byteblower.PPPoEStatus_Discovering
    Initial = _byteblower.PPPoEStatus_Initial
    Requesting = _byteblower.PPPoEStatus_Requesting
    SessionActive = _byteblower.PPPoEStatus_SessionActive
    Terminated = _byteblower.PPPoEStatus_Terminated


class RequestStartType(object):
    Direct = _byteblower.HTTPClient_RequestStartType_Direct
    """Send out the HTTP Request as soon the HTTP Client is started"""
    Scheduled = _byteblower.HTTPClient_RequestStartType_Scheduled
    """Only start the HTTP Request when the port or schedule is started"""


class ResultDataType(object):
    Cumulative = _byteblower.ResultDataType_Cumulative
    Interval = _byteblower.ResultDataType_Interval


class RetransmissionPolicy(object):
    FixedTiming = _byteblower.RetransmissionPolicy_FixedTiming
    """Every DHCP retry will use the same timout value"""

    RfcSuggested = _byteblower.RetransmissionPolicy_RfcSuggested
    """The retransmission algorithm used is the one from RFC 2131"""

    Unknown = _byteblower.RetransmissionPolicy_Unknown


class Role(object):
    Client = _byteblower.HTTPSessionInfo_Role_Client
    """The HTTP Session info object originates from a HTTP Client"""
    Server = _byteblower.HTTPSessionInfo_Role_Server
    """The HTTP Session info object originates from a HTTP Server"""


class ScheduleGroupStatus(object):
    Configuration = _byteblower.ScheduleGroupStatus_Configuration
    Error = _byteblower.ScheduleGroupStatus_Error
    Prepared = _byteblower.ScheduleGroupStatus_Prepared
    Started = _byteblower.ScheduleGroupStatus_Started
    Stopped = _byteblower.ScheduleGroupStatus_Stopped


class SequenceNumberFormat(object):
    SequenceNumber_0 = _byteblower.SequenceNumberFormat_SequenceNumber_0
    SequenceNumber_0_CRC = _byteblower.SequenceNumberFormat_SequenceNumber_0_CRC  # noqa: E501


class TCPCongestionAvoidanceAlgorithm(object):
    NewReno = _byteblower.TCPCongestionAvoidanceAlgorithm_NewReno
    NewRenoWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic  # noqa: E501
    No_Algorithm = _byteblower.TCPCongestionAvoidanceAlgorithm__None # XXX Python has None as a keyword, so No_Algorithm is used instead!
    Sack = _byteblower.TCPCongestionAvoidanceAlgorithm_Sack
    SackWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_SackWithCubic


class TCPConnectionState(object):
    """The state of the TCP Connection

    """

    CLOSED = _byteblower.TCPConnectionState_CLOSED
    """ Closed"""

    LISTEN = _byteblower.TCPConnectionState_LISTEN
    """Listen"""

    SYN_RECEIVED = _byteblower.TCPConnectionState_SYN_RECEIVED
    """SYN received"""

    SYN_SENT = _byteblower.TCPConnectionState_SYN_SENT
    """SYN Sent"""

    ESTABLISHED = _byteblower.TCPConnectionState_ESTABLISHED
    """Established"""

    FIN_WAIT_1 = _byteblower.TCPConnectionState_FIN_WAIT_1
    """FIN wait (number 1)"""

    FIN_WAIT_2 = _byteblower.TCPConnectionState_FIN_WAIT_2
    """FIN wait (number 2)"""
    CLOSING = _byteblower.TCPConnectionState_CLOSING
    """Closing"""

    CLOSE_WAIT = _byteblower.TCPConnectionState_CLOSE_WAIT
    LAST_ACK = _byteblower.TCPConnectionState_LAST_ACK
    TIME_WAIT = _byteblower.TCPConnectionState_TIME_WAIT


class TransmitErrorStatus(object):
    """The error status of a Stream

    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_status_UNKNOWN
    """Unknown error.

    This can indicate 2 things:

    - The API is outdated
    - The server encountered an error, but does not know what

    """

    NONE = _byteblower.StreamRuntimeStatus_transmit_error_status_NONE
    """No error"""

    OUT_OF_RESOURCES = _byteblower.StreamRuntimeStatus_transmit_error_status_OUT_OF_RESOURCES  # noqa: E501
    """The server went out of resources.

    The origin of the error can be queried by calling
    :meth:`StreamRuntimeStatus.ErrorSourceGet`
    """


class TransmitErrorSource(object):
    """ The source of an error of a Stream
    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_source_UNKNOWN
    """The stream does honestly not know where the error came from.

    This can also be returned when you encounter an error with an outdated API.
    """

    NONE = _byteblower.StreamRuntimeStatus_transmit_error_source_NONE
    """Nothing has gone wrong, this is what you want!"""

    INTERFACE_HARDWARE = _byteblower.StreamRuntimeStatus_transmit_error_source_INTERFACE_HARDWARE  # noqa: E501
    """One tries to transmit more than the interface bandwith.

    e.g. One tries to send 2 700Mbps flows on a single 1Gbps interface
    """

    SCHEDULING_CONFLICT = _byteblower.StreamRuntimeStatus_transmit_error_source_SCHEDULING_CONFLICT  # noqa: E501
    """The stream cannot keep up.

    .. deprecated:: 2.9.0

       The stream has issues to schedule all frames on the network interface.
    """

    TXUSER = _byteblower.StreamRuntimeStatus_transmit_error_source_TXUSER
    """The user is requesting too much processing power on the server"""


class TransmitStatus(object):
    """The current transmission status of a class:`Stream`
    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_status_UNKNOWN
    """The server honestly does not know what the stream is doing.

    .. note:: If this happens, please contact the ByteBlower support team.
              It will indicate us that something is going wrong.
    """

    INACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_INACTIVE
    """The stream is inactive and not transmitting frames.

    This can either be because the stream is not started (yet)
    or the stream has transmitted all frames as configured
    by :meth:`.Stream.NumberOfFramesSet`
    """

    ACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_ACTIVE
    """The stream is active and transmitting frames"""


class TimeStampFormat(object):
    Microseconds = _byteblower.TimeStampFormat_Microseconds
    """Insert timestamps with Microsecond resolution

    .. deprecated:: 2.0
    """
    Microseconds_CRC = _byteblower.TimeStampFormat_Microseconds_CRC
    """Insert timestamps with Microsecond resolution and a CRC

    .. deprecated:: 2.9
       Use TenNanoseconds
    """
    TenNanoseconds = _byteblower.TimeStampFormat_TenNanoseconds
    """Insert timestamps with 10 nanosecond resolution"""


#class TimeUnit(object):
#    Microseconds = _byteblower.TimeUnit_Microseconds
#    Milliseconds = _byteblower.TimeUnit_Milliseconds
#    Nanoseconds = _byteblower.TimeUnit_Nanoseconds
#    Seconds = _byteblower.TimeUnit_Seconds


class WiFiBand(object):
    Band_2_4_GHz = _byteblower.WiFiBand_Band_2_4_GHz
    """The ByteBlower Endpoint connected through a 2.4 GHz channel"""

    Band_5_GHz = _byteblower.WiFiBand_Band_5_GHz
    """The ByteBlower Endpoint connected through a 5 GHz channel"""

    Band_6_GHz = _byteblower.WiFiBand_Band_6_GHz
    """The ByteBlower Endpoint connected through a 6 GHz channel"""

    Band_60_GHz = _byteblower.WiFiBand_Band_60_GHz
    """The ByteBlower Endpoint connected through a 60 GHz channel"""

    Unknown = _byteblower.WiFiBand_Unknown
    """The ByteBlower Endpoint connected through an unknown Wi-Fi channel"""


class WiFiLinkState(object):
    Active = _byteblower.WiFiLinkState_Active
    """The ByteBlower Endpoint has this Wi-Fi (MLO) link and has traffic streams mapped to it."""

    Idle = _byteblower.WiFiLinkState_Idle
    """The ByteBlower Endpoint has this Wi-Fi (MLO) link and has no traffic streams mapped to it."""

    Unassociated = _byteblower.WiFiLinkState_Unassociated
    """The ByteBlower Endpoint sees this Wi-Fi link, but does not use this and is thus not associated."""

    Invalid = _byteblower.WiFiLinkState_Invalid
    """This Wi-Fi link is not valid Wi-Fi 7.  This might be due to backwards compatibility."""

    Unknown = _byteblower.WiFiLinkState_Unknown
    """The ByteBlower Endpoint, MeetingPoint or API does not know this link state.  Maybe an update of these components might be required."""

