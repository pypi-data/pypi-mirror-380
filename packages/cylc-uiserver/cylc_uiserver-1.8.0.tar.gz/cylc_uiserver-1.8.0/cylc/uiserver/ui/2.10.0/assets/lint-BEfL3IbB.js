import{C as Y}from"./codemirror-CgvGFWt9.js";import{d as S,i as ce,a as V,n as fe,b as C,s as _,t as I,c as w,e as q,f as we,h as _e,j as b,k as F,l as E,m as A,o as ne,p as de,q as L,r as $e,v as Re,G as Fe,u as Ve,w as k,x as Ce,y as Ae,z as Le,A as ke,B as te,T as pe,C as me,D as Ue,E as je,F as Me}from"./GraphiQL-BQoybdla.js";import{R as ge,P as U}from"./Range-CZNrBk8u.js";import{dW as Pe,aA as f,aC as p,aH as T,aK as O,aG as y,aJ as N,aL as B,dX as ve,dY as Ge,dZ as qe,d_ as Ye,aR as ye,aB as Be,d$ as Qe,aQ as We}from"./index-jbzX_AXb.js";import"./codemirror-HbUmq4EM.js";function Ne(n){return{Document(t){for(const e of t.definitions)if(!Pe(e)){const r=e.kind===f.SCHEMA_DEFINITION||e.kind===f.SCHEMA_EXTENSION?"schema":'"'+e.name.value+'"';n.reportError(new p(`The ${r} definition is not executable.`,{nodes:e}))}return!1}}}function Xe(n){return{Field(t){const e=n.getParentType();if(e&&!n.getFieldDef()){const s=n.getSchema(),i=t.name.value;let o=S("to use an inline fragment on",He(s,e,i));o===""&&(o=S(Je(e,i))),n.reportError(new p(`Cannot query field "${i}" on type "${e.name}".`+o,{nodes:t}))}}}}function He(n,t,e){if(!ce(t))return[];const r=new Set,s=Object.create(null);for(const o of n.getPossibleTypes(t))if(o.getFields()[e]){r.add(o),s[o.name]=1;for(const a of o.getInterfaces()){var i;a.getFields()[e]&&(r.add(a),s[a.name]=((i=s[a.name])!==null&&i!==void 0?i:0)+1)}}return[...r].sort((o,a)=>{const l=s[a.name]-s[o.name];return l!==0?l:V(o)&&n.isSubType(o,a)?-1:V(a)&&n.isSubType(a,o)?1:fe(o.name,a.name)}).map(o=>o.name)}function Je(n,t){if(C(n)||V(n)){const e=Object.keys(n.getFields());return _(t,e)}return[]}function Ke(n){return{InlineFragment(t){const e=t.typeCondition;if(e){const r=I(n.getSchema(),e);if(r&&!w(r)){const s=T(e);n.reportError(new p(`Fragment cannot condition on non composite type "${s}".`,{nodes:e}))}}},FragmentDefinition(t){const e=I(n.getSchema(),t.typeCondition);if(e&&!w(e)){const r=T(t.typeCondition);n.reportError(new p(`Fragment "${t.name.value}" cannot condition on non composite type "${r}".`,{nodes:t.typeCondition}))}}}}function ze(n){return{...Ze(n),Argument(t){const e=n.getArgument(),r=n.getFieldDef(),s=n.getParentType();if(!e&&r&&s){const i=t.name.value,o=r.args.map(l=>l.name),a=_(i,o);n.reportError(new p(`Unknown argument "${i}" on field "${s.name}.${r.name}".`+S(a),{nodes:t}))}}}}function Ze(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():q;for(const o of r)t[o.name]=o.args.map(a=>a.name);const s=n.getDocument().definitions;for(const o of s)if(o.kind===f.DIRECTIVE_DEFINITION){var i;const a=(i=o.arguments)!==null&&i!==void 0?i:[];t[o.name.value]=a.map(l=>l.name.value)}return{Directive(o){const a=o.name.value,l=t[a];if(o.arguments&&l)for(const u of o.arguments){const c=u.name.value;if(!l.includes(c)){const d=_(c,l);n.reportError(new p(`Unknown argument "${c}" on directive "@${a}".`+S(d),{nodes:u}))}}return!1}}}function xe(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():q;for(const i of r)t[i.name]=i.locations;const s=n.getDocument().definitions;for(const i of s)i.kind===f.DIRECTIVE_DEFINITION&&(t[i.name.value]=i.locations.map(o=>o.value));return{Directive(i,o,a,l,u){const c=i.name.value,d=t[c];if(!d){n.reportError(new p(`Unknown directive "@${c}".`,{nodes:i}));return}const m=en(u);m&&!d.includes(m)&&n.reportError(new p(`Directive "@${c}" may not be used on ${m}.`,{nodes:i}))}}}function en(n){const t=n[n.length-1];switch("kind"in t||O(!1),t.kind){case f.OPERATION_DEFINITION:return nn(t.operation);case f.FIELD:return N.FIELD;case f.FRAGMENT_SPREAD:return N.FRAGMENT_SPREAD;case f.INLINE_FRAGMENT:return N.INLINE_FRAGMENT;case f.FRAGMENT_DEFINITION:return N.FRAGMENT_DEFINITION;case f.VARIABLE_DEFINITION:return N.VARIABLE_DEFINITION;case f.SCHEMA_DEFINITION:case f.SCHEMA_EXTENSION:return N.SCHEMA;case f.SCALAR_TYPE_DEFINITION:case f.SCALAR_TYPE_EXTENSION:return N.SCALAR;case f.OBJECT_TYPE_DEFINITION:case f.OBJECT_TYPE_EXTENSION:return N.OBJECT;case f.FIELD_DEFINITION:return N.FIELD_DEFINITION;case f.INTERFACE_TYPE_DEFINITION:case f.INTERFACE_TYPE_EXTENSION:return N.INTERFACE;case f.UNION_TYPE_DEFINITION:case f.UNION_TYPE_EXTENSION:return N.UNION;case f.ENUM_TYPE_DEFINITION:case f.ENUM_TYPE_EXTENSION:return N.ENUM;case f.ENUM_VALUE_DEFINITION:return N.ENUM_VALUE;case f.INPUT_OBJECT_TYPE_DEFINITION:case f.INPUT_OBJECT_TYPE_EXTENSION:return N.INPUT_OBJECT;case f.INPUT_VALUE_DEFINITION:{const e=n[n.length-3];return"kind"in e||O(!1),e.kind===f.INPUT_OBJECT_TYPE_DEFINITION?N.INPUT_FIELD_DEFINITION:N.ARGUMENT_DEFINITION}default:O(!1,"Unexpected kind: "+y(t.kind))}}function nn(n){switch(n){case B.QUERY:return N.QUERY;case B.MUTATION:return N.MUTATION;case B.SUBSCRIPTION:return N.SUBSCRIPTION}}function tn(n){return{FragmentSpread(t){const e=t.name.value;n.getFragment(e)||n.reportError(new p(`Unknown fragment "${e}".`,{nodes:t.name}))}}}function rn(n){const t=n.getSchema(),e=t?t.getTypeMap():Object.create(null),r=Object.create(null);for(const i of n.getDocument().definitions)ve(i)&&(r[i.name.value]=!0);const s=[...Object.keys(e),...Object.keys(r)];return{NamedType(i,o,a,l,u){const c=i.name.value;if(!e[c]&&!r[c]){var d;const m=(d=u[2])!==null&&d!==void 0?d:a,g=m!=null&&sn(m);if(g&&re.includes(c))return;const v=_(c,g?re.concat(s):s);n.reportError(new p(`Unknown type "${c}".`+S(v),{nodes:i}))}}}}const re=[...we,..._e].map(n=>n.name);function sn(n){return"kind"in n&&(Ge(n)||qe(n))}function an(n){let t=0;return{Document(e){t=e.definitions.filter(r=>r.kind===f.OPERATION_DEFINITION).length},OperationDefinition(e){!e.name&&t>1&&n.reportError(new p("This anonymous operation must be the only defined operation.",{nodes:e}))}}}const on=3;function ln(n){function t(e,r=Object.create(null),s=0){if(e.kind===f.FRAGMENT_SPREAD){const i=e.name.value;if(r[i]===!0)return!1;const o=n.getFragment(i);if(!o)return!1;try{return r[i]=!0,t(o,r,s)}finally{r[i]=void 0}}if(e.kind===f.FIELD&&(e.name.value==="fields"||e.name.value==="interfaces"||e.name.value==="possibleTypes"||e.name.value==="inputFields")&&(s++,s>=on))return!0;if("selectionSet"in e&&e.selectionSet){for(const i of e.selectionSet.selections)if(t(i,r,s))return!0}return!1}return{Field(e){if((e.name.value==="__schema"||e.name.value==="__type")&&t(e))return n.reportError(new p("Maximum introspection depth exceeded",{nodes:[e]})),!1}}}function un(n){const t=Object.create(null),e=[],r=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(i){return s(i),!1}};function s(i){if(t[i.name.value])return;const o=i.name.value;t[o]=!0;const a=n.getFragmentSpreads(i.selectionSet);if(a.length!==0){r[o]=e.length;for(const l of a){const u=l.name.value,c=r[u];if(e.push(l),c===void 0){const d=n.getFragment(u);d&&s(d)}else{const d=e.slice(c),m=d.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");n.reportError(new p(`Cannot spread fragment "${u}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:d}))}e.pop()}r[o]=void 0}}}function cn(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s}of r){const i=s.name.value;t[i]!==!0&&n.reportError(new p(e.name?`Variable "$${i}" is not defined by operation "${e.name.value}".`:`Variable "$${i}" is not defined.`,{nodes:[s,e]}))}}},VariableDefinition(e){t[e.variable.name.value]=!0}}}function Te(n){const t=[],e=[];return{OperationDefinition(r){return t.push(r),!1},FragmentDefinition(r){return e.push(r),!1},Document:{leave(){const r=Object.create(null);for(const s of t)for(const i of n.getRecursivelyReferencedFragments(s))r[i.name.value]=!0;for(const s of e){const i=s.name.value;r[i]!==!0&&n.reportError(new p(`Fragment "${i}" is never used.`,{nodes:s}))}}}}}function fn(n){let t=[];return{OperationDefinition:{enter(){t=[]},leave(e){const r=Object.create(null),s=n.getRecursiveVariableUsages(e);for(const{node:i}of s)r[i.name.value]=!0;for(const i of t){const o=i.variable.name.value;r[o]!==!0&&n.reportError(new p(e.name?`Variable "$${o}" is never used in operation "${e.name.value}".`:`Variable "$${o}" is never used.`,{nodes:i}))}}},VariableDefinition(e){t.push(e)}}}function K(n){switch(n.kind){case f.OBJECT:return{...n,fields:dn(n.fields)};case f.LIST:return{...n,values:n.values.map(K)};case f.INT:case f.FLOAT:case f.STRING:case f.BOOLEAN:case f.NULL:case f.ENUM:case f.VARIABLE:return n}}function dn(n){return n.map(t=>({...t,value:K(t.value)})).sort((t,e)=>fe(t.name.value,e.name.value))}function Ee(n){return Array.isArray(n)?n.map(([t,e])=>`subfields "${t}" conflict because `+Ee(e)).join(" and "):n}function pn(n){const t=new be,e=new Tn,r=new Map;return{SelectionSet(s){const i=mn(n,r,t,e,n.getParentType(),s);for(const[[o,a],l,u]of i){const c=Ee(a);n.reportError(new p(`Fields "${o}" conflict because ${c}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:l.concat(u)}))}}}}function mn(n,t,e,r,s,i){const o=[],[a,l]=P(n,t,s,i);if(vn(n,o,t,e,r,a),l.length!==0)for(let u=0;u<l.length;u++){j(n,o,t,e,r,!1,a,l[u]);for(let c=u+1;c<l.length;c++)M(n,o,t,e,r,!1,l[u],l[c])}return o}function j(n,t,e,r,s,i,o,a){if(r.has(o,a,i))return;r.add(o,a,i);const l=n.getFragment(a);if(!l)return;const[u,c]=X(n,e,l);if(o!==u){z(n,t,e,r,s,i,o,u);for(const d of c)j(n,t,e,r,s,i,o,d)}}function M(n,t,e,r,s,i,o,a){if(o===a||s.has(o,a,i))return;s.add(o,a,i);const l=n.getFragment(o),u=n.getFragment(a);if(!l||!u)return;const[c,d]=X(n,e,l),[m,g]=X(n,e,u);z(n,t,e,r,s,i,c,m);for(const v of g)M(n,t,e,r,s,i,o,v);for(const v of d)M(n,t,e,r,s,i,v,a)}function gn(n,t,e,r,s,i,o,a,l){const u=[],[c,d]=P(n,t,i,o),[m,g]=P(n,t,a,l);z(n,u,t,e,r,s,c,m);for(const v of g)j(n,u,t,e,r,s,c,v);for(const v of d)j(n,u,t,e,r,s,m,v);for(const v of d)for(const h of g)M(n,u,t,e,r,s,v,h);return u}function vn(n,t,e,r,s,i){for(const[o,a]of Object.entries(i))if(a.length>1)for(let l=0;l<a.length;l++)for(let u=l+1;u<a.length;u++){const c=he(n,e,r,s,!1,o,a[l],a[u]);c&&t.push(c)}}function z(n,t,e,r,s,i,o,a){for(const[l,u]of Object.entries(o)){const c=a[l];if(c)for(const d of u)for(const m of c){const g=he(n,e,r,s,i,l,d,m);g&&t.push(g)}}}function he(n,t,e,r,s,i,o,a){const[l,u,c]=o,[d,m,g]=a,v=s||l!==d&&C(l)&&C(d);if(!v){const R=u.name.value,ee=m.name.value;if(R!==ee)return[[i,`"${R}" and "${ee}" are different fields`],[u],[m]];if(!yn(u,m))return[[i,"they have differing arguments"],[u],[m]]}const h=c?.type,$=g?.type;if(h&&$&&W(h,$))return[[i,`they return conflicting types "${y(h)}" and "${y($)}"`],[u],[m]];const Z=u.selectionSet,x=m.selectionSet;if(Z&&x){const R=gn(n,t,e,r,v,b(h),Z,b($),x);return Nn(R,i,u,m)}}function yn(n,t){const e=n.arguments,r=t.arguments;if(e===void 0||e.length===0)return r===void 0||r.length===0;if(r===void 0||r.length===0||e.length!==r.length)return!1;const s=new Map(r.map(({name:i,value:o})=>[i.value,o]));return e.every(i=>{const o=i.value,a=s.get(i.name.value);return a===void 0?!1:ie(o)===ie(a)})}function ie(n){return T(K(n))}function W(n,t){return F(n)?F(t)?W(n.ofType,t.ofType):!0:F(t)?!0:E(n)?E(t)?W(n.ofType,t.ofType):!0:E(t)?!0:A(n)||A(t)?n!==t:!1}function P(n,t,e,r){const s=t.get(r);if(s)return s;const i=Object.create(null),o=Object.create(null);Ie(n,e,r,i,o);const a=[i,Object.keys(o)];return t.set(r,a),a}function X(n,t,e){const r=t.get(e.selectionSet);if(r)return r;const s=I(n.getSchema(),e.typeCondition);return P(n,t,s,e.selectionSet)}function Ie(n,t,e,r,s){for(const i of e.selections)switch(i.kind){case f.FIELD:{const o=i.name.value;let a;(C(t)||V(t))&&(a=t.getFields()[o]);const l=i.alias?i.alias.value:o;r[l]||(r[l]=[]),r[l].push([t,i,a]);break}case f.FRAGMENT_SPREAD:s[i.name.value]=!0;break;case f.INLINE_FRAGMENT:{const o=i.typeCondition,a=o?I(n.getSchema(),o):t;Ie(n,a,i.selectionSet,r,s);break}}}function Nn(n,t,e,r){if(n.length>0)return[[t,n.map(([s])=>s)],[e,...n.map(([,s])=>s).flat()],[r,...n.map(([,,s])=>s).flat()]]}class be{constructor(){this._data=new Map}has(t,e,r){var s;const i=(s=this._data.get(t))===null||s===void 0?void 0:s.get(e);return i===void 0?!1:r?!0:r===i}add(t,e,r){const s=this._data.get(t);s===void 0?this._data.set(t,new Map([[e,r]])):s.set(e,r)}}class Tn{constructor(){this._orderedPairSet=new be}has(t,e,r){return t<e?this._orderedPairSet.has(t,e,r):this._orderedPairSet.has(e,t,r)}add(t,e,r){t<e?this._orderedPairSet.add(t,e,r):this._orderedPairSet.add(e,t,r)}}function En(n){return{InlineFragment(t){const e=n.getType(),r=n.getParentType();if(w(e)&&w(r)&&!ne(n.getSchema(),e,r)){const s=y(r),i=y(e);n.reportError(new p(`Fragment cannot be spread here as objects of type "${s}" can never be of type "${i}".`,{nodes:t}))}},FragmentSpread(t){const e=t.name.value,r=hn(n,e),s=n.getParentType();if(r&&s&&!ne(n.getSchema(),r,s)){const i=y(s),o=y(r);n.reportError(new p(`Fragment "${e}" cannot be spread here as objects of type "${i}" can never be of type "${o}".`,{nodes:t}))}}}}function hn(n,t){const e=n.getFragment(t);if(e){const r=I(n.getSchema(),e.typeCondition);if(w(r))return r}}function In(n){return{...bn(n),Field:{leave(t){var e;const r=n.getFieldDef();if(!r)return!1;const s=new Set((e=t.arguments)===null||e===void 0?void 0:e.map(i=>i.name.value));for(const i of r.args)if(!s.has(i.name)&&de(i)){const o=y(i.type);n.reportError(new p(`Field "${r.name}" argument "${i.name}" of type "${o}" is required, but it was not provided.`,{nodes:t}))}}}}}function bn(n){var t;const e=Object.create(null),r=n.getSchema(),s=(t=r?.getDirectives())!==null&&t!==void 0?t:q;for(const a of s)e[a.name]=L(a.args.filter(de),l=>l.name);const i=n.getDocument().definitions;for(const a of i)if(a.kind===f.DIRECTIVE_DEFINITION){var o;const l=(o=a.arguments)!==null&&o!==void 0?o:[];e[a.name.value]=L(l.filter(Dn),u=>u.name.value)}return{Directive:{leave(a){const l=a.name.value,u=e[l];if(u){var c;const d=(c=a.arguments)!==null&&c!==void 0?c:[],m=new Set(d.map(g=>g.name.value));for(const[g,v]of Object.entries(u))if(!m.has(g)){const h=$e(v.type)?y(v.type):T(v.type);n.reportError(new p(`Directive "@${l}" argument "${g}" of type "${h}" is required, but it was not provided.`,{nodes:a}))}}}}}}function Dn(n){return n.type.kind===f.NON_NULL_TYPE&&n.defaultValue==null}function On(n){return{Field(t){const e=n.getType(),r=t.selectionSet;if(e)if(A(b(e))){if(r){const s=t.name.value,i=y(e);n.reportError(new p(`Field "${s}" must not have a selection since type "${i}" has no subfields.`,{nodes:r}))}}else if(r){if(r.selections.length===0){const s=t.name.value,i=y(e);n.reportError(new p(`Field "${s}" of type "${i}" must have at least one field selected.`,{nodes:t}))}}else{const s=t.name.value,i=y(e);n.reportError(new p(`Field "${s}" of type "${i}" must have a selection of subfields. Did you mean "${s} { ... }"?`,{nodes:t}))}}}}function Sn(n,t,e){var r;const s={},i=(r=t.arguments)!==null&&r!==void 0?r:[],o=L(i,a=>a.name.value);for(const a of n.args){const l=a.name,u=a.type,c=o[l];if(!c){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(E(u))throw new p(`Argument "${l}" of required type "${y(u)}" was not provided.`,{nodes:t});continue}const d=c.value;let m=d.kind===f.NULL;if(d.kind===f.VARIABLE){const v=d.name.value;if(e==null||!wn(e,v)){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(E(u))throw new p(`Argument "${l}" of required type "${y(u)}" was provided the variable "$${v}" which was not provided a runtime value.`,{nodes:d});continue}m=e[v]==null}if(m&&E(u))throw new p(`Argument "${l}" of non-null type "${y(u)}" must not be null.`,{nodes:d});const g=Re(d,u,e);if(g===void 0)throw new p(`Argument "${l}" has invalid value ${T(d)}.`,{nodes:d});s[l]=g}return s}function se(n,t,e){var r;const s=(r=t.directives)===null||r===void 0?void 0:r.find(i=>i.name.value===n.name);if(s)return Sn(n,s,e)}function wn(n,t){return Object.prototype.hasOwnProperty.call(n,t)}function _n(n,t,e,r,s){const i=new Map;return H(n,t,e,r,s,i,new Set),i}function H(n,t,e,r,s,i,o){for(const a of s.selections)switch(a.kind){case f.FIELD:{if(!Q(e,a))continue;const l=$n(a),u=i.get(l);u!==void 0?u.push(a):i.set(l,[a]);break}case f.INLINE_FRAGMENT:{if(!Q(e,a)||!ae(n,a,r))continue;H(n,t,e,r,a.selectionSet,i,o);break}case f.FRAGMENT_SPREAD:{const l=a.name.value;if(o.has(l)||!Q(e,a))continue;o.add(l);const u=t[l];if(!u||!ae(n,u,r))continue;H(n,t,e,r,u.selectionSet,i,o);break}}}function Q(n,t){const e=se(Fe,t,n);if(e?.if===!0)return!1;const r=se(Ve,t,n);return r?.if!==!1}function ae(n,t,e){const r=t.typeCondition;if(!r)return!0;const s=I(n,r);return s===e?!0:ce(s)?n.isSubType(s,e):!1}function $n(n){return n.alias?n.alias.value:n.name.value}function Rn(n){return{OperationDefinition(t){if(t.operation==="subscription"){const e=n.getSchema(),r=e.getSubscriptionType();if(r){const s=t.name?t.name.value:null,i=Object.create(null),o=n.getDocument(),a=Object.create(null);for(const u of o.definitions)u.kind===f.FRAGMENT_DEFINITION&&(a[u.name.value]=u);const l=_n(e,a,i,r,t.selectionSet);if(l.size>1){const d=[...l.values()].slice(1).flat();n.reportError(new p(s!=null?`Subscription "${s}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:d}))}for(const u of l.values())u[0].name.value.startsWith("__")&&n.reportError(new p(s!=null?`Subscription "${s}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:u}))}}}}}function De(n,t){const e=new Map;for(const r of n){const s=t(r),i=e.get(s);i===void 0?e.set(s,[r]):i.push(r)}return e}function Fn(n){return{Field:t,Directive:t};function t(e){var r;const s=(r=e.arguments)!==null&&r!==void 0?r:[],i=De(s,o=>o.name.value);for(const[o,a]of i)a.length>1&&n.reportError(new p(`There can be only one argument named "${o}".`,{nodes:a.map(l=>l.name)}))}}function Vn(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():q;for(const a of r)t[a.name]=!a.isRepeatable;const s=n.getDocument().definitions;for(const a of s)a.kind===f.DIRECTIVE_DEFINITION&&(t[a.name.value]=!a.repeatable);const i=Object.create(null),o=Object.create(null);return{enter(a){if(!("directives"in a)||!a.directives)return;let l;if(a.kind===f.SCHEMA_DEFINITION||a.kind===f.SCHEMA_EXTENSION)l=i;else if(ve(a)||Ye(a)){const u=a.name.value;l=o[u],l===void 0&&(o[u]=l=Object.create(null))}else l=Object.create(null);for(const u of a.directives){const c=u.name.value;t[c]&&(l[c]?n.reportError(new p(`The directive "@${c}" can only be used once at this location.`,{nodes:[l[c],u]})):l[c]=u)}}}}function Cn(n){const t=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(e){const r=e.name.value;return t[r]?n.reportError(new p(`There can be only one fragment named "${r}".`,{nodes:[t[r],e.name]})):t[r]=e.name,!1}}}function An(n){const t=[];let e=Object.create(null);return{ObjectValue:{enter(){t.push(e),e=Object.create(null)},leave(){const r=t.pop();r||O(!1),e=r}},ObjectField(r){const s=r.name.value;e[s]?n.reportError(new p(`There can be only one input field named "${s}".`,{nodes:[e[s],r.name]})):e[s]=r.name}}}function Ln(n){const t=Object.create(null);return{OperationDefinition(e){const r=e.name;return r&&(t[r.value]?n.reportError(new p(`There can be only one operation named "${r.value}".`,{nodes:[t[r.value],r]})):t[r.value]=r),!1},FragmentDefinition:()=>!1}}function kn(n){return{OperationDefinition(t){var e;const r=(e=t.variableDefinitions)!==null&&e!==void 0?e:[],s=De(r,i=>i.variable.name.value);for(const[i,o]of s)o.length>1&&n.reportError(new p(`There can be only one variable named "$${i}".`,{nodes:o.map(a=>a.variable.name)}))}}}function Un(n){let t={};return{OperationDefinition:{enter(){t={}}},VariableDefinition(e){t[e.variable.name.value]=e},ListValue(e){const r=Ae(n.getParentInputType());if(!F(r))return D(n,e),!1},ObjectValue(e){const r=b(n.getInputType());if(!k(r))return D(n,e),!1;const s=L(e.fields,i=>i.name.value);for(const i of Object.values(r.getFields()))if(!s[i.name]&&Ce(i)){const a=y(i.type);n.reportError(new p(`Field "${r.name}.${i.name}" of required type "${a}" was not provided.`,{nodes:e}))}r.isOneOf&&jn(n,e,r,s,t)},ObjectField(e){const r=b(n.getParentInputType());if(!n.getInputType()&&k(r)){const i=_(e.name.value,Object.keys(r.getFields()));n.reportError(new p(`Field "${e.name.value}" is not defined by type "${r.name}".`+S(i),{nodes:e}))}},NullValue(e){const r=n.getInputType();E(r)&&n.reportError(new p(`Expected value of type "${y(r)}", found ${T(e)}.`,{nodes:e}))},EnumValue:e=>D(n,e),IntValue:e=>D(n,e),FloatValue:e=>D(n,e),StringValue:e=>D(n,e),BooleanValue:e=>D(n,e)}}function D(n,t){const e=n.getInputType();if(!e)return;const r=b(e);if(!A(r)){const s=y(e);n.reportError(new p(`Expected value of type "${s}", found ${T(t)}.`,{nodes:t}));return}try{if(r.parseLiteral(t,void 0)===void 0){const i=y(e);n.reportError(new p(`Expected value of type "${i}", found ${T(t)}.`,{nodes:t}))}}catch(s){const i=y(e);s instanceof p?n.reportError(s):n.reportError(new p(`Expected value of type "${i}", found ${T(t)}; `+s.message,{nodes:t,originalError:s}))}}function jn(n,t,e,r,s){var i;const o=Object.keys(r);if(o.length!==1){n.reportError(new p(`OneOf Input Object "${e.name}" must specify exactly one key.`,{nodes:[t]}));return}const l=(i=r[o[0]])===null||i===void 0?void 0:i.value,u=!l||l.kind===f.NULL,c=l?.kind===f.VARIABLE;if(u){n.reportError(new p(`Field "${e.name}.${o[0]}" must be non-null.`,{nodes:[t]}));return}if(c){const d=l.name.value;s[d].type.kind!==f.NON_NULL_TYPE&&n.reportError(new p(`Variable "${d}" must be non-nullable to be used for OneOf Input Object "${e.name}".`,{nodes:[t]}))}}function Mn(n){return{VariableDefinition(t){const e=I(n.getSchema(),t.type);if(e!==void 0&&!Le(e)){const r=t.variable.name.value,s=T(t.type);n.reportError(new p(`Variable "$${r}" cannot be non-input type "${s}".`,{nodes:t.type}))}}}}function Pn(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s,type:i,defaultValue:o,parentType:a}of r){const l=s.name.value,u=t[l];if(u&&i){const c=n.getSchema(),d=I(c,u.type);if(d&&!Gn(c,d,u.defaultValue,i,o)){const m=y(d),g=y(i);n.reportError(new p(`Variable "$${l}" of type "${m}" used in position expecting type "${g}".`,{nodes:[u,s]}))}k(a)&&a.isOneOf&&ke(d)&&n.reportError(new p(`Variable "$${l}" is of type "${d}" but must be non-nullable to be used for OneOf Input Object "${a}".`,{nodes:[u,s]}))}}}},VariableDefinition(e){t[e.variable.name.value]=e}}}function Gn(n,t,e,r,s){if(E(r)&&!E(t)){if(!(e!=null&&e.kind!==f.NULL)&&!(s!==void 0))return!1;const a=r.ofType;return te(n,t,a)}return te(n,t,r)}const qn=Object.freeze([ln]),Oe=Object.freeze([Ne,Ln,an,Rn,rn,Ke,Mn,On,Xe,Cn,tn,Te,En,un,kn,cn,fn,xe,Vn,ze,Fn,Un,In,Pn,pn,An,...qn]);class Yn{constructor(t,e){this._ast=t,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=e}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(t){this._onError(t)}getDocument(){return this._ast}getFragment(t){let e;if(this._fragments)e=this._fragments;else{e=Object.create(null);for(const r of this.getDocument().definitions)r.kind===f.FRAGMENT_DEFINITION&&(e[r.name.value]=r);this._fragments=e}return e[t]}getFragmentSpreads(t){let e=this._fragmentSpreads.get(t);if(!e){e=[];const r=[t];let s;for(;s=r.pop();)for(const i of s.selections)i.kind===f.FRAGMENT_SPREAD?e.push(i):i.selectionSet&&r.push(i.selectionSet);this._fragmentSpreads.set(t,e)}return e}getRecursivelyReferencedFragments(t){let e=this._recursivelyReferencedFragments.get(t);if(!e){e=[];const r=Object.create(null),s=[t.selectionSet];let i;for(;i=s.pop();)for(const o of this.getFragmentSpreads(i)){const a=o.name.value;if(r[a]!==!0){r[a]=!0;const l=this.getFragment(a);l&&(e.push(l),s.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(t,e)}return e}}class Bn extends Yn{constructor(t,e,r,s){super(e,s),this._schema=t,this._typeInfo=r,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(t){let e=this._variableUsages.get(t);if(!e){const r=[],s=new pe(this._schema);ye(t,me(s,{VariableDefinition:()=>!1,Variable(i){r.push({node:i,type:s.getInputType(),defaultValue:s.getDefaultValue(),parentType:s.getParentInputType()})}})),e=r,this._variableUsages.set(t,e)}return e}getRecursiveVariableUsages(t){let e=this._recursiveVariableUsages.get(t);if(!e){e=this.getVariableUsages(t);for(const r of this.getRecursivelyReferencedFragments(t))e=e.concat(this.getVariableUsages(r));this._recursiveVariableUsages.set(t,e)}return e}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Se(n,t,e=Oe,r,s=new pe(n)){var i;const o=(i=void 0)!==null&&i!==void 0?i:100;t||Be(!1,"Must provide document."),Ue(n);const a=Object.freeze({}),l=[],u=new Bn(n,t,s,d=>{if(l.length>=o)throw l.push(new p("Too many validation errors, error limit reached. Validation aborted.")),a;l.push(d)}),c=Qe(e.map(d=>d(u)));try{ye(t,me(s,c))}catch(d){if(d!==a)throw d}return l}function Qn(n){return{Field(t){const e=n.getFieldDef(),r=e?.deprecationReason;if(e&&r!=null){const s=n.getParentType();s!=null||O(!1),n.reportError(new p(`The field ${s.name}.${e.name} is deprecated. ${r}`,{nodes:t}))}},Argument(t){const e=n.getArgument(),r=e?.deprecationReason;if(e&&r!=null){const s=n.getDirective();if(s!=null)n.reportError(new p(`Directive "@${s.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}));else{const i=n.getParentType(),o=n.getFieldDef();i!=null&&o!=null||O(!1),n.reportError(new p(`Field "${i.name}.${o.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}))}}},ObjectField(t){const e=b(n.getParentInputType());if(k(e)){const r=e.getFields()[t.name.value],s=r?.deprecationReason;s!=null&&n.reportError(new p(`The input field ${e.name}.${r.name} is deprecated. ${s}`,{nodes:t}))}},EnumValue(t){const e=n.getEnumValue(),r=e?.deprecationReason;if(e&&r!=null){const s=b(n.getInputType());s!=null||O(!1),n.reportError(new p(`The enum value "${s.name}.${e.name}" is deprecated. ${r}`,{nodes:t}))}}}}function Wn(n,t,e,r,s){const i=Oe.filter(a=>!(a===Te||a===Ne));return e&&Array.prototype.push.apply(i,e),Se(n,t,i).filter(a=>{if(a.message.includes("Unknown directive")&&a.nodes){const l=a.nodes[0];if(l&&l.kind===f.DIRECTIVE){const u=l.name.value;if(u==="arguments"||u==="argumentDefinitions")return!1}}return!0})}const oe={Error:"Error",Warning:"Warning"},J={[oe.Error]:1,[oe.Warning]:2},G=(n,t)=>{if(!n)throw new Error(t)};function Xn(n,t=null,e,r,s){var i,o;let a=null,l="";s&&(l=typeof s=="string"?s:s.reduce((c,d)=>c+T(d)+`

`,""));const u=l?`${n}

${l}`:n;try{a=We(u)}catch(c){if(c instanceof p){const d=Jn((o=(i=c.locations)===null||i===void 0?void 0:i[0])!==null&&o!==void 0?o:{line:0},u);return[{severity:J.Error,message:c.message,source:"GraphQL: Syntax",range:d}]}throw c}return Hn(a,t,e)}function Hn(n,t=null,e,r){if(!t)return[];const s=Wn(t,n,e).flatMap(o=>le(o,J.Error,"Validation")),i=Se(t,n,[Qn]).flatMap(o=>le(o,J.Warning,"Deprecation"));return s.concat(i)}function le(n,t,e){if(!n.nodes)return[];const r=[];for(const[s,i]of n.nodes.entries()){const o=i.kind!=="Variable"&&"name"in i&&i.name!==void 0?i.name:"variable"in i&&i.variable!==void 0?i.variable:i;if(o){G(n.locations,"GraphQL validation error requires locations.");const a=n.locations[s],l=Kn(o),u=a.column+(l.end-l.start);r.push({source:`GraphQL: ${e}`,message:n.message,severity:t,range:new ge(new U(a.line-1,a.column-1),new U(a.line-1,u))})}}return r}function Jn(n,t){const e=je(),r=e.startState(),s=t.split(`
`);G(s.length>=n.line,"Query text must have more lines than where the error happened");let i=null;for(let u=0;u<n.line;u++)for(i=new Me(s[u]);!i.eol()&&e.token(i,r)!=="invalidchar";);G(i,"Expected Parser stream to be available.");const o=n.line-1,a=i.getStartOfToken(),l=i.getCurrentPosition();return new ge(new U(o,a),new U(o,l))}function Kn(n){const e=n.loc;return G(e,"Expected ASTNode to have a location."),e}const ue=["error","warning","information","hint"],zn={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};Y.registerHelper("lint","graphql",(n,t)=>{const{schema:e,validationRules:r,externalFragments:s}=t;return Xn(n,e,r,void 0,s).map(a=>({message:a.message,severity:a.severity?ue[a.severity-1]:ue[0],type:a.source?zn[a.source]:void 0,from:Y.Pos(a.range.start.line,a.range.start.character),to:Y.Pos(a.range.end.line,a.range.end.character)}))});
