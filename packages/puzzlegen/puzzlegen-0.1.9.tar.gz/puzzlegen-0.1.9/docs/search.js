window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "puzzlegen", "modulename": "puzzlegen", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core", "modulename": "puzzlegen.core", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator", "modulename": "puzzlegen.core.batch_generator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.logger", "modulename": "puzzlegen.core.batch_generator", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger puzzlegen.core.batch_generator (INFO)&gt;"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator", "kind": "class", "doc": "<p>Generate and manage batches of puzzles by iterating over ranges of parameters.</p>\n\n<p>This class systematically generates puzzles for each integer value within the given\nranges of block counts and color counts. For each combination, it attempts to generate\npuzzles solvable within the specified move limit.</p>\n\n<p>It provides functionality to:</p>\n\n<ul>\n<li>Filter out puzzles unsolvable within the move constraints.</li>\n<li>Collect statistics about solvable and unsolvable puzzles across the batch.</li>\n<li>Export puzzles visually as PDFs and metadata as CSV files.</li>\n<li>Display summary charts (bar and pie) to analyze batch characteristics.</li>\n</ul>\n\n<p>Args:</p>\n\n<pre><code>blocks_range (tuple[int, int]): Inclusive range of block counts to iterate through (min_blocks, max_blocks).\n\ncolors_range (tuple[int, int]): Inclusive range of color counts to iterate through (min_colors, max_colors).\n\ncolors_blocks (list[str]): List of available colors for blocks.\n\nnb_moves (int): Maximum number of moves allowed for the optimal solution.\n\nbatch_grid_size (tuple[int, int]): Grid size for each puzzle as (rows, columns).\n\nbatch_stack_probability (float): Probability to stack blocks vertically during puzzle generation.\n\nblocks_gap (int, optional): Maximum allowed gap between blocks during generation (e.g., 1 means at most one empty cell). Default is 1.\n</code></pre>\n\n<p>Attributes:</p>\n\n<pre><code>puzzle_batch (dict[int, list]): Dictionary mapping move counts to lists of generated puzzles.\n\nnb_solvables (int): Number of puzzles solvable within the move limit.\n\nnb_unsolvables (int): Number of puzzles not solvable within the move limit.\n\nstats (dict[str, int]):  \n    Counts of puzzles solvable in 1 up to `nb_moves` moves.  \n    Keys are of the form 'solvable_in_X_moves' mapping to counts.  \n    Example: {'solvable_in_1_moves': 3, 'solvable_in_2_moves': 4, ...}\n\ncsv_data (dict): Data formatted for CSV export.\n</code></pre>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.__init__", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">blocks_range</span>,</span><span class=\"param\">\t<span class=\"n\">colors_range</span>,</span><span class=\"param\">\t<span class=\"n\">colors_blocks</span>,</span><span class=\"param\">\t<span class=\"n\">nb_moves</span>,</span><span class=\"param\">\t<span class=\"n\">batch_grid_size</span>,</span><span class=\"param\">\t<span class=\"n\">nb_attempts</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">batch_stack_probability</span><span class=\"o\">=</span><span class=\"mf\">0.75</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_gap</span><span class=\"o\">=</span><span class=\"mi\">1</span></span>)</span>"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.blocks_range", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.blocks_range", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.colors_range", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.colors_range", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.colors", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.colors", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.nb_moves", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.nb_moves", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.puzzle_batch", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.puzzle_batch", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.nb_solvables", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.nb_solvables", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.nb_unsolvables", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.nb_unsolvables", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.stats", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.stats", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.csv_data", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.csv_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.batch_grid_size", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.batch_grid_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.nb_attempts", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.nb_attempts", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.batch_stack_probability", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.batch_stack_probability", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.blocks_gap", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.blocks_gap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.generate_puzzles", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.generate_puzzles", "kind": "function", "doc": "<p>Generate puzzles for all combinations of block and color counts within the specified ranges.</p>\n\n<p>For each combination:</p>\n\n<ul>\n<li>Attempts up to <code>nb_attempts</code> times to create a puzzle solvable within <code>nb_moves</code>.</li>\n<li>Stores solvable puzzles grouped by the number of moves required to solve.</li>\n<li>Updates statistics and prepares data for CSV export.</li>\n</ul>\n\n<p>Returns:\n    dict: Dictionary of generated puzzles grouped by move counts, \n        keys formatted as 'solvable_in_X_moves'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.print_and_save_batch", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.print_and_save_batch", "kind": "function", "doc": "<p>Print and save all generated puzzles as a PDF file.</p>\n\n<ul>\n<li>Visualizes each puzzle's solution history.</li>\n<li>Saves all figures to a single PDF.</li>\n<li>Also displays summary charts (bar and pie).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.save_multi_image", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.save_multi_image", "kind": "function", "doc": "<p>Save all open matplotlib figures to a single PDF file.</p>\n\n<p>Args:\n    filename (str): Name of the PDF file to save.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.compute_stats", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.compute_stats", "kind": "function", "doc": "<p>Compute and update statistics for the generated puzzle batch.</p>\n\n<p>Populates the <code>stats</code> attribute with counts of puzzles solvable in each number of moves.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.set_batch", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.set_batch", "kind": "function", "doc": "<p>Set the current batch of puzzles manually.</p>\n\n<p>Args:\n    batch (dict): Dictionary of puzzles grouped by move count.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">batch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.print_charts", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.print_charts", "kind": "function", "doc": "<p>Display bar and pie charts summarizing the batch statistics.</p>\n\n<p>Args:\n    show (bool): If True, display the charts.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">show</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.save_results_as_csv", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.save_results_as_csv", "kind": "function", "doc": "<p>Save the batch data as a CSV file.</p>\n\n<p>The CSV contains, for each puzzle:</p>\n\n<ul>\n<li>Number of blocks</li>\n<li>Colors used</li>\n<li>Initial block positions</li>\n<li>Number of moves to solve</li>\n</ul>\n\n<p>Args:\n    filename (str, optional): CSV filename. Defaults to a timestamped filename.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.batch_generator.PuzzleBatchGenerator.save_file", "modulename": "puzzlegen.core.batch_generator", "qualname": "PuzzleBatchGenerator.save_file", "kind": "function", "doc": "<p>Save or provide a download link for the file depending on the execution environment.</p>\n\n<p>Supports:</p>\n\n<ul>\n<li>Google Colab: triggers browser download.</li>\n<li>Jupyter Notebook/Lab: shows a clickable download link.</li>\n<li>Script or other environments: saves file in 'outputs' directory.</li>\n</ul>\n\n<p>Args:\n    filename (str): Name of the file to save or offer for download.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.bfs_solver", "modulename": "puzzlegen.core.bfs_solver", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.bfs_solver.logger", "modulename": "puzzlegen.core.bfs_solver", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger puzzlegen.core.bfs_solver (INFO)&gt;"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver", "kind": "class", "doc": "<p>A solver that uses Breadth-First Search (BFS) to explore possible move sequences \nand determine whether a puzzle configuration can be solved.</p>\n\n<p>This class delegates puzzle-specific logic (gravity, move execution, match detection) \nto external components provided via <code>grid_initializer</code> and <code>puzzle_logic</code>.</p>\n"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.__init__", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.__init__", "kind": "function", "doc": "<p>Initialize the BFSSolver with a grid and puzzle logic instance.</p>\n\n<p>Args:</p>\n\n<pre><code>grid_initializer (GridInitializer): Handles initial puzzle setup and parameters.\n\npuzzle_logic (PuzzleLogic): Provides core puzzle mechanics (moves, gravity, match detection).\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid_initializer</span>, </span><span class=\"param\"><span class=\"n\">puzzle_logic</span></span>)</span>"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.grid_initializer", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.grid_initializer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.puzzle_logic", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.puzzle_logic", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.perform_all_blocks_moves", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.perform_all_blocks_moves", "kind": "function", "doc": "<p>Attempt to solve the puzzle using Breadth-First Search (BFS) within a limited number of moves.</p>\n\n<p>This function explores all possible sequences of valid block moves (simple or exchange)\nusing a BFS strategy to determine whether the current puzzle configuration can be solved\nin <code>min_nb_moves</code> steps or fewer.</p>\n\n<p>It starts from the initial grid state and simulates possible actions at each round. Each node \nin the search tree tracks the history of block positions, moves performed, and puzzle states.\nThe exploration stops when either a solution is found or the search depth exceeds the allowed limit.</p>\n\n<p>Args:</p>\n\n<pre><code>display_progress (bool): Whether to show a progress bar during the search.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>tuple:\n    - is_solvable (bool): True if a valid solution is found within the move limit, False otherwise.\n    - solution (dict): A dictionary containing the move history and block states leading to the solution,\n                    or an empty dict if no solution was found.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">display_progress</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.process_possible_moves", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.process_possible_moves", "kind": "function", "doc": "<p>Explore and enqueue all valid moves from the current puzzle state in the BFS process.</p>\n\n<p>For each block in the current grid state, this method checks all possible move types \n(simple moves and exchanges to the left and right). For each valid move:</p>\n\n<ul>\n<li>The move is applied to a copy of the current block set.</li>\n<li>Gravity and match elimination are applied to the updated grid.</li>\n<li>The new state is evaluated and stored in a new BFS node.</li>\n<li>This new node is appended to the BFS queue for further exploration.</li>\n</ul>\n\n<p>If a terminal game state is reached (e.g., state == 3), a solution is extracted and returned immediately.</p>\n\n<p>Args:</p>\n\n<pre><code>set_blocks (dict): Dictionary of current block positions and Block objects.\n\ncurrent_item (dict): Current BFS node containing history of previous states and moves.\n\ncurrent_round (int): The current depth (round) in the BFS search tree.\n\ngrid_size (tuple): Tuple indicating grid dimensions (rows, columns).\n\ncolors (list): List of allowed block colors.\n\nqueue (deque): The BFS queue, to which new valid states will be appended.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>tuple:\n    - is_solvable (bool): True if a solution is found in this branch, False otherwise.\n    - solution (dict): Dictionary containing the history of moves and states leading to the solution,\n                    or an empty dict if no solution is found at this level.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">set_blocks</span>,</span><span class=\"param\">\t<span class=\"n\">current_item</span>,</span><span class=\"param\">\t<span class=\"n\">current_round</span>,</span><span class=\"param\">\t<span class=\"n\">grid_size</span>,</span><span class=\"param\">\t<span class=\"n\">colors</span>,</span><span class=\"param\">\t<span class=\"n\">queue</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.process_solution", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.process_solution", "kind": "function", "doc": "<p>Finalize and return the solution after the puzzle is solved.</p>\n\n<p>This function adds empty entries to the move history to mark the end,\nprints the solution path, and returns it.</p>\n\n<p>Args:</p>\n\n<pre><code>solved_puzzle_dict (dict): Contains the steps that led to the solution.\n\ncurrent_round (int): Number of moves it took to solve the puzzle.\n</code></pre>\n\n<p>Returns:\n    dict: The completed solution dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">solved_puzzle_dict</span>, </span><span class=\"param\"><span class=\"n\">current_round</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.print_history", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.print_history", "kind": "function", "doc": "<p>Visualize the full sequence of moves that solved the puzzle.</p>\n\n<p>This function creates a series of side-by-side grid plots, one for each step\nin the solution. It highlights moved blocks and shows arrows indicating moves.\nThe initial and final grid states are labeled clearly.</p>\n\n<p>Args:</p>\n\n<pre><code>solved_puzzle_dict (dict): Dictionary containing the history of grid states,\n                        moves, and block positions from the solver.\n\ngrid_size (tuple): Size of the puzzle grid (rows, columns).\n\nshow (bool): If True, the plot is displayed using matplotlib.\n\nax (matplotlib.axes.Axes, optional): Optional axis to plot on (useful for embedding).\n</code></pre>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">solved_puzzle_dict</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span>, </span><span class=\"param\"><span class=\"n\">show</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">max_cols</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.highlight_moved_block", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.highlight_moved_block", "kind": "function", "doc": "<p>Visually highlight the block that was moved by drawing a lime-colored border around it.</p>\n\n<p>Args:</p>\n\n<pre><code>position (tuple): (row, col) coordinates of the moved block.\n\nax (matplotlib.axes.Axes): The matplotlib axis on which to draw.\n\ngrid (list): 2D list representing the grid colors.\n\ngrid_size (tuple): Size of the grid (rows, columns).\n</code></pre>\n\n<p>Returns:\n    tuple: (ax, grid) \u2014 The updated axis and grid, unchanged except for visualization.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.draw_arrow", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.draw_arrow", "kind": "function", "doc": "<p>Draw an arrow on the plot to indicate the direction of a block\u2019s move.</p>\n\n<p>Args:</p>\n\n<pre><code>position (tuple): (row, col) coordinates of the moved block.\n\nmove_type (str): Type of move performed (e.g., 'move_left', 'exchange_right').\n\nax (matplotlib.axes.Axes): The matplotlib axis on which to draw the arrow.\n\ngrid (list): 2D list representing the grid colors.\n\ngrid_size (tuple): Size of the grid (rows, columns).\n</code></pre>\n\n<p>Returns:\n    tuple: (ax, grid) \u2014 The updated axis and grid, with the arrow added for visualization.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">move_type</span>, </span><span class=\"param\"><span class=\"n\">ax</span>, </span><span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.bfs_solver.BFSSolver.create_fancy_arrow_patch", "modulename": "puzzlegen.core.bfs_solver", "qualname": "BFSSolver.create_fancy_arrow_patch", "kind": "function", "doc": "<p>Create a FancyArrowPatch for move visualization.</p>\n\n<p>Args:</p>\n\n<pre><code>arrow_pos_col (int): Column of the arrow start.\n\narrow_pos_row (int): Row of the arrow start.\n\nmove_type (str): Type of move.\n\nlinecol (str): Color of the arrow.\n\ngrid_size (tuple): Size of the grid.\n</code></pre>\n\n<p>Returns:\n    FancyArrowPatch: The arrow patch object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arrow_pos_col</span>, </span><span class=\"param\"><span class=\"n\">arrow_pos_row</span>, </span><span class=\"param\"><span class=\"n\">move_type</span>, </span><span class=\"param\"><span class=\"n\">linecol</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.block", "modulename": "puzzlegen.core.block", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.block.Block", "modulename": "puzzlegen.core.block", "qualname": "Block", "kind": "class", "doc": "<p>Block Class: This class represents the individual blocks on the game board. It contains the color of the block and methods to set and get the color.</p>\n"}, {"fullname": "puzzlegen.core.block.Block.__init__", "modulename": "puzzlegen.core.block", "qualname": "Block.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">color</span></span>)</span>"}, {"fullname": "puzzlegen.core.block.Block.color", "modulename": "puzzlegen.core.block", "qualname": "Block.color", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.block.Block.set_color", "modulename": "puzzlegen.core.block", "qualname": "Block.set_color", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">color</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.block.Block.get_color", "modulename": "puzzlegen.core.block", "qualname": "Block.get_color", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer", "modulename": "puzzlegen.core.grid_initializer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer", "kind": "class", "doc": "<p>GridInitializer Class: This class is responsible for handling the setup of the game board, including generating the initial configuration of blocks.</p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.__init__", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.__init__", "kind": "function", "doc": "<p>Initialize the GridInitializer.</p>\n\n<p>Args:</p>\n\n<pre><code>grid_size (tuple): Size of the grid as (rows, columns).\n\nnb_blocks (int): Number of blocks to place.\n\ncolors (list): List of block colors.\n\nmin_nb_moves (int): Maximum number of moves allowed for the optimal solution.\n\nstack_probability (float): Probability of stacking blocks.\n\nblocks_gap (int, optional): Maximum allowed gap between blocks during generation (e.g., 1 means at most one empty cell). Default is 1.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">grid_size</span>,</span><span class=\"param\">\t<span class=\"n\">nb_blocks</span>,</span><span class=\"param\">\t<span class=\"n\">colors</span>,</span><span class=\"param\">\t<span class=\"n\">min_nb_moves</span>,</span><span class=\"param\">\t<span class=\"n\">stack_probability</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_gap</span></span>)</span>"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.grid_size", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.grid_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.nb_blocks", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.nb_blocks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.colors", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.colors", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.set_blocks", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.set_blocks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.min_nb_moves", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.min_nb_moves", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.stack_probability", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.stack_probability", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.blocks_gap", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.blocks_gap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.is_valid_position", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.is_valid_position", "kind": "function", "doc": "<p>Check if a position is within the grid bounds.</p>\n\n<p>Args:</p>\n\n<pre><code>row (int): Row index.\n\ncol (int): Column index.\n</code></pre>\n\n<p>Returns:\n    bool: True if position is valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">row</span>, </span><span class=\"param\"><span class=\"n\">col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.is_block_present", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.is_block_present", "kind": "function", "doc": "<p>Check if a block is present at the given position.</p>\n\n<p>Args:</p>\n\n<pre><code>row (int): Row index.\n\ncol (int): Column index.\n</code></pre>\n\n<p>Returns:\n    list: [True, color] if block is present, [False, None] otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">row</span>, </span><span class=\"param\"><span class=\"n\">col</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.is_similar_block", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.is_similar_block", "kind": "function", "doc": "<p>Check if a block of the same color is present at the given position.</p>\n\n<p>Args:</p>\n\n<pre><code>row (int): Row index.\n\ncol (int): Column index.\n\ncolor (str): Color to check.\n</code></pre>\n\n<p>Returns:\n    bool: True if a similar block is present, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">row</span>, </span><span class=\"param\"><span class=\"n\">col</span>, </span><span class=\"param\"><span class=\"n\">color</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.check_valid_placement", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.check_valid_placement", "kind": "function", "doc": "<p>Check if placing a block at the given position is valid according to the rules (no matches are allowed during initial setup).</p>\n\n<p>Args:</p>\n\n<pre><code>row (int): Row index.\n\ncol (int): Column index.\n\ncolor (str): Color of the block.\n</code></pre>\n\n<p>Returns:\n    bool: True if placement is valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">row</span>, </span><span class=\"param\"><span class=\"n\">col</span>, </span><span class=\"param\"><span class=\"n\">color</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.get_highest_positions", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.get_highest_positions", "kind": "function", "doc": "<p>Get the highest (topmost) block positions for each column.</p>\n\n<p>Returns:\n    list: List of (row, col) tuples representing the highest block in each column.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.select_random_highest_position", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.select_random_highest_position", "kind": "function", "doc": "<p>Select a random position above the highest block in a random column or return an empty position with a gap.</p>\n\n<p>Returns:\n    tuple: (row, col) position above a random highest block, or an empty position with gap if none found.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.get_empty_positions_with_gap", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.get_empty_positions_with_gap", "kind": "function", "doc": "<p>Get empty positions in the bottomost row that respect the minimum gap between blocks.</p>\n\n<p>Returns:\n    list: List of (row, col) tuples for valid empty positions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.select_empty_positions_with_gap", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.select_empty_positions_with_gap", "kind": "function", "doc": "<p>Select a random empty position in the last row that respects the minimum gap.</p>\n\n<p>Returns:\n    tuple: (row, col) position.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.initialize_grid", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.initialize_grid", "kind": "function", "doc": "<p>Initialize the grid with blocks according to the rules and constraints.</p>\n\n<p>The method performs the following steps:</p>\n\n<ul>\n<li>Determines the number of blocks to place per color using <code>assign_blocks_per_color</code>.</li>\n<li>Creates a list of blocks to place, respecting the color distribution.</li>\n<li>Iteratively places each block in the grid, either stacking on existing blocks or\nplacing in empty positions that respect minimum spacing (gap) constraints.</li>\n<li>The first block is placed near the center top of the grid.</li>\n<li>For subsequent blocks, the placement is either stacked on top of existing blocks (with a\nprobability defined by <code>stack_probability</code>) or placed in valid empty positions.</li>\n<li>Each potential placement is validated by <code>check_valid_placement</code> to avoid rule violations (e.g., no immediate matches).</li>\n<li>Once placed, blocks are recorded in <code>self.set_blocks</code> with their positions as keys.</li>\n<li>Finally, <code>self.set_blocks</code> is sorted by row to maintain a consistent order.</li>\n</ul>\n\n<p>This process ensures the initial puzzle grid respects the game's placement rules\nand sets up a valid starting configuration for the puzzle.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.change_set_blocks", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.change_set_blocks", "kind": "function", "doc": "<p>Change the current set of blocks to a new configuration.</p>\n\n<p>Args:\n    set_blocks (dict): New set of blocks.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.init_graphical_grid", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.init_graphical_grid", "kind": "function", "doc": "<p>Create a graphical representation of the puzzle grid using matplotlib.</p>\n\n<p>This method builds a 2D color grid from the set of placed blocks, then draws it using \nmatplotlib by rendering each cell as a colored rectangle. The Y-axis is flipped so that \nrow 0 appears at the bottom, consistent with a bottom-up grid orientation.</p>\n\n<p>Args:</p>\n\n<pre><code>set_blocks (dict): Dictionary mapping (row, col) positions to Block objects. Each block\n                    contains a `color` attribute used for rendering.\n\ngrid_size (tuple): A (rows, columns) tuple indicating the dimensions of the grid.\n</code></pre>\n\n<p>Returns:</p>\n\n<pre><code>tuple: (fig, ax, grid)\n    - fig (matplotlib.figure.Figure): The matplotlib figure object.\n    - ax (matplotlib.axes.Axes): The matplotlib axis with rendered grid.\n    - grid (list of lists): 2D list of cell colors representing the grid state.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.grid_initializer.GridInitializer.print_initial_grid", "modulename": "puzzlegen.core.grid_initializer", "qualname": "GridInitializer.print_initial_grid", "kind": "function", "doc": "<p>Print and display the initial grid using matplotlib.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic", "modulename": "puzzlegen.core.puzzle_logic", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic", "kind": "class", "doc": "<p>PuzzleLogic Class: Contains methods responsible for the game's core logic.\nThis includes checking for block elimination, enforcing gravity rules (making blocks fall down after elimination),\nand performing player moves (e.g., swapping two adjacent blocks).</p>\n"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.__init__", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.__init__", "kind": "function", "doc": "<p>Initialize the PuzzleLogic class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.check_all_available_moves", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.check_all_available_moves", "kind": "function", "doc": "<p>Check all possible moves for a block at the given position.</p>\n\n<p>Args:\n    current_position (tuple): (row, col) position of the block.\n    color (str): Color of the block.\n    set_blocks (dict): Current set of blocks.\n    grid_size (tuple): Size of the grid.</p>\n\n<p>Returns:\n    dict: Dictionary with possible moves as keys and booleans as values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">current_position</span>, </span><span class=\"param\"><span class=\"n\">color</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.can_move_left", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.can_move_left", "kind": "function", "doc": "<p>Check if a block can move left to an unoccupied space.</p>\n\n<p>Args:\n    position (tuple): (row, col) position of the block.\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    bool: True if the block can move left, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.can_move_right", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.can_move_right", "kind": "function", "doc": "<p>Check if a block can move right to an unoccupied space.</p>\n\n<p>Args:\n    position (tuple): (row, col) position of the block.\n    set_blocks (dict): Current set of blocks.\n    grid_size (tuple): Size of the grid.</p>\n\n<p>Returns:\n    bool: True if the block can move right, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.can_exchange_left", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.can_exchange_left", "kind": "function", "doc": "<p>Check if a block can exchange with the block to its left.</p>\n\n<p>Args:\n    position (tuple): (row, col) position of the block.\n    color (str): Color of the block.\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    bool: True if the block can exchange left, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">color</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.can_exchange_right", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.can_exchange_right", "kind": "function", "doc": "<p>Check if a block can exchange with the block to its right.</p>\n\n<p>Args:\n    position (tuple): (row, col) position of the block.\n    color (str): Color of the block.\n    set_blocks (dict): Current set of blocks.\n    grid_size (tuple): Size of the grid.</p>\n\n<p>Returns:\n    bool: True if the block can exchange right, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">color</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.update_block", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.update_block", "kind": "function", "doc": "<p>Update the position of a block in the set_blocks dictionary.</p>\n\n<p>Args:\n    old_position (tuple): Previous (row, col) position.\n    new_position (tuple): New (row, col) position.\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    dict: Updated set_blocks dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">old_position</span>, </span><span class=\"param\"><span class=\"n\">new_position</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.exchange_block", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.exchange_block", "kind": "function", "doc": "<p>Exchange two blocks in the set_blocks dictionary.</p>\n\n<p>Args:\n    first_position (tuple): (row, col) of the first block.\n    second_position (tuple): (row, col) of the second block.\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    dict: Updated set_blocks dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">first_position</span>, </span><span class=\"param\"><span class=\"n\">second_position</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.has_matches", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.has_matches", "kind": "function", "doc": "<p>Check if there are any matches (3 or more aligned blocks of the same color).</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    bool: True if matches exist, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.find_matches", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.find_matches", "kind": "function", "doc": "<p>Find all matches (3 or more aligned blocks of the same color).</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    set: Set of positions where matches are found.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.find_matches_by_rows", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.find_matches_by_rows", "kind": "function", "doc": "<p>Find all horizontal matches in the set_blocks.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    set: Set of positions where horizontal matches are found.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.find_matches_by_columns", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.find_matches_by_columns", "kind": "function", "doc": "<p>Find all vertical matches in the set_blocks.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    set: Set of positions where vertical matches are found.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.find_matches_in_iterator", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.find_matches_in_iterator", "kind": "function", "doc": "<p>Helper function to find matches in an iterator (row or column).</p>\n\n<p>Args:\n    set_blocks (iterator): Iterator over set_blocks items.\n    is_same_row (bool): True for row, False for column.</p>\n\n<p>Returns:\n    set: Set of positions where matches are found.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">is_same_row</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.delete_matches", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.delete_matches", "kind": "function", "doc": "<p>Delete all matched blocks from the set_blocks.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.\n    matches (set): Set of positions to delete.</p>\n\n<p>Returns:\n    dict: Updated set_blocks dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">matches</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.is_aligned", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.is_aligned", "kind": "function", "doc": "<p>Check if two blocks are aligned and of the same color.</p>\n\n<p>Args:\n    position (tuple): (row, col) of the first block.\n    next_position (tuple): (row, col) of the second block.\n    block (Block): First block.\n    next_block (Block): Second block.\n    is_same_row (bool): True for row, False for column.</p>\n\n<p>Returns:\n    bool: True if aligned and same color, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">next_position</span>, </span><span class=\"param\"><span class=\"n\">block</span>, </span><span class=\"param\"><span class=\"n\">next_block</span>, </span><span class=\"param\"><span class=\"n\">is_same_row</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.has_gravity", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.has_gravity", "kind": "function", "doc": "<p>Check if any block can fall due to gravity.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.\n    grid_size (tuple): Size of the grid.</p>\n\n<p>Returns:\n    bool: True if gravity applies, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.apply_gravity", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.apply_gravity", "kind": "function", "doc": "<p>Apply gravity to all blocks (make unsupported blocks fall).</p>\n\n<p>For each block in the grid (processed from bottom to top), this function checks whether\nthere is empty space directly beneath it. If so, it allows the block to fall vertically \nuntil it lands on either another block or the bottom of the grid.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.\n    grid_size (tuple): Size of the grid.</p>\n\n<p>Returns:\n    dict: Updated set_blocks dictionary after gravity.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.apply_gravity_and_eliminate_matches", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.apply_gravity_and_eliminate_matches", "kind": "function", "doc": "<p>Apply gravity and eliminate matches repeatedly until stable.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.\n    grid_size (tuple): Size of the grid.</p>\n\n<p>Returns:\n    dict: Updated set_blocks dictionary after gravity and elimination.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">grid_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.make_move", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.make_move", "kind": "function", "doc": "<p>Perform a move (either a simple shift or an exchange) on a given block in the grid (set_blocks).</p>\n\n<p>Args:\n    move_type (str): Type of move ('move_left', 'move_right', etc.).\n    position (tuple): (row, col) of the block to move.\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    dict: Updated set_blocks dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">move_type</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.make_simple_move", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.make_simple_move", "kind": "function", "doc": "<p>Perform a simple move (left or right) for a given block.</p>\n\n<p>Args:\n    position (tuple): (row, col) of the block.\n    direction (str): 'left' or 'right'.\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    dict: Updated set_blocks dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">direction</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.make_exchange_move", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.make_exchange_move", "kind": "function", "doc": "<p>Perform an exchange move (left or right) for a given block.</p>\n\n<p>Args:\n    position (tuple): (row, col) of the block.\n    direction (str): 'left' or 'right'.\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    dict: Updated set_blocks dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span>, </span><span class=\"param\"><span class=\"n\">direction</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.get_game_state", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.get_game_state", "kind": "function", "doc": "<p>Get the current game state.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.\n    colors (list): List of block colors.</p>\n\n<p>Returns:\n    int: 3 for victory, 2 for defeat, 1 for in progress.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">colors</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.has_valid_block_color_counts", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.has_valid_block_color_counts", "kind": "function", "doc": "<p>Check if all colors have at least 3 blocks.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.\n    colors (list): List of block colors.</p>\n\n<p>Returns:\n    bool: True if valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span>, </span><span class=\"param\"><span class=\"n\">colors</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.puzzle_logic.PuzzleLogic.count_block_colors", "modulename": "puzzlegen.core.puzzle_logic", "qualname": "PuzzleLogic.count_block_colors", "kind": "function", "doc": "<p>Count the number of blocks for each color.</p>\n\n<p>Args:\n    set_blocks (dict): Current set of blocks.</p>\n\n<p>Returns:\n    Counter: Counter object with color counts.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_blocks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.utils", "modulename": "puzzlegen.core.utils", "kind": "module", "doc": "<p>Utility functions for puzzle generation and manipulation.</p>\n"}, {"fullname": "puzzlegen.core.utils.assign_blocks_per_color", "modulename": "puzzlegen.core.utils", "qualname": "assign_blocks_per_color", "kind": "function", "doc": "<p>Randomly assign a color to each block, ensuring at least 3 blocks per color.</p>\n\n<p>Args:\n    nb_blocks (int): Total number of blocks to assign.\n    colors (list): List of color names.</p>\n\n<p>Returns:\n    list: List of tuples (color, number_of_blocks).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">nb_blocks</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.utils.sort_blocks_by_rows", "modulename": "puzzlegen.core.utils", "qualname": "sort_blocks_by_rows", "kind": "function", "doc": "<p>Sort blocks by their row index.</p>\n\n<p>Args:\n    set_blocks (dict): Dictionary with positions as keys.</p>\n\n<p>Returns:\n    dict: Sorted dictionary by row.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">set_blocks</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.utils.sort_blocks_by_columns", "modulename": "puzzlegen.core.utils", "qualname": "sort_blocks_by_columns", "kind": "function", "doc": "<p>Sort blocks by their column index.</p>\n\n<p>Args:\n    set_blocks (dict): Dictionary with positions as keys.</p>\n\n<p>Returns:\n    dict: Sorted dictionary by column.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">set_blocks</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.core.utils.print_framed", "modulename": "puzzlegen.core.utils", "qualname": "print_framed", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text_lines</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.frontend", "modulename": "puzzlegen.frontend", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.frontend.SinglePuzzle", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle", "kind": "class", "doc": "<p>User-facing interface for generating and solving a single Match-3 puzzle instance.\nWraps the core logic to provide a simplified API.</p>\n"}, {"fullname": "puzzlegen.frontend.SinglePuzzle.__init__", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle.__init__", "kind": "function", "doc": "<p>Initialize the SinglePuzzle frontend.</p>\n\n<p>Args:</p>\n\n<pre><code>nb_blocks (int): Total number of blocks to place on the grid.\n\ncolors (list of str): List of colors to use for the blocks.\n\nnb_moves (int): Upper bound on the number of moves in the optimal solution. The generator ensures the puzzle can be solved in at most this number of moves.\n\ngrid_size (tuple of int): Dimensions of the grid as (rows, columns).\n\nstack_probability (float, optional): Probability of stacking blocks vertically. Default is 0.75.\n\nblocks_gap (int, optional): Maximum allowed gap between blocks during generation (e.g., 1 means at most one empty cell). Default is 1.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">nb_blocks</span>,</span><span class=\"param\">\t<span class=\"n\">colors</span>,</span><span class=\"param\">\t<span class=\"n\">nb_moves</span>,</span><span class=\"param\">\t<span class=\"n\">grid_size</span>,</span><span class=\"param\">\t<span class=\"n\">stack_probability</span><span class=\"o\">=</span><span class=\"mf\">0.75</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_gap</span><span class=\"o\">=</span><span class=\"mi\">1</span></span>)</span>"}, {"fullname": "puzzlegen.frontend.SinglePuzzle.grid", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle.grid", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.frontend.SinglePuzzle.solver", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle.solver", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.frontend.SinglePuzzle.solution", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle.solution", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.frontend.SinglePuzzle.generate", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle.generate", "kind": "function", "doc": "<p>Randomly generate a puzzle grid based on the parameters defined in the SinglePuzzle instance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.frontend.SinglePuzzle.show", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle.show", "kind": "function", "doc": "<p>Display the initial state of the puzzle grid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.frontend.SinglePuzzle.solve", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle.solve", "kind": "function", "doc": "<p>Attempt to solve the puzzle using BFS. The search is limited to solutions within a maximum number of moves (<code>nb_moves</code>).</p>\n\n<p>Returns:\n    solution (dict or None): \n        A dictionary containing the move history and block states leading to the solution,\n        or None if no solution exists within <code>nb_moves</code> (meaning the solution requires more moves).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.frontend.SinglePuzzle.show_solution", "modulename": "puzzlegen.frontend", "qualname": "SinglePuzzle.show_solution", "kind": "function", "doc": "<p>Display the solution path if one was found.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.frontend.PuzzleBatch", "modulename": "puzzlegen.frontend", "qualname": "PuzzleBatch", "kind": "class", "doc": "<p>Frontend interface for generating and exporting multiple puzzles with varying parameters.\nUseful for statistical analysis or dataset creation.</p>\n"}, {"fullname": "puzzlegen.frontend.PuzzleBatch.__init__", "modulename": "puzzlegen.frontend", "qualname": "PuzzleBatch.__init__", "kind": "function", "doc": "<p>Initialize the batch puzzle generator.</p>\n\n<p>Args:</p>\n\n<pre><code>blocks_range (tuple of int): Range of block counts to iterate over as (min_blocks, max_blocks).\n    For each block count in this range, puzzles will be generated.\n\ncolors_range (tuple of int): Range of color counts to iterate over as (min_colors, max_colors).\n    For each color count in this range, puzzles will be generated.\n\ncolors_blocks (list of str): Pool of possible block colors to choose from.\n\nnb_moves (int): Maximum number of moves allowed in the optimal solution.\n    The generator attempts to create puzzles solvable within this limit.\n\ngrid_size (tuple of int): Dimensions of the puzzle grid as (rows, columns).\n\nnb_attempts (int, optional): Number of attempts to generate a solvable puzzle for each\n    combination of blocks and colors. If no valid puzzle is found after these attempts,\n    no puzzle is generated for that combination. Default is 5.\n\nstack_probability (float, optional): Probability to stack blocks vertically during generation.\n    Default is 0.75.\nblocks_gap (int, optional): Maximum allowed gap between blocks during generation (e.g., 1 means at most one empty cell). Default is 1.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">blocks_range</span>,</span><span class=\"param\">\t<span class=\"n\">colors_range</span>,</span><span class=\"param\">\t<span class=\"n\">colors_blocks</span>,</span><span class=\"param\">\t<span class=\"n\">nb_moves</span>,</span><span class=\"param\">\t<span class=\"n\">grid_size</span>,</span><span class=\"param\">\t<span class=\"n\">nb_attempts</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">stack_probability</span><span class=\"o\">=</span><span class=\"mf\">0.75</span>,</span><span class=\"param\">\t<span class=\"n\">blocks_gap</span><span class=\"o\">=</span><span class=\"mi\">1</span></span>)</span>"}, {"fullname": "puzzlegen.frontend.PuzzleBatch.generator", "modulename": "puzzlegen.frontend", "qualname": "PuzzleBatch.generator", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.frontend.PuzzleBatch.generated", "modulename": "puzzlegen.frontend", "qualname": "PuzzleBatch.generated", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "puzzlegen.frontend.PuzzleBatch.generate", "modulename": "puzzlegen.frontend", "qualname": "PuzzleBatch.generate", "kind": "function", "doc": "<p>Generate a batch of puzzles based on the configured parameter ranges.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.frontend.PuzzleBatch.show_stats", "modulename": "puzzlegen.frontend", "qualname": "PuzzleBatch.show_stats", "kind": "function", "doc": "<p>Display statistical charts for the generated batch (e.g., bar chart and pie chart).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.frontend.PuzzleBatch.save_pdf", "modulename": "puzzlegen.frontend", "qualname": "PuzzleBatch.save_pdf", "kind": "function", "doc": "<p>Export all puzzle grids in the batch as a PDF.</p>\n\n<p>Args:\n    filename (str): Output filename for the PDF.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "puzzlegen.frontend.PuzzleBatch.save_csv", "modulename": "puzzlegen.frontend", "qualname": "PuzzleBatch.save_csv", "kind": "function", "doc": "<p>Export puzzle metadata and configuration results as a CSV file.</p>\n\n<p>Args:\n    filename (str): Output filename for the CSV.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();