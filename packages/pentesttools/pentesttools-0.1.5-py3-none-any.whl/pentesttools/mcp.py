"""
The Model-Context Protocol (MCP) module for Pentest-Tools.com. It uses the ptt API to provide tools, resources and prompts
to LLM agents that implement MCP.
"""

try:
    from mcp.server.fastmcp import Context, FastMCP
    from fastmcp.utilities import json_schema_type

    # TODO: It might be a good idea to use fastmcp2 here
    # from fastmcp import Context, FastMCP
except ImportError:
    # We use this as a guard, in case `pentesttools` was not installed with mcp support
    FastMCP = None


import asyncio
from copy import deepcopy
import json
import os
import sys
import time
import logging
from typing import Literal

import pentesttools as ptt
from pydantic import BaseModel, Field


class ConfirmDeleteSchema(BaseModel):
    confirm: str = Field(
        ...,
        description="Type 'yes' to confirm deletion, 'no' to cancel",
        pattern="^(yes|no)$",
    )


# JSON schema for the Discovery type
DISCOVERY_SCHEMA = {
    "type": "array",
    "items": {
        "type": "string",
        "enum": [
            "fingerprint",
            "software_vulnerabilities",
            "check_robots",
            "outdated_js",
            "untrusted_certificates",
            "client_access_policies",
            "http_debug_methods",
            "security_txt",
            "cors_misconfiguration",
            "resource_discovery",
            "sensitive_files",
            "admin_consoles",
            "interesting_files",
            "server_info_disc",
            "server_software",
            "misconfigurations",
            "graphql_endpoint",
            "fuzz_openapi_locations",
        ],
    },
    "description": "Discovery modules to run. If not set, all will run. If empty list, none will run.",
}

Discovery = json_schema_type.json_schema_to_type(DISCOVERY_SCHEMA)


os.environ["PTT_USER_AGENT"] = "ptt-cli-mcp"

API_URL = "https://app.pentest-tools.com/api/v2/"
MCP_METHOD = "stdio"
HEADERS = {
    "User-Agent": "ptt-cli-mcp",
    "Accept": "*/*",
}


def get_authentication_headers(context: Context) -> dict[str, str]:
    """A function that gives the headers for the request. We need this to get the PTT-API-KEY header

    Returns the headers necessary for a request, with the authentication added. If the key is not found, return an empty dict.
    """
    global HEADERS

    # For stdio, we get the api key from `ptt.api.api_key`
    if MCP_METHOD == "stdio":
        HEADERS["Authorization"] = f"Bearer {ptt.api.api_key}"
        return HEADERS

    # For http, we get the api key from the `Context` object
    elif MCP_METHOD == "http":
        request_object = context.request_context.request
        if request_object is None:
            return {}

        if not hasattr(request_object, "headers"):
            return {}

        headers: dict[str, str] = request_object.headers

        ptt_api_key = headers.get("ptt_api_key")
        if ptt_api_key is not None:
            headers = deepcopy(HEADERS)
            headers["Authorization"] = f"Bearer {ptt_api_key}"

            return headers

    return {}


def run_tool(
    tool_id: int,
    target: str,
    tool_params: dict,
    scan_params: dict,
    context: Context,
    raw: bool = False,
):
    """The main way of running a scanning tool"""

    # `HEADERS` + authentication
    headers = get_authentication_headers(context)
    if not headers:
        return "The api key is missing."

    res = ptt.api.start_scan(target, tool_id, tool_params, scan_params, headers=headers)
    res_json = res.json()

    scan_id = res_json["data"]["created_id"]
    logging.info("Started scan %i, for tool_id %s", scan_id, tool_id)

    while True:
        time.sleep(2)

        # Get the status of our scan
        status = ptt.api.get_scan_status(scan_id, headers=headers)
        status_name = status.json()["data"]["status_name"]

        if status_name == "finished":
            logging.debug("Scan status: %s" % res_json["data"])
            logging.debug("Getting JSON report")

            if raw:
                res = ptt.api.get_raw_output(scan_id, headers=headers)
                return res.text

            res = ptt.api.get_output(scan_id, headers=headers)
            output_json = json.dumps(res.json())
            return output_json


async def run_tool_long_running(
    tool_id: int,
    target: str,
    tool_params: dict,
    scan_params: dict,
    context: Context,
    raw: bool = False,
):
    """
    Run a tool as a long-running MCP task, reporting progress/status updates to the LLM via mcp_task.
    """

    headers = get_authentication_headers(context)

    if not headers:
        return "The api key is missing."

    res = ptt.api.start_scan(target, tool_id, tool_params, scan_params, headers=headers)
    res_json = res.json()

    try:
        scan_id = res_json["data"]["created_id"]
    except KeyError:
        return f"There was a problem starting the scan: {res_json}"

    logging.info("Started scan %i, for tool_id %s", scan_id, tool_id)

    # Status groups
    progress_statuses = {"running", "waiting"}
    finished_statuses = {"finished"}
    failed_statuses = {
        "failed to start",
        "stopped",
        "timed out",
        "aborted",
        "VPN connection error",
        "auth failed",
        "connection error",
    }

    while True:
        await asyncio.sleep(2)

        # Get the status of our scan
        status = ptt.api.get_scan_status(scan_id, headers=headers)
        status_data = status.json()["data"]
        status_name = status_data["status_name"]

        # Compose progress message using the provided output structure
        progress_msg = (
            f"Scan {scan_id} is {status_name}.\n"
            f"Progress: {status_data.get('progress', 0.0)}\n"
            f"Status message: {status_data.get('status_message', '')}\n"
            f"Critical: {status_data.get('result_summary', {}).get('critical', 0)}, "
            f"High: {status_data.get('result_summary', {}).get('high', 0)}, "
            f"Medium: {status_data.get('result_summary', {}).get('medium', 0)}, "
            f"Low: {status_data.get('result_summary', {}).get('low', 0)}, "
            f"Info: {status_data.get('result_summary', {}).get('info', 0)}"
        )

        # Report progress if running or waiting
        if context is not None and status_name in progress_statuses:
            await context.report_progress(
                float(status_data.get("progress", 0.0)),
                total=100.0,
                message="Scan id "
                + str(scan_id)
                + " | Status: "
                + str(status_name)
                + f" | Progress: {float(status_data.get('progress', 0.0))}",
            )

        if status_name in finished_statuses:
            logging.debug("Scan status: %s" % status_data)
            logging.debug("Getting JSON report")

            if raw:
                res = ptt.api.get_raw_output(scan_id, headers=headers)
                return res.text

            res = ptt.api.get_output(scan_id, headers=headers)
            output_json = json.dumps(res.json())
            return output_json

        elif status_name in failed_statuses:
            # Report failure to the LLM
            if context is not None:
                await context.info(
                    f"Scan {scan_id} failed with status: {status_name}. Status message: {status_data.get('status_message', '')}"
                )
            return json.dumps(
                {
                    "error": f"Scan failed with status: {status_name}",
                    "details": status_data,
                }
            )

        # Otherwise, keep waiting and reporting progress


if FastMCP is not None:
    mcp = FastMCP("ptt-http", port=9000)

    ### Resources
    # TODO: Resources have not worked in vscode copilot. Try to make them work and test in other MCP clients as well.
    # Resources are generally the GET requests from API
    # @mcp.resource("scans://")
    # def get_scans() -> str:
    #     """Get the current running scans"""
    #     res = ptt.api.get_scans(headers=HEADERS)

    #     # TODO: json data may not be suitable for LLMs, at least for the less powerful ones.
    #     # Make the data more LLM friendly
    #     return json.dumps(res.json())

    # @mcp.resource("targets://")
    # def get_targets() -> str:
    #     """Get the current targets available"""
    #     res = ptt.api.get_targets(headers=HEADERS)

    #     return json.dumps(res.json())

    ### Prompts
    # Prompts should match the intended use-cases for the pentesttools MCP
    @mcp.prompt()
    def pentest(target: str) -> str:
        """Create a pentesting report prompt"""
        return f"Please provide a comprehensive pentesting report for this target: {target}, using the tools at your disposal."

    @mcp.prompt()
    def is_up(target: str) -> str:
        """Create a simple target checking prompt"""
        return f"Please see if this target: {target} is up, using the tools at your disposal."

    @mcp.prompt()
    def subdomains(target: str) -> str:
        """Discover all subdomains for the target domain"""
        return f"Please find all the subdomains that you can for this domain: {target}, using the tools at your disposal."

    @mcp.prompt()
    def translate(target: str) -> str:
        """Translates report findings in another language."""
        return f"Please use the tools at your disposal to extract the latest finding and translate it from English into {target}. Please take extra care not to translate things that should be in English, like URLs, API endpoints or other such resources. Additionally, you may keep the names of the vulnerabilities in English, if you deem that to be better."

    @mcp.prompt()
    def summary(workspace_id: int) -> str:
        """Create an executive summary for scans in a certain time period from workspace `workspace_id`"""
        return f"Please create an executive summary for the latest scans in the workspace {workspace_id}, using the tools at your disposal."

    ### Tools
    # These are the actual pentesting tools, with some added management tools, available through `ptt.api`

    # Pentesting tools
    # @mcp.tool()
    async def run_website_scanner(target: str, context: Context) -> str:
        """
        Run a website scanner on the target URL.
        If you need to run a general website scan, this is the tool to use.
        If you need more information from a website under test, use this tool and tell the user you'll use this tool to accomplish your goal.

        Args:
            target: The target URL to scan.
        """
        return run_tool(
            ptt.api.Tool.WEBSITE_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    WEBSITE_SCANNER_SCHEMA = {
        "scan_type": {
            "type": "string",
            "enum": ["light", "deep", "custom"],
            "default": "deep",
        },
        "attack_active": {
            "type": "array",
            "items": {
                "type": "string",
                "enum": [
                    "xss",
                    "sqli",
                    "lfi",
                    "oscmdi",
                    "ssrf",
                    "open_redirect",
                    "broken_authentication",
                    "php_code_injection",
                    "js_code_injection",
                    "ruby_code_injection",
                    "python_code_injection",
                    "perl_code_injection",
                    "log4j_rce",
                    "ssti",
                    "xxe",
                    "viewstate_rce",
                    "prototype_pollution",
                    "backup_files",
                    "request_url_override",
                    "http_request_smuggling",
                    "session_fixation",
                    "idor",
                    "jwt",
                    "response_header_injection",
                ],
            },
            "description": "Active attacks to run. If not set, all will run. If empty list, none will run.",
        },
        "attack_passive": {
            "type": "array",
            "items": {
                "type": "string",
                "enum": [
                    "security_headers",
                    "cookie_security",
                    "directory_listing",
                    "secure_communication",
                    "weak_password_submission",
                    "error_debug_messages",
                    "password_cleartext",
                    "cross_domain_source",
                    "mixed_content",
                    "sensitive_data",
                    "login_interfaces",
                    "file_upload",
                    "path_disclosure",
                    "sql_statement_in_request",
                    "password_in_response",
                    "session_token_in_url",
                    "api_endpoint",
                ],
            },
            "description": "Passive attacks to run. If not set, all will run. If empty list, none will run.",
        },
        "discovery": {
            "type": "array",
            "items": {
                "type": "string",
                "enum": [
                    "fingerprint",
                    "software_vulnerabilities",
                    "check_robots",
                    "outdated_js",
                    "untrusted_certificates",
                    "client_access_policies",
                    "http_debug_methods",
                    "security_txt",
                    "cors_misconfiguration",
                    "resource_discovery",
                    "sensitive_files",
                    "admin_consoles",
                    "interesting_files",
                    "server_info_disc",
                    "server_software",
                    "misconfigurations",
                    "graphql_endpoint",
                    "fuzz_openapi_locations",
                ],
            },
            "description": "Discovery modules to run. If not set, all will run. If empty list, none will run.",
        },
        "spider": {
            "type": "object",
            "properties": {
                "approach": {
                    "type": "string",
                    "enum": ["auto", "classic", "spa"],
                    "default": "auto",
                },
                "depth": {"type": "integer", "default": 10},
                "exclude_urls": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "URLs to exclude from spidering.",
                },
                "include_urls": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "URLs to include in spidering.",
                },
                "subdomains_in_scope": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Subdomains to include in scope.",
                },
            },
        },
        "requests_per_second": {
            "type": "integer",
            "default": 100,
            "minimum": 1,
            "maximum": 10000,
            "description": "Max requests per second.",
        },
    }

    WebsiteScanner = json_schema_type.json_schema_to_type(WEBSITE_SCANNER_SCHEMA)

    @mcp.tool()
    async def run_website_scanner_long(
        target: str,
        scan_type: Literal["light", "deep", "custom"] = "deep",
        attack_active: list[Literal["sqli", "xss"]] = None,
        attack_passive: list[str] = None,
        discovery: list[str] = None,
        spider: dict = None,
        requests_per_second: int = 100,
        context: Context = None,
    ) -> str:
        """
        Run a website scanner on the target URL, reporting progress/status updates.

        Args:
            target: The target URL to scan.
            scan_type: The type of scan to perform. Possible values: "light", "deep", "custom". Default is "deep".
            attack_active: List of active attack modules to run. Possible values:
            [
                "xss",
                "sqli",
                "lfi",
                "oscmdi",
                "ssrf",
                "open_redirect",
                "broken_authentication",
                "php_code_injection",
                "js_code_injection",
                "ruby_code_injection",
                "python_code_injection",
                "perl_code_injection",
                "log4j_rce",
                "ssti",
                "xxe",
                "viewstate_rce",
                "prototype_pollution",
                "backup_files",
                "request_url_override",
                "http_request_smuggling",
                "session_fixation",
                "idor",
                "jwt",
                "response_header_injection",
            ]
            attack_passive: List of passive attack modules to run. Possible values:
            [
                "security_headers",
                "cookie_security",
                "directory_listing",
                "secure_communication",
                "weak_password_submission",
                "error_debug_messages",
                "password_cleartext",
                "cross_domain_source",
                "mixed_content",
                "sensitive_data",
                "login_interfaces",
                "file_upload",
                "path_disclosure",
                "sql_statement_in_request",
                "password_in_response",
                "session_token_in_url",
                "api_endpoint",
            ]
            discovery: List of discovery modules to run. Possible values:
            [
                "fingerprint",
                "software_vulnerabilities",
                "check_robots",
                "outdated_js",
                "untrusted_certificates",
                "client_access_policies",
                "http_debug_methods",
                "security_txt",
                "cors_misconfiguration",
                "resource_discovery",
                "sensitive_files",
                "admin_consoles",
                "interesting_files",
                "server_info_disc",
                "server_software",
                "misconfigurations",
                "graphql_endpoint",
                "fuzz_openapi_locations",
            ]
            spider: Spidering options as a dict. Structure:
            {
                "approach": "auto" | "classic" | "spa",  # Default: "auto"
                "depth": int,  # Default: 10
                "exclude_urls": [str],  # URLs to exclude from spidering
                "include_urls": [str],  # URLs to include in spidering
                "subdomains_in_scope": [str],  # Subdomains to include in scope
            }
            requests_per_second: Max requests per second (1-10000). Default is 100.

        All possible options and their values are available in the WEBSITE_SCANNER_SCHEMA variable.
        """
        tool_params = {
            "scan_type": scan_type,
            "requests_per_second": requests_per_second,
        }
        if attack_active:
            tool_params["attack_active"] = attack_active
        if attack_passive:
            tool_params["attack_passive"] = attack_passive
        if discovery:
            tool_params["discovery"] = discovery
        if spider:
            tool_params["spider"] = spider

        return await run_tool_long_running(
            ptt.api.Tool.WEBSITE_SCANNER,
            target,
            tool_params,
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def network_recon(
        verb: Literal[
            "icmp_ping",
            "subdomain_finder",
            "domain_finder",
            "whois_lookup",
            "port_scanner",
            "vhosts_finder",
        ],
        target: str,
        context: Context,
    ) -> str:
        """
        Reconnaissance tool for Pentest-Tools.com. Use the `verb` parameter to select the specific recon activity to perform on the target.

        Supported verbs and their actions:
        - "icmp_ping": Run an ICMP ping to check if the target is reachable/alive. Use for basic liveness checks.
        - "subdomain_finder": Discover all subdomains for the target domain. Use to enumerate subdomains for further scanning.
        - "domain_finder": Discover domain names owned by a company and map its attack surface. Use with company domains (e.g. oracle.com).
        - "whois_lookup": Perform a Whois lookup for a domain or IP address. Use to extract registration and ownership info.
        - "port_scanner": Scan the target for open TCP/UDP ports and services. Use for network attack surface mapping.
        - "vhosts_finder": Discover virtual hosts configured on a given IP address or hostname. Use to enumerate hosted sites.

        Args:
            verb: The reconnaissance action to perform. Must be one of: icmp_ping, subdomain_finder, domain_finder, whois_lookup, port_scanner, vhosts_finder.
            target: The target for the scan. For most verbs, this is a domain name, IP address, or hostname. See individual verb descriptions for details.
            context: The MCP context object.

        Returns:
            The result of the selected reconnaissance scan, as JSON or raw text (for icmp_ping).
        """
        tool_map = {
            "icmp_ping": (ptt.api.Tool.ICMP_PING, {"scan_type": "light"}, {}, True),
            "subdomain_finder": (
                ptt.api.Tool.SUBDOMAIN_FINDER,
                {"scan_type": "light"},
                {"max_scan_time": "5"},
                False,
            ),
            "domain_finder": (
                ptt.api.Tool.DOMAIN_FINDER,
                {"scan_type": "light"},
                {"max_scan_time": "5"},
                False,
            ),
            "whois_lookup": (
                ptt.api.Tool.WHOIS_LOOKUP,
                {"scan_type": "light"},
                {"max_scan_time": "5"},
                False,
            ),
            "port_scanner": (
                ptt.api.Tool.PORT_SCANNER,
                {"scan_type": "light"},
                {"max_scan_time": "5"},
                False,
            ),
            "vhosts_finder": (
                ptt.api.Tool.VIRTUAL_HOSTS_FINDER,
                {"scan_type": "light"},
                {"max_scan_time": "5"},
                False,
            ),
        }
        tool_info = tool_map.get(verb)
        if not tool_info:
            return (
                f"Unknown verb '{verb}'. Supported values: icmp_ping, subdomain_finder, "
                "domain_finder, whois_lookup, port_scanner, vhosts_finder."
            )
        tool_id, tool_params, scan_params, raw = tool_info
        return run_tool(tool_id, target, tool_params, scan_params, context, raw=raw)

    NETWORK_SCANNER_SCHEMA = {
        "preset": {
            "type": "string",
            "enum": ["light", "deep", "custom"],
            "default": "deep",
            "description": (
                "Determines the Network Scanner scan type that will be used. "
                "`light` uses the `version_based` scanning engine on top 100 ports. "
                "`deep` uses the `version_based`, `sniper` and `nuclei` scanning engines on top 5000 ports (TCP) or top 1000 ports (UDP). "
                "`custom` allows you to use custom configurations of scanning engines and ports."
            ),
        },
        "scanning_engines": {
            "type": "array",
            "description": (
                "Scanning engines that will be loaded for a scan. Can be set only if `custom` preset was selected. "
                "It must contain at least one engine."
            ),
            "items": {
                "type": "string",
                "enum": ["version_based", "sniper", "nuclei", "openvas"],
            },
            "example": ["version_based", "sniper", "nuclei", "openvas"],
        },
        "engines_options": {
            "type": "object",
            "properties": {
                "requests_per_second": {
                    "type": "integer",
                    "default": 50,
                    "description": (
                        "Specify a maximum number of requests per second between 1 and 1000. "
                        "It is only valid with the `deep` preset or with the `custom` preset if `nuclei` and/or `openvas` are included in `scanning_engines`."
                    ),
                    "minimum": 1,
                    "maximum": 1000,
                },
                "cves_to_scan": {
                    "type": "array",
                    "default": [],
                    "description": (
                        "Specify particular CVEs for scanning. Can be set only if `custom` preset was selected."
                    ),
                    "items": {"type": "string"},
                    "example": ["CVE-2024-23108", "CVE-2024-27198"],
                },
            },
        },
        "check_alive": {
            "type": "boolean",
            "default": True,
        },
        "extensive_modules": {
            "type": "boolean",
            "default": False,
        },
        "protocol_type": {
            "type": "string",
            "enum": ["tcp", "udp"],
            "default": "tcp",
        },
        "port_range": {
            "type": "object",
            "properties": {
                "start_port": {"type": "integer"},
                "end_port": {"type": "integer"},
            },
            "example": {"start_port": 0, "end_port": 443},
        },
        "port_top": {
            "type": "string",
            "enum": ["OpenVAS default", "10", "100", "1000", "5000"],
        },
        "port_list": {
            "type": "array",
            "items": {
                "type": "integer",
                "minimum": 1,
                "maximum": 65535,
            },
            "example": [22, 80, 443],
        },
    }

    NetworkScanner = json_schema_type.json_schema_to_type(NETWORK_SCANNER_SCHEMA)

    @mcp.tool()
    async def run_network_scanner(
        target: str,
        preset: Literal["light", "deep", "custom"] = "deep",
        scanning_engines: list[str] = None,
        engines_options: dict = None,
        check_alive: bool = True,
        extensive_modules: bool = False,
        protocol_type: Literal["tcp", "udp"] = "tcp",
        port_range: dict = None,
        port_top: str = None,
        port_list: list[int] = None,
        context: Context = None,
    ) -> str:
        """
        Run a network scanner on the target hostname.

        Args:
            target: The target hostname to scan.
            preset: Determines the Network Scanner scan type that will be used. `light`, `deep`, or `custom`. Default is `deep`.
            scanning_engines: Scanning engines to use (only if `custom` preset). Possible values: version_based, sniper, nuclei, openvas.
            engines_options: Options for scanning engines. Example: {"requests_per_second": 50, "cves_to_scan": ["CVE-2024-23108"]}.
            check_alive: Whether to check if the host is alive before scanning. Default: True.
            extensive_modules: Whether to use extensive modules. Default: False.
            protocol_type: Protocol to scan. "tcp" or "udp". Default: "tcp".
            port_range: Dict with "start_port" and "end_port" (e.g. {"start_port": 0, "end_port": 443}).
            port_top: Top ports to scan. One of: "OpenVAS default", "10", "100", "1000", "5000".
            port_list: List of specific ports to scan (e.g. [22, 80, 443]).

        All possible options and their values are available in the NETWORK_SCANNER_SCHEMA variable.
        """
        tool_params = {
            "scan_type": preset,
            "check_alive": check_alive,
            "extensive_modules": extensive_modules,
            "protocol_type": protocol_type,
        }
        if scanning_engines:
            tool_params["scanning_engines"] = scanning_engines
        if engines_options:
            tool_params["engines_options"] = engines_options
        if port_range:
            tool_params["port_range"] = port_range
        if port_top:
            tool_params["port_top"] = port_top
        if port_list:
            tool_params["port_list"] = port_list

        return await run_tool_long_running(
            ptt.api.Tool.NETWORK_SCANNER,
            target,
            tool_params,
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_cms_scanner(
        cms: Literal["sharepoint", "wordpress", "drupal", "joomla"],
        target: str,
        context: Context,
    ) -> str:
        """
        This tool performs a security scan on a CMS (Content Management System) website. The first parameter, `cms`, selects which CMS-specific scanner to use.

        Supported values for `cms`:
        - "sharepoint": Uses the SharePoint scanner to discover security weaknesses and vulnerabilities in Microsoft SharePoint and FrontPage web applications.
        - "wordpress": Uses the WordPress scanner (WPScan) to discover vulnerabilities and security issues in WordPress installations.
        - "drupal": Uses the Drupal scanner to find Drupal version, modules, theme vulnerabilities, and misconfigurations.
        - "joomla": Uses the Joomla scanner to assess Joomla core, components, modules, and template vulnerabilities.

        Args:
            cms: The CMS type to scan. Must be one of: "sharepoint", "wordpress", "drupal", "joomla".
            target: The URL of the CMS website to scan. All URLs must start with http or https. For WordPress, Drupal, and Joomla, specify the complete path to the base directory of the installation.
        """
        tool_map = {
            "sharepoint": ptt.api.Tool.SHARE_POINT_SCANNER,
            "wordpress": ptt.api.Tool.WORDPRESS_SCANNER,
            "drupal": ptt.api.Tool.DRUPAL_SCANNER,
            "joomla": ptt.api.Tool.JOOMLA_SCANNER,
        }
        tool_id = tool_map.get(cms)
        if not tool_id:
            return f"Unknown CMS type '{cms}'. Supported values: sharepoint, wordpress, drupal, joomla."
        return run_tool(
            tool_id,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_website_recon(
        verb: Literal[
            "fingerprint_website", "url_fuzzer", "waf_detector", "people_hunter"
        ],
        target: str,
        context: Context,
    ) -> str:
        """
        This tool allows you to perform a specific reconnaissance activity on a target website using the Pentest-Tools.com API.

        The API call depends on the `verb` parameter:
        - "fingerprint_website": Uses Tool.WEBSITE_RECON.
        - "url_fuzzer": Uses Tool.URL_FUZZER.
        - "waf_detector": Uses Tool.WAF_DETECTOR.
        - "people_hunter": Uses Tool.PEOPLE_HUNTER.

        Args:
            verb: The reconnaissance sub-tool to run. Must be one of: fingerprint_website, url_fuzzer, waf_detector, people_hunter.
            target: The address of the website to scan. Must start with http:// or https://.
        """
        tool_map = {
            "fingerprint_website": ptt.api.Tool.WEBSITE_RECON,
            "url_fuzzer": ptt.api.Tool.URL_FUZZER,
            "waf_detector": ptt.api.Tool.WAF_DETECTOR,
            "people_hunter": ptt.api.Tool.PEOPLE_HUNTER,
        }
        tool_id = tool_map.get(verb)
        if not tool_id:
            return f"Unknown verb '{verb}'. Supported values: fingerprint_website, url_fuzzer, waf_detector, people_hunter."
        tool_params = {"scan_type": "light"}
        return run_tool(
            tool_id,
            target,
            tool_params,
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_sqli_exploiter(target: str, context: Context) -> str:
        """
        This tool allows you to confirm SQL Injection vulnerabilities in your site, to see the vulnerable parameters, and also to demonstrate the business risk by extracting data from the database. Powered by SQLMap.

        Args:
            target: This is the URL of the website that will be scanned. All URLs must start with http or https.
        """
        return run_tool(
            ptt.api.Tool.SQLI_EXPLOITER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_password_auditor(target: str, context: Context) -> str:
        """
        This tool scans an URL, IP address, or hostname for network services that require authentication (ex. HTTP web forms, SSH, FTP, MYSQL, PostgreSQL, RDP, etc) and detects weak credentials by trying to log in using the usernames and passwords from the input wordlists.

        Args:
            target: This is the hostname or IP address to scan.
        """
        return run_tool(
            ptt.api.Tool.PASSWORD_AUDITOR,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_ssl_scanner(target: str, context: Context) -> str:
        """
        This tool connects to the target port and attempts to negotiate various cipher suites and multiple SSL/TLS versions to determine weak configurations and common vulnerabilities (ex. POODLE, Heartbleed, DROWN, ROBOT, etc.). The full version of the SSL Scanner scans multiple ports and services (HTTPS, SMTPs, IMAPs, etc.).

        Args:
            target: This specifies the target that will be scanned. It can be a single IP address or a hostname (ex. 8.8.8.8 or www.example.com)
        """
        return run_tool(
            ptt.api.Tool.SSL_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_sniper(target: str, context: Context) -> str:
        """
        This tool automatically exploits known, widespread vulnerabilities in high-profile software. The tool gains remote command execution on the vulnerable targets and automatically runs post-exploitation modules to extract interesting data (artefacts) as solid proof for vulnerability validation.

        Args:
            target: Specifies the system that will be scanned. Target can be an IP address, hostname or an URL.
        """
        return run_tool(
            ptt.api.Tool.SNIPER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_api_scanner(target: str, context: Context) -> str:
        """
        This tool is a custom tool designed to assess the security of REST and GraphQL APIs quickly.

        Args:
            target: This is the URL of the API that will be scanned.
        """
        return run_tool(
            ptt.api.Tool.API_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_cloud_scanner(target: str, context: Context) -> str:
        """
        This tool evaluates multi-cloud environments (Amazon Web Services - AWS and Google Cloud Platform - GCP) to identify misconfigurations, vulnerabilities, weak access controls, interesting files, and other security issues.
        A penetration tester can use the tool to discover and confirm security vulnerabilities in cloud infrastructure and report them.

        Args:
            target: Specifies the system to be scanned. Target can be an IP address, hostname or URL. If you want to scan an AWS S3 bucket, you can input it in the URL form: http(s)://<bucket_name>.s3.amazonaws.com. If you want to scan a Google Cloud Storage bucket, you can input it in the URL form: https://storage.googleapis.com/<bucket_name>
        """
        return run_tool(
            ptt.api.Tool.CLOUD_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_kubernetes_scanner(target: str, context: Context) -> str:
        """
        This tool automates the search for security vulnerabilities and misconfigurations in Kubernetes clusters. Its findings vary from reconnaissance to initial access vulnerabilities.

        Args:
            target: Specifies the target that will be scanned. It can be a single IP address or a hostname (ex. www.example.com)
        """
        return run_tool(
            ptt.api.Tool.KUBERNETES_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    # Administrative tools
    @mcp.tool()
    async def get_scans(
        context: Context,
        workspace_id: int = None,
        target_id: int = None,
        status: Literal[
            "running",
            "finished",
            "failed to start",
            "stopped",
            "timed out",
            "waiting",
            "aborted",
            "VPN connection error",
            "auth failed",
            "connection error",
        ] = None,
        limit: int = None,
        page: int = None,
        start_time: dict = None,
    ) -> str:
        """
        Retrieve scans from Pentest-Tools.com with optional filtering.

        Usage:
        - To get all scans: call with no extra parameters.
        - To filter by workspace: set workspace_id=<workspace id>.
        - To filter by target: set target_id=<target id>.
        - To filter by scan status: set status to one of the allowed values.
        - To limit results: set limit=<max number of scans>.
        - To paginate: set page=<page number>.
        - To filter by start time: set start_time as a dictionary (e.g. {"from": "...", "to": "..."}).

        Args:
            context: The MCP context object.
            workspace_id: (optional) ID of the workspace to show scans from.
            target_id: (optional) ID of the target to show scans from.
            status: (optional) Status of the scans to be shown. Allowed values: running, finished, failed to start, stopped, timed out, waiting, aborted, VPN connection error, auth failed, connection error.
            limit: (optional) Maximum number of scans to return.
            page: (optional) Page number to return.
            start_time: (optional) Dictionary specifying start time interval for scans (e.g. {"from": "...", "to": "..."}).

        Returns:
            JSON string containing the list of scans matching the filters.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_scans(
            workspace_id=workspace_id,
            target_id=target_id,
            status=status,
            limit=limit,
            page=page,
            start_time=start_time,
            headers=headers,
        )
        return json.dumps(res.json())

    @mcp.tool()
    async def scan(
        verb: Literal[
            "get_status",
            "get_raw_output",
            "get_output",
            "start_by_targetid",
            "stop",
            "delete",
            "get_scan_output_by_id",
        ],
        context: Context,
        scan_id: int = None,
        target_id: int = None,
        tool_id: int = None,
        tool_params: dict = None,
    ) -> str:
        """
        Manage scans in Pentest-Tools.com.

        Usage:
        - To get the status of a scan: verb="get_status", scan_id=<scan id>
        - To get the raw output of a scan: verb="get_raw_output", scan_id=<scan id>
        - To get the parsed output of a scan: verb="get_output", scan_id=<scan id>
        - To start a scan by target id: verb="start_by_targetid", target_id=<target id>, tool_id=<tool id>, tool_params=<tool params>
        - To stop a scan: verb="stop", scan_id=<scan id>
        - To delete a scan: verb="delete", scan_id=<scan id>
        - To get a scan output of a scan: verb="get_scan_output_by_id", scan_id=<scan id>

        Only set the parameters required for the verb you use.

        Args:
            verb: The action to perform. Must be one of: get_status, get_raw_output, get_output, start_by_targetid, stop, delete.
            scan_id: The scan ID (required for get_status, get_raw_output, get_output, stop, delete).
            target_id: The target ID (required for start_by_targetid).
            tool_id: The tool ID (required for start_by_targetid).
            tool_params: The tool parameters (required for start_by_targetid).
            context: The MCP context object.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        if verb == "get_status":
            if not scan_id:
                return "Missing scan_id for get_status."
            res = ptt.api.get_scan_status(scan_id, headers=headers)
            return json.dumps(res.json())
        elif verb == "get_raw_output":
            if not scan_id:
                return "Missing scan_id for get_raw_output."
            res = ptt.api.get_raw_output(scan_id, headers=headers)
            return res.text
        elif verb == "get_output":
            if not scan_id:
                return "Missing scan_id for get_output."
            res = ptt.api.get_output(scan_id, headers=headers)
            return json.dumps(res.json())
        elif verb == "start_by_targetid":
            if not target_id or not tool_id or tool_params is None:
                return (
                    "Missing target_id, tool_id, or tool_params for start_by_targetid."
                )
            res = ptt.api.start_scan_by_targetid(
                target_id, tool_id, tool_params, headers=headers
            )
            return json.dumps(res.json())
        elif verb == "stop":
            if not scan_id:
                return "Missing scan_id for stop."
            res = ptt.api.stop_scan(scan_id, headers=headers)
            return json.dumps(res.json())
        elif verb == "delete":
            if not scan_id:
                return "Missing scan_id for delete."

            # Elicit confirmation from the user before deleting
            if context is not None:
                result = await context.elicit(
                    message="Deleting a scan is an irreversible operation. Respond to this message in order to proceed",
                    schema=ConfirmDeleteSchema,
                )
                # Only proceed if user typed 'yes'
                if result.action != "accept":
                    return "Scan deletion cancelled by user."

            res = ptt.api.delete_scan(scan_id, headers=headers)
            return json.dumps(res.json())
        elif verb == "get_scan_output_by_id":
            if not scan_id:
                return "Missing scan_id for get_scan_output_by_id."
            res = ptt.api.get_output(scan_id, headers=headers)
            return json.dumps(res.json())
        else:
            return "Unknown verb: {verb}. Use one of: get_status, get_raw_output, get_output, start_by_targetid, stop, delete."

    # VPNs
    @mcp.tool()
    async def get_vpn_profiles(
        context: Context,
    ) -> str:
        """
        Use this tool to get a list of vpn profiles from Pentest-Tools.com.

        Returns:
            JSON string containing the list of targets matching the filters.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        res = ptt.api.get_vpn_profiles(
            headers=headers,
        )
        return json.dumps(res.json())

    ### Targets
    @mcp.tool()
    async def get_targets(
        context: Context,
        workspace_id: int = None,
        target_type: Literal["hostname", "ip_address", "url"] = None,
        limit: int = None,
        page: int = None,
    ) -> str:
        """
        Use this tool to get a list of targets from Pentest-Tools.com.

        Args:
            context: The MCP context object.
            workspace_id: (optional) ID of the workspace to show targets from.
            target_type: (optional) The type of target. Possible values: "hostname", "ip_address", "url".
            limit: (optional) The maximum number of targets to return.
            page: (optional) The page number to return.

        Returns:
            JSON string containing the list of targets matching the filters.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_targets(
            workspace_id=workspace_id,
            target_type=target_type,
            limit=limit,
            page=page,
            headers=headers,
        )
        return json.dumps(res.json())

    @mcp.tool()
    async def target(
        verb: Literal["add", "delete"],
        context: Context,
        name: str = None,
        description: str = "",
        workspace_id: int = None,
        target_id: int = None,
    ) -> str:
        """
        Manage targets in Pentest-Tools.com.

        Usage:
        - To add a new target: verb="add", name=<target name>, description=<optional>, workspace_id=<optional>.
        - To delete a target: verb="delete", target_id=<target id>.

        Only set the parameters required for the verb you use.

        Args:
            verb: The action to perform. Must be one of: add, delete.
            context: The MCP context object.
            name: The name of the target to add (required for add).
            description: Description for the target (optional for add).
            workspace_id: Workspace ID to associate with the target (optional for add).
            target_id: The ID of the target to delete (required for delete).
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        if verb == "add":
            if not name:
                return "Missing target name for add."
            res = ptt.api.add_target(name, description, workspace_id, headers=headers)
            return json.dumps(res.json())
        elif verb == "delete":
            if not target_id:
                return "Missing target_id for delete."
            res = ptt.api.delete_target(target_id, headers=headers)
            return json.dumps(res.json())
        else:
            return f"Unknown verb: {verb}. Use one of: add, delete."

    ### Reports
    @mcp.tool()
    async def create_report(
        format: Literal["pdf", "html", "json", "csv", "xlsx", "docx"],
        group_by: Literal["target", "vulnerability"],
        source: Literal["scans", "findings"],
        resources: list[int],
        context: Context,
        filters: dict = None,
        webhook_url: str = None,
    ) -> str:
        """Create a pentesting report, based on the findings already present in the platform.

        Args:
            format: The format in which to create the report. Possible values: pdf, html, json, csv, xlsx, docx.
            group_by: What key is used to create the report. Possible values: target, vulnerability.
            source: This is the source that is used to create the report. Possible values: scans, findings.
            resources: A list of ids, depeding on which source was chosen. If `scans` was chosed, then it's a list of scan_ids. If `findings` was chosed, then it's a list of finding_ids.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.create_report(
            format, group_by, source, resources, filters, webhook_url, headers=headers
        )
        return json.dumps(res.json())

    @mcp.tool()
    async def report(
        verb: Literal["delete", "download", "get_all", "get_report_information_by_id"],
        context: Context,
        report_id: int = None,
    ) -> str:
        """
        Manage reports in Pentest-Tools.com.

        Usage:
        - To delete a report: verb="delete", report_id=<report id>
        - To download a report: verb="download", report_id=<report id>
        - To get all reports: verb="get_all"
        - To get report information: verb="get_report_information_by_id", report_id=<report id>

        Only set the parameters required for the verb you use.

        Args:
            verb: The action to perform. Must be one of: delete, download, get_all.
            context: The MCP context object.
            report_id: The ID of the report (required for delete and download).
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        if verb == "delete":
            if not report_id:
                return "Missing report_id for delete."
            res = ptt.api.delete_report(report_id, headers=headers)
            return json.dumps(res.json())
        elif verb == "download":
            if not report_id:
                return "Missing report_id for download."
            res = ptt.api.download_report(report_id, headers=headers)
            return res.text
        elif verb == "get_all":
            res = ptt.api.get_all_reports(headers=headers)
            return json.dumps(res.json())
        elif verb == "get_report_information_by_id":
            if not report_id:
                return "Missing report_id for get_report_information_by_id."
            res = ptt.api.get_report_information_by_id(report_id, headers=headers)
            return json.dumps(res.json())
        else:
            return f"Unknown verb: {verb}. Use one of: delete, download, get_all."

    ### Loggers
    @mcp.tool()
    async def http_logger(
        verb: Literal["create", "delete", "clear"],
        context: Context,
        label: str = None,
        logger_id: int = None,
        workspace_id: int = None,
    ) -> str:
        """
        Manage HTTP request loggers.

        Usage:
        - To create a new HTTP logger: call with verb="create", label="logger label", workspace_id=<optional workspace id>.
        - To delete an HTTP logger: call with verb="delete", logger_id=<logger id>.
        - To clear all data for a logger: call with verb="clear", logger_id=<logger id>.

        Only set the parameters required for the verb you use.

        Args:
            verb: The action to perform. Must be one of: create, delete, clear.
            label: The label for the logger (required for create).
            logger_id: The ID of the logger (required for delete and clear).
            workspace_id: The workspace to associate with the logger (optional for create).
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        if verb == "create":
            if not label:
                return "Missing label for logger creation."
            res = ptt.api.create_http_logger(label, workspace_id, headers=headers)
        elif verb == "delete":
            if not logger_id:
                return "Missing logger_id for deletion."
            res = ptt.api.delete_logger(logger_id, headers=headers)
        elif verb == "clear":
            if not logger_id:
                return "Missing logger_id for clearing data."
            res = ptt.api.clear_data_for_logger(logger_id, headers=headers)
        else:
            return f"Unknown verb: {verb}. Use one of: create, delete, clear."
        return json.dumps(res.json())

    ### Workspaces
    @mcp.tool()
    async def workspace(
        verb: Literal["create", "delete", "edit", "list", "get"],
        context: Context,
        workspace_id: int = None,
        name: str = None,
        description: str = None,
    ) -> str:
        """
        Everything you need to manage workspaces.

        Usage:
        - To create a workspace: call with verb="create", name="workspace name", description="optional description".
        - To delete a workspace: call with verb="delete", workspace_id=<id>. You will need to get the id beforehand.
        - To edit a workspace: call with verb="edit", workspace_id=<id>, name="new name" (optional), description="new description" (optional).
        - To get all workspaces: call with verb="list".
        - To get a workspace by id: call with verb="get", workspace_id=<id>.

        Only set the parameters required for the verb you use.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        if verb == "create":
            if not name:
                return "Missing workspace name for creation."
            res = ptt.api.create_workspace(name, description or "", headers=headers)
        elif verb == "delete":
            if not workspace_id:
                return "Missing workspace_id for deletion."
            res = ptt.api.delete_workspace(workspace_id, headers=headers)
        elif verb == "edit":
            if not workspace_id:
                return "Missing workspace_id for editing."
            res = ptt.api.edit_workspace(
                workspace_id, name, description, headers=headers
            )
        elif verb == "list":
            res = ptt.api.get_workspaces(headers=headers)
        elif verb == "get":
            if not workspace_id:
                return "Missing workspace_id for get."
            res = ptt.api.get_workspace_by_id(workspace_id, headers=headers)
        else:
            return f"Unknown verb: {verb}. Use one of: create, delete, edit, list, get."
        return json.dumps(res.json())

    ### Findings
    @mcp.tool()
    async def findings(
        verb: Literal["get_finding_information_by_id", "get"],
        context: Context,
        finding_id: int = None,
    ) -> str:
        """
        Manage findings in Pentest-Tools.com.

        Usage:
        - To get all findings: call with verb="get".
        - To get finding information by id: call with verb="get_finding_information_by_id"

        Only set the parameters required for the verb you use.

        Args:
            verb: The action to perform. Must be one of: import, get.
            finding_id: The id of the finding you want more information for.
            context: The MCP context object.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        if verb == "get_finding_information_by_id":
            if not finding_id:
                return "Missing finding_id for get_finding_information_by_id."
            res = ptt.api.get_finding_information_by_id(
                finding_id=finding_id, headers=headers
            )
            return json.dumps(res.json())
        elif verb == "get":
            res = ptt.api.get_findings(headers=headers)
            return json.dumps(res.json())
        else:
            return (
                f"Unknown verb: {verb}. Use one of: get_finding_information_by_id, get."
            )

    @mcp.tool()
    def import_findings(
        target_name: str,
        finding_name: str,
        workspace_id: int,
        test_description: str,
        vuln_description: str,
        vuln_risk_level: int,
        vuln_recommendation: str,
        cvss_v3: float,
        vuln_evidence: str,
        context: Context,
    ):
        """Import findings into Pentest-Tools.com.

        This is the only way to create new findings manually. Use this when you need to add findings that do not come from scans.

        The import finding call has a large number of parameters. Only some are given here, for simplicity.

        Args:
            target_name: The target of the finding we want to create
            finding_name: The name of the finding we want to create
            workspace_id: The id of the workspace associated with the finding
            test_description: The descripion of the test. This appears at the top of the section in the report. Example: "Scan results showing jQuery vulnerabilities"
            vuln_description: The description of the found vulnerability. This is the title of the vulnerability. Example: "We noticed known vulnerabilities in the target application."
            vuln_risk_level: The risk level of the vulnerability. This is a degree between 1 and 5, with 1 being info and 5 being critical. Example: 2
            vuln_recommendation: This is the recommended action to take, in order to mitigate the vulnerability. Example: "Update jQuery to the latest version."
            cvss_v3: The CVSS v3 score of the vulnerability. Example: 9.2
            vuln_evidence: The evidence that proves the vulnerability is present. Example: "Evidence"
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        res = ptt.api.import_findings(
            target_name=target_name,
            finding_name=finding_name,
            workspace_id=workspace_id,
            test_description=test_description,
            vuln_description=vuln_description,
            vuln_risk_level=vuln_risk_level,
            vuln_recommendation=vuln_recommendation,
            cvss_v3=cvss_v3,
            vuln_evidence=vuln_evidence,
            headers=headers,
        )
        return json.dumps(res.json())


def entrypoint(mcp_method: str = "stdio"):
    """Entrypoint for ptt-mcp"""
    global MCP_METHOD

    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    if FastMCP is None:
        logging.error(
            "PentestTools has been installed without MCP support. Install with pip install PentestTools[mcp] if you want MCP support."
        )
        return

    logging.info("Starting the PentestTools MCP server")
    if mcp_method == "stdio":
        logging.info("Using the `stdio` mcp type")
        MCP_METHOD = "stdio"

        # Get the api key for stdio
        if not getattr(ptt.api, "api_key", False):
            api_key = os.getenv("PTT_KEY", "")
            if not api_key:
                sys.exit(
                    "API key not found. Please provide it using the --key flag or set the PTT_KEY environment variable."
                )

            ptt.api.api_key = api_key

        ptt.api.init()  # This call sets the given key

        return mcp.run(transport="stdio")
    elif mcp_method == "http":
        logging.info("Using the `http` mcp type")
        MCP_METHOD = "http"
        return mcp.run(transport="streamable-http")
