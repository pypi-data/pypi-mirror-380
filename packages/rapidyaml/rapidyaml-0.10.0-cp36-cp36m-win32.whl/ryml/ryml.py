# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ryml
else:
    import _ryml

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def parse_csubstr(s, t):
    return _ryml.parse_csubstr(s, t)

def parse_substr(s, t):
    return _ryml.parse_substr(s, t)

def emit_yaml_malloc(t, id):
    return _ryml.emit_yaml_malloc(t, id)

def emit_json_malloc(t, id):
    return _ryml.emit_json_malloc(t, id)

def emit_yaml_length(t, id):
    return _ryml.emit_yaml_length(t, id)

def emit_json_length(t, id):
    return _ryml.emit_json_length(t, id)

def emit_yaml_to_substr(t, id, s):
    return _ryml.emit_yaml_to_substr(t, id, s)

def emit_json_to_substr(t, id, s):
    return _ryml.emit_json_to_substr(t, id, s)

def _get_as_csubstr(s):
    return _ryml._get_as_csubstr(s)

def _get_as_substr(s):
    return _ryml._get_as_substr(s)

def _same_ptr(l, r):
    return _ryml._same_ptr(l, r)

def _same_mem(l, r):
    return _ryml._same_mem(l, r)


from deprecation import deprecated


def as_csubstr(s):
    """return as a ryml::csubstr"""
    return _get_as_csubstr(s)

def as_substr(s):
    """return as a ryml::ssubstr"""
    return _get_as_substr(s)

def u(memview):
    """return memview as a utf8"""
    return str(memview, "utf8")


def children(tree, node=None):
    """walk (non-recursively) the children of a node"""
    assert tree is not None
    if node is None:
        node = tree.root_id()
    ch = tree.first_child(node)
    while ch != NONE:
        yield ch
        ch = tree.next_sibling(ch)


def siblings(tree, node):
    """walk (non-recursively) the siblings of a node"""
    assert tree is not None
    if node is None:
        return
    ch = tree.first_sibling(node)
    while ch != NONE:
        yield ch
        ch = tree.next_sibling(ch)


def walk(tree, node=None, depth=0):
    """walk recursively starting at a node, returning a tuple of node and depth"""
    assert tree is not None
    if node is None:
        node = tree.root_id()
    yield node, depth
    ch = tree.first_child(node)
    while ch != NONE:
       for gc, il in walk(tree, ch, depth + 1):
           yield gc, il
       ch = tree.next_sibling(ch)


@deprecated(deprecated_in="0.5.0", details="Use parse_in_arena() instead")
def parse(buf, **kwargs):
    return parse_in_arena(tree, id)

def parse_in_arena(buf, tree=None):
    """parse immutable YAML in the trees arena. Copy the YAML into a buffer
    in the C++ tree's arena, then parse the YAML from the trees arena.

    :param buf:
       the YAML buffer to be parsed
    :type buf: ``str``, ``bytes``, ``bytearray`` or ``memoryview``

    :param tree:
       a tree to be reused. When no tree is given, a new tree is created,
       and returned at the end.
    :type buf: ``ryml.Tree``
    """
    return _call_parse(parse_csubstr, buf, tree)

def parse_in_place(buf, tree=None):
    """parse in place a mutable buffer containing YAML. The resulting tree
    will point into the given buffer.

    :param buf:
       the YAML buffer to be parsed
    :type buf:
       ``bytearray`` or ``memoryview`` (NOT ``str`` or ``bytes``, which are not writeable)

    :param tree:
       a tree to be reused. When no tree is given, a new tree is created,
       and returned at the end.
    :type buf: ``ryml.Tree``
    """
    _check_valid_for_in_place(buf)
    return _call_parse(parse_substr, buf, tree)



def _call_parse(parse_fn, buf, tree):
    if tree is None:
        tree = Tree()
    parse_fn(buf, tree)
    return tree


def _check_valid_for_in_place(obj):
    if type(obj) in (str, bytes):  # is there a better heuristic?
        raise TypeError("cannot parse in place: " + type(obj).__name__)



@deprecated(deprecated_in="0.5.0", details="Use emit_yaml() instead")
def emit(tree, id=None):
    return emit_yaml(tree, id)

def emit_yaml(tree, id=None):
    """emit the given tree as YAML, creating a new output buffer"""
    if id is None:
        id = tree.root_id()
    return emit_yaml_malloc(tree, id)

def emit_json(tree, id=None):
    """emit the given tree as JSON, creating a new output buffer"""
    if id is None:
        id = tree.root_id()
    return emit_json_malloc(tree, id)


@deprecated(deprecated_in="0.5.0", details="Use compute_emit_yaml_length() instead")
def compute_emit_length(tree, id=None):
    return compute_emit_yaml_length(tree, id)

def compute_emit_yaml_length(tree, id=None):
    if id is None:
        id = tree.root_id()
    return emit_yaml_length(tree, id)

def compute_emit_json_length(tree, id=None):
    if id is None:
        id = tree.root_id()
    return emit_json_length(tree, id)


@deprecated(deprecated_in="0.5.0", details="Use emit_yaml_in_place() instead")
def emit_in_place(tree, buf, id=None):
    return emit_yaml_in_place(tree, buf, id)

def emit_yaml_in_place(tree, buf, id=None):
    return _emit_fn_in_place(tree, buf, id, emit_yaml_to_substr)

def emit_json_in_place(tree, buf, id=None):
    return _emit_fn_in_place(tree, buf, id, emit_json_to_substr)

def _emit_fn_in_place(tree, buf, id, fn):
    if id is None:
        id = tree.root_id()
    (failed, expected_size) = fn(tree, id, buf)
    if failed:
        raise IndexError("Output buffer has {} bytes, but emit requires {} bytes".format(
            len(buf), expected_size))
    return memoryview(buf)[:expected_size]


NOTYPE = _ryml.NOTYPE
VAL = _ryml.VAL
KEY = _ryml.KEY
MAP = _ryml.MAP
SEQ = _ryml.SEQ
DOC = _ryml.DOC
STREAM = _ryml.STREAM
KEYREF = _ryml.KEYREF
VALREF = _ryml.VALREF
KEYANCH = _ryml.KEYANCH
VALANCH = _ryml.VALANCH
KEYTAG = _ryml.KEYTAG
VALTAG = _ryml.VALTAG
KEY_UNFILT = _ryml.KEY_UNFILT
VAL_UNFILT = _ryml.VAL_UNFILT
FLOW_SL = _ryml.FLOW_SL
FLOW_ML = _ryml.FLOW_ML
BLOCK = _ryml.BLOCK
KEY_LITERAL = _ryml.KEY_LITERAL
VAL_LITERAL = _ryml.VAL_LITERAL
KEY_FOLDED = _ryml.KEY_FOLDED
VAL_FOLDED = _ryml.VAL_FOLDED
KEY_SQUO = _ryml.KEY_SQUO
VAL_SQUO = _ryml.VAL_SQUO
KEY_DQUO = _ryml.KEY_DQUO
VAL_DQUO = _ryml.VAL_DQUO
KEY_PLAIN = _ryml.KEY_PLAIN
VAL_PLAIN = _ryml.VAL_PLAIN
KEYVAL = _ryml.KEYVAL
KEYSEQ = _ryml.KEYSEQ
KEYMAP = _ryml.KEYMAP
DOCMAP = _ryml.DOCMAP
DOCSEQ = _ryml.DOCSEQ
DOCVAL = _ryml.DOCVAL
SCALAR_LITERAL = _ryml.SCALAR_LITERAL
SCALAR_FOLDED = _ryml.SCALAR_FOLDED
SCALAR_SQUO = _ryml.SCALAR_SQUO
SCALAR_DQUO = _ryml.SCALAR_DQUO
SCALAR_PLAIN = _ryml.SCALAR_PLAIN
KEYQUO = _ryml.KEYQUO
VALQUO = _ryml.VALQUO
KEY_STYLE = _ryml.KEY_STYLE
VAL_STYLE = _ryml.VAL_STYLE
SCALAR_STYLE = _ryml.SCALAR_STYLE
CONTAINER_STYLE_FLOW = _ryml.CONTAINER_STYLE_FLOW
CONTAINER_STYLE_BLOCK = _ryml.CONTAINER_STYLE_BLOCK
CONTAINER_STYLE = _ryml.CONTAINER_STYLE
STYLE = _ryml.STYLE

def __or__(lhs, rhs):
    return _ryml.__or__(lhs, rhs)

def __and__(lhs, rhs):
    return _ryml.__and__(lhs, rhs)

def __rshift__(bits, n):
    return _ryml.__rshift__(bits, n)

def __lshift__(bits, n):
    return _ryml.__lshift__(bits, n)

def __invert__(bits):
    return _ryml.__invert__(bits)

def __iand__(subject, bits):
    return _ryml.__iand__(subject, bits)

def __ior__(subject, bits):
    return _ryml.__ior__(subject, bits)
class NodeType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_ryml.NodeType_type_get, _ryml.NodeType_type_set)

    def __init__(self, *args):
        _ryml.NodeType_swiginit(self, _ryml.new_NodeType(*args))

    def has_any(self, t):
        return _ryml.NodeType_has_any(self, t)

    def has_all(self, t):
        return _ryml.NodeType_has_all(self, t)

    def has_none(self, t):
        return _ryml.NodeType_has_none(self, t)

    def set(self, t):
        return _ryml.NodeType_set(self, t)

    def add(self, t):
        return _ryml.NodeType_add(self, t)

    def rem(self, t):
        return _ryml.NodeType_rem(self, t)

    def addrem(self, bits_to_add, bits_to_remove):
        return _ryml.NodeType_addrem(self, bits_to_add, bits_to_remove)

    def clear(self):
        return _ryml.NodeType_clear(self)

    @staticmethod
    def type_str(*args):
        return _ryml.NodeType_type_str(*args)

    def is_notype(self):
        return _ryml.NodeType_is_notype(self)

    def is_stream(self):
        return _ryml.NodeType_is_stream(self)

    def is_doc(self):
        return _ryml.NodeType_is_doc(self)

    def is_container(self):
        return _ryml.NodeType_is_container(self)

    def is_map(self):
        return _ryml.NodeType_is_map(self)

    def is_seq(self):
        return _ryml.NodeType_is_seq(self)

    def has_key(self):
        return _ryml.NodeType_has_key(self)

    def has_val(self):
        return _ryml.NodeType_has_val(self)

    def is_val(self):
        return _ryml.NodeType_is_val(self)

    def is_keyval(self):
        return _ryml.NodeType_is_keyval(self)

    def has_key_tag(self):
        return _ryml.NodeType_has_key_tag(self)

    def has_val_tag(self):
        return _ryml.NodeType_has_val_tag(self)

    def has_key_anchor(self):
        return _ryml.NodeType_has_key_anchor(self)

    def has_val_anchor(self):
        return _ryml.NodeType_has_val_anchor(self)

    def has_anchor(self):
        return _ryml.NodeType_has_anchor(self)

    def is_key_ref(self):
        return _ryml.NodeType_is_key_ref(self)

    def is_val_ref(self):
        return _ryml.NodeType_is_val_ref(self)

    def is_ref(self):
        return _ryml.NodeType_is_ref(self)

    def is_key_unfiltered(self):
        return _ryml.NodeType_is_key_unfiltered(self)

    def is_val_unfiltered(self):
        return _ryml.NodeType_is_val_unfiltered(self)

    def is_container_styled(self):
        return _ryml.NodeType_is_container_styled(self)

    def is_block(self):
        return _ryml.NodeType_is_block(self)

    def is_flow_sl(self):
        return _ryml.NodeType_is_flow_sl(self)

    def is_flow_ml(self):
        return _ryml.NodeType_is_flow_ml(self)

    def is_flow(self):
        return _ryml.NodeType_is_flow(self)

    def is_key_styled(self):
        return _ryml.NodeType_is_key_styled(self)

    def is_val_styled(self):
        return _ryml.NodeType_is_val_styled(self)

    def is_key_literal(self):
        return _ryml.NodeType_is_key_literal(self)

    def is_val_literal(self):
        return _ryml.NodeType_is_val_literal(self)

    def is_key_folded(self):
        return _ryml.NodeType_is_key_folded(self)

    def is_val_folded(self):
        return _ryml.NodeType_is_val_folded(self)

    def is_key_squo(self):
        return _ryml.NodeType_is_key_squo(self)

    def is_val_squo(self):
        return _ryml.NodeType_is_val_squo(self)

    def is_key_dquo(self):
        return _ryml.NodeType_is_key_dquo(self)

    def is_val_dquo(self):
        return _ryml.NodeType_is_val_dquo(self)

    def is_key_plain(self):
        return _ryml.NodeType_is_key_plain(self)

    def is_val_plain(self):
        return _ryml.NodeType_is_val_plain(self)

    def is_key_quoted(self):
        return _ryml.NodeType_is_key_quoted(self)

    def is_val_quoted(self):
        return _ryml.NodeType_is_val_quoted(self)

    def is_quoted(self):
        return _ryml.NodeType_is_quoted(self)

    def set_container_style(self, style):
        return _ryml.NodeType_set_container_style(self, style)

    def set_key_style(self, style):
        return _ryml.NodeType_set_key_style(self, style)

    def set_val_style(self, style):
        return _ryml.NodeType_set_val_style(self, style)
    __swig_destroy__ = _ryml.delete_NodeType

# Register NodeType in _ryml:
_ryml.NodeType_swigregister(NodeType)
cvar = _ryml.cvar
NONE = cvar.NONE

class Tree(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _ryml.Tree_swiginit(self, _ryml.new_Tree())
    __swig_destroy__ = _ryml.delete_Tree

    def reserve(self, node_capacity):
        return _ryml.Tree_reserve(self, node_capacity)

    def reserve_arena(self, arena_capacity):
        return _ryml.Tree_reserve_arena(self, arena_capacity)

    def clear(self):
        return _ryml.Tree_clear(self)

    def clear_arena(self):
        return _ryml.Tree_clear_arena(self)

    def empty(self):
        return _ryml.Tree_empty(self)

    def size(self):
        return _ryml.Tree_size(self)

    def capacity(self):
        return _ryml.Tree_capacity(self)

    def slack(self):
        return _ryml.Tree_slack(self)

    def arena_size(self):
        return _ryml.Tree_arena_size(self)

    def arena_capacity(self):
        return _ryml.Tree_arena_capacity(self)

    def arena_slack(self):
        return _ryml.Tree_arena_slack(self)

    def resolve(self):
        return _ryml.Tree_resolve(self)

    def type(self, node):
        return _ryml.Tree_type(self, node)

    def type_str(self, node):
        return _ryml.Tree_type_str(self, node)

    def key(self, node):
        return _ryml.Tree_key(self, node)

    def key_tag(self, node):
        return _ryml.Tree_key_tag(self, node)

    def key_ref(self, node):
        return _ryml.Tree_key_ref(self, node)

    def key_anchor(self, node):
        return _ryml.Tree_key_anchor(self, node)

    def keysc(self, node):
        return _ryml.Tree_keysc(self, node)

    def val(self, node):
        return _ryml.Tree_val(self, node)

    def val_tag(self, node):
        return _ryml.Tree_val_tag(self, node)

    def val_ref(self, node):
        return _ryml.Tree_val_ref(self, node)

    def val_anchor(self, node):
        return _ryml.Tree_val_anchor(self, node)

    def valsc(self, node):
        return _ryml.Tree_valsc(self, node)

    def type_has_any(self, node, bits):
        return _ryml.Tree_type_has_any(self, node, bits)

    def type_has_all(self, node, bits):
        return _ryml.Tree_type_has_all(self, node, bits)

    def type_has_none(self, node, bits):
        return _ryml.Tree_type_has_none(self, node, bits)

    def is_stream(self, node):
        return _ryml.Tree_is_stream(self, node)

    def is_doc(self, node):
        return _ryml.Tree_is_doc(self, node)

    def is_container(self, node):
        return _ryml.Tree_is_container(self, node)

    def is_map(self, node):
        return _ryml.Tree_is_map(self, node)

    def is_seq(self, node):
        return _ryml.Tree_is_seq(self, node)

    def has_key(self, node):
        return _ryml.Tree_has_key(self, node)

    def has_val(self, node):
        return _ryml.Tree_has_val(self, node)

    def is_val(self, node):
        return _ryml.Tree_is_val(self, node)

    def is_keyval(self, node):
        return _ryml.Tree_is_keyval(self, node)

    def has_key_tag(self, node):
        return _ryml.Tree_has_key_tag(self, node)

    def has_val_tag(self, node):
        return _ryml.Tree_has_val_tag(self, node)

    def has_key_anchor(self, node):
        return _ryml.Tree_has_key_anchor(self, node)

    def has_val_anchor(self, node):
        return _ryml.Tree_has_val_anchor(self, node)

    def is_key_ref(self, node):
        return _ryml.Tree_is_key_ref(self, node)

    def is_val_ref(self, node):
        return _ryml.Tree_is_val_ref(self, node)

    def is_ref(self, node):
        return _ryml.Tree_is_ref(self, node)

    def parent_is_seq(self, node):
        return _ryml.Tree_parent_is_seq(self, node)

    def parent_is_map(self, node):
        return _ryml.Tree_parent_is_map(self, node)

    def has_anchor(self, *args):
        return _ryml.Tree_has_anchor(self, *args)

    def key_is_null(self, node):
        return _ryml.Tree_key_is_null(self, node)

    def val_is_null(self, node):
        return _ryml.Tree_val_is_null(self, node)

    def is_root(self, node):
        return _ryml.Tree_is_root(self, node)

    def has_parent(self, node):
        return _ryml.Tree_has_parent(self, node)

    def has_child(self, node, key):
        return _ryml.Tree_has_child(self, node, key)

    def has_children(self, node):
        return _ryml.Tree_has_children(self, node)

    def has_sibling(self, node, key):
        return _ryml.Tree_has_sibling(self, node, key)

    def has_other_siblings(self, node):
        return _ryml.Tree_has_other_siblings(self, node)

    def root_id(self):
        return _ryml.Tree_root_id(self)

    def parent(self, node):
        return _ryml.Tree_parent(self, node)

    def prev_sibling(self, node):
        return _ryml.Tree_prev_sibling(self, node)

    def next_sibling(self, node):
        return _ryml.Tree_next_sibling(self, node)

    def num_children(self, node):
        return _ryml.Tree_num_children(self, node)

    def child_pos(self, node, ch):
        return _ryml.Tree_child_pos(self, node, ch)

    def first_child(self, node):
        return _ryml.Tree_first_child(self, node)

    def last_child(self, node):
        return _ryml.Tree_last_child(self, node)

    def child(self, node, pos):
        return _ryml.Tree_child(self, node, pos)

    def find_child(self, node, key):
        return _ryml.Tree_find_child(self, node, key)

    def num_siblings(self, node):
        return _ryml.Tree_num_siblings(self, node)

    def num_other_siblings(self, node):
        return _ryml.Tree_num_other_siblings(self, node)

    def sibling_pos(self, node, sib):
        return _ryml.Tree_sibling_pos(self, node, sib)

    def first_sibling(self, node):
        return _ryml.Tree_first_sibling(self, node)

    def last_sibling(self, node):
        return _ryml.Tree_last_sibling(self, node)

    def sibling(self, node, pos):
        return _ryml.Tree_sibling(self, node, pos)

    def find_sibling(self, node, key):
        return _ryml.Tree_find_sibling(self, node, key)

    def is_container_styled(self, node):
        return _ryml.Tree_is_container_styled(self, node)

    def is_block(self, node):
        return _ryml.Tree_is_block(self, node)

    def is_flow_sl(self, node):
        return _ryml.Tree_is_flow_sl(self, node)

    def is_flow_ml(self, node):
        return _ryml.Tree_is_flow_ml(self, node)

    def is_flow(self, node):
        return _ryml.Tree_is_flow(self, node)

    def is_key_styled(self, node):
        return _ryml.Tree_is_key_styled(self, node)

    def is_val_styled(self, node):
        return _ryml.Tree_is_val_styled(self, node)

    def is_key_literal(self, node):
        return _ryml.Tree_is_key_literal(self, node)

    def is_val_literal(self, node):
        return _ryml.Tree_is_val_literal(self, node)

    def is_key_folded(self, node):
        return _ryml.Tree_is_key_folded(self, node)

    def is_val_folded(self, node):
        return _ryml.Tree_is_val_folded(self, node)

    def is_key_squo(self, node):
        return _ryml.Tree_is_key_squo(self, node)

    def is_val_squo(self, node):
        return _ryml.Tree_is_val_squo(self, node)

    def is_key_dquo(self, node):
        return _ryml.Tree_is_key_dquo(self, node)

    def is_val_dquo(self, node):
        return _ryml.Tree_is_val_dquo(self, node)

    def is_key_plain(self, node):
        return _ryml.Tree_is_key_plain(self, node)

    def is_val_plain(self, node):
        return _ryml.Tree_is_val_plain(self, node)

    def is_key_quoted(self, node):
        return _ryml.Tree_is_key_quoted(self, node)

    def is_val_quoted(self, node):
        return _ryml.Tree_is_val_quoted(self, node)

    def is_quoted(self, node):
        return _ryml.Tree_is_quoted(self, node)

    def set_container_style(self, node, style):
        return _ryml.Tree_set_container_style(self, node, style)

    def set_key_style(self, node, style):
        return _ryml.Tree_set_key_style(self, node, style)

    def set_val_style(self, node, style):
        return _ryml.Tree_set_val_style(self, node, style)

    def to_keyval(self, node, key, val, more_flags=0):
        return _ryml.Tree_to_keyval(self, node, key, val, more_flags)

    def to_val(self, node, val, more_flags=0):
        return _ryml.Tree_to_val(self, node, val, more_flags)

    def to_stream(self, node, more_flags=0):
        return _ryml.Tree_to_stream(self, node, more_flags)

    def to_map(self, *args):
        return _ryml.Tree_to_map(self, *args)

    def to_seq(self, *args):
        return _ryml.Tree_to_seq(self, *args)

    def to_doc(self, node, more_flags=0):
        return _ryml.Tree_to_doc(self, node, more_flags)

    def set_key_tag(self, node, tag):
        return _ryml.Tree_set_key_tag(self, node, tag)

    def set_key_anchor(self, node, anchor):
        return _ryml.Tree_set_key_anchor(self, node, anchor)

    def set_val_anchor(self, node, anchor):
        return _ryml.Tree_set_val_anchor(self, node, anchor)

    def set_key_ref(self, node, ref):
        return _ryml.Tree_set_key_ref(self, node, ref)

    def set_val_ref(self, node, ref):
        return _ryml.Tree_set_val_ref(self, node, ref)

    def _set_key(self, node, key, more_flags=0):
        return _ryml.Tree__set_key(self, node, key, more_flags)

    def _set_val(self, node, val, more_flags=0):
        return _ryml.Tree__set_val(self, node, val, more_flags)

    def set_val_tag(self, node, tag):
        return _ryml.Tree_set_val_tag(self, node, tag)

    def rem_key_anchor(self, node):
        return _ryml.Tree_rem_key_anchor(self, node)

    def rem_val_anchor(self, node):
        return _ryml.Tree_rem_val_anchor(self, node)

    def rem_key_ref(self, node):
        return _ryml.Tree_rem_key_ref(self, node)

    def rem_val_ref(self, node):
        return _ryml.Tree_rem_val_ref(self, node)

    def rem_anchor_ref(self, node):
        return _ryml.Tree_rem_anchor_ref(self, node)

    def insert_child(self, parent, after):
        return _ryml.Tree_insert_child(self, parent, after)

    def prepend_child(self, parent):
        return _ryml.Tree_prepend_child(self, parent)

    def append_child(self, parent):
        return _ryml.Tree_append_child(self, parent)

    def insert_sibling(self, node, after):
        return _ryml.Tree_insert_sibling(self, node, after)

    def prepend_sibling(self, node):
        return _ryml.Tree_prepend_sibling(self, node)

    def append_sibling(self, node):
        return _ryml.Tree_append_sibling(self, node)

    def remove(self, node):
        return _ryml.Tree_remove(self, node)

    def remove_children(self, node):
        return _ryml.Tree_remove_children(self, node)

    def reorder(self):
        return _ryml.Tree_reorder(self)

    def move(self, *args):
        return _ryml.Tree_move(self, *args)

    def duplicate(self, *args):
        return _ryml.Tree_duplicate(self, *args)

    def duplicate_children(self, *args):
        return _ryml.Tree_duplicate_children(self, *args)

    def duplicate_contents(self, node, where):
        return _ryml.Tree_duplicate_contents(self, node, where)

    def duplicate_children_no_rep(self, node, parent, after):
        return _ryml.Tree_duplicate_children_no_rep(self, node, parent, after)

# Register Tree in _ryml:
_ryml.Tree_swigregister(Tree)

