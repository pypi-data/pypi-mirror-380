name: Publish

on:
  push:
    tags:
      - "*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to generate changelog for and publish'
        required: true
        type: string

jobs:
  test:
    uses: ./.github/workflows/test.yml

  update-changelog:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.11"
        
    - name: Install uv
      uses: astral-sh/setup-uv@v5
      with:
        enable-cache: true
        
    - name: Update requirements.txt
      run: |
        echo "# This file was autogenerated by uv via the following command:" > requirements.txt
        echo "#    uv export --all-extras --no-hashes --format requirements-txt" >> requirements.txt
        uv export --all-extras --no-hashes --format requirements-txt >> requirements.txt

    - name: Get tag name
      id: get_tag
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "tag=${{ inputs.tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        fi

    - name: Get previous tag
      id: get_previous_tag
      run: |
        PREV_TAG=$(git describe --tags --abbrev=0 ${{ steps.get_tag.outputs.tag }}^ 2>/dev/null || echo "")
        echo "previous_tag=$PREV_TAG" >> $GITHUB_OUTPUT
        echo "Previous tag: $PREV_TAG"

    - name: Generate changelog entry
      id: generate_changelog
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CURRENT_TAG: ${{ steps.get_tag.outputs.tag }}
        PREVIOUS_TAG: ${{ steps.get_previous_tag.outputs.previous_tag }}
      run: |
        echo "Generating changelog for $CURRENT_TAG"
        
        # Get the date for the current tag
        TAG_DATE=$(git log -1 --format=%cd --date=short $CURRENT_TAG 2>/dev/null || date +%Y-%m-%d)
        
        # Create temporary file for the new changelog entry
        NEW_ENTRY_FILE=$(mktemp)
        
        # Header for the new version
        echo "## [$CURRENT_TAG] - $TAG_DATE" > $NEW_ENTRY_FILE
        echo "" >> $NEW_ENTRY_FILE
        
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "Getting PRs merged between $PREVIOUS_TAG and $CURRENT_TAG"
          
          # Get the date of the previous tag for API filtering (use unix timestamp for easier comparison)
          PREV_TAG_DATE=$(git log -1 --format=%ct $PREVIOUS_TAG 2>/dev/null)
          CURRENT_TAG_DATE=$(git log -1 --format=%ct $CURRENT_TAG 2>/dev/null)
          
          echo "Previous tag date: $PREV_TAG_DATE"
          echo "Current tag date: $CURRENT_TAG_DATE"
          
          # Get merged PRs in the date range using GitHub API
          if [ -n "$PREV_TAG_DATE" ] && [ -n "$CURRENT_TAG_DATE" ]; then
            echo "Fetching merged PRs from GitHub API..."
            
            # Use GitHub CLI to get merged PRs and filter by date using shell
            TEMP_PR_FILE=$(mktemp)
            gh api graphql \
              -f query='
                query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequests(states: MERGED, first: 100, orderBy: {field: UPDATED_AT, direction: DESC}) {
                      edges {
                        node {
                          number
                          title
                          author {
                            login
                          }
                          url
                          mergedAt
                        }
                      }
                    }
                  }
                }' \
              -f owner="${{ github.repository_owner }}" \
              -f repo="${{ github.event.repository.name }}" \
              -q '.data.repository.pullRequests.edges[].node | "- " + .title + " ([#" + (.number | tostring) + "](" + .url + ")) by @" + .author.login + "|" + .mergedAt' > $TEMP_PR_FILE
            
            # Filter PRs by date range and format output  
            while IFS='|' read -r pr_line merge_date; do
              if [[ -n "$merge_date" && -n "$PREV_TAG_DATE" && -n "$CURRENT_TAG_DATE" ]]; then
                # Convert GitHub API date to unix timestamp for comparison
                merge_timestamp=$(date -d "$merge_date" +%s 2>/dev/null || echo "0")
                if [[ "$merge_timestamp" -ge "$PREV_TAG_DATE" && "$merge_timestamp" -le "$CURRENT_TAG_DATE" ]]; then
                  echo "$pr_line" >> $NEW_ENTRY_FILE
                fi
              fi
            done < $TEMP_PR_FILE
            
            rm -f $TEMP_PR_FILE
          fi
          
          # If no PRs found, fall back to commit messages
          if ! grep -q "^-" $NEW_ENTRY_FILE; then
            echo "No PRs found in commit range, using commit messages instead"
            git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges >> $NEW_ENTRY_FILE
          fi
          
        else
          echo "- Initial release" >> $NEW_ENTRY_FILE
        fi
        
        echo "" >> $NEW_ENTRY_FILE
        
        # Store the new entry file path
        echo "new_entry_file=$NEW_ENTRY_FILE" >> $GITHUB_OUTPUT

    - name: Update CHANGELOG.md
      run: |
        NEW_ENTRY_FILE="${{ steps.generate_changelog.outputs.new_entry_file }}"
        
        if [ -f "CHANGELOG.md" ]; then
          # Create temporary file for updated changelog
          TEMP_CHANGELOG=$(mktemp)
          
          # Find the line with "## [Unreleased]" and add new entry after it
          awk '
            /^## \[Unreleased\]/ {
              print $0
              print ""
              while ((getline line < "'"$NEW_ENTRY_FILE"'") > 0) {
                print line
              }
              next
            }
            { print }
          ' CHANGELOG.md > $TEMP_CHANGELOG
          
          # Replace original with updated version
          mv $TEMP_CHANGELOG CHANGELOG.md
          
          # Clean up
          rm -f $NEW_ENTRY_FILE
          
        else
          echo "Warning: CHANGELOG.md not found, creating new one"
          cat > CHANGELOG.md << 'EOF'
        # Changelog

        All notable changes to this project will be documented in this file.

        The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
        and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

        ## [Unreleased]

        - Upcoming features and fixes

        EOF
          cat $NEW_ENTRY_FILE >> CHANGELOG.md
          rm -f $NEW_ENTRY_FILE
        fi

    - name: Commit changelog and requirements updates
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        git config --local user.name "github-actions[bot]"
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        
        # Switch to main branch and pull latest changes
        git checkout main
        git pull origin main
        
        # Check if there are any changes to commit
        if git diff --quiet CHANGELOG.md requirements.txt; then
          echo "No changes to CHANGELOG.md or requirements.txt"
        else
          git add CHANGELOG.md requirements.txt
          
          # Create commit message based on what changed
          COMMIT_MSG="docs: update for ${{ steps.get_tag.outputs.tag }}"
          if ! git diff --quiet --cached CHANGELOG.md; then
            COMMIT_MSG="$COMMIT_MSG (CHANGELOG.md"
            if ! git diff --quiet --cached requirements.txt; then
              COMMIT_MSG="$COMMIT_MSG, requirements.txt)"
            else
              COMMIT_MSG="$COMMIT_MSG)"
            fi
          elif ! git diff --quiet --cached requirements.txt; then
            COMMIT_MSG="$COMMIT_MSG (requirements.txt)"
          fi
          
          git commit -m "$COMMIT_MSG"
          git push origin main
          echo "‚úÖ Files updated and pushed to main branch"
        fi

  build:
    name: Build distribution üì¶
    needs: update-changelog
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        ref: ${{ github.ref }}
        fetch-depth: 0
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.11"
    - name: Install pypa/build
      run: python3 -m pip install build --user
    - name: Build a binary wheel and a source tarball
      run: python3 -m build
    - name: Store the distribution packages
      uses: actions/upload-artifact@v4
      with:
        name: python-package-distributions
        path: dist/

  publish-to-testpypi:
    name: Publish Python üêç distribution üì¶ to TestPyPI
    needs:
      - build
    runs-on: ubuntu-latest

    environment:
      name: testpypi
      url: https://test.pypi.org/p/xopr

    permissions:
      id-token: write

    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distribution üì¶ to TestPyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        repository-url: https://test.pypi.org/legacy/
        verbose: true

  publish-to-pypi:
    name: Publish Python üêç distribution üì¶ to PyPI
    needs:
      - publish-to-testpypi
    runs-on: ubuntu-latest
    
    environment:
      name: pypi
      url: https://pypi.org/p/xopr
      
    permissions:
      id-token: write

    steps:
    - name: Download all the dists
      uses: actions/download-artifact@v4
      with:
        name: python-package-distributions
        path: dist/
    - name: Publish distribution üì¶ to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1

  github-release:
    name: Create GitHub Release with source code
    needs:
      - publish-to-pypi
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main
        fetch-depth: 0
    - name: Get tag name
      id: get_tag
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "tag=${{ inputs.tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        fi
    - name: Create GitHub Release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Create release with changelog notes
        TAG_NAME="${{ steps.get_tag.outputs.tag }}"
        
        # Get the section for this release from CHANGELOG.md
        awk "/^## \[$TAG_NAME\]/, /^## \[.*\]/ {
          if (/^## \[$TAG_NAME\]/) { found=1; print; next }
          if (/^## \[.*\]/ && found) { exit }
          if (found) print
        }" CHANGELOG.md > release_notes.md
        
        # Remove trailing empty lines
        sed -i '/^$/N;/^\n$/d' release_notes.md
        
        # Add installation instructions
        echo "" >> release_notes.md
        echo "## Installation" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "pip install xopr==$TAG_NAME" >> release_notes.md
        echo '```' >> release_notes.md
        
        gh release create "$TAG_NAME" \
          --repo '${{ github.repository }}' \
          --title "Release $TAG_NAME" \
          --notes-file release_notes.md || echo "Release already exists"
