<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Polar Map Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/ol@10.2.1/dist/ol.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@10.2.1/ol.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.11.0/proj4.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map { 
            width: 100%; 
            height: 600px;
        }
        .map-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
        }
        .cors-status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 11px;
            z-index: 1000;
            display: none;
        }
        .cors-status.visible { display: block; }
        .cors-status.success { border-left: 3px solid #28a745; }
        .cors-status.proxy { border-left: 3px solid #ffc107; }
        .cors-status.error { border-left: 3px solid #dc3545; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="map-info" id="info">Click on features for details</div>
    <div class="cors-status" id="corsStatus"></div>
    
    <script type="module">
        // Load WASM modules from Google Cloud Storage to avoid path resolution issues
        // Local files are at: src/xopr/map/parquet_wasm.js and src/xopr/map/parquet_wasm_bg.wasm
        console.log('Loading WASM module from GCS');
        const { default: init, readParquet } = await import('https://storage.googleapis.com/opr_test_dataset_1/parquet_wasm.js');
        import * as arrow from 'https://cdn.jsdelivr.net/npm/apache-arrow@14.0.2/+esm';
        
        // Parse S3 URLs and convert to HTTP URLs (define this before parseConfigFromURL)
        function parseS3Url(url) {
            if (!url) return url;
            
            // Handle s3:// URLs
            const s3Match = url.match(/^s3:\/\/([^\/]+)\/(.*)$/);
            if (s3Match) {
                const bucket = s3Match[1];
                const key = s3Match[2];
                // Try to use the S3 HTTP URL format
                return `https://${bucket}.s3.amazonaws.com/${key}`;
            }
            
            // Handle S3 ARN format
            const arnMatch = url.match(/^arn:aws:s3:::([^\/]+)\/(.*)$/);
            if (arnMatch) {
                const bucket = arnMatch[1];
                const key = arnMatch[2];
                return `https://${bucket}.s3.amazonaws.com/${key}`;
            }
            
            // Return original URL if not S3
            return url;
        }
        
        // Parse configuration from URL parameters
        function parseConfigFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const config = {};
            
            // Get pole parameter
            if (urlParams.has('pole')) {
                config.pole = urlParams.get('pole');
            }
            
            // Get dataPath parameter (base URL for files)
            if (urlParams.has('dataPath')) {
                config.dataPath = urlParams.get('dataPath');
            }
            
            // Get fileGroups parameter (JSON array of file groups with colors)
            if (urlParams.has('fileGroups')) {
                try {
                    const groups = JSON.parse(urlParams.get('fileGroups'));
                    // Note: We'll expand wildcards later when loading files
                    config.fileGroups = groups.map(group => {
                        const processedGroup = { ...group };
                        // Process files in each group
                        if (config.dataPath && group.files) {
                            processedGroup.files = group.files.map(file => {
                                // If file is already a full URL (including S3), process it
                                if (file.startsWith('http://') || file.startsWith('https://') || file.startsWith('s3://')) {
                                    return parseS3Url(file);
                                }
                                // Otherwise, prepend the dataPath (which might be S3)
                                const basePath = parseS3Url(config.dataPath);
                                const fullBasePath = basePath.endsWith('/') ? basePath : basePath + '/';
                                return fullBasePath + file;
                            });
                        }
                        return processedGroup;
                    });
                } catch (e) {
                    console.error('Failed to parse fileGroups from URL:', e);
                    config.fileGroups = [];
                }
            } else if (urlParams.has('parquetFiles')) {
                // Fallback to old parquetFiles parameter for backward compatibility
                try {
                    const files = JSON.parse(urlParams.get('parquetFiles'));
                    // Convert to fileGroups format with default color
                    const processedFiles = files.map(file => {
                        // If file is already a full URL (including S3), process it
                        if (file.startsWith('http://') || file.startsWith('https://') || file.startsWith('s3://')) {
                            return parseS3Url(file);
                        }
                        // Otherwise, prepend the dataPath if available
                        if (config.dataPath) {
                            const basePath = parseS3Url(config.dataPath);
                            const fullBasePath = basePath.endsWith('/') ? basePath : basePath + '/';
                            return fullBasePath + file;
                        }
                        return file;
                    });
                    // Store in both formats for backward compatibility
                    config.fileGroups = [{ files: processedFiles, color: 'red' }];
                    config.parquetFiles = processedFiles;  // Keep this for backward compatibility
                } catch (e) {
                    console.error('Failed to parse parquetFiles from URL:', e);
                    config.fileGroups = [];
                }
            }
            
            // Get defaultZoom parameter
            if (urlParams.has('defaultZoom')) {
                config.defaultZoom = parseInt(urlParams.get('defaultZoom'), 10) || 3;
            }
            
            // Ensure we have at least some configuration
            if (!config.fileGroups && !config.parquetFiles) {
                console.warn('No fileGroups or parquetFiles found in URL parameters');
            }
            
            console.log('Parsed config from URL:', config);
            return config;
        }
        
        // Make CONFIG settable even before the script runs (for backwards compatibility)
        if (typeof window.CONFIG === 'undefined') {
            window.CONFIG = null;
        }
        
        // Allow parent to set CONFIG even after initialization
        let configUsed = false;
        
        // Get CONFIG from URL params or parent window
        function getConfig() {
            // First, try to get config from URL parameters
            const urlConfig = parseConfigFromURL();
            // Check if we have meaningful config (at least pole and files)
            if (urlConfig && (urlConfig.fileGroups || urlConfig.parquetFiles)) {
                console.log('Using URL parameter CONFIG:', urlConfig);
                // Set default pole if not specified
                if (!urlConfig.pole) {
                    urlConfig.pole = 'south';
                    console.log('Using default pole: south');
                }
                window.CONFIG = urlConfig;
                configUsed = true;
                return urlConfig;
            }
            
            // Fallback: Check if CONFIG was set by parent window
            if (window.CONFIG && typeof window.CONFIG === 'object') {
                console.log('Using parent-provided CONFIG:', window.CONFIG);
                configUsed = true;
                return window.CONFIG;
            }
            
            // No valid configuration found
            console.error('ERROR: No valid CONFIG provided. Map requires configuration.');
            document.getElementById('map').innerHTML = 
                '<div style="padding: 20px; text-align: center; color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; margin: 20px;">' +
                '<strong>Configuration Required</strong><br>' +
                'CONFIG must be provided via URL parameters or parent window.<br>' +
                '<code style="font-size: 11px;">URL params: ?pole=south&parquetFiles=["file.parquet"]&defaultZoom=3</code>' +
                '</div>';
            return null;
        }
        
        // Simplified wait function since URL params are available immediately
        async function waitForConfig() {
            // Check URL params first (available immediately)
            const urlConfig = parseConfigFromURL();
            if (urlConfig && (urlConfig.fileGroups || urlConfig.parquetFiles)) {
                // Set default pole if not specified
                if (!urlConfig.pole) {
                    urlConfig.pole = 'south';
                }
                return urlConfig;
            }
            
            // Give parent window a brief chance to set CONFIG
            for (let i = 0; i < 5; i++) {
                if (window.CONFIG && typeof window.CONFIG === 'object') {
                    console.log(`Parent CONFIG found after ${i * 50}ms`);
                    return window.CONFIG;
                }
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            // Final check
            return getConfig();
        }
        
        // Setup projections
        const PROJECTIONS = {
            south: {
                code: 'EPSG:3031',
                def: '+proj=stere +lat_0=-90 +lat_ts=-71 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs',
                extent: [-3369955, -3369955, 3369955, 3369955],
                wmsUrl: 'https://gibs.earthdata.nasa.gov/wms/epsg3031/best/wms.cgi',
                wmsLayer: 'BlueMarble_ShadedRelief'
            },
            north: {
                code: 'EPSG:3413',
                def: '+proj=stere +lat_0=90 +lat_ts=70 +lon_0=-45 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs',
                extent: [-4194304, -4194304, 4194304, 4194304],
                wmsUrl: 'https://gibs.earthdata.nasa.gov/wms/epsg3413/best/wms.cgi',
                wmsLayer: 'BlueMarble_ShadedRelief'
            }
        };
        
        // Initialize map and features after CONFIG is ready
        async function initializeMap() {
            const CONFIG = await waitForConfig();
            if (!CONFIG) {
                // CONFIG is required - error already displayed
                return null;
            }
            const projConfig = PROJECTIONS[CONFIG.pole];
            
            // Define projection
            proj4.defs(projConfig.code, projConfig.def);
            ol.proj.proj4.register(proj4);
            
            const projection = ol.proj.get(projConfig.code);
            projection.setExtent(projConfig.extent);
            
            // Create map
            const map = new ol.Map({
                target: 'map',
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.TileWMS({
                            url: projConfig.wmsUrl,
                            params: {
                                'LAYERS': projConfig.wmsLayer,
                                'FORMAT': 'image/jpeg',
                                'SRS': projConfig.code
                            },
                            projection: projection,
                            crossOrigin: 'anonymous'
                        })
                    })
                ],
                view: new ol.View({
                    projection: projection,
                    center: [0, 0],
                    zoom: CONFIG.defaultZoom
                })
            });
            
            return { map, projConfig, CONFIG };
        }
        
        // Initialize WKB format reader
        const wkbFormat = new ol.format.WKB();
        
        // Smart fetch with automatic CORS proxy fallback
        async function smartFetch(url, options = {}) {
            const statusEl = document.getElementById('corsStatus');
            
            // First, try direct fetch
            try {
                console.log('Attempting direct fetch:', url);
                const response = await fetch(url, {
                    ...options,
                    mode: 'cors',
                    credentials: 'omit'
                });
                
                if (response.ok) {
                    console.log('Direct fetch successful');
                    if (statusEl) {
                        statusEl.className = 'cors-status visible success';
                        statusEl.textContent = '✓ Direct';
                    }
                    return response;
                }
            } catch (error) {
                console.log('Direct fetch failed, trying proxy...', error.message);
            }
            
            // If direct fetch fails, try proxy
            try {
                const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
                console.log('Trying proxy:', proxyUrl);
                
                const response = await fetch(proxyUrl, options);
                
                if (response.ok) {
                    console.log('Proxy successful');
                    if (statusEl) {
                        statusEl.className = 'cors-status visible proxy';
                        statusEl.textContent = '⚡ Proxy';
                    }
                    return response;
                }
            } catch (error) {
                console.log('Proxy failed:', error.message);
            }
            
            // All attempts failed
            if (statusEl) {
                statusEl.className = 'cors-status visible error';
                statusEl.textContent = '✗ Failed';
            }
            throw new Error('Failed to fetch resource');
        }
        
        // Create color styles for features using native CSS color names
        function createColorStyle(colorName, opacity = 0.8) {
            // Use a canvas to validate color names - JavaScript recognizes standard CSS color names
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.fillStyle = colorName || 'red';  // Default to red if invalid
            const validatedColor = ctx.fillStyle;  // This will be the computed RGB value
            
            // Create stroke and fill colors with opacity
            const strokeColor = validatedColor + Math.round(opacity * 255).toString(16).padStart(2, '0');
            const fillColor = validatedColor + Math.round(opacity * 0.25 * 255).toString(16).padStart(2, '0');
            
            return { stroke: strokeColor, fill: fillColor, base: validatedColor };
        }
        
        // Expand wildcards in file patterns
        async function expandWildcards(pattern, basePath) {
            // If no wildcards, return as-is
            if (!pattern.includes('*') && !pattern.includes('?')) {
                return [pattern];
            }
            
            // For GCS paths
            if (basePath && basePath.includes('storage.googleapis.com')) {
                return await expandGCSWildcards(pattern, basePath);
            }
            
            // For S3 paths
            if (basePath && (basePath.includes('s3.amazonaws.com') || basePath.includes('s3://'))) {
                return await expandS3Wildcards(pattern, basePath);
            }
            
            // If we can't expand, return the pattern as-is and let it fail later
            console.warn(`Cannot expand wildcard pattern: ${pattern}`);
            return [pattern];
        }
        
        // Expand wildcards for Google Cloud Storage using prefix-based listing
        async function expandGCSWildcards(pattern, basePath) {
            console.log('Expanding GCS pattern:', pattern, 'with basePath:', basePath);
            
            // Extract bucket name and path from the basePath
            const url = new URL(basePath);
            const pathParts = url.pathname.substring(1).split('/');
            const bucket = pathParts[0];
            const pathPrefix = pathParts.slice(1).join('/');
            
            // Check if this is a directory wildcard (ends with /* or /)
            const isDirectoryWildcard = pattern.endsWith('/*') || pattern.endsWith('/');
            
            let prefix = pathPrefix;
            let filterRegex = null;
            
            if (isDirectoryWildcard) {
                // For directory wildcards, use the directory path as the prefix
                // Remove trailing /* or / to get clean directory path
                const dirPath = pattern.replace(/\/?\*?$/, '');
                prefix = pathPrefix + dirPath;
                if (!prefix.endsWith('/') && dirPath !== '') {
                    prefix += '/';
                }
                console.log('Directory wildcard detected, using prefix:', prefix);
                // No additional filtering needed - return everything under this prefix
            } else if (pattern.includes('*') || pattern.includes('?')) {
                // Handle file-level wildcards
                // Try to extract a prefix before the first wildcard
                const wildcardIndex = Math.min(
                    pattern.indexOf('*') === -1 ? Infinity : pattern.indexOf('*'),
                    pattern.indexOf('?') === -1 ? Infinity : pattern.indexOf('?')
                );
                
                if (wildcardIndex > 0) {
                    // Use the part before wildcard as additional prefix
                    const additionalPrefix = pattern.substring(0, wildcardIndex);
                    prefix = pathPrefix + additionalPrefix;
                }
                
                // Convert pattern to regex for filtering results
                const regexPattern = pattern
                    .replace(/\./g, '\\.')
                    .replace(/\*/g, '.*')
                    .replace(/\?/g, '.');
                filterRegex = new RegExp(regexPattern);
            } else {
                // No wildcards, just use the pattern as-is
                prefix = pathPrefix + pattern;
            }
            
            try {
                // Use the GCS XML API to list with prefix
                const listUrl = `https://storage.googleapis.com/${bucket}/?prefix=${encodeURIComponent(prefix)}`;
                console.log('Fetching GCS listing from:', listUrl);
                
                const response = await fetch(listUrl);
                if (!response.ok) {
                    throw new Error(`Failed to list GCS bucket: ${response.status}`);
                }
                
                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                
                // Extract all Keys from the XML response
                const keys = Array.from(xml.querySelectorAll('Key')).map(k => k.textContent);
                console.log(`Found ${keys.length} files with prefix "${prefix}"`);
                
                // Filter results based on pattern type
                let matches = keys;
                if (!isDirectoryWildcard && filterRegex) {
                    matches = keys.filter(key => {
                        // Extract just the filename part after the path prefix
                        const relativePath = key.substring(pathPrefix.length);
                        return filterRegex.test(relativePath);
                    });
                    console.log(`Filtered to ${matches.length} files matching pattern "${pattern}"`);
                } else if (isDirectoryWildcard) {
                    // For directory wildcards, optionally filter to only .parquet files
                    matches = keys.filter(key => key.endsWith('.parquet'));
                    console.log(`Found ${matches.length} parquet files under "${prefix}"`);
                }
                
                // Convert keys back to full URLs
                const fullUrls = matches.map(key => `https://storage.googleapis.com/${bucket}/${key}`);
                
                return fullUrls.length > 0 ? fullUrls : [basePath + pattern];
            } catch (e) {
                console.error('GCS wildcard expansion failed:', e);
                // Fallback to trying the pattern as-is
                return [basePath + pattern];
            }
        }
        
        // Expand wildcards for S3
        async function expandS3Wildcards(pattern, basePath) {
            // Parse the S3 bucket and prefix from basePath
            const url = new URL(parseS3Url(basePath));
            const bucket = url.hostname.split('.')[0];
            const prefix = url.pathname.substring(1);
            
            try {
                // S3 LIST API endpoint (requires CORS configuration on bucket)
                const listUrl = `https://${bucket}.s3.amazonaws.com/?list-type=2&prefix=${prefix}`;
                const response = await fetch(listUrl);
                
                if (!response.ok) {
                    console.warn('S3 listing failed, returning pattern as-is');
                    return [pattern];
                }
                
                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                
                // Extract all Keys from the XML response
                const keys = Array.from(xml.querySelectorAll('Key')).map(k => k.textContent);
                
                // Convert pattern to regex
                const regexPattern = pattern
                    .replace(/\./g, '\\.')
                    .replace(/\*/g, '.*')
                    .replace(/\?/g, '.');
                const regex = new RegExp(`^${regexPattern}$`);
                
                // Filter keys that match the pattern
                const matches = keys.filter(key => {
                    const filename = key.substring(prefix.length);
                    return regex.test(filename);
                });
                
                return matches.length > 0 ? matches : [pattern];
            } catch (e) {
                console.warn('S3 wildcard expansion failed:', e);
                return [pattern];
            }
        }
        
        // Load parquet file with smart CORS handling
        async function loadParquetFile(filename, projConfig, color = 'red') {
            console.log(`Loading parquet file: ${filename}`);
            
            try {
                // For remote files, use smartFetch with fallback
                let response;
                if (filename.startsWith('http://') || filename.startsWith('https://')) {
                    response = await smartFetch(filename);
                } else {
                    // For local files, use regular fetch
                    response = await fetch(filename);
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${filename}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                console.log(`Successfully fetched ${filename}, size: ${arrayBuffer.byteLength} bytes`);
                const wasmTable = readParquet(new Uint8Array(arrayBuffer));
                
                const ipcStream = wasmTable.intoIPCStream();
                const arrowTable = arrow.tableFromIPC(ipcStream);
                
                const features = [];
                const geometryColumn = arrowTable.getChild('geometry');
                const idColumn = arrowTable.getChild('id');
                const collectionColumn = arrowTable.getChild('collection');
                const nameColumn = arrowTable.getChild('name');
                const descriptionColumn = arrowTable.getChild('description');
                
                for (let i = 0; i < arrowTable.numRows; i++) {
                const wkbData = geometryColumn?.get(i);
                if (wkbData) {
                    // Convert Arrow data to format OpenLayers can read
                    // OpenLayers accepts ArrayBuffer, ArrayBufferView (like Uint8Array), or string
                    let wkbInput = wkbData;
                    if (wkbData.toArray) {
                        // Handle Arrow-specific format
                        wkbInput = new Uint8Array(wkbData.toArray());
                    }
                    
                    // Use OpenLayers' built-in WKB reader with automatic projection transformation
                    const olGeometry = wkbFormat.readGeometry(wkbInput, {
                        dataProjection: 'EPSG:4326',
                        featureProjection: projConfig.code
                    });
                    
                    if (olGeometry) {
                        features.push(new ol.Feature({
                            geometry: olGeometry,
                            id: idColumn?.get(i) || `feature_${i}`,
                            collection: collectionColumn?.get(i) || '',
                            name: nameColumn?.get(i) || `Feature ${i}`,
                            description: descriptionColumn?.get(i) || '',
                            source_file: filename,
                            feature_color: color  // Store the color for this feature
                        }));
                    }
                }
                }
                
                return features;
            } catch (e) {
                console.error(`Error fetching ${filename}:`, e);
                throw e;
            }
        }
        
        // Initialize and load all parquet files
        async function initialize() {
            try {
                console.log('Initializing parquet-wasm...');
                // Load WASM binary from GCS (local file at: src/xopr/map/parquet_wasm_bg.wasm)
                const wasmPath = 'https://storage.googleapis.com/opr_test_dataset_1/parquet_wasm_bg.wasm';
                
                console.log('Loading WASM binary from GCS');
                await init(wasmPath);
                console.log('parquet-wasm initialized successfully');
                
                // Initialize map with CONFIG
                const mapResult = await initializeMap();
                if (!mapResult) {
                    // No CONFIG provided - error already displayed
                    return;
                }
                const { map, projConfig, CONFIG } = mapResult;
                console.log('Map initialized with CONFIG:', CONFIG);
                
                const allFeatures = [];
                // Process file groups with their associated colors
                if (CONFIG.fileGroups && CONFIG.fileGroups.length > 0) {
                    for (const group of CONFIG.fileGroups) {
                        const groupColor = group.color || 'red';
                        for (const filePattern of (group.files || [])) {
                            // filePattern is already a full path from parseConfigFromURL
                            let filesToLoad = [filePattern];
                            
                            if (filePattern.includes('*') || filePattern.includes('?') || filePattern.endsWith('/')) {
                                // Extract base URL and pattern
                                const lastSlash = filePattern.lastIndexOf('/');
                                let basePath = '';
                                let pattern = filePattern;
                                
                                if (lastSlash > 0) {
                                    basePath = filePattern.substring(0, lastSlash + 1);
                                    pattern = filePattern.substring(lastSlash + 1);
                                }
                                
                                // For Hive-partitioned GCS catalogs, transform the pattern if needed
                                // But skip transformation for directory wildcards (provider=bas/*)
                                const isDirectoryPattern = pattern.endsWith('/*') || pattern.endsWith('/');
                                
                                if (basePath.includes('catalog') && !pattern.includes('=') && !isDirectoryPattern) {
                                    // Transform simple wildcards to match Hive structure
                                    // e.g., "*2014*.parquet" -> "collection=*2014*/stac.parquet"
                                    let basePattern = pattern.replace('.parquet', '');
                                    pattern = `collection=${basePattern}/stac.parquet`;
                                }
                                // If pattern already contains '=' (like provider=bas/*), use as-is
                                
                                console.log('Expanding pattern:', pattern, 'with basePath:', basePath);
                                filesToLoad = await expandWildcards(pattern, basePath);
                            }
                            
                            // Load each expanded file
                            for (const file of filesToLoad) {
                                try {
                                    const features = await loadParquetFile(file, projConfig, groupColor);
                                    allFeatures.push(...features);
                                } catch (e) {
                                    console.error(`Error loading ${file}:`, e);
                                }
                            }
                        }
                    }
                } else if (CONFIG.parquetFiles && Array.isArray(CONFIG.parquetFiles)) {
                    // Backward compatibility with old parquetFiles format
                    for (const file of CONFIG.parquetFiles) {
                        try {
                            const features = await loadParquetFile(file, projConfig, 'red');
                            allFeatures.push(...features);
                        } catch (e) {
                            console.error(`Error loading ${file}:`, e);
                        }
                    }
                } else {
                    console.warn('No fileGroups or parquetFiles defined in CONFIG');
                }
                
                // Track selected feature (define outside if block)
                let selectedFeature = null;
                let vectorSource = null;
                
                if (allFeatures.length > 0) {
                    vectorSource = new ol.source.Vector({ features: allFeatures });
                    
                    // Style function for different geometry types
                    const styleFunction = function(feature) {
                        const geomType = feature.getGeometry().getType();
                        const isSelected = feature === selectedFeature;
                        const featureColor = feature.get('feature_color') || 'red';
                        
                        // Create color styles using the feature's color
                        const colorStyle = createColorStyle(featureColor, isSelected ? 1.0 : 0.8);
                        
                        const pointRadius = isSelected ? 8 : 6;
                        const lineWidth = isSelected ? 4 : 2;
                        
                        const styles = {
                            'Point': new ol.style.Style({
                                image: new ol.style.Circle({
                                    radius: pointRadius,
                                    fill: new ol.style.Fill({ color: colorStyle.base }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: isSelected ? 2 : 1.5 })
                                })
                            }),
                            'LineString': new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: colorStyle.base,
                                    width: lineWidth
                                })
                            }),
                            'Polygon': new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: colorStyle.base,
                                    width: isSelected ? 3 : 2
                                }),
                                fill: new ol.style.Fill({
                                    color: colorStyle.fill
                                })
                            })
                        };
                        
                        return styles[geomType] || styles['Point'];
                    };
                    
                    const vectorLayer = new ol.layer.Vector({
                        source: vectorSource,
                        style: styleFunction
                    });
                    
                    map.addLayer(vectorLayer);
                    
                    // Fit to extent
                    const extent = vectorSource.getExtent();
                    if (!ol.extent.isEmpty(extent)) {
                        map.getView().fit(extent, {
                            padding: [50, 50, 50, 50],
                            duration: 1000
                        });
                    }
                }
                
                // Feature click handler
                map.on('click', function(evt) {
                    const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
                    if (feature) {
                        // Update selected feature and refresh styles
                        selectedFeature = feature;
                        vectorSource.changed();  // Trigger style refresh
                        
                        const props = feature.getProperties();
                        document.getElementById('info').innerHTML = 
                            `<strong>ID:</strong> ${props.id}<br><strong>Collection:</strong> ${props.collection}`;
                    } else {
                        // Clear selection when clicking empty space
                        selectedFeature = null;
                        vectorSource.changed();
                        const coords = evt.coordinate;
                        const lonlat = ol.proj.transform(coords, projConfig.code, 'EPSG:4326');
                        document.getElementById('info').innerHTML = 
                            `${lonlat[1].toFixed(4)}°, ${lonlat[0].toFixed(4)}°`;
                    }
                });
                
                // Hover cursor change
                map.on('pointermove', function(evt) {
                    const pixel = map.getEventPixel(evt.originalEvent);
                    const hit = map.hasFeatureAtPixel(pixel);
                    const targetElement = map.getTargetElement();
                    if (targetElement) {
                        targetElement.style.cursor = hit ? 'pointer' : '';
                    }
                });
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('info').innerHTML = 'Error loading data';
            }
        }
        
        // Start with error protection
        initialize().catch(error => {
            console.warn('Map initialization warning:', error.message);
            // Even if there's an error, the map might still work
        });
    </script>
</body>
</html>
