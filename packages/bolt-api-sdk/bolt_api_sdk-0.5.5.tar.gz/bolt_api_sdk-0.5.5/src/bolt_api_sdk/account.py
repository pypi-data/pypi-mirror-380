"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from bolt_api_sdk import errors, models, utils
from bolt_api_sdk._hooks import HookContext
from bolt_api_sdk.types import OptionalNullable, UNSET
from bolt_api_sdk.utils import get_security_from_env
from bolt_api_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Mapping, Optional, Union


class Account(BaseSDK):
    r"""Use the Account endpoint to view and manage customer accounts. Perform actions such as creating an account, updating an address, or adding a payment method. This endpoint is for merchants using the Accounts Package. See our related guide on [Bolt OAuth](https://help.bolt.com/developers/bolt-oauth/)."""

    def get_account(
        self,
        *,
        security: Union[models.GetAccountSecurity, models.GetAccountSecurityTypedDict],
        x_publishable_key: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AccountDetails:
        r"""Get Account Details

        Fetch a shopper's account details to pre-fill checkout fields. This request must come from your backend for security purposes, as it requires the use of your private key to authenticate. For PCI compliance, only limited information is returned for each credit card available in the shopper’s wallet.

        :param security:
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAccountRequest(
            x_publishable_key=x_publishable_key,
        )

        req = self._build_request(
            method="GET",
            path="/v1/account",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetAccountSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAccount",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AccountDetails, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def get_account_async(
        self,
        *,
        security: Union[models.GetAccountSecurity, models.GetAccountSecurityTypedDict],
        x_publishable_key: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AccountDetails:
        r"""Get Account Details

        Fetch a shopper's account details to pre-fill checkout fields. This request must come from your backend for security purposes, as it requires the use of your private key to authenticate. For PCI compliance, only limited information is returned for each credit card available in the shopper’s wallet.

        :param security:
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAccountRequest(
            x_publishable_key=x_publishable_key,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/account",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetAccountSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getAccount",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AccountDetails, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def create_account(
        self,
        *,
        x_publishable_key: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        create_account_input: Optional[
            Union[models.CreateAccountInput, models.CreateAccountInputTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AccountDetails:
        r"""Create Bolt Account

        Create a Bolt shopping account.

        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param idempotency_key: A key created by merchants that ensures `POST` and `PATCH` requests are only performed once. [Read more about Idempotent Requests here](/developers/references/idempotency/).
        :param create_account_input:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateAccountRequest(
            x_publishable_key=x_publishable_key,
            idempotency_key=idempotency_key,
            create_account_input=utils.get_pydantic_model(
                create_account_input, Optional[models.CreateAccountInput]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/account",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_account_input,
                False,
                True,
                "json",
                Optional[models.CreateAccountInput],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createAccount",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AccountDetails, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def create_account_async(
        self,
        *,
        x_publishable_key: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        create_account_input: Optional[
            Union[models.CreateAccountInput, models.CreateAccountInputTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AccountDetails:
        r"""Create Bolt Account

        Create a Bolt shopping account.

        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param idempotency_key: A key created by merchants that ensures `POST` and `PATCH` requests are only performed once. [Read more about Idempotent Requests here](/developers/references/idempotency/).
        :param create_account_input:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateAccountRequest(
            x_publishable_key=x_publishable_key,
            idempotency_key=idempotency_key,
            create_account_input=utils.get_pydantic_model(
                create_account_input, Optional[models.CreateAccountInput]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/account",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_account_input,
                False,
                True,
                "json",
                Optional[models.CreateAccountInput],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createAccount",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AccountDetails, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def update_account_profile(
        self,
        *,
        security: Union[
            models.UpdateAccountProfileSecurity,
            models.UpdateAccountProfileSecurityTypedDict,
        ],
        x_publishable_key: Optional[str] = None,
        update_profile: Optional[
            Union[models.UpdateProfile, models.UpdateProfileTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProfileView:
        r"""Update Profile

        Update the identifiers for a shopper's profile (first name or last name).

        :param security:
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param update_profile:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateAccountProfileRequest(
            x_publishable_key=x_publishable_key,
            update_profile=utils.get_pydantic_model(
                update_profile, Optional[models.UpdateProfile]
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/v1/account/profile",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.UpdateAccountProfileSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_profile,
                False,
                True,
                "json",
                Optional[models.UpdateProfile],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateAccountProfile",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ProfileView, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def update_account_profile_async(
        self,
        *,
        security: Union[
            models.UpdateAccountProfileSecurity,
            models.UpdateAccountProfileSecurityTypedDict,
        ],
        x_publishable_key: Optional[str] = None,
        update_profile: Optional[
            Union[models.UpdateProfile, models.UpdateProfileTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProfileView:
        r"""Update Profile

        Update the identifiers for a shopper's profile (first name or last name).

        :param security:
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param update_profile:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateAccountProfileRequest(
            x_publishable_key=x_publishable_key,
            update_profile=utils.get_pydantic_model(
                update_profile, Optional[models.UpdateProfile]
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/v1/account/profile",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.UpdateAccountProfileSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_profile,
                False,
                True,
                "json",
                Optional[models.UpdateProfile],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="updateAccountProfile",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ProfileView, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def add_address(
        self,
        *,
        security: Union[models.AddAddressSecurity, models.AddAddressSecurityTypedDict],
        x_publishable_key: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        address_account: Optional[
            Union[models.AddressAccount, models.AddressAccountTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AddAddressResponse:
        r"""Add Address

        Add an address to a shopper's account address book.

        :param security:
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param idempotency_key: A key created by merchants that ensures `POST` and `PATCH` requests are only performed once. [Read more about Idempotent Requests here](/developers/references/idempotency/).
        :param address_account:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddAddressRequest(
            x_publishable_key=x_publishable_key,
            idempotency_key=idempotency_key,
            address_account=utils.get_pydantic_model(
                address_account, Optional[models.AddressAccount]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/account/addresses",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.AddAddressSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.address_account,
                False,
                True,
                "json",
                Optional[models.AddressAccount],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addAddress",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AddAddressResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def add_address_async(
        self,
        *,
        security: Union[models.AddAddressSecurity, models.AddAddressSecurityTypedDict],
        x_publishable_key: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        address_account: Optional[
            Union[models.AddressAccount, models.AddressAccountTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AddAddressResponse:
        r"""Add Address

        Add an address to a shopper's account address book.

        :param security:
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param idempotency_key: A key created by merchants that ensures `POST` and `PATCH` requests are only performed once. [Read more about Idempotent Requests here](/developers/references/idempotency/).
        :param address_account:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddAddressRequest(
            x_publishable_key=x_publishable_key,
            idempotency_key=idempotency_key,
            address_account=utils.get_pydantic_model(
                address_account, Optional[models.AddressAccount]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/account/addresses",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.AddAddressSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.address_account,
                False,
                True,
                "json",
                Optional[models.AddressAccount],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addAddress",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.AddAddressResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def delete_address(
        self,
        *,
        security: Union[
            models.DeleteAddressSecurity, models.DeleteAddressSecurityTypedDict
        ],
        id: str,
        x_publishable_key: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Address

        Deletes an existing address in a shopper's address book.


        :param security:
        :param id: The ID for an address in the shopper's Address Book.
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteAddressRequest(
            id=id,
            x_publishable_key=x_publishable_key,
        )

        req = self._build_request(
            method="DELETE",
            path="/v1/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.DeleteAddressSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteAddress",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def delete_address_async(
        self,
        *,
        security: Union[
            models.DeleteAddressSecurity, models.DeleteAddressSecurityTypedDict
        ],
        id: str,
        x_publishable_key: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Address

        Deletes an existing address in a shopper's address book.


        :param security:
        :param id: The ID for an address in the shopper's Address Book.
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteAddressRequest(
            id=id,
            x_publishable_key=x_publishable_key,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/v1/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.DeleteAddressSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteAddress",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def replace_address(
        self,
        *,
        security: Union[
            models.ReplaceAddressSecurity, models.ReplaceAddressSecurityTypedDict
        ],
        id: str,
        country_code: str,
        email: str,
        first_name: str,
        last_name: str,
        locality: str,
        postal_code: str,
        region: str,
        street_address1: str,
        x_publishable_key: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        company: Optional[str] = None,
        country: Optional[str] = None,
        default: Optional[bool] = None,
        door_code: OptionalNullable[str] = UNSET,
        name: Optional[str] = None,
        phone: Optional[str] = None,
        region_code: OptionalNullable[str] = UNSET,
        street_address2: Optional[str] = None,
        street_address3: OptionalNullable[str] = UNSET,
        street_address4: OptionalNullable[str] = UNSET,
        metadata: OptionalNullable[
            Union[models.ShopperMetadata, models.ShopperMetadataTypedDict]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ReplaceAddressResponse:
        r"""Replace Address

        Replace an existing address in a shopper's address book.
        These changes delete the existing address and create a new one.


        :param security:
        :param id: The ID for an address in the shopper's Address Book.
        :param country_code: The ISO 3166-1 alpha-2 country code associated with this address.
        :param email: An email address.
        :param first_name: The given name of the person associated with this address.
        :param last_name: The surname of the person associated with this address.
        :param locality: The city name details associated with this address.
        :param postal_code: The the postal or zip code associated with this address.
        :param region: **Not Required for NON US addresses**. The region details such as state or province associated with this address.
        :param street_address1: The street number and street name of the address.
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param idempotency_key: A key created by merchants that ensures `POST` and `PATCH` requests are only performed once. [Read more about Idempotent Requests here](/developers/references/idempotency/).
        :param company: The company name associated with this address.
        :param country: The name of the country associated with this address.
        :param default: Set this to true to make this the default shipping address. There can be only one address with default set to true.
        :param door_code: The building door code or community gate code.
        :param name: The given and surname of the person associated with this address.
        :param phone: A phone number following E164 standards, in its globalized format, i.e. prepended with a plus sign.
        :param region_code: The ISO 3166-2 region code associated with this address.   - * If specified, value must be valid for the `country`.   - * If null, value is inferred from the `region`.
        :param street_address2: Any apartment, floor, or unit details.
        :param street_address3: Any additional street address details.
        :param street_address4: Any additional street address details.
        :param metadata: A key-value pair object that allows users to store arbitrary information associated with an object.  For any individual account object, we allow up to 50 keys. Keys can be up to 40 characters long and values can be up to 500 characters long.  Metadata should not contain any sensitive customer information, like PII (Personally Identifiable Information). For more information about metadata, see our [documentation](https://help.bolt.com/developers/references/embedded-metadata/).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ReplaceAddressRequest(
            id=id,
            x_publishable_key=x_publishable_key,
            idempotency_key=idempotency_key,
            address_account=models.AddressAccount(
                company=company,
                country=country,
                country_code=country_code,
                default=default,
                door_code=door_code,
                email=email,
                first_name=first_name,
                last_name=last_name,
                locality=locality,
                name=name,
                phone=phone,
                postal_code=postal_code,
                region=region,
                region_code=region_code,
                street_address1=street_address1,
                street_address2=street_address2,
                street_address3=street_address3,
                street_address4=street_address4,
                metadata=utils.get_pydantic_model(
                    metadata, OptionalNullable[models.ShopperMetadata]
                ),
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ReplaceAddressSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.address_account,
                False,
                True,
                "json",
                Optional[models.AddressAccount],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="replaceAddress",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ReplaceAddressResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def replace_address_async(
        self,
        *,
        security: Union[
            models.ReplaceAddressSecurity, models.ReplaceAddressSecurityTypedDict
        ],
        id: str,
        country_code: str,
        email: str,
        first_name: str,
        last_name: str,
        locality: str,
        postal_code: str,
        region: str,
        street_address1: str,
        x_publishable_key: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        company: Optional[str] = None,
        country: Optional[str] = None,
        default: Optional[bool] = None,
        door_code: OptionalNullable[str] = UNSET,
        name: Optional[str] = None,
        phone: Optional[str] = None,
        region_code: OptionalNullable[str] = UNSET,
        street_address2: Optional[str] = None,
        street_address3: OptionalNullable[str] = UNSET,
        street_address4: OptionalNullable[str] = UNSET,
        metadata: OptionalNullable[
            Union[models.ShopperMetadata, models.ShopperMetadataTypedDict]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ReplaceAddressResponse:
        r"""Replace Address

        Replace an existing address in a shopper's address book.
        These changes delete the existing address and create a new one.


        :param security:
        :param id: The ID for an address in the shopper's Address Book.
        :param country_code: The ISO 3166-1 alpha-2 country code associated with this address.
        :param email: An email address.
        :param first_name: The given name of the person associated with this address.
        :param last_name: The surname of the person associated with this address.
        :param locality: The city name details associated with this address.
        :param postal_code: The the postal or zip code associated with this address.
        :param region: **Not Required for NON US addresses**. The region details such as state or province associated with this address.
        :param street_address1: The street number and street name of the address.
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param idempotency_key: A key created by merchants that ensures `POST` and `PATCH` requests are only performed once. [Read more about Idempotent Requests here](/developers/references/idempotency/).
        :param company: The company name associated with this address.
        :param country: The name of the country associated with this address.
        :param default: Set this to true to make this the default shipping address. There can be only one address with default set to true.
        :param door_code: The building door code or community gate code.
        :param name: The given and surname of the person associated with this address.
        :param phone: A phone number following E164 standards, in its globalized format, i.e. prepended with a plus sign.
        :param region_code: The ISO 3166-2 region code associated with this address.   - * If specified, value must be valid for the `country`.   - * If null, value is inferred from the `region`.
        :param street_address2: Any apartment, floor, or unit details.
        :param street_address3: Any additional street address details.
        :param street_address4: Any additional street address details.
        :param metadata: A key-value pair object that allows users to store arbitrary information associated with an object.  For any individual account object, we allow up to 50 keys. Keys can be up to 40 characters long and values can be up to 500 characters long.  Metadata should not contain any sensitive customer information, like PII (Personally Identifiable Information). For more information about metadata, see our [documentation](https://help.bolt.com/developers/references/embedded-metadata/).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ReplaceAddressRequest(
            id=id,
            x_publishable_key=x_publishable_key,
            idempotency_key=idempotency_key,
            address_account=models.AddressAccount(
                company=company,
                country=country,
                country_code=country_code,
                default=default,
                door_code=door_code,
                email=email,
                first_name=first_name,
                last_name=last_name,
                locality=locality,
                name=name,
                phone=phone,
                postal_code=postal_code,
                region=region,
                region_code=region_code,
                street_address1=street_address1,
                street_address2=street_address2,
                street_address3=street_address3,
                street_address4=street_address4,
                metadata=utils.get_pydantic_model(
                    metadata, OptionalNullable[models.ShopperMetadata]
                ),
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ReplaceAddressSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.address_account,
                False,
                True,
                "json",
                Optional[models.AddressAccount],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="replaceAddress",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ReplaceAddressResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def edit_address(
        self,
        *,
        security: Union[
            models.EditAddressSecurity, models.EditAddressSecurityTypedDict
        ],
        id: str,
        country_code: str,
        email: str,
        first_name: str,
        last_name: str,
        locality: str,
        postal_code: str,
        region: str,
        street_address1: str,
        x_publishable_key: Optional[str] = None,
        company: Optional[str] = None,
        country: Optional[str] = None,
        default: Optional[bool] = None,
        door_code: OptionalNullable[str] = UNSET,
        name: Optional[str] = None,
        phone: Optional[str] = None,
        region_code: OptionalNullable[str] = UNSET,
        street_address2: Optional[str] = None,
        street_address3: OptionalNullable[str] = UNSET,
        street_address4: OptionalNullable[str] = UNSET,
        metadata: OptionalNullable[
            Union[models.ShopperMetadata, models.ShopperMetadataTypedDict]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EditAddressResponse:
        r"""Edit Address

        Edit an existing address in a shopper's address book.
        This endpoint fully replaces the information for an existing address while retaining the same address ID.


        :param security:
        :param id: The ID for an address in the shopper's Address Book.
        :param country_code: The ISO 3166-1 alpha-2 country code associated with this address.
        :param email: An email address.
        :param first_name: The given name of the person associated with this address.
        :param last_name: The surname of the person associated with this address.
        :param locality: The city name details associated with this address.
        :param postal_code: The the postal or zip code associated with this address.
        :param region: **Not Required for NON US addresses**. The region details such as state or province associated with this address.
        :param street_address1: The street number and street name of the address.
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param company: The company name associated with this address.
        :param country: The name of the country associated with this address.
        :param default: Set this to true to make this the default shipping address. There can be only one address with default set to true.
        :param door_code: The building door code or community gate code.
        :param name: The given and surname of the person associated with this address.
        :param phone: A phone number following E164 standards, in its globalized format, i.e. prepended with a plus sign.
        :param region_code: The ISO 3166-2 region code associated with this address.   - * If specified, value must be valid for the `country`.   - * If null, value is inferred from the `region`.
        :param street_address2: Any apartment, floor, or unit details.
        :param street_address3: Any additional street address details.
        :param street_address4: Any additional street address details.
        :param metadata: A key-value pair object that allows users to store arbitrary information associated with an object.  For any individual account object, we allow up to 50 keys. Keys can be up to 40 characters long and values can be up to 500 characters long.  Metadata should not contain any sensitive customer information, like PII (Personally Identifiable Information). For more information about metadata, see our [documentation](https://help.bolt.com/developers/references/embedded-metadata/).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EditAddressRequest(
            id=id,
            x_publishable_key=x_publishable_key,
            address_account=models.AddressAccount(
                company=company,
                country=country,
                country_code=country_code,
                default=default,
                door_code=door_code,
                email=email,
                first_name=first_name,
                last_name=last_name,
                locality=locality,
                name=name,
                phone=phone,
                postal_code=postal_code,
                region=region,
                region_code=region_code,
                street_address1=street_address1,
                street_address2=street_address2,
                street_address3=street_address3,
                street_address4=street_address4,
                metadata=utils.get_pydantic_model(
                    metadata, OptionalNullable[models.ShopperMetadata]
                ),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/v1/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.EditAddressSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.address_account,
                False,
                True,
                "json",
                Optional[models.AddressAccount],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="editAddress",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EditAddressResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def edit_address_async(
        self,
        *,
        security: Union[
            models.EditAddressSecurity, models.EditAddressSecurityTypedDict
        ],
        id: str,
        country_code: str,
        email: str,
        first_name: str,
        last_name: str,
        locality: str,
        postal_code: str,
        region: str,
        street_address1: str,
        x_publishable_key: Optional[str] = None,
        company: Optional[str] = None,
        country: Optional[str] = None,
        default: Optional[bool] = None,
        door_code: OptionalNullable[str] = UNSET,
        name: Optional[str] = None,
        phone: Optional[str] = None,
        region_code: OptionalNullable[str] = UNSET,
        street_address2: Optional[str] = None,
        street_address3: OptionalNullable[str] = UNSET,
        street_address4: OptionalNullable[str] = UNSET,
        metadata: OptionalNullable[
            Union[models.ShopperMetadata, models.ShopperMetadataTypedDict]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EditAddressResponse:
        r"""Edit Address

        Edit an existing address in a shopper's address book.
        This endpoint fully replaces the information for an existing address while retaining the same address ID.


        :param security:
        :param id: The ID for an address in the shopper's Address Book.
        :param country_code: The ISO 3166-1 alpha-2 country code associated with this address.
        :param email: An email address.
        :param first_name: The given name of the person associated with this address.
        :param last_name: The surname of the person associated with this address.
        :param locality: The city name details associated with this address.
        :param postal_code: The the postal or zip code associated with this address.
        :param region: **Not Required for NON US addresses**. The region details such as state or province associated with this address.
        :param street_address1: The street number and street name of the address.
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param company: The company name associated with this address.
        :param country: The name of the country associated with this address.
        :param default: Set this to true to make this the default shipping address. There can be only one address with default set to true.
        :param door_code: The building door code or community gate code.
        :param name: The given and surname of the person associated with this address.
        :param phone: A phone number following E164 standards, in its globalized format, i.e. prepended with a plus sign.
        :param region_code: The ISO 3166-2 region code associated with this address.   - * If specified, value must be valid for the `country`.   - * If null, value is inferred from the `region`.
        :param street_address2: Any apartment, floor, or unit details.
        :param street_address3: Any additional street address details.
        :param street_address4: Any additional street address details.
        :param metadata: A key-value pair object that allows users to store arbitrary information associated with an object.  For any individual account object, we allow up to 50 keys. Keys can be up to 40 characters long and values can be up to 500 characters long.  Metadata should not contain any sensitive customer information, like PII (Personally Identifiable Information). For more information about metadata, see our [documentation](https://help.bolt.com/developers/references/embedded-metadata/).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EditAddressRequest(
            id=id,
            x_publishable_key=x_publishable_key,
            address_account=models.AddressAccount(
                company=company,
                country=country,
                country_code=country_code,
                default=default,
                door_code=door_code,
                email=email,
                first_name=first_name,
                last_name=last_name,
                locality=locality,
                name=name,
                phone=phone,
                postal_code=postal_code,
                region=region,
                region_code=region_code,
                street_address1=street_address1,
                street_address2=street_address2,
                street_address3=street_address3,
                street_address4=street_address4,
                metadata=utils.get_pydantic_model(
                    metadata, OptionalNullable[models.ShopperMetadata]
                ),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/v1/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.EditAddressSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.address_account,
                False,
                True,
                "json",
                Optional[models.AddressAccount],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="editAddress",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EditAddressResponse, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def detect_account(
        self,
        *,
        x_publishable_key: str,
        email: Optional[str] = None,
        sha256_email: Optional[str] = None,
        phone: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.V1AccountsView:
        r"""Detect Account

        Check whether an account exists using one of `email`, `phone`, or `sha256_email` as the unique identifier.

        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard.
        :param email: The shopper's email address is the primary mechanism for detecting an account. You **must** provide either a value for this parameter or for `sha256_email`.
        :param sha256_email: The sha256 hash of the shopper's normalized email address can be used to detect an account instead of `email`.
        :param phone: The shopper's phone number. Includes country code (e.g. +1); does not include dashes or spaces. Can be used to detect an account instead of `sha256_email` or `email`.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DetectAccountRequest(
            email=email,
            sha256_email=sha256_email,
            phone=phone,
            x_publishable_key=x_publishable_key,
        )

        req = self._build_request(
            method="GET",
            path="/v1/account/exists",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="detectAccount",
                oauth2_scopes=[],
                security_source=None,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.V1AccountsView, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.ErrorsBoltAPIResponseData, http_res
            )
            raise errors.ErrorsBoltAPIResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def detect_account_async(
        self,
        *,
        x_publishable_key: str,
        email: Optional[str] = None,
        sha256_email: Optional[str] = None,
        phone: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.V1AccountsView:
        r"""Detect Account

        Check whether an account exists using one of `email`, `phone`, or `sha256_email` as the unique identifier.

        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard.
        :param email: The shopper's email address is the primary mechanism for detecting an account. You **must** provide either a value for this parameter or for `sha256_email`.
        :param sha256_email: The sha256 hash of the shopper's normalized email address can be used to detect an account instead of `email`.
        :param phone: The shopper's phone number. Includes country code (e.g. +1); does not include dashes or spaces. Can be used to detect an account instead of `sha256_email` or `email`.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DetectAccountRequest(
            email=email,
            sha256_email=sha256_email,
            phone=phone,
            x_publishable_key=x_publishable_key,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/account/exists",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="detectAccount",
                oauth2_scopes=[],
                security_source=None,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.V1AccountsView, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.ErrorsBoltAPIResponseData, http_res
            )
            raise errors.ErrorsBoltAPIResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def add_payment_method(
        self,
        *,
        security: Union[
            models.AddPaymentMethodSecurity, models.AddPaymentMethodSecurityTypedDict
        ],
        x_publishable_key: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        request_body: Optional[
            Union[
                models.AddPaymentMethodRequestBody,
                models.AddPaymentMethodRequestBodyTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SavedCreditCardView:
        r"""Add Payment Method

        Add a payment method to a shopper's Bolt account Wallet. For security purposes, this request must come from your backend because authentication requires the use of your private key.

        **Note**: Before using this API, the credit card details must be tokenized using Bolt's JavaScript library function, which is documented in [Install the Bolt Tokenizer](https://help.bolt.com/developers/references/bolt-tokenizer).


        :param security:
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param idempotency_key: A key created by merchants that ensures `POST` and `PATCH` requests are only performed once. [Read more about Idempotent Requests here](/developers/references/idempotency/).
        :param request_body:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddPaymentMethodRequest(
            x_publishable_key=x_publishable_key,
            idempotency_key=idempotency_key,
            request_body=utils.get_pydantic_model(
                request_body, Optional[models.AddPaymentMethodRequestBody]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/account/payment_methods",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AddPaymentMethodSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[models.AddPaymentMethodRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addPaymentMethod",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SavedCreditCardView, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def add_payment_method_async(
        self,
        *,
        security: Union[
            models.AddPaymentMethodSecurity, models.AddPaymentMethodSecurityTypedDict
        ],
        x_publishable_key: Optional[str] = None,
        idempotency_key: Optional[str] = None,
        request_body: Optional[
            Union[
                models.AddPaymentMethodRequestBody,
                models.AddPaymentMethodRequestBodyTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SavedCreditCardView:
        r"""Add Payment Method

        Add a payment method to a shopper's Bolt account Wallet. For security purposes, this request must come from your backend because authentication requires the use of your private key.

        **Note**: Before using this API, the credit card details must be tokenized using Bolt's JavaScript library function, which is documented in [Install the Bolt Tokenizer](https://help.bolt.com/developers/references/bolt-tokenizer).


        :param security:
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param idempotency_key: A key created by merchants that ensures `POST` and `PATCH` requests are only performed once. [Read more about Idempotent Requests here](/developers/references/idempotency/).
        :param request_body:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddPaymentMethodRequest(
            x_publishable_key=x_publishable_key,
            idempotency_key=idempotency_key,
            request_body=utils.get_pydantic_model(
                request_body, Optional[models.AddPaymentMethodRequestBody]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/account/payment_methods",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AddPaymentMethodSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[models.AddPaymentMethodRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="addPaymentMethod",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SavedCreditCardView, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def delete_payment_method(
        self,
        *,
        security: Union[
            models.DeletePaymentMethodSecurity,
            models.DeletePaymentMethodSecurityTypedDict,
        ],
        payment_method_id: str,
        x_publishable_key: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Payment Method

        Delete a saved payment method from a shopper's Bolt account Wallet.

        :param security:
        :param payment_method_id: The ID for a payment method in the shopper's Bolt account Wallet. This ID can be obtained using [Get Account Details](#tag/Account/operation/GetAccountDetails).
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletePaymentMethodRequest(
            payment_method_id=payment_method_id,
            x_publishable_key=x_publishable_key,
        )

        req = self._build_request(
            method="DELETE",
            path="/v1/account/payment_methods/{payment_method_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DeletePaymentMethodSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletePaymentMethod",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["403", "404"], "application/json"):
            response_data = unmarshal_json_response(
                errors.ErrorsBoltAPIResponseData, http_res
            )
            raise errors.ErrorsBoltAPIResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def delete_payment_method_async(
        self,
        *,
        security: Union[
            models.DeletePaymentMethodSecurity,
            models.DeletePaymentMethodSecurityTypedDict,
        ],
        payment_method_id: str,
        x_publishable_key: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Payment Method

        Delete a saved payment method from a shopper's Bolt account Wallet.

        :param security:
        :param payment_method_id: The ID for a payment method in the shopper's Bolt account Wallet. This ID can be obtained using [Get Account Details](#tag/Account/operation/GetAccountDetails).
        :param x_publishable_key: The publicly viewable identifier used to identify a merchant division. This key is found in the Developer > API section of the Bolt Merchant Dashboard [RECOMMENDED].
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletePaymentMethodRequest(
            payment_method_id=payment_method_id,
            x_publishable_key=x_publishable_key,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/v1/account/payment_methods/{payment_method_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DeletePaymentMethodSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletePaymentMethod",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["403", "404"], "application/json"):
            response_data = unmarshal_json_response(
                errors.ErrorsBoltAPIResponseData, http_res
            )
            raise errors.ErrorsBoltAPIResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)
