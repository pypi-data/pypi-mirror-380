# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.service_unavailable_error import ServiceUnavailableError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.actual_error_response import ActualErrorResponse
from ..types.add_user_memory_response import AddUserMemoryResponse
from ..types.delete_user_memory_response import DeleteUserMemoryResponse
from ..types.generate_user_memory_response import GenerateUserMemoryResponse
from ..types.list_user_memories_response import ListUserMemoriesResponse
from ..types.retrieve_user_memory_response import RetrieveUserMemoryResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawUserMemoryClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_user_memories(
        self,
        *,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListUserMemoriesResponse]:
        """
        Retrieve all stored user memories for your tenant.

        This endpoint returns a comprehensive list of all user memories that have been stored,
        whether they were added manually or generated through AI. User memories help personalize
        your experience by storing context, preferences, and important information.

        You can optionally specify a sub-tenant to filter memories within that specific scope.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListUserMemoriesResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "user_memory/list_user_memories",
            method="GET",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListUserMemoriesResponse,
                    parse_obj_as(
                        type_=ListUserMemoriesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_user_memory(
        self,
        *,
        tenant_id: str,
        memory_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeleteUserMemoryResponse]:
        """
        Permanently remove a specific user memory from storage.

        This endpoint allows you to delete a user memory by its unique identifier.
        Once deleted, the memory cannot be recovered, so use this operation carefully.

        The memory will be removed from your tenant's storage and will no longer
        appear in search results or memory listings.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        memory_id : str
            Unique identifier of the memory to delete

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteUserMemoryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "user_memory/delete_user_memory",
            method="DELETE",
            params={
                "tenant_id": tenant_id,
                "memory_id": memory_id,
                "sub_tenant_id": sub_tenant_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteUserMemoryResponse,
                    parse_obj_as(
                        type_=DeleteUserMemoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve_user_memory(
        self,
        *,
        tenant_id: str,
        query: str,
        sub_tenant_id: typing.Optional[str] = None,
        max_count: typing.Optional[int] = None,
        user_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RetrieveUserMemoryResponse]:
        """
        Find relevant user memories using semantic search.

        This endpoint performs a semantic search across all your stored user memories
        to find the most relevant ones based on your query. The results are ranked by
        similarity score, with the most relevant memories returned first.

        Use this to recall past preferences, context, or information that might be
        relevant to your current task or query.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        query : str
            Search query to find relevant user memories

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        max_count : typing.Optional[int]
            Maximum number of memories to return (default: 5)

        user_name : typing.Optional[str]
            User's name to enhance personalisation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RetrieveUserMemoryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "user_memory/retrieve_user_memory",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "max_count": max_count,
            },
            json={
                "query": query,
                "user_name": user_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrieveUserMemoryResponse,
                    parse_obj_as(
                        type_=RetrieveUserMemoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def generate_user_memory(
        self,
        *,
        tenant_id: str,
        user_message: str,
        user_name: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GenerateUserMemoryResponse]:
        """
        Generate AI-powered user memories from your query and context.

        This endpoint uses artificial intelligence to create personalized memories
        based on your query and user context. The AI analyzes your input and generates
        relevant, contextual memories that can help improve future interactions.

        Generated memories are automatically stored and can be retrieved through
        the standard memory search endpoints.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        user_message : str
            Your query or context for AI memory generation

        user_name : str
            Your name to personalize the generated memories

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GenerateUserMemoryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "user_memory/generate_user_memory",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "user_message": user_message,
                "user_name": user_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GenerateUserMemoryResponse,
                    parse_obj_as(
                        type_=GenerateUserMemoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def add_user_memory(
        self,
        *,
        tenant_id: str,
        user_memory: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AddUserMemoryResponse]:
        """
        Store a new user memory for future reference.

        This endpoint allows you to manually add a memory that will be stored and
        can be retrieved later through memory search. Use this to save important
        preferences, context, or information that you want the system to remember.

        The stored memory will be indexed and available for semantic search, making
        it accessible when relevant to future queries or interactions.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        user_memory : str
            The memory content to store for future reference

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AddUserMemoryResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "user_memory/add_user_memory",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "user_memory": user_memory,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddUserMemoryResponse,
                    parse_obj_as(
                        type_=AddUserMemoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawUserMemoryClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_user_memories(
        self,
        *,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListUserMemoriesResponse]:
        """
        Retrieve all stored user memories for your tenant.

        This endpoint returns a comprehensive list of all user memories that have been stored,
        whether they were added manually or generated through AI. User memories help personalize
        your experience by storing context, preferences, and important information.

        You can optionally specify a sub-tenant to filter memories within that specific scope.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListUserMemoriesResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "user_memory/list_user_memories",
            method="GET",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListUserMemoriesResponse,
                    parse_obj_as(
                        type_=ListUserMemoriesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_user_memory(
        self,
        *,
        tenant_id: str,
        memory_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeleteUserMemoryResponse]:
        """
        Permanently remove a specific user memory from storage.

        This endpoint allows you to delete a user memory by its unique identifier.
        Once deleted, the memory cannot be recovered, so use this operation carefully.

        The memory will be removed from your tenant's storage and will no longer
        appear in search results or memory listings.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        memory_id : str
            Unique identifier of the memory to delete

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteUserMemoryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "user_memory/delete_user_memory",
            method="DELETE",
            params={
                "tenant_id": tenant_id,
                "memory_id": memory_id,
                "sub_tenant_id": sub_tenant_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteUserMemoryResponse,
                    parse_obj_as(
                        type_=DeleteUserMemoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve_user_memory(
        self,
        *,
        tenant_id: str,
        query: str,
        sub_tenant_id: typing.Optional[str] = None,
        max_count: typing.Optional[int] = None,
        user_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RetrieveUserMemoryResponse]:
        """
        Find relevant user memories using semantic search.

        This endpoint performs a semantic search across all your stored user memories
        to find the most relevant ones based on your query. The results are ranked by
        similarity score, with the most relevant memories returned first.

        Use this to recall past preferences, context, or information that might be
        relevant to your current task or query.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        query : str
            Search query to find relevant user memories

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        max_count : typing.Optional[int]
            Maximum number of memories to return (default: 5)

        user_name : typing.Optional[str]
            User's name to enhance personalisation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RetrieveUserMemoryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "user_memory/retrieve_user_memory",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "max_count": max_count,
            },
            json={
                "query": query,
                "user_name": user_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrieveUserMemoryResponse,
                    parse_obj_as(
                        type_=RetrieveUserMemoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def generate_user_memory(
        self,
        *,
        tenant_id: str,
        user_message: str,
        user_name: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GenerateUserMemoryResponse]:
        """
        Generate AI-powered user memories from your query and context.

        This endpoint uses artificial intelligence to create personalized memories
        based on your query and user context. The AI analyzes your input and generates
        relevant, contextual memories that can help improve future interactions.

        Generated memories are automatically stored and can be retrieved through
        the standard memory search endpoints.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        user_message : str
            Your query or context for AI memory generation

        user_name : str
            Your name to personalize the generated memories

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GenerateUserMemoryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "user_memory/generate_user_memory",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "user_message": user_message,
                "user_name": user_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GenerateUserMemoryResponse,
                    parse_obj_as(
                        type_=GenerateUserMemoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def add_user_memory(
        self,
        *,
        tenant_id: str,
        user_memory: str,
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AddUserMemoryResponse]:
        """
        Store a new user memory for future reference.

        This endpoint allows you to manually add a memory that will be stored and
        can be retrieved later through memory search. Use this to save important
        preferences, context, or information that you want the system to remember.

        The stored memory will be indexed and available for semantic search, making
        it accessible when relevant to future queries or interactions.

        Parameters
        ----------
        tenant_id : str
            Unique identifier for the tenant/organization

        user_memory : str
            The memory content to store for future reference

        sub_tenant_id : typing.Optional[str]
            Optional sub-tenant identifier used to organize data within a tenant. If omitted, the default sub-tenant created during tenant setup will be used.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AddUserMemoryResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "user_memory/add_user_memory",
            method="POST",
            params={
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
            },
            json={
                "user_memory": user_memory,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddUserMemoryResponse,
                    parse_obj_as(
                        type_=AddUserMemoryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
