Metadata-Version: 2.4
Name: funstall
Version: 0.1.0
Summary: The fun cross-platform package manager!
Project-URL: Homepage, https://github.com/hbibel/funstall
Project-URL: Repository, https://github.com/hbibel/funstall.git
Project-URL: Issues, https://github.com/hbibel/funstall/issues
Author: Hannes Bibel
License-Expression: AGPL-3.0-or-later
License-File: LICENSE
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: System Administrators
Classifier: License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3.13
Classifier: Topic :: System :: Installation/Setup
Classifier: Topic :: System :: Software Distribution
Classifier: Topic :: System :: Systems Administration
Classifier: Topic :: Utilities
Requires-Python: >=3.13
Requires-Dist: click>=8.3.0
Requires-Dist: isort>=6.0.1
Requires-Dist: mypy>=1.18.2
Requires-Dist: pydantic>=2.11.9
Requires-Dist: pytest>=8.4.2
Requires-Dist: pyyaml>=6.0.3
Requires-Dist: ruff>=0.13.2
Description-Content-Type: text/markdown

# Funstall

This is my own custom package manager (well, mostly it's a wrapper around other
package managers).

## Usage

### List all available packages

```sh
funstall list
```

## Why?

I use multiple operating systems on multiple machines, requiring me to switch
between package managers (mainly pacman and brew).
My goal is to have a consistent, personal workflow no matter which machine I
use, so I need a wrapper around platform-specific package managers.

As a side note, I also don't agree with how some AUR packages are implemented,
so I'm hesitant to use `yay` on Arch.
Implementing my own installation scripts based on AUR implementations also
makes me feel safer from supply-chain attacks.

## Implementation Considerations

Initially I planned to implement this in nushell within my dotfiles.
However I started to feel uneasy with the rather simplistic typing system in
nushell as data models surpassed a certain level of complexity.
Therefore I decided to reach for another programming language.

I started this project using Python because I want to avoid writing a GitHub
action for now to distribute this project across my computers.
Generally I prefer compiled languages for CLI applications though so I may
**rewrite in Rustâ„¢** in the future (or in another language).

## Development

Publish a new version:

First create a PyPI API key with access to the repository.
Then save it in `.pypi-token.secret`.

```sh
uv build --sdist
uv publish --token $(cat .pypi-token.secret)
```
