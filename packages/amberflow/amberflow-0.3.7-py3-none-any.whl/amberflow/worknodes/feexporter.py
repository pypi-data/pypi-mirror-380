import warnings
from pathlib import Path
from typing import Optional

with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    # ignore `BiopythonDeprecationWarning` warning

from amberflow.artifacts import (
    ArtifactContainer,
    PythonScript,
    AnalysisCSVFile,
    AnalysisJSONFile,
)
from amberflow.artifacts import BatchArtifacts
from amberflow.primitives import (
    filepath_t,
    dirpath_t,
    DEFAULT_RESOURCES_PATH,
)
from amberflow.worknodes import BaseBatchWorkNode, noderesource, worknodehelper

__all__ = (
    "FEDataExporter",
    "AnalysisJSONDataExporter",
)

import csv


# noinspection DuplicatedCode
@noderesource(DEFAULT_RESOURCES_PATH / "tleap")
@worknodehelper(
    file_exists=True,
    input_artifact_types=(PythonScript,),
)
class FEDataExporter(BaseBatchWorkNode):
    """This work node extracts free energy data from edgembar generated PythonScript artifacts and exports the data to a CSV file.

    It processes multiple systems in a batch, reading the PythonScript files to obtain free energy values and writing them into a structured CSV format for easy analysis and reporting.

    Output CSV columns:
        - System: Name of the system
        - DeltaG_kcal_per_mol: MBAR free energy value (kcal/mol
        - DeltaG_Error_kcal_per_mol: MBAR free energy error (kcal/mol)
        - TI_kcal_per_mol: Thermodynamic Integration (TI) free energy value (kcal/mol)
        - TI3n_kcal_per_mol: TI free energy value using natural cubic spline
        - TI3c_kcal_per_mol: TI free energy value using clamped cubic spline
        - MinDiff_kcal_per_mol: Minimum absolute difference between MBAR and TI values

    Args:
        wnid (str): Work node identifier.
        debug (bool, optional): Enable debug mode. Defaults to False.

    Returns:
        BatchArtifacts: Container with the output CSV artifacts.

    Raises:
        RuntimeError: If the input artifacts are not as expected.

    Notes:
        - This work node assumes that the input artifacts are PythonScript files generated by edgembar.
        - The output CSV file is named "fe_data.csv" and is stored in the respective output directories for each system.
        - Ensure that the edgembar package is installed and accessible in the environment where this work node is executed.



    """

    def __init__(
        self,
        wnid: str,
        *args,
        debug: bool = False,
        **kwargs,
    ) -> None:
        super().__init__(
            wnid=wnid,
            *args,
            **kwargs,
        )

        self.out_dirs: dict[str, Path] = {}

    def _run(
        self,
        *,
        cwd: dirpath_t,
        binpath: Optional[filepath_t] = None,
        **kwargs,
    ) -> BatchArtifacts:
        # Init paths
        # Assume input_artifacts contains EdgeMBARhtml artifacts keyed by sysname
        data = {}
        for sysname, artifact_container in self.input_artifacts.items():
            data[sysname] = self.obtain_fe_data(str(artifact_container["PythonScript"].filepath))

        for dirname, _ in self.input_artifacts.items():
            # Write to CSV
            csv_path = self.out_dirs[dirname] / "fe_data.csv"
            with open(csv_path, mode="w", newline="") as csvfile:
                csvwriter = csv.writer(csvfile)
                csvwriter.writerow(
                    [
                        "System",
                        "DeltaG_kcal_per_mol",
                        "DeltaG_Error_kcal_per_mol",
                        "TI_kcal_per_mol",
                        "TI3n_kcal_per_mol",
                        "TI3c_kcal_per_mol",
                        "MinDiff_kcal_per_mol",
                    ]
                )
                for sysname, values in data.items():
                    csvwriter.writerow(
                        [
                            sysname,
                            values["mbar"],
                            values["mbarerr"],
                            values["ti"],
                            values["ti3n"],
                            values["ti3c"],
                            values["mindiff"],
                        ]
                    )

        self.output_artifacts = self.fill_output_artifacts()

        return self.output_artifacts

    def fill_output_artifacts(self) -> BatchArtifacts:
        """Collects and organizes output artifacts after processing.

        Returns:
            BatchArtifacts: Container with the output artifacts.

        """
        outdata: dict[str, ArtifactContainer] = {}
        for sysname, _ in self.input_artifacts.items():
            csv_file_path = self.out_dirs[sysname] / "fe_data.csv"
            out_csv = AnalysisCSVFile(csv_file_path)
            outdata[sysname] = ArtifactContainer(sysname, (out_csv,))
        return BatchArtifacts(_id=self.id, data=outdata)

    def obtain_fe_data(self, filepath: filepath_t) -> list[float]:
        """Extracts free energy data from an edgembar generated PythonScript artifact.


        Args:
            filepath (filepath_t): Path to the PythonScript artifact file.


        Returns:
            list[float]: List of free energy values extracted from the file.

        """
        from edgembar.ImportEdge import ImportEdge

        edge = ImportEdge(filepath)

        prod = edge.results.prod
        mbarval, mbarerr = edge.GetValueAndError(prod)
        tidata = edge.GetTIValuesAndErrors()

        if tidata is not None:
            tival = tidata["Linear"][0]
            ti3nval = tidata["Natural"][0]
            ti3cval = tidata["Clamped"][0]
            mindiff = min(abs(mbarval - tival), min(abs(mbarval - ti3nval), abs(mbarval - ti3cval)))

        msgs = edge.GetErrorMsgs()
        errs = [m for m in msgs if m.iserr]
        nerr = len(errs)
        warns = [m for m in msgs if not m.iserr and m.kind != "outlier"]
        nwarn = len(warns)
        return {"mbar": mbarval, "mbarerr": mbarerr, "ti": tival, "ti3n": ti3nval, "ti3c": ti3cval, "mindiff": mindiff}


# noinspection DuplicatedCode
@noderesource(DEFAULT_RESOURCES_PATH / "tleap")
@worknodehelper(
    file_exists=True,
    input_artifact_types=(PythonScript,),
)
class AnalysisJSONDataExporter(BaseBatchWorkNode):
    """
    Exports analysis data to a JSON file, providing access to detailed edgembar analysis results, including per-environment, per-stage, and per-trial data.
    Often used after free energy (FE) calculations to summarize results for further processing or reporting. The exported JSON contains free energy values and associated errors for each environment, stage, and trial.

    Output JSON dictionary structure:
        {
            "edge": str,                # Name of the edge (system)
            "bar_vs_ti": float,         # Minimum absolute difference between MBAR and TI values
            "num_errors": int,          # Number of error messages encountered
            "num_warnings": int,        # Number of warning messages encountered
            "barval": float,            # MBAR free energy value for the edge
            "barerr": float,            # MBAR free energy error for the edge
            "envs": [                   # List of environments
                {
                    "name": str,        # Environment name
                    "barval": float,    # MBAR free energy value for the environment
                    "barerr": float,    # MBAR free energy error for the environment
                    "stages": [         # List of stages within the environment
                        {
                            "name": str,        # Stage name
                            "barval": float,    # MBAR free energy value for the stage
                            "barerr": float,    # MBAR free energy error for the stage
                            "trials": [         # List of trials within the stage
                                {
                                    "name": str,        # Trial name
                                    "barval": float,    # MBAR free energy value for the trial
                                    "barerr": float,    # MBAR free energy error for the trial
                                    "spns": float,      # Average single pass steps
                                    "tripsper": float,  # Round trips per replica
                                    "tripstot": float,  # Total round trips
                                },
                                ...
                            ],
                        },
                        ...
                    ],
                },
                ...
            ],

    Args:
        wnid (str): Work node ID.
        debug (bool, optional): Enable debug mode. Defaults to False.
        *args: Additional positional arguments.
        **kwargs: Additional keyword arguments.

    Returns:
        BatchArtifacts: Container with the exported JSON file artifact.

    Note:
        This work node processes input artifacts containing analysis data and exports the relevant information to a JSON file.

    """

    def __init__(
        self,
        wnid: str,
        *args,
        debug: bool = False,
        **kwargs,
    ) -> None:
        super().__init__(
            wnid=wnid,
            *args,
            **kwargs,
        )

        self.out_dirs: dict[str, Path] = {}

    def _run(
        self,
        *,
        cwd: dirpath_t,
        binpath: Optional[filepath_t] = None,
        **kwargs,
    ) -> BatchArtifacts:
        # Init paths
        # Assume input_artifacts contains EdgeMBARhtml artifacts keyed by sysname
        data = {}
        for sysname, artifact_container in self.input_artifacts.items():
            data[sysname] = self.obtain_fe_data(str(artifact_container["PythonScript"].filepath))

        # Output data to JSON file here
        for dirname, _ in self.input_artifacts.items():
            # Write to JSON
            json_path = self.out_dirs[dirname] / "analysis_record.json"
            import json

            with open(json_path, "w") as json_file:
                json.dump(data, json_file, indent=4)

        self.output_artifacts = self.fill_output_artifacts()

        return self.output_artifacts

    def fill_output_artifacts(self) -> BatchArtifacts:
        """Collects and organizes output artifacts after processing.

        Returns:
            BatchArtifacts: Container with the output artifacts.

        """
        outdata: dict[str, ArtifactContainer] = {}
        for sysname, _ in self.input_artifacts.items():
            json_file_path = self.out_dirs[sysname] / "analysis_record.json"
            out_json = AnalysisJSONFile(json_file_path)
            outdata[sysname] = ArtifactContainer(sysname, (out_json,))
        return BatchArtifacts(_id=self.id, data=outdata)

    def obtain_fe_data(self, filepath: filepath_t) -> list[float]:
        """Extracts free energy data from an edgembar generated PythonScript artifact.


        Args:
            filepath (filepath_t): Path to the PythonScript artifact file.


        Returns:
            list[float]: List of free energy values extracted from the file.

        """
        from edgembar.ImportEdge import ImportEdge
        from edgembar.HtmlUtils import GetReplExchData

        edge = ImportEdge(filepath)

        prod = edge.results.prod
        mbarval, mbarerr = edge.GetValueAndError(prod)
        tidata = edge.GetTIValuesAndErrors()

        if tidata is not None:
            tival = tidata["Linear"][0]
            ti3nval = tidata["Natural"][0]
            ti3cval = tidata["Clamped"][0]
            mindiff = min(abs(mbarval - tival), min(abs(mbarval - ti3nval), abs(mbarval - ti3cval)))

        msgs = edge.GetErrorMsgs()
        errs = [m for m in msgs if m.iserr]
        nerr = len(errs)
        warns = [m for m in msgs if not m.iserr and m.kind != "outlier"]
        nwarn = len(warns)
        fwdrev = self.get_fwd_rev_data(edge.name, "", "", "", edge.timeseries)

        data = {
            "edge": edge.name,
            "bar_vs_ti": mindiff,
            "num_errors": nerr,
            "num_warnings": nwarn,
            "barval": mbarval,
            "barerr": mbarerr,
            "fwd_rev": fwdrev,
            "envs": [],
        }

        for env in edge.GetEnvs():
            barval, barerr = env.GetValueAndError(prod)
            fwdrev = self.get_fwd_rev_data(edge.name, env.name, "", "", env.timeseries)
            env_data = {
                "name": env.name,
                "barval": barval,
                "barerr": barerr,
                "fwd_rev": fwdrev,
                "stages": [],
            }
            for stage in env.stages:
                barval, barerr = stage.GetValueAndError(prod)
                fwdrev = self.get_fwd_rev_data(edge.name, env.name, stage.name, "", stage.timeseries)
                stage_data = {
                    "name": stage.name,
                    "barval": barval,
                    "barerr": barerr,
                    "fwd_rev": fwdrev,
                    "trials": [],
                }
                stage_data["barval"], stage_data["barerr"] = edge.GetValueAndError(prod)
                for trial in stage.trials:
                    repdata = GetReplExchData(trial)
                    spns = repdata["Average single pass steps:"]
                    tripsper = repdata["Round trips per replica:"]
                    tripstot = repdata["Total round trips:"]
                    tval, terr = trial.GetValueAndError(prod)
                    fwdrev = self.get_fwd_rev_data(edge.name, env.name, stage.name, trial.name, trial.timeseries)
                    trial_data = {
                        "name": trial.name,
                        "barval": tval,
                        "barerr": terr,
                        "spns": spns,
                        "tripsper": tripsper,
                        "tripstot": tripstot,
                        "ar": repdata["neighbor_acceptance_ratio"],
                        "fwd_rev": fwdrev,
                    }
                    stage_data["trials"].append(trial_data)
                env_data["stages"].append(stage_data)
            data["envs"].append(env_data)
        return data

    @staticmethod
    def get_fwd_rev_data(edgename, envname, stagename, trialname, ts):
        """Extracts forward and reverse free energy data from a timeseries object.

        Args:
            edgename (str): Name of the edge.
            envname (str): Name of the environment.
            stagename (str): Name of the stage.
            trialname (str): Name of the trial.
            ts: Timeseries object containing forward and reverse data.

        Returns:
            dict: Dictionary containing times, forward energies, forward errors, reverse energies, and reverse errors

        """
        times, fwdenes, fwderrs, revenes, reverrs = [], [], [], [], []
        output_data = {
            "times": times,
            "fwdene": fwdenes,
            "fwderr": fwderrs,
            "revene": revenes,
            "reverr": reverrs,
        }

        if ts is None:
            return output_data

        if ts is not None:
            ntimes = len(ts.frtimes)
            for itime in range(ntimes):
                fwdene = "None"
                fwderr = "None"
                if ts.fwd is not None:
                    v, e = ts.fwd[itime]
                    fwdene = "%.2f" % (v)
                    fwderr = "%.2f" % (e)

                revene = "None"
                reverr = "None"
                if ts.rev is not None:
                    v, e = ts.rev[itime]
                    revene = "%.2f" % (v)
                    reverr = "%.2f" % (e)

                # print("Fwd/Rev t: %8.2f  Fwd: %8s +- %8s  Rev: %8s +- %8s"%\
                #    (ts.frtimes[itime],fwdene,fwderr,revene,reverr))
                times.append(ts.frtimes[itime])
                fwdenes.append(fwdene)
                fwderrs.append(fwderr)
                revenes.append(revene)
                reverrs.append(reverr)

        output_data = {
            "times": times,
            "fwdene": fwdenes,
            "fwderr": fwderrs,
            "revene": revenes,
            "reverr": reverrs,
        }
        return output_data
