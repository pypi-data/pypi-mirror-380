# Copyright (c) 2004-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import logging
import os
import secrets
import socket
import string
import textwrap
from collections.abc import Iterable, Iterator, Sequence
from datetime import datetime
from ipaddress import ip_address, ip_network
from typing import Callable

import clusterondemand.tracing as tracing
from clusterondemand import const
from clusterondemand.clusternameprefix import ensure_cod_prefix
from clusterondemand.exceptions import CODException
from clusterondemand.images.find import CODImage
from clusterondemand.inbound_traffic_rule import (
    ALL_PROTOCOL_NUMBER,
    ANY,
    InboundNetworkACLRule,
    InboundTrafficRule,
    RuleType
)
from clusterondemand.tags import format_cluster_tags, format_packagegroups_tags
from clusterondemandconfig import config

from .utils import get_public_ip_of_cod_client

log = logging.getLogger("cluster-on-demand")


def generate_random_cluster_password(length: int) -> str:
    assert length > 0
    assert length < 256

    letters = string.ascii_letters
    chars = letters + string.digits
    password = "".join((secrets.choice(chars)) for x in range(length))
    return password


def enable_cmd_debug_commands(subsystems: str = "*", base_paths: Sequence[str] | None = None) -> list[str]:
    """Return list with the proper commmands to enable debug on logging.cmd.conf"""
    LOG_CONF = "cm/local/apps/cmd/etc/logging.cmd.conf"

    if not base_paths:
        base_paths = ["/", "/cm/images/default-image/"]

    # We want to replace "debug: " for "debug: subsystems", but not on the commented lines
    # that's why "/\\#/"
    return [
        "sed -i '/\\#/! s/debug:.*/debug: {subsystems}/' {path}".format(
            subsystems=subsystems,
            path=os.path.join(base_path, LOG_CONF),
        )
        for base_path in base_paths
    ]


def set_cmd_advanced_config_commands(parameters: list[str], base_paths: Sequence[str] | None = None) -> list[str]:
    """
    Return list with the proper commands to configure specified AdvancedConfig parameters on cmd.conf

    :param parameters: a list of parameters in the ["param1=value1", "param2=value2", ...] format
    :param base_paths: a list of filesystem prefixes
    """
    CMD_CONF = "cm/local/apps/cmd/etc/cmd.conf"

    assert parameters and all(isinstance(p, str) for p in parameters)

    if not base_paths:
        base_paths = ["/", "/cm/images/default-image/"]

    return [
        "! grep -P '^ *AdvancedConfig *=' \"{path}\""  # Make sure it wasn't set before
        " && echo 'AdvancedConfig = {{ {params} }}' >> \"{path}\"".format(
            params=", ".join(f'"{p}"' for p in parameters),
            path=os.path.join(base_path, CMD_CONF),
        )
        for base_path in base_paths
    ]


def cluster_name_generator(head_node_image: CODImage) -> Iterator[str]:
    version = head_node_image.version
    if version == "trunk":
        version = version.replace("trunk", "t")
    else:
        version = "b" + version.replace(".", "")

    distro = head_node_image.distro
    distro = distro.lower().replace("centos", "c")
    distro = distro.lower().replace("sles", "s")
    distro = distro.lower().replace("ubuntu", "u")
    distro = distro.lower().replace("rocky", "r")
    distro = distro.lower().replace("alma", "a")

    now = datetime.now()

    base_name = ensure_cod_prefix(f"{version}-{distro}-{now:%m-%d}")
    yield base_name

    index = 0
    while True:
        index = index + 1
        yield f"{base_name}-{index}"


def make_cluster_name(head_node_image: CODImage, cluster_exists_func: Callable[[str], bool]) -> str:
    """
    Creates a unique non-existent depending on user input
    """
    if config["name"] is None:
        for name in cluster_name_generator(head_node_image):
            if not cluster_exists_func(name):
                return name
    else:
        name = ensure_cod_prefix(config["name"])
        if cluster_exists_func(name):
            raise CODException(textwrap.dedent(
                "A cluster with the name '%s' already exists. Remember that "
                "you can skip specifying --name, which will result in an autogenerated "
                "unique name for your cluster. " % name
            ))
        return name

    # Unreachable. Gotta make the linter happy
    assert False


def generate_uuid_tag(head_node_image: CODImage) -> str:
    return format_cluster_tags({const.COD_HEAD_IMAGE_UUID: head_node_image.uuid})[0]


def generate_cluster_tags(head_node_image: CODImage, only_image_tags: bool = False) -> list[str]:
    tags = [const.COD_TAG]
    tags += format_cluster_tags({
        const.COD_TOOL_VERSION_TAG: const.COD_TOOL_VERSION,
        const.COD_DISTRO_TAG: head_node_image.distro,
        const.COD_VERSION_TAG: head_node_image.version,
        const.COD_CMDREV_TAG: head_node_image.cmd_revision,
        const.COD_HEAD_IMAGE_CREATED_AT: head_node_image.created_at,
        const.COD_HEAD_IMAGE_ID: head_node_image.id,
        const.COD_HEAD_IMAGE_NAME: head_node_image.name,
        const.COD_HEAD_IMAGE_REV: head_node_image.revision,
    })
    tags.append(generate_uuid_tag(head_node_image))

    # On vmware we cannot create any new tags on cluster creation
    # So we leave this separate
    if not only_image_tags:
        tags += format_cluster_tags({
            const.COD_TRACE_ID: tracing.get_trace_id(),
        })

    tags += format_packagegroups_tags(head_node_image.package_groups)
    return tags


def detect_duplicate_tags(first: Iterable[str], second: Iterable[str]) -> str | None:
    for tag1 in first:
        if "=" in tag1:
            match = tag1.split("=")[0]
            for tag2 in second:
                if tag2.startswith(match):
                    return match
        else:
            if tag1 in second:
                return tag1
    return None


def validate_inbound_rules(inbound_rules: list[InboundTrafficRule] | None) -> None:
    """
    Validate that the inbound rules don't create an inaccessible cluster.
    Should only be called when BCM manages security groups.
    Clusters created based on pre-existing resources don't need this validation
    """
    message = (
        "Cluster is created with external IP or BCM-managed security rules, but no inbound security rules were "
        "configured. This cluster cannot be managed from the internet after creation. "
        "Please configure inbound rules to allow port 22 or 8081 from at least one public CIDR block. "
        "Refer to '--inbound-rule' help for examples and more information"
    )
    if config["cloud_type"] == "openstack":
        message = (
            "No inbound rules found to allow port 22 or 8081. This cluster cannot be managed after creation. "
            "Please configure inbound rules to allow port 22 or 8081 from at least one CIDR block. "
            "Refer to '--inbound-rule' help for examples and more information"
        )
    if inbound_rules:
        inbound_rules = InboundTrafficRule.process_inbound_rules(inbound_rules)
        if config["cloud_type"] != "openstack":
            if not check_client_ssh_access(inbound_rules):
                log.warning(
                    "SSH access is not allowed from the client IP address due to missing inbound rules "
                    "Cluster creation will proceed, but waiting for SSH access is disabled (wait_ssh set to 0)."
                )
                config["wait_ssh"] = 0
            else:
                return

        access_ports = [22, 8081]
        for rule in inbound_rules:
            if (
                (rule.protocol in ("tcp", ANY) or config["cloud_type"] == "openstack") and (
                    int(rule.dst_first_port) <= access_ports[0] <= int(rule.dst_last_port)
                    or int(rule.dst_first_port) <= access_ports[1] <= int(rule.dst_last_port)
                )
            ):
                return

    raise CODException(message)


def check_client_ssh_access(inbound_rules: Sequence[InboundTrafficRule | InboundNetworkACLRule]) -> bool:
    """
    There are 2 use-cases where below validation is useful:
    1. User is creating a cluster that is intended to be managed with web only, therefore ssh is not allowed
    2. User is creating a cluster for someone else, so ports 22 or 8081 are not open for creator's public IP
    In both cases waiting for cluster will fail and raise an exception, so we're disabling wait_ssh
    """
    try:
        client_ip = get_public_ip_of_cod_client()
    except Exception:
        # We don't want to fail the cluster creation because of this
        log.warning("Failed to determine client IP address, cannot verify SSH access")
        return False

    for rule in inbound_rules:
        # Handles InboundNetworkACLRule "all" protocol case
        if (
            isinstance(rule, InboundNetworkACLRule)
            and rule.rule_type == RuleType.ICMP_OR_ALL
        ):
            if rule.protocol_number == ALL_PROTOCOL_NUMBER and ip_address(
                client_ip
            ) in ip_network(rule.src_cidr):
                return True

        if (
            rule.protocol_number == socket.IPPROTO_TCP
            and (
                int(rule.dst_first_port) <= 22 <= int(rule.dst_last_port)
                and ip_address(client_ip) in ip_network(rule.src_cidr)
            )
        ):
            return True

    return False
