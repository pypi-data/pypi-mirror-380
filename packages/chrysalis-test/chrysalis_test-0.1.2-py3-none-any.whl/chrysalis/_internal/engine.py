import pickle
import sqlite3
from collections.abc import Callable
from pathlib import Path

import duckdb

from chrysalis._internal.tables import defs
from chrysalis._internal.tables.relation import generate_uuid
from chrysalis._internal.search import SearchSpace
from chrysalis._internal.writer import Writer


class Engine[T, R]:
    """
    A class responsible for execution in metamorphic testing.

    The engine performs the actual execution of tests specificed by provided relation
    chains. To start, an engine is initialized with a static SUT (system under test) and
    input dataset. Then, the SUT can be tested using provided relation chains (likely
    generated by the search space class). Each relation chain is completely independent
    from all other relation chains, although multiple chains can be passed to `execute`
    at once for performance reasons. Additionally, all input data objects are tested for
    each specified relation chain.

    Performing metamorphic testing on a single input data object and relation chain
    combination is an iterative process. First, the results of execution of the SUT on
    the input data is determined. Then, the input data is transformed by the
    transformation specified by the first relation in the relation chain. Lastly, the
    result of execution of the SUT on the transformed data is compared to the previous
    result so it can be determined if each invariant for the given transformation held.
    This process is repeated for each transformation in the relation chain.

    Under the hood, a sqlite database is maintained which denotes the results of
    executing each relation chain on all of the input data. This data is kept so it can
    be used later for debugging if an invariant failed.
    """

    def __init__(
        self,
        sut: Callable[[T], R],
        input_data: list[T],
        search_space: SearchSpace,
        sqlite_conn: sqlite3.Connection,
        sqlite_db: Path,
        writer: Writer | None = None,
    ):
        self._sut = sut
        self._search_space = search_space
        self._conn = sqlite_conn
        self._sqlite_db = sqlite_db
        self._writer = writer

        # Insert input data into database and store uuid for future reference.
        self._input_data: dict[str, T] = {}
        cur = self._conn.cursor()
        for input_obj in input_data:
            obj_id = self._insert_input_data(
                obj=input_obj,
                cursor=cur,
            )
            self._input_data[obj_id] = input_obj

    def _insert_input_data(
        self,
        obj: T,
        cursor: sqlite3.Cursor,
    ) -> str:
        """Insert a record into the `input_data` table."""
        input_data_id = generate_uuid()
        cursor.execute(
            """
INSERT INTO input_data (id, obj)
VALUES (?, ?);
""",
            (input_data_id, pickle.dumps(obj)),
        )
        return input_data_id

    def _insert_applied_transformation(
        self,
        transformation: str,
        relation_chain_id: str,
        link_index: int,
        cursor: sqlite3.Cursor,
    ) -> str:
        """Insert a record into the `applied_transformation` table."""
        applied_transformation_id = generate_uuid()
        cursor.execute(
            """
INSERT INTO applied_transformation
    (id, transformation, relation_chain_id, link_index)
VALUES
    (?, ?, ?, ?);
""",
            (
                applied_transformation_id,
                transformation,
                relation_chain_id,
                link_index,
            ),
        )
        return applied_transformation_id

    def _insert_failed_invariant(
        self,
        invariant: str,
        applied_transformation: str,
        input_data: str,
        cursor: sqlite3.Cursor,
    ) -> None:
        """Insert a record into the `failed_invariant` table."""
        invariant_id = generate_uuid()
        cursor.execute(
            """
INSERT INTO failed_invariant (id, invariant, applied_transformation, input_data)
VALUES (?, ?, ?, ?);
        """,
            (invariant_id, invariant, applied_transformation, input_data),
        )

    def _execute_chain(
        self,
        chain_length: int,
        cursor: sqlite3.Cursor,
    ) -> None:
        """Execute a relation chain and store all results in a provided database."""
        results: dict[str, R] = {}
        for curr_id, curr_input in self._input_data.items():
            try:
                results[curr_id] = self._sut(curr_input)  # NOQA: PERF401
            except Exception as e:
                raise RuntimeError(
                    f"Exception encountered while running the SUT on input `{curr_id}`: {e}"
                )

        generator = self._search_space.create_generator()

        relation_chain_id = generate_uuid()
        previous_inputs = self._input_data
        previous_results = results
        for link_index in range(chain_length):
            relation = next(generator)
            current_inputs: dict[str, T] = {}
            for input_id, prev_input in previous_inputs.items():
                try:
                    current_inputs[input_id] = relation.apply_transform(prev_input)
                except Exception as e:
                    raise RuntimeError(
                        f"Exception encountered while applying transform `{relation.transformation_id}` on the input `{input_id}`: {e}"
                    )

            current_results: dict[str, R] = {}
            for input_id, curr_input in current_inputs.items():
                try:
                    current_results[input_id] = self._sut(curr_input)
                except Exception as e:
                    raise RuntimeError(
                        f"Exception encountered while running the SUT on input `{input_id}` after transform `{relation.transformation_id}`: {e}"
                    )

                if self._writer is not None:
                    self._writer.report_finished_test_case()

            current_transformation_id = self._insert_applied_transformation(
                transformation=relation.transformation_id,
                relation_chain_id=relation_chain_id,
                link_index=link_index,
                cursor=cursor,
            )
            for invariant_id, invariant in relation.invariants.items():
                for (input_id, prev_result), curr_result in zip(
                    previous_results.items(), current_results.values(), strict=True
                ):
                    if not invariant(curr_result, prev_result):
                        self._insert_failed_invariant(
                            invariant=invariant_id,
                            applied_transformation=current_transformation_id,
                            input_data=input_id,
                            cursor=cursor,
                        )

            previous_inputs = current_inputs
            previous_results = current_results

    def execute(
        self,
        chain_length: int,
        num_chains: int,
    ) -> None:
        """
        Execute a list of provided relation chains and store the results.

        Execution of a relation chain involves iteratively applying transformations to
        each item in the input data and ensuring all invariants hold. At the moment,
        we do not anticipate transformations causing errors regardless of the input.
        It is important to note that multiple relations can reference the same
        transformation and thus multiple invariant can be checked during a single step
        in a relation chain.
        """
        cursor = self._conn.cursor()
        for _ in range(num_chains):
            try:
                self._execute_chain(
                    chain_length=chain_length,
                    cursor=cursor,
                )
            except Exception as e:
                print(e)
        self._conn.commit()

    def results_to_duckdb(
        self, db_path: Path | None = None
    ) -> duckdb.DuckDBPyConnection:
        """
        Convert the sqlite3 database kept during execution into a duckdb database.

        Sqlite databases are designed for transactional processing, which fits our use
        case when inserting transaction and invariant records, especially if the program
        is using multiple cores. Once all the results have been accumulated, we can
        convert the database into a duckdb database due to duckdb's better performance
        on analytical queries and better data compression.
        """
        return defs.sqlite_to_duckdb(self._sqlite_db, output_db_path=db_path)
