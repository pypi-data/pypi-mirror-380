##################### generated by xml-casa (v2) from imstat.xml ####################
##################### 76730722711b052751c7e443e885cbf7 ##############################
from __future__ import absolute_import
import numpy
from casatools.typecheck import CasaValidator as _val_ctor
_pc = _val_ctor( )
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from .private.task_imstat import imstat as _imstat_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from casatasks.private.task_logging import except_log as _except_log

class _imstat:
    """
    imstat ---- Calculates statistical information from an image or image region

    --------- parameter descriptions ---------------------------------------------

    imagename Name of the input image
    axes      List of axes to evaluate statistics over. Default is all axes.
    region    Region selection. Default is to use the full image.
    box       Rectangular region(s) to select in direction plane. Default is to use the entire direction plane.
    chans     Channels to use. Default is to use all channels.
    stokes    Stokes planes to use. Default is to use all Stokes planes.
    listit    Print stats and bounding box to logger?
    verbose   Print additional messages to logger?
    mask      Mask to use. Default is none.
    stretch   Stretch the mask if necessary and possible?
    logfile   Name of file to write fit results.
    append    If logfile exists, append to it if True or overwrite it if False
    algorithm Algorithm to use. Supported values are "biweight", "chauvenet", "classic", "fit-half", and "hinges-fences". Minimum match is supported.
    fence     Fence value for hinges-fences. A negative value means use the entire data set (ie default to the "classic" algorithm). Ignored if algorithm is not "hinges-fences".
    center    Center to use for fit-half. Valid choices are "mean", "median", and "zero". Ignored if algorithm is not "fit-half".
    lside     For fit-half, use values <= center for real data if True? If False, use values >= center as real data. Ignored if algorithm is not "fit-half".
    zscore    For chauvenet, this is the target maximum number of standard deviations data may have to be included. If negative, use Chauvenet"s criterion. Ignored if algorithm is not "chauvenet".
    maxiter   For chauvenet, this is the maximum number of iterations to attempt. Iterating will stop when either this limit is reached, or the zscore criterion is met. If negative, iterate until the zscore criterion is met. Ignored if algorithm is not "chauvenet".
    clmethod  Method to use for calculating classical statistics. Supported methods are "auto", "tiled", and "framework". Ignored if algorithm is not "classic".
    niter     For biweight, this is the maximum number of iterations to attempt. Iterating will stop when either this limit is reached, or the zscore criterion is met. If negative, do a fast, simple computation (see description). Ignored if the algorithm is not "biweight".
    [1;42mRETURNS[1;m      void

    --------- examples -----------------------------------------------------------

    


    """

    _info_group_ = """information, analysis"""
    _info_desc_ = """Calculates statistical information from an image or image region"""

    def __call__( self, imagename='', axes=[ ], region='', box='', chans='', stokes='', listit=True, verbose=True, mask='', stretch=False, logfile='', append=True, algorithm='classic', fence=float(-1), center='mean', lside=True, zscore=float(-1), maxiter=int(-1), clmethod='auto', niter=int(3) ):
        schema = {'imagename': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'axes': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'region': {'anyof': [{'type': 'cPath', 'coerce': _coerce.expand_path}, {'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cDict'}]}, 'box': {'type': 'cStr', 'coerce': _coerce.to_str}, 'chans': {'type': 'cStr', 'coerce': _coerce.to_str}, 'stokes': {'type': 'cStr', 'coerce': _coerce.to_str}, 'listit': {'type': 'cBool'}, 'verbose': {'type': 'cBool'}, 'mask': {'type': 'cStr', 'coerce': _coerce.to_str}, 'stretch': {'type': 'cBool'}, 'logfile': {'type': 'cStr', 'coerce': _coerce.to_str}, 'append': {'type': 'cBool'}, 'algorithm': {'type': 'cStr', 'coerce': _coerce.to_str}, 'fence': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'center': {'type': 'cStr', 'coerce': _coerce.to_str}, 'lside': {'type': 'cBool'}, 'zscore': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'maxiter': {'type': 'cInt'}, 'clmethod': {'type': 'cStr', 'coerce': _coerce.to_str}, 'niter': {'type': 'cInt'}}
        doc = {'imagename': imagename, 'axes': axes, 'region': region, 'box': box, 'chans': chans, 'stokes': stokes, 'listit': listit, 'verbose': verbose, 'mask': mask, 'stretch': stretch, 'logfile': logfile, 'append': append, 'algorithm': algorithm, 'fence': fence, 'center': center, 'lside': lside, 'zscore': zscore, 'maxiter': maxiter, 'clmethod': clmethod, 'niter': niter}
        assert _pc.validate(doc,schema), create_error_string(_pc.errors)
        _logging_state_ = _start_log( 'imstat', [ 'imagename=' + repr(_pc.document['imagename']), 'axes=' + repr(_pc.document['axes']), 'region=' + repr(_pc.document['region']), 'box=' + repr(_pc.document['box']), 'chans=' + repr(_pc.document['chans']), 'stokes=' + repr(_pc.document['stokes']), 'listit=' + repr(_pc.document['listit']), 'verbose=' + repr(_pc.document['verbose']), 'mask=' + repr(_pc.document['mask']), 'stretch=' + repr(_pc.document['stretch']), 'logfile=' + repr(_pc.document['logfile']), 'append=' + repr(_pc.document['append']), 'algorithm=' + repr(_pc.document['algorithm']), 'fence=' + repr(_pc.document['fence']), 'center=' + repr(_pc.document['center']), 'lside=' + repr(_pc.document['lside']), 'zscore=' + repr(_pc.document['zscore']), 'maxiter=' + repr(_pc.document['maxiter']), 'clmethod=' + repr(_pc.document['clmethod']), 'niter=' + repr(_pc.document['niter']) ] )
        task_result = None
        try:
            task_result = _imstat_t( _pc.document['imagename'], _pc.document['axes'], _pc.document['region'], _pc.document['box'], _pc.document['chans'], _pc.document['stokes'], _pc.document['listit'], _pc.document['verbose'], _pc.document['mask'], _pc.document['stretch'], _pc.document['logfile'], _pc.document['append'], _pc.document['algorithm'], _pc.document['fence'], _pc.document['center'], _pc.document['lside'], _pc.document['zscore'], _pc.document['maxiter'], _pc.document['clmethod'], _pc.document['niter'] )
        except Exception as exc:
            _except_log('imstat', exc)
            raise
        finally:
            task_result = _end_log( _logging_state_, 'imstat', task_result )
        return task_result

imstat = _imstat( )

