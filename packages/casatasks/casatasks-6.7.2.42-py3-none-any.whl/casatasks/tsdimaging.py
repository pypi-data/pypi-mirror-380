##################### generated by xml-casa (v2) from tsdimaging.xml ################
##################### 713609c253d369e84269a826601df774 ##############################
from __future__ import absolute_import
import numpy
from casatools.typecheck import CasaValidator as _val_ctor
_pc = _val_ctor( )
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from .private.task_tsdimaging import tsdimaging as _tsdimaging_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from casatasks.private.task_logging import except_log as _except_log

class _tsdimaging:
    """
    tsdimaging ---- SD task: imaging for total power and spectral data

    
    Task sdimaging creates an image from input single-dish data sets.
    The input can be either total power and spectral data.
    
    The coordinate of output image is defined by four axes, i.e., two
    spatial axes, frequency and polarization axes.n
    By default, spatial coordinate of image is defined so that the all
    pointing directions in POINTING tables of input data sets are covered
    with the cell size, 1/3 of FWHM of primary beam of antennas in the
    first MS. Therefore, it is often easiest to leave spatial definitions
    at the default values. It is also possible to define spatial axes of
    the image by specifying the image center direction (phasecenter),
    number of image pixel (imsize) and size of the pixel (cell).n
    The frequency coordinate of image is defined by three parameters,
    the number of channels (nchan), the channel id/frequency/velocity of
    the first channel (start), and channel width (width).There are three
    modes available to define unit of start and width, i.e., 'channel' (use
    channel indices), 'frequency' (use frequency unit, e.g., 'GHz'),
    and 'velocity' (use velocity unit, e.g., 'km/s'). By default, nchan,
    start, and width are defined so that all selected spectral windows are
    covered with the channel width equal to separation of first two
    channels selected.n
    Finally, polarizations of image is defined by stokes parameter or
    polarization. For example, stokes='XXYY' produces an image cube with
    each plane contains the image of one of the polarizations, while
    stokes='I' produces a 'total intensity' or Stokes I image.
    The stokes parameter has a special option, 'pseudoI'. The option is
    introduced to support imaging of partially flagged correlations.
    Main difference between 'I' and 'pseudoI' is that the former only takes
    into account the data whose correlations are all valid (this is the
    Stokes I in the strict sense) while the latter accumulates partially
    flagged data in addition. Note that the 'pseudoI' option is compatible
    with 'I' for sdimaging task.
    
    The task also supports various grid function (convolution kernel) to
    weight spectra as well as an option to remove the most extreme minimum
    and maximum (unweighted) values prior to computing the gridded pixel
    values. See description below for details of gridfunction available.
    
    

    --------- parameter descriptions ---------------------------------------------

    infiles        a list of names of input SD Measurementsets (only MS is allowed for this task)
    outfile        prefix of output images (.image, .weight)
    overwrite      overwrite the output file if already exists [True, False]
    field          select data by field IDs and names, e.g. \'3C2*\' (\'\'=all)
    spw            select data by IF IDs (spectral windows), e.g. \'3,5,7\' (\'\'=all)
    antenna        select data by antenna names or IDs, e.g, \'PM03\' (\'\' = all antennas)
    scan           select data by scan numbers, e.g. \'21~23\' (\'\'=all)
    intent         select data by observational intent, e.g. \'*ON_SOURCE*\' (\'\'=all)
    timerange      select data by range of time, e.g. 20:15:00~20:16:00 (\'\'=all)
    outframe       velocity frame of output image (''=current frame or LSRK for multiple-MS inputs)
    mode           spectral gridding type [\'channel\', \'frequency\', \'velocity\']
    nchan          number of channels (planes) in output image (-1=all)
    start          start of output spectral dimension, e.g. \'0\', \'110GHz\', \'-20km/s\'
    width          width of output spectral channels
    veltype        velocity definition
    specmode       Spectral definition mode (cube, cubedata, cubesource)
    interpolation  Spectral interpolation ["nearest", "linear", "cubic"]
                   Interpolation rules to use when binning data channels onto image channels and evaluating visibility values at the centers of image channels.
                   Note :
                   - "linear" and "cubic" interpolation requires data points on both sides of each image frequency. Errors are therefore possible at edge channels, or near flagged data channels. When image channel width is much larger than the data channel width there is nothing much to be gained using linear or cubic thus not worth the extra computation involved.
                   - If there are significant differences in the observation dates of the input MSes, "nearest" interpolation may cause some problems with frequency channel matching.
    pointingcolumn pointing data column to use
    convertfirst   Specify whether the direction of the specified pointing column must be converted to image"s reference frame prior to being interpolated at data-taking time, and when. "never": interpolate against the pointing column, then convert.  "always": interpolate against the beforehand converted pointing column. "auto": if there are less pointings than selected data rows convert first, else interpolate first
    projection     map projection type
    imsize         x and y image size in pixels, e.g., [64,64]. Single value: same for both spatial axes ([] = number of pixels to cover whole pointings in MSes)
    cell           x and y cell size, (e.g., [\'8arcsec\',\'8arcsec\']. default unit arcmin. ('' = 1/3 of FWHM of primary beam)
    phasecenter    image center direction: position or field index or ephemeris source info, e.g., \'J2000 17:30:15.0 -25.30.00.0\', \'MARS\'. (\'\' = the center of pointing directions in MSes)
    stokes         stokes parameters or polarization types to image, e.g. \'I\', \'XX\'
    gridfunction   gridding function for imaging (see description in help)
    convsupport    convolution support for gridding
    truncate       truncation radius for gridding
    gwidth         HWHM for gaussian
    jwidth         c-parameter for jinc function
    clipminmax     Clip minimum and maximum value from each pixel. Note the benefit of clipping is lost when the number of integrations contributing to each gridded pixel is small, or where the incidence of spurious datapoints is approximately or greater than the number of beams (in area) encompassed by expected image.
    minweight      Minimum weight ratio to the median of weight used in weight correction and weight beased masking
    brightnessunit Overwrite the brightness unit in image (\'\' = respect the unit in MS) [\'K\' or \'Jy/beam\'].
                   If no unit is provided, the task examines unit keywords ('UNIT' and 'QuantumUnits' in turn) of data columns.
                   Order of the examination is 'CORRECTED_DATA' - 'FLOAT_DATA' - 'DATA'. The order also represents the priority.
                   When unit string is found, it will be used as brightness unit.
    restfreq       rest frequency to assign to image, e.g., \'114.5GHz\'. When the default value \'\' is used, the task currently internally uses REST_FREQUENCY of SOURCE table or mean frequency of given spectral window as a default value.
    [1;42mRETURNS[1;m           void

    --------- examples -----------------------------------------------------------

    
    Keyword arguments:
    infiles -- a list of names of input SD Measurementsets
    example: 'm100.PM01.ms'
    ['m100.PM01.ms','m100.PM03.ms']; multiple MSes
    outfile -- prefix of output images
    Currently, four images are created by the task:
    .image -- target image
    .weight -- weight image
    .sumwt -- sumwt image
    .psf -- psf image (equivalent to weight image)
    .sumwt and .psf are kind of useless so far. image products
    will be improved later.
    default: ''
    example: 'mySDimage.im'
    overwrite -- overwrite the output file if already exists
    options: (bool) True,False
    default: False (do NOT overwrite)
    example: if True, existing file will be overwritten
    field -- select data by field IDs and names
    If field string is a non-negative integer, it is assumed to
    be a field index otherwise, it is assumed to be a
    field name
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 3 or filed named 3C273)
    For multiple MS input, a list of field strings can be used:
    field = ['0~2','0~4'] (field ids 0-2 for the first MS and 0-4
    for the second)
    field = '0~2' (field ids 0-2 for all input MSes)
    this selection is in addition to the other selections to data
    spw -- select data by spectral window IDs/channels
    NOTE: channels de-selected here will contain all zeros if
    selected by the parameter mode subparameters.
    default: '' (use all IFs and channels)
    example: spw='3,5,7' (IF IDs 3,5,7; all channels)
    spw='<2' (IF IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (IF IDs with the center frequencies in range 30-45GHz; all channels)
    spw='0:5~61' (IF ID 0; channels 5 to 61; all channels)
    spw='3:10~20;50~60' (select multiple channel ranges within IF ID 3)
    spw='3:10~20,4:0~30' (select different channel ranges for IF IDs 3 and 4)
    spw='1~4;6:15~48' (for channels 15 through 48 for IF IDs 1,2,3,4 and 6)
    For multiple MS input, a list of spw strings can be used:
    spw=['0','0~3'] (spw ids 0 for the first MS and 0-3 for the second)
    spw='0~3' (spw ids 0-3 for all input MSes)
    this selection is in addition to the other selections to data
    antenna -- select data by antenna names or IDs
    If antenna string is a non-negative integer, it is
    assumed to be an antenna index, otherwise, it is
    considered an antenna name.
    default: '' (all baselines, i.e. all antenna in case of auto data)
    example: antenna='PM03'
    For multiple MS input, a list of antenna strings can be used:
    antenna=['5','6'] (antenna id5 for the first MS and 6 for the second)
    antenna='5' (antenna index 5 for all input MSes)
    this selection is in addition to the other selections to data
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    For multiple MS input, a list of scan strings can be used:
    scan=['0~100','10~200'] (scan ids 0-100 for the first MS
    and 10-200 for the second)
    scan='0~100 (scan ids 0-100 for all input MSes)
    this selection is in addition to the other selections to data
    intent -- select data by observational intent, also referred to as 'scan intent'
    default: 'OBSERVE_TARGET#ON_SOURCE' (ALMA ON-source intent)
    example: intent='' (use all scan intents)
    intent='*ON_SOURCE*' (any valid scan-intent expression accepted by the MSSelection module can be specified)
    For multiple MS input, a list of scan-intent expressions can be used:
    intent=['ON_SOURCE','CALIBRATE_BANDPASS'] (scan intent ON_SOURCE for the first MS
    and CALIBRATE_BANDPASS for the second)
    this selection is in addition to the other selections to data
    mode -- spectral gridding type
    options: 'channel', 'velocity', 'frequency'
    default: 'channel'
    >>> mode expandable parameters
    nchan -- Total number of channels in the output image.
    default: -1; Automatically selects enough channels to cover
    data selected by 'spw' consistent with 'start' and 'width'.
    It is often easiest to leave nchan at the default value.
    example: nchan=100
    start -- First channel, velocity, or frequency.
    For mode='channel'; This selects the channel index number
    from the MS (0 based) that you want to correspond to the
    first channel of the output cube. The output cube will be
    in frequency space with the first channel having the
    frequency of the MS channel selected by start.  start=0
    refers to the first channel in the first selected spw, even
    if that channel is de-selected in the spw parameter.
    Channels de-selected by the spw parameter will be filled with
    zeros if included by the start parameter. For example,
    spw=3~8:3~100 and start=2 will produce a cube that starts on
    the third channel (recall 0 based) of spw index 3, and the
    first channel will be blank.
    default: '' (the first input channel of first input spw)
    example: start=100 (mode='channel')
    start='22.3GHz' (mode='frequency')
    start='5.0km/s' (mode='velocity')
    width -- Output channel width
    For mode='channel', default=1; width>1 indicates channel averaging
    example: width=4.
    For mode= 'velocity' or 'frequency', default=''; width of
    first input channel, or more precisely, the difference
    in frequencies between the first two selected channels.
    -- For example if channels 1 and 3 are selected with spw,
    then the default width will be the difference between their
    frequencies, and not the width of channel 1.
    -- Similarly, if the selected data has uneven channel-spacing,
    the default width will be picked from the first two selected
    channels. In this case, please specify the desired width.
    When specifying the width, one must give units
    examples: width='1.0km/s', or width='24.2kHz'.
    Setting width>0 gives channels of increasing frequency for
    mode='frequency', and increasing velocity for mode='velocity'.
    veltype -- Velocity definition
    Options: 'radio','optical','true','relativistic'
    default: 'radio'
    specmode -- Spectral definition mode (cube, cubedata, cubesource)
    default: 'cube'
    Options: 'cube', 'cubedata', 'cubesource'
    'cube' : Spectral line imaging with one or more channels
    Parameters start, width,and nchan define the spectral
    coordinate system and can be specified either in terms
    of channel numbers, frequency or velocity in whatever
    spectral frame is specified in 'outframe'.
    All internal and output images are made with outframe as the
    base spectral frame. However imaging code internally uses the fixed
    spectral frame, LSRK for automatic internal software
    Doppler tracking so that a spectral line observed over an
    extended time range will line up appropriately.
    Therefore the output images have additional spectral frame conversion
    layer in LSRK on the top the base frame.
    'cubedata' : Spectral line imaging with one or more channels
    There is no internal software Doppler tracking so
    a spectral line observed over an extended time range
    may be smeared out in frequency. There is strictly
    no valid spectral frame with which to label the output
    images, but they will list the frame defined in the MS
    'cubesource': Spectral line imaging while
    tracking moving source (near field or solar system
    objects). The velocity of the source is accounted
    and the frequency reported is in the source frame.
    As there is not SOURCE frame defined,
    the frame reported will be REST (as it may not be
    in the rest frame emission region may be
    moving w.r.t the systemic velocity frame)
    outframe -- velocity reference frame of output image
    Options: '','LSRK','LSRD','BARY','GEO','TOPO','GALACTO',
    'LGROUP','CMB'
    default: ''; same as input data or 'LSRK' for multiple-MS inputs
    example: frame='bary' for Barycentric frame
    gridfunction -- gridding function for imaging
    options: 'BOX' (Box-car), 'SF' (Spheroidal),
    'PB' (Primary-beam), 'GAUSS' (Gaussian),
    'GJINC' (Gaussian*Jinc)
    default: 'BOX'
    example: 'SF'
    >>> gridfunction expandable parameter:
    convsupport -- convolution support for 'SF'
    default: -1 (use default for each gridfunction)
    example: 3
    truncate -- truncattion radius of convolution kernel.
    effective only for 'GAUSS' and 'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    gwidth -- HWHM for gaussian. Effective only for
    'GAUSS' and 'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    jwidth -- Width of jinc function. Effective only for
    'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    imsize -- x and y image size in pixels, symmetric for single value
    default: [] (=cover all pointings in MS)
    example: imsize=200 (equivalent to [200,200])
    cell -- x and y cell size. default unit arcmin
    default: '' (= 1/3 of FWHM of primary beam)
    example: cell=['0.2arcmin, 0.2arcmin']
    cell='0.2arcmin' (equivalent to example above)
    phasecenter -- image center: direction measure, field ID, or
    ephemerides source information for moving source (solar system objects)
    default: '' (= the center of pointing directions in
    POINTING table of infiles)
    example: phasecenter=6 (field ID)
    phasecenter='J2000 13h44m00 -17d02m00'
    phasecenter='AZEL -123d48m29 15d41m41'
    phasecenter='MARS'
    phasecenter='myComet_ephem.tab'
    phasecenter='TRACKFIELD'
    
    If the phasecenter is the name known major solar system object
    ('MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS',
    'NEPTUNE', 'PLUTO', 'SUN', 'MOON') or is an ephemerides table
    then that source is tracked and the background sources get smeared.
    There is a special case, when phasecenter='TRACKFIELD', which
    will use the ephemerides or polynomial phasecenter in the FIELD
    table of the MS's as the source center to track.
    
    When moving source correction is applied, the source is fixed to
    the position at the beginning of on-source observations in the data.
    Direction reference frame of output image refers phasecenter ('J2000'
    if phasecenter is empty).
    
    Caution: in case of specifying ephemeris table name, its name or path
    must not start with known major solar system object listed
    above (case-insensitive), otherwise, CASA will use its
    internal ephemeris data for phasecenter instead. In such case
    you need to add './' at the beginning so that the specified
    table will be used. For example, if you wish to explicitly
    specify ephemeris table attached to the input MS 'SunObs.ms',
    set phasecenter like './SunObs.ms/FIELD/ephemtab_name.tab'.
    
    projection -- map projection type. See Calabretta & Greisen (2002) for detail.
    default: 'SIN'
    options: 'SIN', 'CAR', 'TAN', 'SFL'
    pointingcolumn -- pointing data column to use
    option: 'direction', 'target', 'pointing_offset', 'source_offset', encoder'
    default: 'direction'
    restfreq -- specify rest frequency to use for output image
    default: '' (refer input data)
    example: 1.0e11, '100GHz'
    stokes -- Stokes Planes to make
    default='I'; example: stokes='XXYY';
    options: 'I','Q','U','V','IV','QU','IQ','UV','IQUV','RR','LL','XX','YY','RRLL','XXYY','pseudoI'
    Note : The 'pseudoI' option is a partial solution, allowing Stokes I imaging
    when either of the parallel-hand correlations are unflagged.
    
    minweight -- Minimum weight ratio to the median of weight used in
    weight correction and weight based masking
    default: 0.1
    example: minweight = 0.
    brightnessunit -- Overwrite the brightness unit in image ['K' or 'Jy/beam'].
    If no unit is provided, the task examines unit keywords ('UNIT' and 'QuantumUnits' in turn) of data columns.
    Order of the examination is 'CORRECTED_DATA' - 'FLOAT_DATA' - 'DATA'. The order also represents the priority.
    When unit string is found, it will be used as brightness unit.
    default: '' (use the unit in MS)
    Options: '', 'K' (Kelvin), 'Jy/beam'
    clipminmax -- Clip minimum and maximum value from each pixel.
    Note the benefit of clipping is lost when the number of
    integrations contributing to each gridded pixel is small,
    or where the incidence of spurious datapoints is
    approximately or greater than the number of beams (in area)
    encompassed by expected image.
    default: False
    option: True, False
    interpolation -- Spectral interpolation.
    Interpolation rules to use when binning data channels onto image channels and
    evaluating visibility values at the centers of image channels.
    Note :
    - 'linear' and 'cubic' interpolation requires data points on both sides of each image frequency.
    Errors are therefore possible at edge channels, or near flagged data channels.
    When image channel width is much larger than the data channel width there is nothing much to be gained
    using linear or cubic thus not worth the extra computation involved.
    - If there are significant differences in observing dates of input MSes, some problems merely occur
    in frequency channel matching when 'nearest' interpolation.
    option: 'linear', 'nearest', 'cubic'
    default: 'linear'
    
    -----------------
    Gridding Kernel
    -----------------
    The parameter gridfunction sets gridding function (convolution kernel)
    for imaging. Currently, the task supports 'BOX' (Box-car), 'SF' (Prolate
    Spheroidal Wave Function), 'GAUSS' (Gaussian), 'GJINC' (Gaussian*Jinc),
    where Jinc(x) = J_1(pi*x/c)/(pi*x/c) with a first order Bessel function
    J_1, and 'PB' (Primary Beam). For 'PB', correct antenna informations
    should be included in input file.
    
    There are four subparameters for gridfunction: convsupport, truncate,
    gwidth, and jwidth. The convsupport is an integer specifying cut-off
    radius for 'SF' in units of pixel. By default (convsupport=-1),
    the cut-off radius is set to 3 pixels. The truncate is a cut-off
    radius for 'GAUSS' or 'GJINC'. It accepts integer, float, and
    string values of numeric plus unit. Allowed units are angular
    units such as 'deg', 'arcmin', 'arcsec', and 'pixel'. Default unit
    is 'pixel' so that string without unit or numerical values (integer
    or float) will be interpreted as radius in pixel. Default value
    for truncate, which is used when negative radius is set, is 3*HWHM
    for 'GAUSS' and radius at first null for 'GJINC'. The gwidth is
    the HWHM of gaussian for 'GAUSS' and 'GJINC'. Default value is
    sqrt(log(2)) pixel for 'GAUSS' and 2.52*sqrt(log(2)) pixel for
    'GJINC'. The jwidth specifies width of the jinc function (parameter
    'c' in the definition above). Default is 1.55 pixel. Both gwidth
    jwidth allows integer, float, or string of numeric plus unit.
    Default values for gwidth and jwidth are taken from Mangum et al.
    (2007). Formula for 'GAUSS' and 'GJINC' are taken from Table 1 in
    the paper, and are written as below using gwidth and jwidth:
    
    GAUSS: exp[-log(2)*(|r|/gwidth)**2]
    
    GJINC: J_1(pi*|r|/jwidth)/(pi*|r|/jwidth)
    * exp[-log(2)*(|r|/gwidth)^2]
    
    
    Reference: Mangum, et al. 2007, A&A, 474, 679-687
    
    --------------------
    Mask in Output Image
    --------------------
    The parameter minweight defines a threshold of weight values
    to mask. The pixels in outfile whose weight is smaller than
    minweight*median(weight) are masked out. The task also creates
    a weight image with the name outfile.weight.
    
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """SD task: imaging for total power and spectral data"""

    def __call__( self, infiles=[  ], outfile='', overwrite=False, field='', spw='', antenna='', scan='', intent='OBSERVE_TARGET#ON_SOURCE', timerange='', outframe='', mode='channel', nchan=int(-1), start=int(0), width=int(1), veltype='radio', specmode='cube', interpolation='linear', pointingcolumn='direction', convertfirst='never', projection='SIN', imsize=[  ], cell='', phasecenter='', stokes='I', gridfunction='BOX', convsupport=int(-1), truncate=int(-1), gwidth=int(-1), jwidth=int(-1), clipminmax=False, minweight=float(0.1), brightnessunit='', restfreq='' ):
        schema = {'infiles': {'type': 'cReqPathVec', 'coerce': [_coerce.to_list,_coerce.expand_pathvec]}, 'outfile': {'type': 'cStr', 'coerce': _coerce.to_str}, 'overwrite': {'type': 'cBool'}, 'field': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'spw': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'antenna': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'scan': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'intent': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'type': 'cStr', 'coerce': _coerce.to_str}, 'outframe': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'LSRK', 'CMB', 'geo', 'bary', 'GALACTO', 'GEO', 'TOPO', 'LSRD', 'lsrk', 'topo', 'LGROUP', 'BARY', 'lsrd', 'cmb', 'galacto', 'lgroup', '' ]}, 'mode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'channel', 'frequency', 'velocity' ]}, 'nchan': {'type': 'cInt'}, 'start': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'width': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'veltype': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'OPTICAL', 'RELATIVISTIC', 'radio', 'true', 'optical', 'RADIO', 'TRUE', 'relativistic' ]}, 'specmode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'cube', 'cubedata', 'cubesource' ]}, 'interpolation': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'nearest', 'linear', 'cubic' ]}, 'pointingcolumn': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'TARGET', 'encoder', 'ENCODER', 'source_offset', 'pointing_offset', 'target', 'POINTING_OFFSET', 'DIRECTION', 'SOURCE_OFFSET', 'direction' ]}, 'convertfirst': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'never', 'auto', 'always' ]}, 'projection': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'sin', 'SIN', 'SFL', 'CAR', 'sfl', 'car', 'TAN', 'tan' ]}, 'imsize': {'anyof': [{'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'cell': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'phasecenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'stokes': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'I', 'IQUV', 'UV', 'RRLL', 'IQ', 'V', 'pseudoI', 'QU', 'YY', 'RR', 'Q', 'U', 'IV', 'XX', 'XXYY', 'LL' ]}, 'gridfunction': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'GJINC', 'pb', 'sf', 'GAUSS', 'PB', 'SF', 'gauss', 'BOX', 'box', 'gjinc' ]}, 'convsupport': {'type': 'cInt'}, 'truncate': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'gwidth': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'jwidth': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'clipminmax': {'type': 'cBool'}, 'minweight': {'type': 'cFloat', 'coerce': _coerce.to_float, 'min': 0}, 'brightnessunit': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ '', 'K', 'Jy/beam' ]}, 'restfreq': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}}
        doc = {'infiles': infiles, 'outfile': outfile, 'overwrite': overwrite, 'field': field, 'spw': spw, 'antenna': antenna, 'scan': scan, 'intent': intent, 'timerange': timerange, 'outframe': outframe, 'mode': mode, 'nchan': nchan, 'start': start, 'width': width, 'veltype': veltype, 'specmode': specmode, 'interpolation': interpolation, 'pointingcolumn': pointingcolumn, 'convertfirst': convertfirst, 'projection': projection, 'imsize': imsize, 'cell': cell, 'phasecenter': phasecenter, 'stokes': stokes, 'gridfunction': gridfunction, 'convsupport': convsupport, 'truncate': truncate, 'gwidth': gwidth, 'jwidth': jwidth, 'clipminmax': clipminmax, 'minweight': minweight, 'brightnessunit': brightnessunit, 'restfreq': restfreq}
        assert _pc.validate(doc,schema), create_error_string(_pc.errors)
        _logging_state_ = _start_log( 'tsdimaging', [ 'infiles=' + repr(_pc.document['infiles']), 'outfile=' + repr(_pc.document['outfile']), 'overwrite=' + repr(_pc.document['overwrite']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'antenna=' + repr(_pc.document['antenna']), 'scan=' + repr(_pc.document['scan']), 'intent=' + repr(_pc.document['intent']), 'timerange=' + repr(_pc.document['timerange']), 'outframe=' + repr(_pc.document['outframe']), 'mode=' + repr(_pc.document['mode']), 'nchan=' + repr(_pc.document['nchan']), 'start=' + repr(_pc.document['start']), 'width=' + repr(_pc.document['width']), 'veltype=' + repr(_pc.document['veltype']), 'specmode=' + repr(_pc.document['specmode']), 'interpolation=' + repr(_pc.document['interpolation']), 'pointingcolumn=' + repr(_pc.document['pointingcolumn']), 'convertfirst=' + repr(_pc.document['convertfirst']), 'projection=' + repr(_pc.document['projection']), 'imsize=' + repr(_pc.document['imsize']), 'cell=' + repr(_pc.document['cell']), 'phasecenter=' + repr(_pc.document['phasecenter']), 'stokes=' + repr(_pc.document['stokes']), 'gridfunction=' + repr(_pc.document['gridfunction']), 'convsupport=' + repr(_pc.document['convsupport']), 'truncate=' + repr(_pc.document['truncate']), 'gwidth=' + repr(_pc.document['gwidth']), 'jwidth=' + repr(_pc.document['jwidth']), 'clipminmax=' + repr(_pc.document['clipminmax']), 'minweight=' + repr(_pc.document['minweight']), 'brightnessunit=' + repr(_pc.document['brightnessunit']), 'restfreq=' + repr(_pc.document['restfreq']) ] )
        task_result = None
        try:
            task_result = _tsdimaging_t( _pc.document['infiles'], _pc.document['outfile'], _pc.document['overwrite'], _pc.document['field'], _pc.document['spw'], _pc.document['antenna'], _pc.document['scan'], _pc.document['intent'], _pc.document['timerange'], _pc.document['outframe'], _pc.document['mode'], _pc.document['nchan'], _pc.document['start'], _pc.document['width'], _pc.document['veltype'], _pc.document['specmode'], _pc.document['interpolation'], _pc.document['pointingcolumn'], _pc.document['convertfirst'], _pc.document['projection'], _pc.document['imsize'], _pc.document['cell'], _pc.document['phasecenter'], _pc.document['stokes'], _pc.document['gridfunction'], _pc.document['convsupport'], _pc.document['truncate'], _pc.document['gwidth'], _pc.document['jwidth'], _pc.document['clipminmax'], _pc.document['minweight'], _pc.document['brightnessunit'], _pc.document['restfreq'] )
        except Exception as exc:
            _except_log('tsdimaging', exc)
            raise
        finally:
            task_result = _end_log( _logging_state_, 'tsdimaging', task_result )
        return task_result

tsdimaging = _tsdimaging( )

