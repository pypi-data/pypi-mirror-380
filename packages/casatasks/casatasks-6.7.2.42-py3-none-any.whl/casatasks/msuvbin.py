##################### generated by xml-casa (v2) from msuvbin.xml ###################
##################### 1b0767ff69d778776ecf7ddce14ced3c ##############################
from __future__ import absolute_import
import numpy
from casatools.typecheck import CasaValidator as _val_ctor
_pc = _val_ctor( )
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from .private.task_msuvbin import msuvbin as _msuvbin_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from casatasks.private.task_logging import except_log as _except_log

class _msuvbin:
    """
    msuvbin ---- grid the visibility data onto a defined uniform grid (in the form of an ms); multiple MS's can be done onto the same grid

    
    msuvbin is a uv gridding task. The use is for large volumes
    of data (from multiple epochs) that needs to be imaged into
    one image.  One way of proceeding is to image the epochs and
    average them after wards. Rather than doing this averaging
    the visibilities on a common uv grid has several convenience
    advantages like easily doing the proper weighted averaging and imaging.
    If an output grid already exists and a second ms is gridded on the grid
    then the output grid parameters is ignored but the existant grid is used.
    
    

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file (MS)
                default: none;
    field       Field selection of input ms; use mssel syntax
    spw         Spw selection; mssel syntax
    taql        TaQl string for data selection; the advance user can do
                sophisticated data selection; see http://casacore.github.io/casacore-notes/199.html
    outputvis   name of output uvgrid; if it existant the data will be binned additively into
                that uvgrid (as long as the parameters match for the grid description). If the gridded ms
                exists
                and the gridding parameters do not match the ones with which the grid was made---
                msuvbin will exit with an exception
    phasecenter phase center of uv grid; if empty it will default
                the first field selected in the input ms
    imsize      Number of pixels
                example:
                
                imsize = [350,250]
                imsize = 500 is equivalent to [500,500]
                
                To take proper advantage of internal optimized FFT routines, the
                number of pixels must be even and factorizable by 2,3,5 only.
                To find the nearest optimal imsize to that desired by the user, please use the following tool method:
                
                from casatools import synthesisutils
                su = synthesisutils()
                su.getOptimumSize(345) 
                Output :  360
    cell        pixel cell size defined in sky dimension
                This should be in the units of sky angle. Usually you want to have a pixel size that
                is smaller than the maximum resolution that can be expected from the data.
    ncorr       number of correlations to store in grid
                if 1 is chosen and data have cross hands, then both XX and YY (or RR and LL)
                will be gridded on the same correlation plane (XX or RR as MS V2.0 does not support
                I as a correlation type).
                if 2 is chosen the parallel hands will be stored on independent grids for each frequency channel
                if 4 is chosen the all correlation type will be gridded independently.
    nchan       Nunmber of spectral channels in the output grid
    start       Frequency of first channel of grid. If left empty, it will try to use the
                	lowest frequency in the selected data
    width       Spectral channel width. If left empty the badwidth of the selected data will be divided by the nchan
                	selected to determine the width of an output channel. This happens only when not output grid already exists.
    wproject    Do wprojection correction while gridding. This should be used with care as it is known to have issues like perfomance
                	and for Cotton-Schwab style cleaning.
    memfrac     Limit fraction of RAM  available to use. Default is half.
    mode        when mode  will transfer back flag from grid to input ms
                For this to work both the original ms and the gridded ms has to exist and the flags will be
                transferred from the gridded ms back to original ms. This is provided as a utility to
                msuvbinflagger task.
    flagbackup  Backup flags before saving flags when using write_flags_back
    [1;42mRETURNS[1;m        void

    --------- examples -----------------------------------------------------------

    
    
    
    
    
    Keyword arguments:
    vis -- Name of input visibility file
    default: none; example: vis='ngc5921.ms'
    field -- Field name list
    default: '' ==> all
    field = '1328+307'  specifies source '1328+307'
    field = '4' specified field with index 4
    spw -- Spw selection
    default: spw = '' (all spw)
    spw='2'
    taql  --TaQl expression for data selection (see https://casacore.github.io/casacore-notes/199.html)
    default taql=''
    Example select all data where U > 1 m in the ms
    taql='UVW[0] > 1'
    outputvis -- name of output grid
    default: ''  The user has to give something here
    phasecenter -- phasecenter of the grid
    default= ''
    phasecenter='J2000 18h03m04 -20d00m45.1'
    imsize  -- number of pixels along the x and y axes of the grid
    default=100
    imsize=[1000, 1000]
    cell -- cellsize of the grid (given in sky units)
    default: '1arcsec'
    cell='0.1arcsec'
    ncorr -- number of correlation/polarization plane in uv grid (allowed 1, 2, 4)
    default: 1
    ncorr=4
    nchan -- number of spectral channel
    default: 1
    nchan=2000
    start -- frequency of the first channel
    default: '';  User has to give something useful here
    width -- spectral channel width
    default: ''
    wproject -- do wprojection correction while gridding
    default: False
    wproject=True
    memfrac -- control how much of computer's memory is available for  gridding
    default=0.5
    memfrac=0.9
    
    


    """

    _info_group_ = """manipulation, imaging"""
    _info_desc_ = """grid the visibility data onto a defined uniform grid (in the form of an ms); multiple MS\'s can be done onto the same grid"""

    def __call__( self, vis='', field='', spw='', taql='', outputvis='', phasecenter='', imsize=[ int(100) ], cell='1arcsec', ncorr=int(1), nchan=int(1), start='', width='', wproject=False, memfrac=float(0.5), mode='bin', flagbackup=False ):
        schema = {'vis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'taql': {'type': 'cStr', 'coerce': _coerce.to_str}, 'outputvis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'phasecenter': {'type': 'cStr', 'coerce': _coerce.to_str}, 'imsize': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'cell': {'type': 'cStr', 'coerce': _coerce.to_str}, 'ncorr': {'type': 'cInt', 'allowed': [ 1, 2, 4 ]}, 'nchan': {'type': 'cInt'}, 'start': {'type': 'cStr', 'coerce': _coerce.to_str}, 'width': {'type': 'cStr', 'coerce': _coerce.to_str}, 'wproject': {'type': 'cBool' # <allowed> IS NOT ALLOWED FOR A PARAMETER OF TYPE bool
}, 'memfrac': {'type': 'cFloat', 'coerce': _coerce.to_float, 'min': 0.01, 'max': 0.99}, 'mode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'bin', 'write_flags_back' ]}, 'flagbackup': {'type': 'cBool'}}
        doc = {'vis': vis, 'field': field, 'spw': spw, 'taql': taql, 'outputvis': outputvis, 'phasecenter': phasecenter, 'imsize': imsize, 'cell': cell, 'ncorr': ncorr, 'nchan': nchan, 'start': start, 'width': width, 'wproject': wproject, 'memfrac': memfrac, 'mode': mode, 'flagbackup': flagbackup}
        assert _pc.validate(doc,schema), create_error_string(_pc.errors)
        _logging_state_ = _start_log( 'msuvbin', [ 'vis=' + repr(_pc.document['vis']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'taql=' + repr(_pc.document['taql']), 'outputvis=' + repr(_pc.document['outputvis']), 'phasecenter=' + repr(_pc.document['phasecenter']), 'imsize=' + repr(_pc.document['imsize']), 'cell=' + repr(_pc.document['cell']), 'ncorr=' + repr(_pc.document['ncorr']), 'nchan=' + repr(_pc.document['nchan']), 'start=' + repr(_pc.document['start']), 'width=' + repr(_pc.document['width']), 'wproject=' + repr(_pc.document['wproject']), 'memfrac=' + repr(_pc.document['memfrac']), 'mode=' + repr(_pc.document['mode']), 'flagbackup=' + repr(_pc.document['flagbackup']) ] )
        task_result = None
        try:
            task_result = _msuvbin_t( _pc.document['vis'], _pc.document['field'], _pc.document['spw'], _pc.document['taql'], _pc.document['outputvis'], _pc.document['phasecenter'], _pc.document['imsize'], _pc.document['cell'], _pc.document['ncorr'], _pc.document['nchan'], _pc.document['start'], _pc.document['width'], _pc.document['wproject'], _pc.document['memfrac'], _pc.document['mode'], _pc.document['flagbackup'] )
        except Exception as exc:
            _except_log('msuvbin', exc)
            raise
        finally:
            task_result = _end_log( _logging_state_, 'msuvbin', task_result )
        return task_result

msuvbin = _msuvbin( )

