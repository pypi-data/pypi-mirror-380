##################### generated by xml-casa (v2) from wvrgcal.xml ###################
##################### 62b478f27bd647d7dd85ba7e69456e62 ##############################
from __future__ import absolute_import
import numpy
from casatools.typecheck import CasaValidator as _val_ctor
_pc = _val_ctor( )
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from .private.task_wvrgcal import wvrgcal as _wvrgcal_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from casatasks.private.task_logging import except_log as _except_log

class _wvrgcal:
    """
    wvrgcal ---- Generate a gain table based on Water Vapour Radiometer data

    
    
    Information about the observation and the performance of WVRGCAL is written to the CASA logger
    and also returned in a dictionary; see the CASA cookbook for a more detailed description of these parameters.
    The dictionary element 'success' is True if no errors occured.
    
    Of particular note is the discrepancy parameter (Disc): high values (> a few hundred microns)
    may indicate some levels of cloud contamination and the effect of applying the WVRGCAL correction
    should be checked; values > 1000 um in all antennas have currently been found to indicate that
    WVRGCAL correction should not be used.
    
    
    vis -- Name of input visibility file
    default: none; example: vis='ngc5921.ms'
    
    caltable -- Name of output gain calibration table
    default: none; example: caltable='ngc5921.wvr'
    
    toffset -- Time offset (sec) between interferometric and WVR data
    default: 0 (ALMA default for cycle 1, for cycle 0, i.e. up to Jan 2013 it was -1)
    
    segsource -- Do a new coefficient calculation for each source
    default: True
    
    tie -- Prioritise tieing the phase of these sources as well as possible
    (requires segsource=True)
    default: [] example: ['3C273,NGC253', 'IC433,3C279']
    
    sourceflag -- Flag the WVR data for these source(s) as bad and do not produce corrections for it
    (requires segsource=True)
    default: [] (none) example: ['3C273']
    
    nsol -- Number of solutions for phase correction coefficients during this observation.
    By default only one set of coefficients is generated for the entire observation.
    If more sets are requested, then they will be evenly distributed in time throughout
    the observation. Values > 1 require segsource=False.
    default: 1
    
    disperse -- Apply correction for dispersion
    default: False
    
    wvrflag -- Regard the WVR data for these antenna(s) as bad and use interpolated values instead
    default: [] (none) example: ['DV03','DA05','PM02']
    
    statfield -- Compute the statistics (Phase RMS, Disc) on this field only
    default: '' (all)
    
    statsource -- Compute the statistics (Phase RMS, Disc) on this source only
    default: '' (all)
    
    smooth -- Smooth the calibration solution on the given timescale
    default: '' (no smoothing), example: '3s' smooth on a timescale of 3 seconds
    
    scale -- Scale the entire phase correction by this factor
    default: 1. (no scaling)
    
    spw -- List of the spectral window IDs for which solutions should be saved into the caltable
    default: [] (all spectral windows), example [17,19,21,23]
    
    wvrspw -- List of the spectral window IDs from which the WVR data should be taken
    default: [] (all WVR spectral windows), example [0]
    
    reversespw -- Reverse the sign of the correction for the listed SPWs
    (only neede for early ALMA data before Cycle 0)
    default: '' (none), example: reversespw='0~2,4'; spectral windows 0,1,2,4
    
    cont -- Estimate the continuum (e.g., due to clouds)
    default: False
    
    maxdistm -- maximum distance (m) an antenna may have to be considered for being part
    of the antenna set (minnumants to 3 antennas) for the interpolation of a solution
    for a flagged antenna
    default: 500.
    
    minnumants -- minimum number of near antennas required for interpolation
    default: 2
    
    mingoodfrac -- If the fraction of unflagged data for an antenna is below this value (0. to 1.),
    the antenna is flagged.
    default: 0.8
    
    usefieldtab -- derive the antenna AZ/EL values from the FIELD rather than the POINTING table
    default: False
    
    refant -- use the WVR data from this antenna for calculating the dT/dL parameters (can give ranked list)
    default: '' (use the first good or interpolatable antenna),
    examples: 'DA45' - use DA45
    ['DA45','DV51'] - use DA45 and if that is not good, use DV51 instead
    
    offsetstable -- subtract the temperature offsets in this table from the WVR measurements before
    using them to calculate the phase corrections
    default: '' (do not apply any offsets)
    examples: 'uid___A002_Xabd867_X2277.cloud_offsets' use the given table
    
    rseed -- set random seed (integer) for the wvrgcal fitting routine to this specific value
    default: 0 - use internal default value
    example: 54321
    
    

    --------- parameter descriptions ---------------------------------------------

    vis          Name of input visibility file
    caltable     Name of output gain calibration table
    toffset      Time offset (sec) between interferometric and WVR data
    segsource    Do a new coefficient calculation for each source
    sourceflag   Regard the WVR data for these source(s) as bad and do not produce corrections for it (requires segsource=True)
    tie          Prioritise tieing the phase of these sources as well as possible (requires segsource=True)
    nsol         Number of solutions for phase correction coefficients (nsol>1 requires segsource=False)
    disperse     Apply correction for dispersion
    wvrflag      Regard the WVR data for these antenna(s) as bad and replace its data with interpolated values from neighbouring antennas
    statfield    Compute the statistics (Phase RMS, Disc) on this field only
    statsource   Compute the statistics (Phase RMS, Disc) on this source only
    smooth       Smooth calibration solution on the given timescale
    scale        Scale the entire phase correction by this factor
    spw          List of the spectral window IDs for which solutions should be saved into the caltable
    wvrspw       List of the spectral window IDs from which the WVR data should be taken
    reversespw   Reverse the sign of the correction for the listed SPWs (only needed for early ALMA data before Cycle 0)
    cont         Estimate the continuum (e.g., due to clouds) (experimental)
    maxdistm     maximum distance (m) of an antenna used for interpolation for a flagged antenna
    minnumants   minimum number of near antennas (up to 3) required for interpolation
    mingoodfrac  If the fraction of unflagged data for an antenna is below this value (0. to 1.), the antenna is flagged.
    usefieldtab  derive the antenna AZ/EL values from the FIELD rather than the POINTING table
    refant       use the WVR data from this antenna for calculating the dT/dL parameters (can give ranked list)
    offsetstable subtract the temperature offsets in this table from the WVR measurements before calculating the phase corrections
    rseed        random seed for fitting routine, 0 == use internal default
    [1;42mRETURNS[1;m         variant

    --------- examples -----------------------------------------------------------

    
    
    wvrgcal(vis='uid___A002_X1d54a1_X5.ms', caltable='cal-wvr-uid___A002_X1d54a1_X5.W',
    toffset=-1, segsource=True, tie=['Titan,1037-295,NGC3256'], statsource='1037-295')
    
    


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Generate a gain table based on Water Vapour Radiometer data"""

    def __call__( self, vis='', caltable='', toffset=float(0), segsource=True, sourceflag=[  ], tie=[  ], nsol=int(1), disperse=False, wvrflag=[  ], statfield='', statsource='', smooth='', scale=float(1.), spw=[  ], wvrspw=[  ], reversespw='', cont=False, maxdistm=float(500.), minnumants=int(2), mingoodfrac=float(0.8), usefieldtab=False, refant=[  ], offsetstable='', rseed=int(0) ):
        schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'caltable': {'type': 'cPath', 'coerce': _coerce.expand_path}, 'toffset': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'segsource': {'type': 'cBool'}, 'sourceflag': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'tie': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'nsol': {'type': 'cInt'}, 'disperse': {'type': 'cBool'}, 'wvrflag': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'statfield': {'type': 'cStr', 'coerce': _coerce.to_str}, 'statsource': {'type': 'cStr', 'coerce': _coerce.to_str}, 'smooth': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scale': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'spw': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'wvrspw': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'reversespw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'cont': {'type': 'cBool'}, 'maxdistm': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'minnumants': {'type': 'cInt', 'allowed': [ 1, 2, 3 ]}, 'mingoodfrac': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'usefieldtab': {'type': 'cBool'}, 'refant': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'offsetstable': {'type': 'cStr', 'coerce': _coerce.to_str}, 'rseed': {'type': 'cInt'}}
        doc = {'vis': vis, 'caltable': caltable, 'toffset': toffset, 'segsource': segsource, 'sourceflag': sourceflag, 'tie': tie, 'nsol': nsol, 'disperse': disperse, 'wvrflag': wvrflag, 'statfield': statfield, 'statsource': statsource, 'smooth': smooth, 'scale': scale, 'spw': spw, 'wvrspw': wvrspw, 'reversespw': reversespw, 'cont': cont, 'maxdistm': maxdistm, 'minnumants': minnumants, 'mingoodfrac': mingoodfrac, 'usefieldtab': usefieldtab, 'refant': refant, 'offsetstable': offsetstable, 'rseed': rseed}
        assert _pc.validate(doc,schema), create_error_string(_pc.errors)
        _logging_state_ = _start_log( 'wvrgcal', [ 'vis=' + repr(_pc.document['vis']), 'caltable=' + repr(_pc.document['caltable']), 'toffset=' + repr(_pc.document['toffset']), 'segsource=' + repr(_pc.document['segsource']), 'sourceflag=' + repr(_pc.document['sourceflag']), 'tie=' + repr(_pc.document['tie']), 'nsol=' + repr(_pc.document['nsol']), 'disperse=' + repr(_pc.document['disperse']), 'wvrflag=' + repr(_pc.document['wvrflag']), 'statfield=' + repr(_pc.document['statfield']), 'statsource=' + repr(_pc.document['statsource']), 'smooth=' + repr(_pc.document['smooth']), 'scale=' + repr(_pc.document['scale']), 'spw=' + repr(_pc.document['spw']), 'wvrspw=' + repr(_pc.document['wvrspw']), 'reversespw=' + repr(_pc.document['reversespw']), 'cont=' + repr(_pc.document['cont']), 'maxdistm=' + repr(_pc.document['maxdistm']), 'minnumants=' + repr(_pc.document['minnumants']), 'mingoodfrac=' + repr(_pc.document['mingoodfrac']), 'usefieldtab=' + repr(_pc.document['usefieldtab']), 'refant=' + repr(_pc.document['refant']), 'offsetstable=' + repr(_pc.document['offsetstable']), 'rseed=' + repr(_pc.document['rseed']) ] )
        task_result = None
        try:
            task_result = _wvrgcal_t( _pc.document['vis'], _pc.document['caltable'], _pc.document['toffset'], _pc.document['segsource'], _pc.document['sourceflag'], _pc.document['tie'], _pc.document['nsol'], _pc.document['disperse'], _pc.document['wvrflag'], _pc.document['statfield'], _pc.document['statsource'], _pc.document['smooth'], _pc.document['scale'], _pc.document['spw'], _pc.document['wvrspw'], _pc.document['reversespw'], _pc.document['cont'], _pc.document['maxdistm'], _pc.document['minnumants'], _pc.document['mingoodfrac'], _pc.document['usefieldtab'], _pc.document['refant'], _pc.document['offsetstable'], _pc.document['rseed'] )
        except Exception as exc:
            _except_log('wvrgcal', exc)
            raise
        finally:
            task_result = _end_log( _logging_state_, 'wvrgcal', task_result )
        return task_result

wvrgcal = _wvrgcal( )

