# Copyright 2019-2025 Rumma & Ko Ltd
# License: GNU Affero General Public License v3 (see file COPYING for details)
"""Some utilities for getlino.
"""

import os
from os.path import expanduser
from pathlib import Path
import stat
import shutil
try:
    import grp
except ImportError:
    grp = None  # e.g. on Windows
import configparser
import subprocess
import click
# import platform
import distro
import getpass
import virtualenv
from contextlib import contextmanager
from jinja2 import Environment, PackageLoader
from synodal import REPOS_DICT, KNOWN_REPOS, FRONT_ENDS
from getlino import __version__


JINJA_ENV = Environment(loader=PackageLoader('getlino', 'templates'))

GITLAB_CI = os.environ.get("GITLAB_CI", "false") == "true"
USING_GITLAB_SERVICES = False

# currently getlino supports only nginx, maybe we might add other web servers
# USE_NGINX = True

BATCH_HELP = "Whether to run in batch mode, i.e. without asking any questions.  "\
             "Don't use this on a machine that is already being used."

# note that we double curly braces because we will run format() on this string:
LOGROTATE_CONF = """\
# generated by getlino
{logfile} {{
    size 1M
    rotate 12
    missingok
    compress
    delaycompress
    notifempty
    create 660 root {usergroup}
    su root {usergroup}
    sharedscripts
}}
"""


def grpexists(name):
    """Check whether the user group with the given ``name`` exists.
    """
    try:
        grp.getgrnam(name)
    except KeyError:
        return False
    return True


def perm2text(value):
    """

    Convert a permission value given as integer returned by os.stat() to an "rwx"
    like text as used by :command:`ls -l`.

    Inspired from comment by hack-tramp (Jul 6, 2020) on
    https://gist.github.com/beugley/47b4812df0837fc90e783347faee2432
    """
    octal = "{:04o}".format(value)
    result = ''
    first = 0
    # if there are 4 digits, deal with first (setuid, setgid, and sticky flags) separately
    if len(octal) > 4:
        raise Exception("value must be less than 0o7777")
    if octal[0] != '0':
        first = int(octal[:1])
    octal = octal[-3:]
    value_letters = [(4, 'r'), (2, 'w'), (1, 'x')]
    # Iterate over each of the digits in octal
    for permission in [int(n) for n in octal]:
        # Check for each of the permissions values
        for value, letter in value_letters:
            if permission >= value:
                result += letter
                permission -= value
            else:
                result += '-'
    if first != 0:
        for value in [4, 2, 1]:
            if first >= value:
                if value == 4:
                    if result[2] == 'x':
                        result = result[:2] + 's' + result[3:]
                    elif result[2] == '-':
                        result = result[:2] + 'S' + result[3:]
                if value == 2:
                    if result[5] == 'x':
                        result = result[:5] + 's' + result[6:]
                    elif result[5] == '-':
                        result = result[:5] + 'S' + result[6:]
                if value == 1:
                    if result[8] == 'x':
                        result = result[:8] + 't' + result[9:]
                    elif result[8] == '-':
                        result = result[:8] + 'T' + result[9:]
                first -= value

    return result


class WebServer(object):
    apt_packages = ''
    service = None
    name = None  # name must match certbot convention (nginx, apache)


class Nginx(WebServer):
    name = 'nginx'
    service = 'nginx'
    apt_packages = "nginx uwsgi-plugin-python3"


class Apache(WebServer):
    name = 'apache'
    service = 'apache2'
    # apt_packages = "apache2 libapache2-mod-wsgi"
    apt_packages = "apache2 libapache2-mod-wsgi-py3"
    python_packages = "mod_wsgi"


WEB_SERVERS = [Nginx(), Apache()]

# def default_web_server():
#     return ifroot("nginx", '')


def resolve_web_server(web_server):
    if not web_server:
        return None
    for e in WEB_SERVERS:
        if e.name == web_server:
            return e
    raise click.ClickException("Invalid --web-server '{}'.".format(web_server))


class DbEngine(object):
    name = None  # Note that the DbEngine.name field must match the Django engine name
    service = None
    apt_packages = ''
    python_packages = ''
    needs_root = False
    "Whether you need to be root in order to create users and databases."
    needs_user = False
    "Whether this engine requires user authentication."

    def runcmd(self, i, sqlcmd):
        pass

    def setup_database(self, i, database, user, db_host):
        click.echo("No setup needed for " + self.name)

    def setup_user(self, i, context):
        click.echo("No need to setup user for " + self.name)

    def after_prep(self, i, context):
        pass


class SQLite(DbEngine):
    name = 'sqlite3'
    default_port = ""

    def after_prep(self, i, context):
        project_dir = context['project_dir']
        prjname = context['prjname']
        pth = Path(project_dir) / prjname
        if os.path.exists(pth):
            with i.override_batch(True):
                i.check_permissions(pth)


class MySQL(DbEngine):
    name = 'mysql'
    # service = '/lib/systemd/system/mysql.service'
    default_port = "3306"
    if distro.id() == "debian":
        service = 'mariadb'
        apt_packages = "mariadb-server libmariadb-dev-compat libmariadb-dev "\
            "python3-dev libffi-dev libssl-dev pkgconf"
    else:
        service = 'mysql'
        apt_packages = "mysql-server mysql-client libmysqlclient-dev pkgconf"
    # apt_packages = "default-mysql-server default-libmysqlclient-dev"
    python_packages = "mysqlclient"
    needs_root = True
    needs_user = True

    # def __init__(self):
    #     super().__init__()
    #     # apt_packages = "mysql-server libmysqlclient-dev"
    #     # TODO: support different platforms (Debian, Ubuntu, Elementary, ...)
    #     # apt_packages += " python3-dev libffi-dev libssl-dev python-mysqldb"
    #     if distro.id() == "debian":
    #         # package name is mariadb but service name remains mysql
    #         # self.service = 'mariadb'
    #         self.apt_packages = "mariadb-server libmariadb-dev-compat libmariadb-dev "\
    #             "python3-dev libffi-dev libssl-dev"
    #             # "python3-dev libffi-dev libssl-dev python-mysqldb"

    def run(self, i, sqlcmd):
        # options = "" if i.batch else "-p"
        # return i.runcmd('sudo mysql -u root {} -e "{};"'.format(options, sqlcmd))
        return i.runcmd('mysql -e "{};"'.format(sqlcmd))

    def setup_user(self, i, context):
        self.run(
            i,
            "create user '{db_user}'@'{db_host}' identified by '{db_password}'"
            .format(**context))

    def setup_database(self, i, database, user, db_host):
        self.run(i, "create database {database}".format(**locals()))
        self.run(
            i, "grant all PRIVILEGES on {database}.* to '{user}'@'{db_host}'".
            format(**locals()))


class PostgreSQL(DbEngine):
    name = 'postgresql'
    service = 'postgresql'
    apt_packages = "postgresql postgresql-contrib libpq-dev python3-dev"
    python_packages = "psycopg2"
    # python_packages = "psycopg2-binary"
    default_port = "5432"
    needs_root = True
    needs_user = True

    def run(self, i, cmd):
        assert '"' not in cmd
        # self.runcmd('sudo -u postgres bash -c "psql -c \\\"{}\\\""'.format(cmd))
        # The following command needs sudo even when i am root:
        i.runcmd_sudo('sudo -u postgres psql -c "{}"'.format(cmd))

    def docker_run(self, i, cmd):
        # assuming the container name is postgres
        i.runcmd_sudo(
            'docker exec -d postgres psql -U postgres -c "{}"'.format(
                cmd))

    def setup_user(self, i, context):
        self.run(
            i, "CREATE USER {db_user} WITH PASSWORD '{db_password}';".format(
                **context))

    def setup_database(self, i, database, user, db_host):
        self.run(i, "CREATE DATABASE {database};".format(**locals()))
        self.run(
            i, "GRANT ALL PRIVILEGES ON DATABASE {database} TO {user};".format(
                **locals()))

        # Used them to test on docker and thought to leave them hanging here,
        # in case when getlino supports db on docker
        #
        # self.docker_run(i, "CREATE DATABASE {database};".format(**locals()))
        # self.docker_run(i, "GRANT ALL PRIVILEGES ON DATABASE {database} TO {user};".format(**locals()))


DB_ENGINES = [MySQL(), PostgreSQL(), SQLite()]


def default_db_engine():
    return ifroot("mysql", 'sqlite3')


def resolve_db_engine(db_engine):
    for e in DB_ENGINES:
        if e.name == db_engine:
            return e
    raise click.ClickException("Invalid --db-engine '{}'.".format(db_engine))


VENV = os.environ.get('VIRTUAL_ENV', '')
CONF_FILES = [
    str(Path(VENV) / '.getlino.conf') if VENV else '/etc/getlino/getlino.conf'
]
CONF_FILES.append(expanduser('~/.getlino.conf'))
CONFIG = configparser.ConfigParser()
FOUND_CONFIG_FILES = CONFIG.read(CONF_FILES)
if len(FOUND_CONFIG_FILES) == 0:
    print(f"No config file found (tried: {CONF_FILES})")
DEFAULTSECTION = CONFIG[CONFIG.default_section]


def ifroot(true=True, false=False):
    if not hasattr(os, 'geteuid'):
        return false
    if os.geteuid() == 0:
        return true
    return false


def has_usergroup(usergroup):
    for gid in os.getgroups():
        if grp.getgrgid(gid).gr_name == usergroup:
            return True
    return False


def which_certbot():
    for x in ["certbot", "certbot-auto"]:
        if shutil.which(x):
            return x


class Installer(object):
    """Volatile object used by :mod:`getlino.configure` and :mod:`getlino.startsite`.
    """

    def __init__(self, batch=False):
        self.batch = batch
        # self.asroot = ifroot()
        self._services = set()
        self._system_packages = set()
        if ifroot():
            click.echo("Running as root.")
        click.echo(
            f"This is getlino version {__version__} "
            f"running on {distro.name(pretty=True)} "
            f"(id={repr(distro.id())} codename={repr(distro.codename())}).")

    def ask_options(self, options, context):
        for p in options:
            k = p.name
            v = context[k]
            if self.batch:
                CONFIG.set(CONFIG.default_section, k, str(v))
            elif p.root_only and not ifroot():
                continue
            else:
                msg = "- {} ({})".format(k, p.help)
                kwargs = dict(default=v)
                if p.type is not None:
                    kwargs.update(type=p.type)
                answer = click.prompt(msg, **kwargs)
                if isinstance(answer, str):
                    answer = answer.rstrip("/")
                # conf_values[k] = answer
                CONFIG.set(CONFIG.default_section, k, str(answer))

    def check_overwrite(self, pth):
        """If `pth` (directory or file) exists, remove it after asking for confirmation.
        Return False if it exists and user doesn't confirm.
        """
        if not os.path.exists(pth):
            return True
        if os.path.isdir(pth):
            if self.yes_or_no("Overwrite existing directory {} ?".format(pth)):
                shutil.rmtree(pth)
                return True
        else:
            if self.yes_or_no("Overwrite existing file {} ?".format(pth)):
                os.remove(pth)
                return True
        return False

    def yes_or_no(self, msg, yes="yY", no="nN", default=True):
        """Ask for confirmation without accepting a mere RETURN."""
        if self.batch:
            return default
        click.echo(msg + " [y or n]", nl=False)
        while True:
            c = click.getchar()
            if c in yes:
                click.echo(" Yes")
                return True
            elif c in no:
                click.echo(" No")
                return False

    def must_restart(self, srvname):
        self._services.add(srvname)

    def runcmd(self, *cmds, **kw):
        """Run the specified command(s) in a subprocess.

        Stop when Ctrl-C. If the subprocess has non-zero return code, we simply
        stop. We don't use check=True because this would add another useless
        traceback.  The subprocess is responsible for reporting the reason of
        the error.

        """
        # kw.update(stdout=subprocess.PIPE)
        # kw.update(stderr=subprocess.STDOUT)
        kw.update(shell=True)
        kw.update(universal_newlines=True)
        # kw.update(check=True)
        # subprocess.check_output(cmd, **kw)
        if self.batch or self.yes_or_no("run {}".format(";".join(cmds)),
                                        default=True):
            for cmd in cmds:
                click.echo(cmd)
                cp = subprocess.run(cmd, **kw)
                if cp.returncode != 0:
                    # subprocess.run("sudo journalctl -xe", **kw)
                    raise click.ClickException(
                        "{} ended with return code {}".format(
                            cmd, cp.returncode))

    def runcmd_sudo(self, *cmds, **kwargs):
        """
        Run the specified command(s) in a subprocess, prefixing each with sudo
        if needed.

        """
        if ifroot():
            pass
        elif has_usergroup('sudo'):
            cmds = ["sudo " + c for c in cmds]
        else:
            click.echo("The following commands were not executed "
                       "because you cannot sudo:\n{}".format("\n".join(cmds)))
            return
        self.runcmd(*cmds, **kwargs)

    def apt_install(self, packages):
        for pkg in packages.split():
            # no check for if package is already installed:
            self._system_packages.add(pkg)

    def run_in_env(self, env, cmd):
        """env is the path of the virtualenv"""
        # click.echo(cmd)
        cmd = ". {}/bin/activate && {}".format(env, cmd)
        self.runcmd(cmd)

    def check_permissions(self, pth, executable=False, writeable=True):
        si = os.stat(pth)

        if writeable and grp and ifroot():
            # check whether group owner is what we want
            usergroup = DEFAULTSECTION.get('usergroup')
            if grpexists(usergroup):
                if grp.getgrgid(si.st_gid).gr_name != usergroup:
                    if self.batch or self.yes_or_no(
                            "Set group owner for {} to '{}''".format(
                                pth, usergroup),
                            default=True):
                        shutil.chown(pth, group=usergroup)

        # check access permissions
        mode = imode = stat.S_IMODE(si.st_mode)
        if writeable:
            mode |= stat.S_IRGRP | stat.S_IWGRP
            mode |= stat.S_IRUSR | stat.S_IWUSR
            mode |= stat.S_IROTH
            if stat.S_ISDIR(si.st_mode):
                mode |= stat.S_ISGID | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH
        if executable:
            mode |= stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH
        if imode ^ mode:
            msg = "Set mode for {} from {} to {}".format(
                pth, perm2text(imode), perm2text(mode))
            # pth, stat.filemode(imode), stat.filemode(mode))
            if self.batch or self.yes_or_no(msg, default=True):
                os.chmod(pth, mode)

    @contextmanager
    def override_batch(self, batch):
        old = self.batch
        try:
            self.batch = batch
            yield self
        finally:
            self.batch = old

    # def write_file(self, pth, content, **kwargs):
    def write_file(self, pth, content):
        """Write the given `content` to the named file `pth`.
        """
        if self.check_overwrite(pth):
            dn = os.path.dirname(pth)
            if not os.path.exists(dn):
                os.makedirs(dn, exist_ok=True)
            with open(pth, 'w') as fd:
                fd.write(content)
            # 20231009 write_file() no longer calls check_permissions()
            # with self.override_batch(True):
            #     self.check_permissions(pth, **kwargs)
            return True

    def write_cron_job(self, filename, content, freq='daily'):
        pth = Path('/etc/cron.' + freq)
        if not pth.exists():
            raise Exception(
                "Error: directory {} does not exist (is cron installed?)")
        fn = pth / filename
        if fn.exists():
            return
        self.write_file(fn, content)
        self.check_permissions(fn, executable=True, writeable=False)

    def write_supervisor_conf(self, filename, content):
        self.write_file(
            Path(DEFAULTSECTION.get('supervisor_dir')) / filename, content)
        self.must_restart('supervisor')

    def make_file_executable(self, file_path):
        """ Make a file executable """
        st = os.stat(file_path)
        os.chmod(file_path, 0o775)
        # os.chmod(file_path, st.st_mode | stat.S_IEXEC)

    def check_virtualenv(self, envdir, context):
        pull_sh_path = Path(envdir) / 'bin' / 'pull.sh'
        ok = False
        if os.path.exists(envdir):
            ok = True
            # msg = "Update virtualenv in {}"
            # return self.batch or click.confirm(msg.format(envdir), default=True)
        else:
            msg = "Create virtualenv in {}"
            if self.batch or self.yes_or_no(msg.format(envdir), default=True):
                # create an empty directory and fix permissions
                os.makedirs(envdir)
                self.check_permissions(envdir)
                virtualenv.cli_run([envdir, '--python', 'python3'])
                ok = True
        if ok:
            context.update(envdir=envdir)
            if not os.path.exists(pull_sh_path):
                self.jinja_write(pull_sh_path, **context)
            self.make_file_executable(pull_sh_path)
        return ok

    def clone_repo(self, repo):
        # branch = DEFAULTSECTION.get('branch')
        if not os.path.exists(repo.nickname):
            # self.runcmd("git clone --depth 1 -b {} {} {}".format(branch, repo.git_repo, repo.nickname))
            self.runcmd("git clone {} {}".format(repo.git_repo, repo.nickname))
        else:
            click.echo("No need to clone {} : directory exists.".format(
                repo.nickname))

    def install_repo(self, repo, env):
        cmd = f"pip install -q -e {repo.nickname}"
        if DEFAULTSECTION.getboolean('devtools'):
            cmd += "[testing]"
        self.run_in_env(env, cmd)
        requirements_txt = Path(repo.nickname) / "requirements.txt"
        if requirements_txt.exists():
            cmd = f"pip install -r {requirements_txt}"
            self.run_in_env(env, cmd)

    def check_usergroup(self, usergroup):
        # not used since 20200720
        if ifroot():
            return
        if grp is None:
            return
        if has_usergroup(usergroup):
            return
        msg = """\
You {0} don't belong to the {1} user group.  Maybe you want to run:
sudo adduser `whoami` {1}"""
        raise click.ClickException(msg.format(getpass.getuser(), usergroup))

    def write_logrotate_conf(self, conffile, logfile):
        ctx = {}
        ctx.update(DEFAULTSECTION)
        ctx.update(logfile=logfile)
        self.write_file('/etc/logrotate.d/' + conffile,
                        LOGROTATE_CONF.format(**ctx))

    def jinja_write(self, pth, tplname=None, **context):
        """
        pth : the full path of the file to generate.
        tplname : name of the template file to render.  If tplname is not specified, use the tail of the output file.
        """
        if not self.check_overwrite(pth):
            return False
        if tplname is None:
            head, tplname = os.path.split(pth)
        tpl = JINJA_ENV.get_template(tplname)
        s = tpl.render(**context)
        with open(pth, 'w') as fh:
            fh.write(s)
        return True

    def run_apt_install(self):
        if len(self._system_packages) == 0:
            return
        cmd = "apt-get install -q "
        if self.batch:
            cmd += "-y "
        cmd += ' '.join(sorted(self._system_packages))
        self.runcmd_sudo("apt-get update -y", "apt-get upgrade -y", cmd)
        self._system_packages = set()

    def restart_services(self):
        if len(self._services) == 0:
            return
        for srv in self._services:
            self.runcmd_sudo(f"service {srv} restart")
            # self.runcmd_sudo("service {} restart".format(srv))
            # try:
            #     self.runcmd_sudo("service {} restart".format(srv))
            # except Exception:
            #     try:
            #         self.runcmd_sudo("/etc/init.d/{} restart".format(srv))
            #     except Exception:
            #         continue


# class Comparator:
#     _equivs = {
#         '<=': 'lte',
#         '<': 'lt',
#         '==': 'eq',
#         '>=': 'gte',
#         '>': 'gt',
#     }
#     def __init__(self, operator=None):
#         if operator is not None:
#             if operator[0] in ['<', '>', '=']:
#                 operator = self._equivs[operator]
#             assert operator in self._equivs.values()
#             self.operator = getattr(self, operator)
#
#     def lte(self, value1, value2):
#         return value1 <= value2
#     def lt(self, value1, value2):
#         return value1 < value2
#     def eq(self, value1, value2):
#         return value1 == value2
#     def gte(self, value1, value2):
#         return value1 >= value2
#     def gt(self, value1, value2):
#         return value1 > value2
#
#     def compare(self, value1, value2):
#         return self.operator(value1, value2)
#
# def compare_versions(version_old, comparison_operator, version_new):
#     vo = []
#     for v in version_old.split('.'):
#         try:
#             v = int(v)
#             vo.append(v)
#         except ValueError:
#             break
#
#     vn = []
#     for v in version_new.split('.'):
#         try:
#             v = int(v)
#             vn.append(v)
#         except ValueError:
#             break
#
#     c = Comparator(comparison_operator)
#
#     _min = min(len(vo), len(vn))
#     return c.compare(vo[:_min], vn[:_min])
