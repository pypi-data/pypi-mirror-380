// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package types

import (
    "encoding/json"
    "fmt"

    baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
    "github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)

type Union2BoolKFalseOrBoolKTrue struct {
    variant string
    
    variant_BoolKTrue *bool
    
    variant_BoolKFalse *bool
    
}

func (u *Union2BoolKFalseOrBoolKTrue) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "bool_true":
            u.variant = "BoolKTrue"
            value := baml.Decode(valueHolder).Interface().(bool)
            u.variant_BoolKTrue = &value
    case "bool_false":
            u.variant = "BoolKFalse"
            value := baml.Decode(valueHolder).Interface().(bool)
            u.variant_BoolKFalse = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union2BoolKFalseOrBoolKTrue) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "BoolKTrue":
        return baml.EncodeUnion(u.BamlEncodeName, "bool_true", *u.variant_BoolKTrue)
    
    case "BoolKFalse":
        return baml.EncodeUnion(u.BamlEncodeName, "bool_false", *u.variant_BoolKFalse)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union2BoolKFalseOrBoolKTrue) BamlTypeName() string {
    return "Union2BoolKFalseOrBoolKTrue"
}

func (u Union2BoolKFalseOrBoolKTrue) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__bool_false__bool_true",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union2BoolKFalseOrBoolKTrue) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "BoolKTrue":
        return json.Marshal(u.variant_BoolKTrue)
    
    case "BoolKFalse":
        return json.Marshal(u.variant_BoolKFalse)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union2BoolKFalseOrBoolKTrue) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_BoolKTrue)
    if err == nil {
        u.variant = "BoolKTrue"
        return nil
    } else {
        u.variant_BoolKTrue = nil
    }
    
    err = json.Unmarshal(data, &u.variant_BoolKFalse)
    if err == nil {
        u.variant = "BoolKFalse"
        return nil
    } else {
        u.variant_BoolKFalse = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union2BoolKFalseOrBoolKTrue__NewBoolKTrue() Union2BoolKFalseOrBoolKTrue {
    
    var v bool = true
    
    return Union2BoolKFalseOrBoolKTrue{
        variant: "BoolKTrue",
        variant_BoolKTrue: &v,
    }
}

func (u *Union2BoolKFalseOrBoolKTrue) SetBoolKTrue() {
    
    var v bool = true
    
    u.variant = "BoolKTrue"
    u.variant_BoolKTrue = &v
    
    u.variant_BoolKFalse = nil
    
}

func (u *Union2BoolKFalseOrBoolKTrue) IsBoolKTrue() bool {
    return u.variant == "BoolKTrue"
}

func (u *Union2BoolKFalseOrBoolKTrue) AsBoolKTrue() *bool {
    if u.variant != "BoolKTrue" {
        return nil
    }
    return u.variant_BoolKTrue
}

func Union2BoolKFalseOrBoolKTrue__NewBoolKFalse() Union2BoolKFalseOrBoolKTrue {
    
    var v bool = false
    
    return Union2BoolKFalseOrBoolKTrue{
        variant: "BoolKFalse",
        variant_BoolKFalse: &v,
    }
}

func (u *Union2BoolKFalseOrBoolKTrue) SetBoolKFalse() {
    
    var v bool = false
    
    u.variant = "BoolKFalse"
    u.variant_BoolKFalse = &v
    
    u.variant_BoolKTrue = nil
    
}

func (u *Union2BoolKFalseOrBoolKTrue) IsBoolKFalse() bool {
    return u.variant == "BoolKFalse"
}

func (u *Union2BoolKFalseOrBoolKTrue) AsBoolKFalse() *bool {
    if u.variant != "BoolKFalse" {
        return nil
    }
    return u.variant_BoolKFalse
}

type Union3IntK1OrIntK2OrIntK3 struct {
    variant string
    
    variant_IntK1 *int64
    
    variant_IntK2 *int64
    
    variant_IntK3 *int64
    
}

func (u *Union3IntK1OrIntK2OrIntK3) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "int_1":
            u.variant = "IntK1"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK1 = &value
    case "int_2":
            u.variant = "IntK2"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK2 = &value
    case "int_3":
            u.variant = "IntK3"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK3 = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3IntK1OrIntK2OrIntK3) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "IntK1":
        return baml.EncodeUnion(u.BamlEncodeName, "int_1", *u.variant_IntK1)
    
    case "IntK2":
        return baml.EncodeUnion(u.BamlEncodeName, "int_2", *u.variant_IntK2)
    
    case "IntK3":
        return baml.EncodeUnion(u.BamlEncodeName, "int_3", *u.variant_IntK3)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3IntK1OrIntK2OrIntK3) BamlTypeName() string {
    return "Union3IntK1OrIntK2OrIntK3"
}

func (u Union3IntK1OrIntK2OrIntK3) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__int_1__int_2__int_3",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3IntK1OrIntK2OrIntK3) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "IntK1":
        return json.Marshal(u.variant_IntK1)
    
    case "IntK2":
        return json.Marshal(u.variant_IntK2)
    
    case "IntK3":
        return json.Marshal(u.variant_IntK3)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3IntK1OrIntK2OrIntK3) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_IntK1)
    if err == nil {
        u.variant = "IntK1"
        return nil
    } else {
        u.variant_IntK1 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK2)
    if err == nil {
        u.variant = "IntK2"
        return nil
    } else {
        u.variant_IntK2 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK3)
    if err == nil {
        u.variant = "IntK3"
        return nil
    } else {
        u.variant_IntK3 = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3IntK1OrIntK2OrIntK3__NewIntK1() Union3IntK1OrIntK2OrIntK3 {
    
    var v int64 = 1
    
    return Union3IntK1OrIntK2OrIntK3{
        variant: "IntK1",
        variant_IntK1: &v,
    }
}

func (u *Union3IntK1OrIntK2OrIntK3) SetIntK1() {
    
    var v int64 = 1
    
    u.variant = "IntK1"
    u.variant_IntK1 = &v
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
}

func (u *Union3IntK1OrIntK2OrIntK3) IsIntK1() bool {
    return u.variant == "IntK1"
}

func (u *Union3IntK1OrIntK2OrIntK3) AsIntK1() *int64 {
    if u.variant != "IntK1" {
        return nil
    }
    return u.variant_IntK1
}

func Union3IntK1OrIntK2OrIntK3__NewIntK2() Union3IntK1OrIntK2OrIntK3 {
    
    var v int64 = 2
    
    return Union3IntK1OrIntK2OrIntK3{
        variant: "IntK2",
        variant_IntK2: &v,
    }
}

func (u *Union3IntK1OrIntK2OrIntK3) SetIntK2() {
    
    var v int64 = 2
    
    u.variant = "IntK2"
    u.variant_IntK2 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK3 = nil
    
}

func (u *Union3IntK1OrIntK2OrIntK3) IsIntK2() bool {
    return u.variant == "IntK2"
}

func (u *Union3IntK1OrIntK2OrIntK3) AsIntK2() *int64 {
    if u.variant != "IntK2" {
        return nil
    }
    return u.variant_IntK2
}

func Union3IntK1OrIntK2OrIntK3__NewIntK3() Union3IntK1OrIntK2OrIntK3 {
    
    var v int64 = 3
    
    return Union3IntK1OrIntK2OrIntK3{
        variant: "IntK3",
        variant_IntK3: &v,
    }
}

func (u *Union3IntK1OrIntK2OrIntK3) SetIntK3() {
    
    var v int64 = 3
    
    u.variant = "IntK3"
    u.variant_IntK3 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
}

func (u *Union3IntK1OrIntK2OrIntK3) IsIntK3() bool {
    return u.variant == "IntK3"
}

func (u *Union3IntK1OrIntK2OrIntK3) AsIntK3() *int64 {
    if u.variant != "IntK3" {
        return nil
    }
    return u.variant_IntK3
}

type Union3IntK200OrIntK404OrIntK500 struct {
    variant string
    
    variant_IntK200 *int64
    
    variant_IntK404 *int64
    
    variant_IntK500 *int64
    
}

func (u *Union3IntK200OrIntK404OrIntK500) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "int_200":
            u.variant = "IntK200"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK200 = &value
    case "int_404":
            u.variant = "IntK404"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK404 = &value
    case "int_500":
            u.variant = "IntK500"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK500 = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3IntK200OrIntK404OrIntK500) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "IntK200":
        return baml.EncodeUnion(u.BamlEncodeName, "int_200", *u.variant_IntK200)
    
    case "IntK404":
        return baml.EncodeUnion(u.BamlEncodeName, "int_404", *u.variant_IntK404)
    
    case "IntK500":
        return baml.EncodeUnion(u.BamlEncodeName, "int_500", *u.variant_IntK500)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3IntK200OrIntK404OrIntK500) BamlTypeName() string {
    return "Union3IntK200OrIntK404OrIntK500"
}

func (u Union3IntK200OrIntK404OrIntK500) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__int_200__int_404__int_500",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3IntK200OrIntK404OrIntK500) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "IntK200":
        return json.Marshal(u.variant_IntK200)
    
    case "IntK404":
        return json.Marshal(u.variant_IntK404)
    
    case "IntK500":
        return json.Marshal(u.variant_IntK500)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3IntK200OrIntK404OrIntK500) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_IntK200)
    if err == nil {
        u.variant = "IntK200"
        return nil
    } else {
        u.variant_IntK200 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK404)
    if err == nil {
        u.variant = "IntK404"
        return nil
    } else {
        u.variant_IntK404 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK500)
    if err == nil {
        u.variant = "IntK500"
        return nil
    } else {
        u.variant_IntK500 = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3IntK200OrIntK404OrIntK500__NewIntK200() Union3IntK200OrIntK404OrIntK500 {
    
    var v int64 = 200
    
    return Union3IntK200OrIntK404OrIntK500{
        variant: "IntK200",
        variant_IntK200: &v,
    }
}

func (u *Union3IntK200OrIntK404OrIntK500) SetIntK200() {
    
    var v int64 = 200
    
    u.variant = "IntK200"
    u.variant_IntK200 = &v
    
    u.variant_IntK404 = nil
    
    u.variant_IntK500 = nil
    
}

func (u *Union3IntK200OrIntK404OrIntK500) IsIntK200() bool {
    return u.variant == "IntK200"
}

func (u *Union3IntK200OrIntK404OrIntK500) AsIntK200() *int64 {
    if u.variant != "IntK200" {
        return nil
    }
    return u.variant_IntK200
}

func Union3IntK200OrIntK404OrIntK500__NewIntK404() Union3IntK200OrIntK404OrIntK500 {
    
    var v int64 = 404
    
    return Union3IntK200OrIntK404OrIntK500{
        variant: "IntK404",
        variant_IntK404: &v,
    }
}

func (u *Union3IntK200OrIntK404OrIntK500) SetIntK404() {
    
    var v int64 = 404
    
    u.variant = "IntK404"
    u.variant_IntK404 = &v
    
    u.variant_IntK200 = nil
    
    u.variant_IntK500 = nil
    
}

func (u *Union3IntK200OrIntK404OrIntK500) IsIntK404() bool {
    return u.variant == "IntK404"
}

func (u *Union3IntK200OrIntK404OrIntK500) AsIntK404() *int64 {
    if u.variant != "IntK404" {
        return nil
    }
    return u.variant_IntK404
}

func Union3IntK200OrIntK404OrIntK500__NewIntK500() Union3IntK200OrIntK404OrIntK500 {
    
    var v int64 = 500
    
    return Union3IntK200OrIntK404OrIntK500{
        variant: "IntK500",
        variant_IntK500: &v,
    }
}

func (u *Union3IntK200OrIntK404OrIntK500) SetIntK500() {
    
    var v int64 = 500
    
    u.variant = "IntK500"
    u.variant_IntK500 = &v
    
    u.variant_IntK200 = nil
    
    u.variant_IntK404 = nil
    
}

func (u *Union3IntK200OrIntK404OrIntK500) IsIntK500() bool {
    return u.variant == "IntK500"
}

func (u *Union3IntK200OrIntK404OrIntK500) AsIntK500() *int64 {
    if u.variant != "IntK500" {
        return nil
    }
    return u.variant_IntK500
}

type Union3KactiveOrKinactiveOrKpending struct {
    variant string
    
    variant_Kactive *string
    
    variant_Kinactive *string
    
    variant_Kpending *string
    
}

func (u *Union3KactiveOrKinactiveOrKpending) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_active":
            u.variant = "Kactive"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kactive = &value
    case "string_inactive":
            u.variant = "Kinactive"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kinactive = &value
    case "string_pending":
            u.variant = "Kpending"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kpending = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KactiveOrKinactiveOrKpending) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kactive":
        return baml.EncodeUnion(u.BamlEncodeName, "string_active", *u.variant_Kactive)
    
    case "Kinactive":
        return baml.EncodeUnion(u.BamlEncodeName, "string_inactive", *u.variant_Kinactive)
    
    case "Kpending":
        return baml.EncodeUnion(u.BamlEncodeName, "string_pending", *u.variant_Kpending)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KactiveOrKinactiveOrKpending) BamlTypeName() string {
    return "Union3KactiveOrKinactiveOrKpending"
}

func (u Union3KactiveOrKinactiveOrKpending) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_active__string_inactive__string_pending",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KactiveOrKinactiveOrKpending) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kactive":
        return json.Marshal(u.variant_Kactive)
    
    case "Kinactive":
        return json.Marshal(u.variant_Kinactive)
    
    case "Kpending":
        return json.Marshal(u.variant_Kpending)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KactiveOrKinactiveOrKpending) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kactive)
    if err == nil {
        u.variant = "Kactive"
        return nil
    } else {
        u.variant_Kactive = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kinactive)
    if err == nil {
        u.variant = "Kinactive"
        return nil
    } else {
        u.variant_Kinactive = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kpending)
    if err == nil {
        u.variant = "Kpending"
        return nil
    } else {
        u.variant_Kpending = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KactiveOrKinactiveOrKpending__NewKactive() Union3KactiveOrKinactiveOrKpending {
    
    var v string = "active"
    
    return Union3KactiveOrKinactiveOrKpending{
        variant: "Kactive",
        variant_Kactive: &v,
    }
}

func (u *Union3KactiveOrKinactiveOrKpending) SetKactive() {
    
    var v string = "active"
    
    u.variant = "Kactive"
    u.variant_Kactive = &v
    
    u.variant_Kinactive = nil
    
    u.variant_Kpending = nil
    
}

func (u *Union3KactiveOrKinactiveOrKpending) IsKactive() bool {
    return u.variant == "Kactive"
}

func (u *Union3KactiveOrKinactiveOrKpending) AsKactive() *string {
    if u.variant != "Kactive" {
        return nil
    }
    return u.variant_Kactive
}

func Union3KactiveOrKinactiveOrKpending__NewKinactive() Union3KactiveOrKinactiveOrKpending {
    
    var v string = "inactive"
    
    return Union3KactiveOrKinactiveOrKpending{
        variant: "Kinactive",
        variant_Kinactive: &v,
    }
}

func (u *Union3KactiveOrKinactiveOrKpending) SetKinactive() {
    
    var v string = "inactive"
    
    u.variant = "Kinactive"
    u.variant_Kinactive = &v
    
    u.variant_Kactive = nil
    
    u.variant_Kpending = nil
    
}

func (u *Union3KactiveOrKinactiveOrKpending) IsKinactive() bool {
    return u.variant == "Kinactive"
}

func (u *Union3KactiveOrKinactiveOrKpending) AsKinactive() *string {
    if u.variant != "Kinactive" {
        return nil
    }
    return u.variant_Kinactive
}

func Union3KactiveOrKinactiveOrKpending__NewKpending() Union3KactiveOrKinactiveOrKpending {
    
    var v string = "pending"
    
    return Union3KactiveOrKinactiveOrKpending{
        variant: "Kpending",
        variant_Kpending: &v,
    }
}

func (u *Union3KactiveOrKinactiveOrKpending) SetKpending() {
    
    var v string = "pending"
    
    u.variant = "Kpending"
    u.variant_Kpending = &v
    
    u.variant_Kactive = nil
    
    u.variant_Kinactive = nil
    
}

func (u *Union3KactiveOrKinactiveOrKpending) IsKpending() bool {
    return u.variant == "Kpending"
}

func (u *Union3KactiveOrKinactiveOrKpending) AsKpending() *string {
    if u.variant != "Kpending" {
        return nil
    }
    return u.variant_Kpending
}

type Union3KadminOrKguestOrKuser struct {
    variant string
    
    variant_Kuser *string
    
    variant_Kadmin *string
    
    variant_Kguest *string
    
}

func (u *Union3KadminOrKguestOrKuser) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_user":
            u.variant = "Kuser"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kuser = &value
    case "string_admin":
            u.variant = "Kadmin"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kadmin = &value
    case "string_guest":
            u.variant = "Kguest"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kguest = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KadminOrKguestOrKuser) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kuser":
        return baml.EncodeUnion(u.BamlEncodeName, "string_user", *u.variant_Kuser)
    
    case "Kadmin":
        return baml.EncodeUnion(u.BamlEncodeName, "string_admin", *u.variant_Kadmin)
    
    case "Kguest":
        return baml.EncodeUnion(u.BamlEncodeName, "string_guest", *u.variant_Kguest)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KadminOrKguestOrKuser) BamlTypeName() string {
    return "Union3KadminOrKguestOrKuser"
}

func (u Union3KadminOrKguestOrKuser) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_admin__string_guest__string_user",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KadminOrKguestOrKuser) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kuser":
        return json.Marshal(u.variant_Kuser)
    
    case "Kadmin":
        return json.Marshal(u.variant_Kadmin)
    
    case "Kguest":
        return json.Marshal(u.variant_Kguest)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KadminOrKguestOrKuser) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kuser)
    if err == nil {
        u.variant = "Kuser"
        return nil
    } else {
        u.variant_Kuser = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kadmin)
    if err == nil {
        u.variant = "Kadmin"
        return nil
    } else {
        u.variant_Kadmin = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kguest)
    if err == nil {
        u.variant = "Kguest"
        return nil
    } else {
        u.variant_Kguest = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KadminOrKguestOrKuser__NewKuser() Union3KadminOrKguestOrKuser {
    
    var v string = "user"
    
    return Union3KadminOrKguestOrKuser{
        variant: "Kuser",
        variant_Kuser: &v,
    }
}

func (u *Union3KadminOrKguestOrKuser) SetKuser() {
    
    var v string = "user"
    
    u.variant = "Kuser"
    u.variant_Kuser = &v
    
    u.variant_Kadmin = nil
    
    u.variant_Kguest = nil
    
}

func (u *Union3KadminOrKguestOrKuser) IsKuser() bool {
    return u.variant == "Kuser"
}

func (u *Union3KadminOrKguestOrKuser) AsKuser() *string {
    if u.variant != "Kuser" {
        return nil
    }
    return u.variant_Kuser
}

func Union3KadminOrKguestOrKuser__NewKadmin() Union3KadminOrKguestOrKuser {
    
    var v string = "admin"
    
    return Union3KadminOrKguestOrKuser{
        variant: "Kadmin",
        variant_Kadmin: &v,
    }
}

func (u *Union3KadminOrKguestOrKuser) SetKadmin() {
    
    var v string = "admin"
    
    u.variant = "Kadmin"
    u.variant_Kadmin = &v
    
    u.variant_Kuser = nil
    
    u.variant_Kguest = nil
    
}

func (u *Union3KadminOrKguestOrKuser) IsKadmin() bool {
    return u.variant == "Kadmin"
}

func (u *Union3KadminOrKguestOrKuser) AsKadmin() *string {
    if u.variant != "Kadmin" {
        return nil
    }
    return u.variant_Kadmin
}

func Union3KadminOrKguestOrKuser__NewKguest() Union3KadminOrKguestOrKuser {
    
    var v string = "guest"
    
    return Union3KadminOrKguestOrKuser{
        variant: "Kguest",
        variant_Kguest: &v,
    }
}

func (u *Union3KadminOrKguestOrKuser) SetKguest() {
    
    var v string = "guest"
    
    u.variant = "Kguest"
    u.variant_Kguest = &v
    
    u.variant_Kuser = nil
    
    u.variant_Kadmin = nil
    
}

func (u *Union3KadminOrKguestOrKuser) IsKguest() bool {
    return u.variant == "Kguest"
}

func (u *Union3KadminOrKguestOrKuser) AsKguest() *string {
    if u.variant != "Kguest" {
        return nil
    }
    return u.variant_Kguest
}

type Union3KdevOrKprodOrKstaging struct {
    variant string
    
    variant_Kdev *string
    
    variant_Kstaging *string
    
    variant_Kprod *string
    
}

func (u *Union3KdevOrKprodOrKstaging) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_dev":
            u.variant = "Kdev"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kdev = &value
    case "string_staging":
            u.variant = "Kstaging"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kstaging = &value
    case "string_prod":
            u.variant = "Kprod"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kprod = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KdevOrKprodOrKstaging) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kdev":
        return baml.EncodeUnion(u.BamlEncodeName, "string_dev", *u.variant_Kdev)
    
    case "Kstaging":
        return baml.EncodeUnion(u.BamlEncodeName, "string_staging", *u.variant_Kstaging)
    
    case "Kprod":
        return baml.EncodeUnion(u.BamlEncodeName, "string_prod", *u.variant_Kprod)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KdevOrKprodOrKstaging) BamlTypeName() string {
    return "Union3KdevOrKprodOrKstaging"
}

func (u Union3KdevOrKprodOrKstaging) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_dev__string_prod__string_staging",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KdevOrKprodOrKstaging) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kdev":
        return json.Marshal(u.variant_Kdev)
    
    case "Kstaging":
        return json.Marshal(u.variant_Kstaging)
    
    case "Kprod":
        return json.Marshal(u.variant_Kprod)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KdevOrKprodOrKstaging) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kdev)
    if err == nil {
        u.variant = "Kdev"
        return nil
    } else {
        u.variant_Kdev = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kstaging)
    if err == nil {
        u.variant = "Kstaging"
        return nil
    } else {
        u.variant_Kstaging = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kprod)
    if err == nil {
        u.variant = "Kprod"
        return nil
    } else {
        u.variant_Kprod = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KdevOrKprodOrKstaging__NewKdev() Union3KdevOrKprodOrKstaging {
    
    var v string = "dev"
    
    return Union3KdevOrKprodOrKstaging{
        variant: "Kdev",
        variant_Kdev: &v,
    }
}

func (u *Union3KdevOrKprodOrKstaging) SetKdev() {
    
    var v string = "dev"
    
    u.variant = "Kdev"
    u.variant_Kdev = &v
    
    u.variant_Kstaging = nil
    
    u.variant_Kprod = nil
    
}

func (u *Union3KdevOrKprodOrKstaging) IsKdev() bool {
    return u.variant == "Kdev"
}

func (u *Union3KdevOrKprodOrKstaging) AsKdev() *string {
    if u.variant != "Kdev" {
        return nil
    }
    return u.variant_Kdev
}

func Union3KdevOrKprodOrKstaging__NewKstaging() Union3KdevOrKprodOrKstaging {
    
    var v string = "staging"
    
    return Union3KdevOrKprodOrKstaging{
        variant: "Kstaging",
        variant_Kstaging: &v,
    }
}

func (u *Union3KdevOrKprodOrKstaging) SetKstaging() {
    
    var v string = "staging"
    
    u.variant = "Kstaging"
    u.variant_Kstaging = &v
    
    u.variant_Kdev = nil
    
    u.variant_Kprod = nil
    
}

func (u *Union3KdevOrKprodOrKstaging) IsKstaging() bool {
    return u.variant == "Kstaging"
}

func (u *Union3KdevOrKprodOrKstaging) AsKstaging() *string {
    if u.variant != "Kstaging" {
        return nil
    }
    return u.variant_Kstaging
}

func Union3KdevOrKprodOrKstaging__NewKprod() Union3KdevOrKprodOrKstaging {
    
    var v string = "prod"
    
    return Union3KdevOrKprodOrKstaging{
        variant: "Kprod",
        variant_Kprod: &v,
    }
}

func (u *Union3KdevOrKprodOrKstaging) SetKprod() {
    
    var v string = "prod"
    
    u.variant = "Kprod"
    u.variant_Kprod = &v
    
    u.variant_Kdev = nil
    
    u.variant_Kstaging = nil
    
}

func (u *Union3KdevOrKprodOrKstaging) IsKprod() bool {
    return u.variant == "Kprod"
}

func (u *Union3KdevOrKprodOrKstaging) AsKprod() *string {
    if u.variant != "Kprod" {
        return nil
    }
    return u.variant_Kprod
}

type Union3KerrorOrKsuccessOrKtimeout struct {
    variant string
    
    variant_Ksuccess *string
    
    variant_Kerror *string
    
    variant_Ktimeout *string
    
}

func (u *Union3KerrorOrKsuccessOrKtimeout) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_success":
            u.variant = "Ksuccess"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Ksuccess = &value
    case "string_error":
            u.variant = "Kerror"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kerror = &value
    case "string_timeout":
            u.variant = "Ktimeout"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Ktimeout = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KerrorOrKsuccessOrKtimeout) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Ksuccess":
        return baml.EncodeUnion(u.BamlEncodeName, "string_success", *u.variant_Ksuccess)
    
    case "Kerror":
        return baml.EncodeUnion(u.BamlEncodeName, "string_error", *u.variant_Kerror)
    
    case "Ktimeout":
        return baml.EncodeUnion(u.BamlEncodeName, "string_timeout", *u.variant_Ktimeout)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KerrorOrKsuccessOrKtimeout) BamlTypeName() string {
    return "Union3KerrorOrKsuccessOrKtimeout"
}

func (u Union3KerrorOrKsuccessOrKtimeout) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_error__string_success__string_timeout",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KerrorOrKsuccessOrKtimeout) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Ksuccess":
        return json.Marshal(u.variant_Ksuccess)
    
    case "Kerror":
        return json.Marshal(u.variant_Kerror)
    
    case "Ktimeout":
        return json.Marshal(u.variant_Ktimeout)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KerrorOrKsuccessOrKtimeout) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Ksuccess)
    if err == nil {
        u.variant = "Ksuccess"
        return nil
    } else {
        u.variant_Ksuccess = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kerror)
    if err == nil {
        u.variant = "Kerror"
        return nil
    } else {
        u.variant_Kerror = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Ktimeout)
    if err == nil {
        u.variant = "Ktimeout"
        return nil
    } else {
        u.variant_Ktimeout = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KerrorOrKsuccessOrKtimeout__NewKsuccess() Union3KerrorOrKsuccessOrKtimeout {
    
    var v string = "success"
    
    return Union3KerrorOrKsuccessOrKtimeout{
        variant: "Ksuccess",
        variant_Ksuccess: &v,
    }
}

func (u *Union3KerrorOrKsuccessOrKtimeout) SetKsuccess() {
    
    var v string = "success"
    
    u.variant = "Ksuccess"
    u.variant_Ksuccess = &v
    
    u.variant_Kerror = nil
    
    u.variant_Ktimeout = nil
    
}

func (u *Union3KerrorOrKsuccessOrKtimeout) IsKsuccess() bool {
    return u.variant == "Ksuccess"
}

func (u *Union3KerrorOrKsuccessOrKtimeout) AsKsuccess() *string {
    if u.variant != "Ksuccess" {
        return nil
    }
    return u.variant_Ksuccess
}

func Union3KerrorOrKsuccessOrKtimeout__NewKerror() Union3KerrorOrKsuccessOrKtimeout {
    
    var v string = "error"
    
    return Union3KerrorOrKsuccessOrKtimeout{
        variant: "Kerror",
        variant_Kerror: &v,
    }
}

func (u *Union3KerrorOrKsuccessOrKtimeout) SetKerror() {
    
    var v string = "error"
    
    u.variant = "Kerror"
    u.variant_Kerror = &v
    
    u.variant_Ksuccess = nil
    
    u.variant_Ktimeout = nil
    
}

func (u *Union3KerrorOrKsuccessOrKtimeout) IsKerror() bool {
    return u.variant == "Kerror"
}

func (u *Union3KerrorOrKsuccessOrKtimeout) AsKerror() *string {
    if u.variant != "Kerror" {
        return nil
    }
    return u.variant_Kerror
}

func Union3KerrorOrKsuccessOrKtimeout__NewKtimeout() Union3KerrorOrKsuccessOrKtimeout {
    
    var v string = "timeout"
    
    return Union3KerrorOrKsuccessOrKtimeout{
        variant: "Ktimeout",
        variant_Ktimeout: &v,
    }
}

func (u *Union3KerrorOrKsuccessOrKtimeout) SetKtimeout() {
    
    var v string = "timeout"
    
    u.variant = "Ktimeout"
    u.variant_Ktimeout = &v
    
    u.variant_Ksuccess = nil
    
    u.variant_Kerror = nil
    
}

func (u *Union3KerrorOrKsuccessOrKtimeout) IsKtimeout() bool {
    return u.variant == "Ktimeout"
}

func (u *Union3KerrorOrKsuccessOrKtimeout) AsKtimeout() *string {
    if u.variant != "Ktimeout" {
        return nil
    }
    return u.variant_Ktimeout
}

type Union3Kv1OrKv2OrKv3 struct {
    variant string
    
    variant_Kv1 *string
    
    variant_Kv2 *string
    
    variant_Kv3 *string
    
}

func (u *Union3Kv1OrKv2OrKv3) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_v1":
            u.variant = "Kv1"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kv1 = &value
    case "string_v2":
            u.variant = "Kv2"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kv2 = &value
    case "string_v3":
            u.variant = "Kv3"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kv3 = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3Kv1OrKv2OrKv3) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kv1":
        return baml.EncodeUnion(u.BamlEncodeName, "string_v1", *u.variant_Kv1)
    
    case "Kv2":
        return baml.EncodeUnion(u.BamlEncodeName, "string_v2", *u.variant_Kv2)
    
    case "Kv3":
        return baml.EncodeUnion(u.BamlEncodeName, "string_v3", *u.variant_Kv3)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3Kv1OrKv2OrKv3) BamlTypeName() string {
    return "Union3Kv1OrKv2OrKv3"
}

func (u Union3Kv1OrKv2OrKv3) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_v1__string_v2__string_v3",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3Kv1OrKv2OrKv3) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kv1":
        return json.Marshal(u.variant_Kv1)
    
    case "Kv2":
        return json.Marshal(u.variant_Kv2)
    
    case "Kv3":
        return json.Marshal(u.variant_Kv3)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3Kv1OrKv2OrKv3) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kv1)
    if err == nil {
        u.variant = "Kv1"
        return nil
    } else {
        u.variant_Kv1 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kv2)
    if err == nil {
        u.variant = "Kv2"
        return nil
    } else {
        u.variant_Kv2 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kv3)
    if err == nil {
        u.variant = "Kv3"
        return nil
    } else {
        u.variant_Kv3 = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3Kv1OrKv2OrKv3__NewKv1() Union3Kv1OrKv2OrKv3 {
    
    var v string = "v1"
    
    return Union3Kv1OrKv2OrKv3{
        variant: "Kv1",
        variant_Kv1: &v,
    }
}

func (u *Union3Kv1OrKv2OrKv3) SetKv1() {
    
    var v string = "v1"
    
    u.variant = "Kv1"
    u.variant_Kv1 = &v
    
    u.variant_Kv2 = nil
    
    u.variant_Kv3 = nil
    
}

func (u *Union3Kv1OrKv2OrKv3) IsKv1() bool {
    return u.variant == "Kv1"
}

func (u *Union3Kv1OrKv2OrKv3) AsKv1() *string {
    if u.variant != "Kv1" {
        return nil
    }
    return u.variant_Kv1
}

func Union3Kv1OrKv2OrKv3__NewKv2() Union3Kv1OrKv2OrKv3 {
    
    var v string = "v2"
    
    return Union3Kv1OrKv2OrKv3{
        variant: "Kv2",
        variant_Kv2: &v,
    }
}

func (u *Union3Kv1OrKv2OrKv3) SetKv2() {
    
    var v string = "v2"
    
    u.variant = "Kv2"
    u.variant_Kv2 = &v
    
    u.variant_Kv1 = nil
    
    u.variant_Kv3 = nil
    
}

func (u *Union3Kv1OrKv2OrKv3) IsKv2() bool {
    return u.variant == "Kv2"
}

func (u *Union3Kv1OrKv2OrKv3) AsKv2() *string {
    if u.variant != "Kv2" {
        return nil
    }
    return u.variant_Kv2
}

func Union3Kv1OrKv2OrKv3__NewKv3() Union3Kv1OrKv2OrKv3 {
    
    var v string = "v3"
    
    return Union3Kv1OrKv2OrKv3{
        variant: "Kv3",
        variant_Kv3: &v,
    }
}

func (u *Union3Kv1OrKv2OrKv3) SetKv3() {
    
    var v string = "v3"
    
    u.variant = "Kv3"
    u.variant_Kv3 = &v
    
    u.variant_Kv1 = nil
    
    u.variant_Kv2 = nil
    
}

func (u *Union3Kv1OrKv2OrKv3) IsKv3() bool {
    return u.variant == "Kv3"
}

func (u *Union3Kv1OrKv2OrKv3) AsKv3() *string {
    if u.variant != "Kv3" {
        return nil
    }
    return u.variant_Kv3
}

type Union4IntK0OrIntK1OrIntK3OrIntK5 struct {
    variant string
    
    variant_IntK0 *int64
    
    variant_IntK1 *int64
    
    variant_IntK3 *int64
    
    variant_IntK5 *int64
    
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "int_0":
            u.variant = "IntK0"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK0 = &value
    case "int_1":
            u.variant = "IntK1"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK1 = &value
    case "int_3":
            u.variant = "IntK3"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK3 = &value
    case "int_5":
            u.variant = "IntK5"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK5 = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union4IntK0OrIntK1OrIntK3OrIntK5) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "IntK0":
        return baml.EncodeUnion(u.BamlEncodeName, "int_0", *u.variant_IntK0)
    
    case "IntK1":
        return baml.EncodeUnion(u.BamlEncodeName, "int_1", *u.variant_IntK1)
    
    case "IntK3":
        return baml.EncodeUnion(u.BamlEncodeName, "int_3", *u.variant_IntK3)
    
    case "IntK5":
        return baml.EncodeUnion(u.BamlEncodeName, "int_5", *u.variant_IntK5)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union4IntK0OrIntK1OrIntK3OrIntK5) BamlTypeName() string {
    return "Union4IntK0OrIntK1OrIntK3OrIntK5"
}

func (u Union4IntK0OrIntK1OrIntK3OrIntK5) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__int_0__int_1__int_3__int_5",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union4IntK0OrIntK1OrIntK3OrIntK5) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "IntK0":
        return json.Marshal(u.variant_IntK0)
    
    case "IntK1":
        return json.Marshal(u.variant_IntK1)
    
    case "IntK3":
        return json.Marshal(u.variant_IntK3)
    
    case "IntK5":
        return json.Marshal(u.variant_IntK5)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_IntK0)
    if err == nil {
        u.variant = "IntK0"
        return nil
    } else {
        u.variant_IntK0 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK1)
    if err == nil {
        u.variant = "IntK1"
        return nil
    } else {
        u.variant_IntK1 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK3)
    if err == nil {
        u.variant = "IntK3"
        return nil
    } else {
        u.variant_IntK3 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK5)
    if err == nil {
        u.variant = "IntK5"
        return nil
    } else {
        u.variant_IntK5 = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union4IntK0OrIntK1OrIntK3OrIntK5__NewIntK0() Union4IntK0OrIntK1OrIntK3OrIntK5 {
    
    var v int64 = 0
    
    return Union4IntK0OrIntK1OrIntK3OrIntK5{
        variant: "IntK0",
        variant_IntK0: &v,
    }
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) SetIntK0() {
    
    var v int64 = 0
    
    u.variant = "IntK0"
    u.variant_IntK0 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) IsIntK0() bool {
    return u.variant == "IntK0"
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) AsIntK0() *int64 {
    if u.variant != "IntK0" {
        return nil
    }
    return u.variant_IntK0
}

func Union4IntK0OrIntK1OrIntK3OrIntK5__NewIntK1() Union4IntK0OrIntK1OrIntK3OrIntK5 {
    
    var v int64 = 1
    
    return Union4IntK0OrIntK1OrIntK3OrIntK5{
        variant: "IntK1",
        variant_IntK1: &v,
    }
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) SetIntK1() {
    
    var v int64 = 1
    
    u.variant = "IntK1"
    u.variant_IntK1 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) IsIntK1() bool {
    return u.variant == "IntK1"
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) AsIntK1() *int64 {
    if u.variant != "IntK1" {
        return nil
    }
    return u.variant_IntK1
}

func Union4IntK0OrIntK1OrIntK3OrIntK5__NewIntK3() Union4IntK0OrIntK1OrIntK3OrIntK5 {
    
    var v int64 = 3
    
    return Union4IntK0OrIntK1OrIntK3OrIntK5{
        variant: "IntK3",
        variant_IntK3: &v,
    }
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) SetIntK3() {
    
    var v int64 = 3
    
    u.variant = "IntK3"
    u.variant_IntK3 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK1 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) IsIntK3() bool {
    return u.variant == "IntK3"
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) AsIntK3() *int64 {
    if u.variant != "IntK3" {
        return nil
    }
    return u.variant_IntK3
}

func Union4IntK0OrIntK1OrIntK3OrIntK5__NewIntK5() Union4IntK0OrIntK1OrIntK3OrIntK5 {
    
    var v int64 = 5
    
    return Union4IntK0OrIntK1OrIntK3OrIntK5{
        variant: "IntK5",
        variant_IntK5: &v,
    }
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) SetIntK5() {
    
    var v int64 = 5
    
    u.variant = "IntK5"
    u.variant_IntK5 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK1 = nil
    
    u.variant_IntK3 = nil
    
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) IsIntK5() bool {
    return u.variant == "IntK5"
}

func (u *Union4IntK0OrIntK1OrIntK3OrIntK5) AsIntK5() *int64 {
    if u.variant != "IntK5" {
        return nil
    }
    return u.variant_IntK5
}

type Union4KDELETEOrKGETOrKPOSTOrKPUT struct {
    variant string
    
    variant_KGET *string
    
    variant_KPOST *string
    
    variant_KPUT *string
    
    variant_KDELETE *string
    
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_GET":
            u.variant = "KGET"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_KGET = &value
    case "string_POST":
            u.variant = "KPOST"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_KPOST = &value
    case "string_PUT":
            u.variant = "KPUT"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_KPUT = &value
    case "string_DELETE":
            u.variant = "KDELETE"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_KDELETE = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union4KDELETEOrKGETOrKPOSTOrKPUT) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "KGET":
        return baml.EncodeUnion(u.BamlEncodeName, "string_GET", *u.variant_KGET)
    
    case "KPOST":
        return baml.EncodeUnion(u.BamlEncodeName, "string_POST", *u.variant_KPOST)
    
    case "KPUT":
        return baml.EncodeUnion(u.BamlEncodeName, "string_PUT", *u.variant_KPUT)
    
    case "KDELETE":
        return baml.EncodeUnion(u.BamlEncodeName, "string_DELETE", *u.variant_KDELETE)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union4KDELETEOrKGETOrKPOSTOrKPUT) BamlTypeName() string {
    return "Union4KDELETEOrKGETOrKPOSTOrKPUT"
}

func (u Union4KDELETEOrKGETOrKPOSTOrKPUT) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_DELETE__string_GET__string_POST__string_PUT",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union4KDELETEOrKGETOrKPOSTOrKPUT) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "KGET":
        return json.Marshal(u.variant_KGET)
    
    case "KPOST":
        return json.Marshal(u.variant_KPOST)
    
    case "KPUT":
        return json.Marshal(u.variant_KPUT)
    
    case "KDELETE":
        return json.Marshal(u.variant_KDELETE)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_KGET)
    if err == nil {
        u.variant = "KGET"
        return nil
    } else {
        u.variant_KGET = nil
    }
    
    err = json.Unmarshal(data, &u.variant_KPOST)
    if err == nil {
        u.variant = "KPOST"
        return nil
    } else {
        u.variant_KPOST = nil
    }
    
    err = json.Unmarshal(data, &u.variant_KPUT)
    if err == nil {
        u.variant = "KPUT"
        return nil
    } else {
        u.variant_KPUT = nil
    }
    
    err = json.Unmarshal(data, &u.variant_KDELETE)
    if err == nil {
        u.variant = "KDELETE"
        return nil
    } else {
        u.variant_KDELETE = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union4KDELETEOrKGETOrKPOSTOrKPUT__NewKGET() Union4KDELETEOrKGETOrKPOSTOrKPUT {
    
    var v string = "GET"
    
    return Union4KDELETEOrKGETOrKPOSTOrKPUT{
        variant: "KGET",
        variant_KGET: &v,
    }
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) SetKGET() {
    
    var v string = "GET"
    
    u.variant = "KGET"
    u.variant_KGET = &v
    
    u.variant_KPOST = nil
    
    u.variant_KPUT = nil
    
    u.variant_KDELETE = nil
    
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) IsKGET() bool {
    return u.variant == "KGET"
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) AsKGET() *string {
    if u.variant != "KGET" {
        return nil
    }
    return u.variant_KGET
}

func Union4KDELETEOrKGETOrKPOSTOrKPUT__NewKPOST() Union4KDELETEOrKGETOrKPOSTOrKPUT {
    
    var v string = "POST"
    
    return Union4KDELETEOrKGETOrKPOSTOrKPUT{
        variant: "KPOST",
        variant_KPOST: &v,
    }
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) SetKPOST() {
    
    var v string = "POST"
    
    u.variant = "KPOST"
    u.variant_KPOST = &v
    
    u.variant_KGET = nil
    
    u.variant_KPUT = nil
    
    u.variant_KDELETE = nil
    
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) IsKPOST() bool {
    return u.variant == "KPOST"
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) AsKPOST() *string {
    if u.variant != "KPOST" {
        return nil
    }
    return u.variant_KPOST
}

func Union4KDELETEOrKGETOrKPOSTOrKPUT__NewKPUT() Union4KDELETEOrKGETOrKPOSTOrKPUT {
    
    var v string = "PUT"
    
    return Union4KDELETEOrKGETOrKPOSTOrKPUT{
        variant: "KPUT",
        variant_KPUT: &v,
    }
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) SetKPUT() {
    
    var v string = "PUT"
    
    u.variant = "KPUT"
    u.variant_KPUT = &v
    
    u.variant_KGET = nil
    
    u.variant_KPOST = nil
    
    u.variant_KDELETE = nil
    
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) IsKPUT() bool {
    return u.variant == "KPUT"
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) AsKPUT() *string {
    if u.variant != "KPUT" {
        return nil
    }
    return u.variant_KPUT
}

func Union4KDELETEOrKGETOrKPOSTOrKPUT__NewKDELETE() Union4KDELETEOrKGETOrKPOSTOrKPUT {
    
    var v string = "DELETE"
    
    return Union4KDELETEOrKGETOrKPOSTOrKPUT{
        variant: "KDELETE",
        variant_KDELETE: &v,
    }
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) SetKDELETE() {
    
    var v string = "DELETE"
    
    u.variant = "KDELETE"
    u.variant_KDELETE = &v
    
    u.variant_KGET = nil
    
    u.variant_KPOST = nil
    
    u.variant_KPUT = nil
    
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) IsKDELETE() bool {
    return u.variant == "KDELETE"
}

func (u *Union4KDELETEOrKGETOrKPOSTOrKPUT) AsKDELETE() *string {
    if u.variant != "KDELETE" {
        return nil
    }
    return u.variant_KDELETE
}

type Union4KarchivedOrKdeletedOrKdraftOrKpublished struct {
    variant string
    
    variant_Kdraft *string
    
    variant_Kpublished *string
    
    variant_Karchived *string
    
    variant_Kdeleted *string
    
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_draft":
            u.variant = "Kdraft"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kdraft = &value
    case "string_published":
            u.variant = "Kpublished"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kpublished = &value
    case "string_archived":
            u.variant = "Karchived"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Karchived = &value
    case "string_deleted":
            u.variant = "Kdeleted"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kdeleted = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union4KarchivedOrKdeletedOrKdraftOrKpublished) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kdraft":
        return baml.EncodeUnion(u.BamlEncodeName, "string_draft", *u.variant_Kdraft)
    
    case "Kpublished":
        return baml.EncodeUnion(u.BamlEncodeName, "string_published", *u.variant_Kpublished)
    
    case "Karchived":
        return baml.EncodeUnion(u.BamlEncodeName, "string_archived", *u.variant_Karchived)
    
    case "Kdeleted":
        return baml.EncodeUnion(u.BamlEncodeName, "string_deleted", *u.variant_Kdeleted)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union4KarchivedOrKdeletedOrKdraftOrKpublished) BamlTypeName() string {
    return "Union4KarchivedOrKdeletedOrKdraftOrKpublished"
}

func (u Union4KarchivedOrKdeletedOrKdraftOrKpublished) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_archived__string_deleted__string_draft__string_published",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union4KarchivedOrKdeletedOrKdraftOrKpublished) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kdraft":
        return json.Marshal(u.variant_Kdraft)
    
    case "Kpublished":
        return json.Marshal(u.variant_Kpublished)
    
    case "Karchived":
        return json.Marshal(u.variant_Karchived)
    
    case "Kdeleted":
        return json.Marshal(u.variant_Kdeleted)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kdraft)
    if err == nil {
        u.variant = "Kdraft"
        return nil
    } else {
        u.variant_Kdraft = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kpublished)
    if err == nil {
        u.variant = "Kpublished"
        return nil
    } else {
        u.variant_Kpublished = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Karchived)
    if err == nil {
        u.variant = "Karchived"
        return nil
    } else {
        u.variant_Karchived = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kdeleted)
    if err == nil {
        u.variant = "Kdeleted"
        return nil
    } else {
        u.variant_Kdeleted = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union4KarchivedOrKdeletedOrKdraftOrKpublished__NewKdraft() Union4KarchivedOrKdeletedOrKdraftOrKpublished {
    
    var v string = "draft"
    
    return Union4KarchivedOrKdeletedOrKdraftOrKpublished{
        variant: "Kdraft",
        variant_Kdraft: &v,
    }
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) SetKdraft() {
    
    var v string = "draft"
    
    u.variant = "Kdraft"
    u.variant_Kdraft = &v
    
    u.variant_Kpublished = nil
    
    u.variant_Karchived = nil
    
    u.variant_Kdeleted = nil
    
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) IsKdraft() bool {
    return u.variant == "Kdraft"
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) AsKdraft() *string {
    if u.variant != "Kdraft" {
        return nil
    }
    return u.variant_Kdraft
}

func Union4KarchivedOrKdeletedOrKdraftOrKpublished__NewKpublished() Union4KarchivedOrKdeletedOrKdraftOrKpublished {
    
    var v string = "published"
    
    return Union4KarchivedOrKdeletedOrKdraftOrKpublished{
        variant: "Kpublished",
        variant_Kpublished: &v,
    }
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) SetKpublished() {
    
    var v string = "published"
    
    u.variant = "Kpublished"
    u.variant_Kpublished = &v
    
    u.variant_Kdraft = nil
    
    u.variant_Karchived = nil
    
    u.variant_Kdeleted = nil
    
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) IsKpublished() bool {
    return u.variant == "Kpublished"
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) AsKpublished() *string {
    if u.variant != "Kpublished" {
        return nil
    }
    return u.variant_Kpublished
}

func Union4KarchivedOrKdeletedOrKdraftOrKpublished__NewKarchived() Union4KarchivedOrKdeletedOrKdraftOrKpublished {
    
    var v string = "archived"
    
    return Union4KarchivedOrKdeletedOrKdraftOrKpublished{
        variant: "Karchived",
        variant_Karchived: &v,
    }
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) SetKarchived() {
    
    var v string = "archived"
    
    u.variant = "Karchived"
    u.variant_Karchived = &v
    
    u.variant_Kdraft = nil
    
    u.variant_Kpublished = nil
    
    u.variant_Kdeleted = nil
    
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) IsKarchived() bool {
    return u.variant == "Karchived"
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) AsKarchived() *string {
    if u.variant != "Karchived" {
        return nil
    }
    return u.variant_Karchived
}

func Union4KarchivedOrKdeletedOrKdraftOrKpublished__NewKdeleted() Union4KarchivedOrKdeletedOrKdraftOrKpublished {
    
    var v string = "deleted"
    
    return Union4KarchivedOrKdeletedOrKdraftOrKpublished{
        variant: "Kdeleted",
        variant_Kdeleted: &v,
    }
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) SetKdeleted() {
    
    var v string = "deleted"
    
    u.variant = "Kdeleted"
    u.variant_Kdeleted = &v
    
    u.variant_Kdraft = nil
    
    u.variant_Kpublished = nil
    
    u.variant_Karchived = nil
    
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) IsKdeleted() bool {
    return u.variant == "Kdeleted"
}

func (u *Union4KarchivedOrKdeletedOrKdraftOrKpublished) AsKdeleted() *string {
    if u.variant != "Kdeleted" {
        return nil
    }
    return u.variant_Kdeleted
}

type Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 struct {
    variant string
    
    variant_IntK1 *int64
    
    variant_IntK2 *int64
    
    variant_IntK3 *int64
    
    variant_IntK4 *int64
    
    variant_IntK5 *int64
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "int_1":
            u.variant = "IntK1"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK1 = &value
    case "int_2":
            u.variant = "IntK2"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK2 = &value
    case "int_3":
            u.variant = "IntK3"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK3 = &value
    case "int_4":
            u.variant = "IntK4"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK4 = &value
    case "int_5":
            u.variant = "IntK5"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK5 = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "IntK1":
        return baml.EncodeUnion(u.BamlEncodeName, "int_1", *u.variant_IntK1)
    
    case "IntK2":
        return baml.EncodeUnion(u.BamlEncodeName, "int_2", *u.variant_IntK2)
    
    case "IntK3":
        return baml.EncodeUnion(u.BamlEncodeName, "int_3", *u.variant_IntK3)
    
    case "IntK4":
        return baml.EncodeUnion(u.BamlEncodeName, "int_4", *u.variant_IntK4)
    
    case "IntK5":
        return baml.EncodeUnion(u.BamlEncodeName, "int_5", *u.variant_IntK5)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) BamlTypeName() string {
    return "Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5"
}

func (u Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__int_1__int_2__int_3__int_4__int_5",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "IntK1":
        return json.Marshal(u.variant_IntK1)
    
    case "IntK2":
        return json.Marshal(u.variant_IntK2)
    
    case "IntK3":
        return json.Marshal(u.variant_IntK3)
    
    case "IntK4":
        return json.Marshal(u.variant_IntK4)
    
    case "IntK5":
        return json.Marshal(u.variant_IntK5)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_IntK1)
    if err == nil {
        u.variant = "IntK1"
        return nil
    } else {
        u.variant_IntK1 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK2)
    if err == nil {
        u.variant = "IntK2"
        return nil
    } else {
        u.variant_IntK2 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK3)
    if err == nil {
        u.variant = "IntK3"
        return nil
    } else {
        u.variant_IntK3 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK4)
    if err == nil {
        u.variant = "IntK4"
        return nil
    } else {
        u.variant_IntK4 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK5)
    if err == nil {
        u.variant = "IntK5"
        return nil
    } else {
        u.variant_IntK5 = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK1() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 1
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK1",
        variant_IntK1: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK1() {
    
    var v int64 = 1
    
    u.variant = "IntK1"
    u.variant_IntK1 = &v
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK4 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK1() bool {
    return u.variant == "IntK1"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK1() *int64 {
    if u.variant != "IntK1" {
        return nil
    }
    return u.variant_IntK1
}

func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK2() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 2
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK2",
        variant_IntK2: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK2() {
    
    var v int64 = 2
    
    u.variant = "IntK2"
    u.variant_IntK2 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK4 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK2() bool {
    return u.variant == "IntK2"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK2() *int64 {
    if u.variant != "IntK2" {
        return nil
    }
    return u.variant_IntK2
}

func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK3() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 3
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK3",
        variant_IntK3: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK3() {
    
    var v int64 = 3
    
    u.variant = "IntK3"
    u.variant_IntK3 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK4 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK3() bool {
    return u.variant == "IntK3"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK3() *int64 {
    if u.variant != "IntK3" {
        return nil
    }
    return u.variant_IntK3
}

func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK4() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 4
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK4",
        variant_IntK4: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK4() {
    
    var v int64 = 4
    
    u.variant = "IntK4"
    u.variant_IntK4 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK4() bool {
    return u.variant == "IntK4"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK4() *int64 {
    if u.variant != "IntK4" {
        return nil
    }
    return u.variant_IntK4
}

func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK5() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 5
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK5",
        variant_IntK5: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK5() {
    
    var v int64 = 5
    
    u.variant = "IntK5"
    u.variant_IntK5 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK4 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK5() bool {
    return u.variant == "IntK5"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK5() *int64 {
    if u.variant != "IntK5" {
        return nil
    }
    return u.variant_IntK5
}

type Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500 struct {
    variant string
    
    variant_IntK200 *int64
    
    variant_IntK201 *int64
    
    variant_IntK400 *int64
    
    variant_IntK404 *int64
    
    variant_IntK500 *int64
    
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "int_200":
            u.variant = "IntK200"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK200 = &value
    case "int_201":
            u.variant = "IntK201"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK201 = &value
    case "int_400":
            u.variant = "IntK400"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK400 = &value
    case "int_404":
            u.variant = "IntK404"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK404 = &value
    case "int_500":
            u.variant = "IntK500"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK500 = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "IntK200":
        return baml.EncodeUnion(u.BamlEncodeName, "int_200", *u.variant_IntK200)
    
    case "IntK201":
        return baml.EncodeUnion(u.BamlEncodeName, "int_201", *u.variant_IntK201)
    
    case "IntK400":
        return baml.EncodeUnion(u.BamlEncodeName, "int_400", *u.variant_IntK400)
    
    case "IntK404":
        return baml.EncodeUnion(u.BamlEncodeName, "int_404", *u.variant_IntK404)
    
    case "IntK500":
        return baml.EncodeUnion(u.BamlEncodeName, "int_500", *u.variant_IntK500)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) BamlTypeName() string {
    return "Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500"
}

func (u Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__int_200__int_201__int_400__int_404__int_500",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "IntK200":
        return json.Marshal(u.variant_IntK200)
    
    case "IntK201":
        return json.Marshal(u.variant_IntK201)
    
    case "IntK400":
        return json.Marshal(u.variant_IntK400)
    
    case "IntK404":
        return json.Marshal(u.variant_IntK404)
    
    case "IntK500":
        return json.Marshal(u.variant_IntK500)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_IntK200)
    if err == nil {
        u.variant = "IntK200"
        return nil
    } else {
        u.variant_IntK200 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK201)
    if err == nil {
        u.variant = "IntK201"
        return nil
    } else {
        u.variant_IntK201 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK400)
    if err == nil {
        u.variant = "IntK400"
        return nil
    } else {
        u.variant_IntK400 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK404)
    if err == nil {
        u.variant = "IntK404"
        return nil
    } else {
        u.variant_IntK404 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK500)
    if err == nil {
        u.variant = "IntK500"
        return nil
    } else {
        u.variant_IntK500 = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500__NewIntK200() Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500 {
    
    var v int64 = 200
    
    return Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500{
        variant: "IntK200",
        variant_IntK200: &v,
    }
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) SetIntK200() {
    
    var v int64 = 200
    
    u.variant = "IntK200"
    u.variant_IntK200 = &v
    
    u.variant_IntK201 = nil
    
    u.variant_IntK400 = nil
    
    u.variant_IntK404 = nil
    
    u.variant_IntK500 = nil
    
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) IsIntK200() bool {
    return u.variant == "IntK200"
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) AsIntK200() *int64 {
    if u.variant != "IntK200" {
        return nil
    }
    return u.variant_IntK200
}

func Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500__NewIntK201() Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500 {
    
    var v int64 = 201
    
    return Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500{
        variant: "IntK201",
        variant_IntK201: &v,
    }
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) SetIntK201() {
    
    var v int64 = 201
    
    u.variant = "IntK201"
    u.variant_IntK201 = &v
    
    u.variant_IntK200 = nil
    
    u.variant_IntK400 = nil
    
    u.variant_IntK404 = nil
    
    u.variant_IntK500 = nil
    
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) IsIntK201() bool {
    return u.variant == "IntK201"
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) AsIntK201() *int64 {
    if u.variant != "IntK201" {
        return nil
    }
    return u.variant_IntK201
}

func Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500__NewIntK400() Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500 {
    
    var v int64 = 400
    
    return Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500{
        variant: "IntK400",
        variant_IntK400: &v,
    }
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) SetIntK400() {
    
    var v int64 = 400
    
    u.variant = "IntK400"
    u.variant_IntK400 = &v
    
    u.variant_IntK200 = nil
    
    u.variant_IntK201 = nil
    
    u.variant_IntK404 = nil
    
    u.variant_IntK500 = nil
    
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) IsIntK400() bool {
    return u.variant == "IntK400"
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) AsIntK400() *int64 {
    if u.variant != "IntK400" {
        return nil
    }
    return u.variant_IntK400
}

func Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500__NewIntK404() Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500 {
    
    var v int64 = 404
    
    return Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500{
        variant: "IntK404",
        variant_IntK404: &v,
    }
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) SetIntK404() {
    
    var v int64 = 404
    
    u.variant = "IntK404"
    u.variant_IntK404 = &v
    
    u.variant_IntK200 = nil
    
    u.variant_IntK201 = nil
    
    u.variant_IntK400 = nil
    
    u.variant_IntK500 = nil
    
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) IsIntK404() bool {
    return u.variant == "IntK404"
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) AsIntK404() *int64 {
    if u.variant != "IntK404" {
        return nil
    }
    return u.variant_IntK404
}

func Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500__NewIntK500() Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500 {
    
    var v int64 = 500
    
    return Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500{
        variant: "IntK500",
        variant_IntK500: &v,
    }
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) SetIntK500() {
    
    var v int64 = 500
    
    u.variant = "IntK500"
    u.variant_IntK500 = &v
    
    u.variant_IntK200 = nil
    
    u.variant_IntK201 = nil
    
    u.variant_IntK400 = nil
    
    u.variant_IntK404 = nil
    
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) IsIntK500() bool {
    return u.variant == "IntK500"
}

func (u *Union5IntK200OrIntK201OrIntK400OrIntK404OrIntK500) AsIntK500() *int64 {
    if u.variant != "IntK500" {
        return nil
    }
    return u.variant_IntK500
}

type Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8 struct {
    variant string
    
    variant_IntK0 *int64
    
    variant_IntK1 *int64
    
    variant_IntK2 *int64
    
    variant_IntK3 *int64
    
    variant_IntK5 *int64
    
    variant_IntK8 *int64
    
    variant_IntK13 *int64
    
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "int_0":
            u.variant = "IntK0"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK0 = &value
    case "int_1":
            u.variant = "IntK1"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK1 = &value
    case "int_2":
            u.variant = "IntK2"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK2 = &value
    case "int_3":
            u.variant = "IntK3"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK3 = &value
    case "int_5":
            u.variant = "IntK5"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK5 = &value
    case "int_8":
            u.variant = "IntK8"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK8 = &value
    case "int_13":
            u.variant = "IntK13"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK13 = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "IntK0":
        return baml.EncodeUnion(u.BamlEncodeName, "int_0", *u.variant_IntK0)
    
    case "IntK1":
        return baml.EncodeUnion(u.BamlEncodeName, "int_1", *u.variant_IntK1)
    
    case "IntK2":
        return baml.EncodeUnion(u.BamlEncodeName, "int_2", *u.variant_IntK2)
    
    case "IntK3":
        return baml.EncodeUnion(u.BamlEncodeName, "int_3", *u.variant_IntK3)
    
    case "IntK5":
        return baml.EncodeUnion(u.BamlEncodeName, "int_5", *u.variant_IntK5)
    
    case "IntK8":
        return baml.EncodeUnion(u.BamlEncodeName, "int_8", *u.variant_IntK8)
    
    case "IntK13":
        return baml.EncodeUnion(u.BamlEncodeName, "int_13", *u.variant_IntK13)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) BamlTypeName() string {
    return "Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8"
}

func (u Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__int_0__int_1__int_13__int_2__int_3__int_5__int_8",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "IntK0":
        return json.Marshal(u.variant_IntK0)
    
    case "IntK1":
        return json.Marshal(u.variant_IntK1)
    
    case "IntK2":
        return json.Marshal(u.variant_IntK2)
    
    case "IntK3":
        return json.Marshal(u.variant_IntK3)
    
    case "IntK5":
        return json.Marshal(u.variant_IntK5)
    
    case "IntK8":
        return json.Marshal(u.variant_IntK8)
    
    case "IntK13":
        return json.Marshal(u.variant_IntK13)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_IntK0)
    if err == nil {
        u.variant = "IntK0"
        return nil
    } else {
        u.variant_IntK0 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK1)
    if err == nil {
        u.variant = "IntK1"
        return nil
    } else {
        u.variant_IntK1 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK2)
    if err == nil {
        u.variant = "IntK2"
        return nil
    } else {
        u.variant_IntK2 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK3)
    if err == nil {
        u.variant = "IntK3"
        return nil
    } else {
        u.variant_IntK3 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK5)
    if err == nil {
        u.variant = "IntK5"
        return nil
    } else {
        u.variant_IntK5 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK8)
    if err == nil {
        u.variant = "IntK8"
        return nil
    } else {
        u.variant_IntK8 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK13)
    if err == nil {
        u.variant = "IntK13"
        return nil
    } else {
        u.variant_IntK13 = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8__NewIntK0() Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8 {
    
    var v int64 = 0
    
    return Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8{
        variant: "IntK0",
        variant_IntK0: &v,
    }
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) SetIntK0() {
    
    var v int64 = 0
    
    u.variant = "IntK0"
    u.variant_IntK0 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
    u.variant_IntK8 = nil
    
    u.variant_IntK13 = nil
    
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) IsIntK0() bool {
    return u.variant == "IntK0"
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) AsIntK0() *int64 {
    if u.variant != "IntK0" {
        return nil
    }
    return u.variant_IntK0
}

func Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8__NewIntK1() Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8 {
    
    var v int64 = 1
    
    return Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8{
        variant: "IntK1",
        variant_IntK1: &v,
    }
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) SetIntK1() {
    
    var v int64 = 1
    
    u.variant = "IntK1"
    u.variant_IntK1 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
    u.variant_IntK8 = nil
    
    u.variant_IntK13 = nil
    
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) IsIntK1() bool {
    return u.variant == "IntK1"
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) AsIntK1() *int64 {
    if u.variant != "IntK1" {
        return nil
    }
    return u.variant_IntK1
}

func Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8__NewIntK2() Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8 {
    
    var v int64 = 2
    
    return Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8{
        variant: "IntK2",
        variant_IntK2: &v,
    }
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) SetIntK2() {
    
    var v int64 = 2
    
    u.variant = "IntK2"
    u.variant_IntK2 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK1 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
    u.variant_IntK8 = nil
    
    u.variant_IntK13 = nil
    
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) IsIntK2() bool {
    return u.variant == "IntK2"
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) AsIntK2() *int64 {
    if u.variant != "IntK2" {
        return nil
    }
    return u.variant_IntK2
}

func Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8__NewIntK3() Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8 {
    
    var v int64 = 3
    
    return Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8{
        variant: "IntK3",
        variant_IntK3: &v,
    }
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) SetIntK3() {
    
    var v int64 = 3
    
    u.variant = "IntK3"
    u.variant_IntK3 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK5 = nil
    
    u.variant_IntK8 = nil
    
    u.variant_IntK13 = nil
    
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) IsIntK3() bool {
    return u.variant == "IntK3"
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) AsIntK3() *int64 {
    if u.variant != "IntK3" {
        return nil
    }
    return u.variant_IntK3
}

func Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8__NewIntK5() Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8 {
    
    var v int64 = 5
    
    return Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8{
        variant: "IntK5",
        variant_IntK5: &v,
    }
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) SetIntK5() {
    
    var v int64 = 5
    
    u.variant = "IntK5"
    u.variant_IntK5 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK8 = nil
    
    u.variant_IntK13 = nil
    
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) IsIntK5() bool {
    return u.variant == "IntK5"
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) AsIntK5() *int64 {
    if u.variant != "IntK5" {
        return nil
    }
    return u.variant_IntK5
}

func Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8__NewIntK8() Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8 {
    
    var v int64 = 8
    
    return Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8{
        variant: "IntK8",
        variant_IntK8: &v,
    }
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) SetIntK8() {
    
    var v int64 = 8
    
    u.variant = "IntK8"
    u.variant_IntK8 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
    u.variant_IntK13 = nil
    
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) IsIntK8() bool {
    return u.variant == "IntK8"
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) AsIntK8() *int64 {
    if u.variant != "IntK8" {
        return nil
    }
    return u.variant_IntK8
}

func Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8__NewIntK13() Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8 {
    
    var v int64 = 13
    
    return Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8{
        variant: "IntK13",
        variant_IntK13: &v,
    }
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) SetIntK13() {
    
    var v int64 = 13
    
    u.variant = "IntK13"
    u.variant_IntK13 = &v
    
    u.variant_IntK0 = nil
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
    u.variant_IntK8 = nil
    
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) IsIntK13() bool {
    return u.variant == "IntK13"
}

func (u *Union7IntK0OrIntK1OrIntK13OrIntK2OrIntK3OrIntK5OrIntK8) AsIntK13() *int64 {
    if u.variant != "IntK13" {
        return nil
    }
    return u.variant_IntK13
}


