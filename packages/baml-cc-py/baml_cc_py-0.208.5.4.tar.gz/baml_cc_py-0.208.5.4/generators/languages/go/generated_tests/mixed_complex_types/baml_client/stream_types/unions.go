// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package stream_types

import (
    "encoding/json"
    "fmt"

    baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
    "github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"

    "mixed_complex_types/baml_client/types"
)

type Union2ConditionOrSimpleCondition struct {
    variant string
    
    variant_Condition *Condition
    
    variant_SimpleCondition *SimpleCondition
    
}

func (u *Union2ConditionOrSimpleCondition) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "Condition":
            u.variant = "Condition"
            value := baml.Decode(valueHolder).Interface().(Condition)
            u.variant_Condition = &value
    case "SimpleCondition":
            u.variant = "SimpleCondition"
            value := baml.Decode(valueHolder).Interface().(SimpleCondition)
            u.variant_SimpleCondition = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union2ConditionOrSimpleCondition) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Condition":
        return baml.EncodeUnion(u.BamlEncodeName, "Condition", *u.variant_Condition)
    
    case "SimpleCondition":
        return baml.EncodeUnion(u.BamlEncodeName, "SimpleCondition", *u.variant_SimpleCondition)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union2ConditionOrSimpleCondition) BamlTypeName() string {
    return "Union2ConditionOrSimpleCondition"
}

func (u Union2ConditionOrSimpleCondition) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__Condition__SimpleCondition",
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
    }
}

func (u Union2ConditionOrSimpleCondition) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Condition":
        return json.Marshal(u.variant_Condition)
    
    case "SimpleCondition":
        return json.Marshal(u.variant_SimpleCondition)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union2ConditionOrSimpleCondition) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Condition)
    if err == nil {
        u.variant = "Condition"
        return nil
    } else {
        u.variant_Condition = nil
    }
    
    err = json.Unmarshal(data, &u.variant_SimpleCondition)
    if err == nil {
        u.variant = "SimpleCondition"
        return nil
    } else {
        u.variant_SimpleCondition = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union2ConditionOrSimpleCondition__NewCondition(v Condition) Union2ConditionOrSimpleCondition {
    
    return Union2ConditionOrSimpleCondition{
        variant: "Condition",
        variant_Condition: &v,
    }
}

func (u *Union2ConditionOrSimpleCondition) SetCondition(v Condition) {
    
    u.variant = "Condition"
    u.variant_Condition = &v
    
    u.variant_SimpleCondition = nil
    
}

func (u *Union2ConditionOrSimpleCondition) IsCondition() bool {
    return u.variant == "Condition"
}

func (u *Union2ConditionOrSimpleCondition) AsCondition() *Condition {
    if u.variant != "Condition" {
        return nil
    }
    return u.variant_Condition
}

func Union2ConditionOrSimpleCondition__NewSimpleCondition(v SimpleCondition) Union2ConditionOrSimpleCondition {
    
    return Union2ConditionOrSimpleCondition{
        variant: "SimpleCondition",
        variant_SimpleCondition: &v,
    }
}

func (u *Union2ConditionOrSimpleCondition) SetSimpleCondition(v SimpleCondition) {
    
    u.variant = "SimpleCondition"
    u.variant_SimpleCondition = &v
    
    u.variant_Condition = nil
    
}

func (u *Union2ConditionOrSimpleCondition) IsSimpleCondition() bool {
    return u.variant == "SimpleCondition"
}

func (u *Union2ConditionOrSimpleCondition) AsSimpleCondition() *SimpleCondition {
    if u.variant != "SimpleCondition" {
        return nil
    }
    return u.variant_SimpleCondition
}
type Union2ErrorOrSuccess struct {
    variant string
    
    variant_Success *Success
    
    variant_Error *Error
    
}

func (u *Union2ErrorOrSuccess) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "Success":
            u.variant = "Success"
            value := baml.Decode(valueHolder).Interface().(Success)
            u.variant_Success = &value
    case "Error":
            u.variant = "Error"
            value := baml.Decode(valueHolder).Interface().(Error)
            u.variant_Error = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union2ErrorOrSuccess) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Success":
        return baml.EncodeUnion(u.BamlEncodeName, "Success", *u.variant_Success)
    
    case "Error":
        return baml.EncodeUnion(u.BamlEncodeName, "Error", *u.variant_Error)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union2ErrorOrSuccess) BamlTypeName() string {
    return "Union2ErrorOrSuccess"
}

func (u Union2ErrorOrSuccess) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__Error__Success",
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
    }
}

func (u Union2ErrorOrSuccess) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Success":
        return json.Marshal(u.variant_Success)
    
    case "Error":
        return json.Marshal(u.variant_Error)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union2ErrorOrSuccess) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Success)
    if err == nil {
        u.variant = "Success"
        return nil
    } else {
        u.variant_Success = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Error)
    if err == nil {
        u.variant = "Error"
        return nil
    } else {
        u.variant_Error = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union2ErrorOrSuccess__NewSuccess(v Success) Union2ErrorOrSuccess {
    
    return Union2ErrorOrSuccess{
        variant: "Success",
        variant_Success: &v,
    }
}

func (u *Union2ErrorOrSuccess) SetSuccess(v Success) {
    
    u.variant = "Success"
    u.variant_Success = &v
    
    u.variant_Error = nil
    
}

func (u *Union2ErrorOrSuccess) IsSuccess() bool {
    return u.variant == "Success"
}

func (u *Union2ErrorOrSuccess) AsSuccess() *Success {
    if u.variant != "Success" {
        return nil
    }
    return u.variant_Success
}

func Union2ErrorOrSuccess__NewError(v Error) Union2ErrorOrSuccess {
    
    return Union2ErrorOrSuccess{
        variant: "Error",
        variant_Error: &v,
    }
}

func (u *Union2ErrorOrSuccess) SetError(v Error) {
    
    u.variant = "Error"
    u.variant_Error = &v
    
    u.variant_Success = nil
    
}

func (u *Union2ErrorOrSuccess) IsError() bool {
    return u.variant == "Error"
}

func (u *Union2ErrorOrSuccess) AsError() *Error {
    if u.variant != "Error" {
        return nil
    }
    return u.variant_Error
}
type Union3DataObjectOrIntOrString struct {
    variant string
    
    variant_String *string
    
    variant_Int *int64
    
    variant_DataObject *DataObject
    
}

func (u *Union3DataObjectOrIntOrString) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string":
            u.variant = "String"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_String = &value
    case "int":
            u.variant = "Int"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_Int = &value
    case "DataObject":
            u.variant = "DataObject"
            value := baml.Decode(valueHolder).Interface().(DataObject)
            u.variant_DataObject = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3DataObjectOrIntOrString) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "String":
        return baml.EncodeUnion(u.BamlEncodeName, "string", *u.variant_String)
    
    case "Int":
        return baml.EncodeUnion(u.BamlEncodeName, "int", *u.variant_Int)
    
    case "DataObject":
        return baml.EncodeUnion(u.BamlEncodeName, "DataObject", *u.variant_DataObject)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3DataObjectOrIntOrString) BamlTypeName() string {
    return "Union3DataObjectOrIntOrString"
}

func (u Union3DataObjectOrIntOrString) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__DataObject__int__string",
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
    }
}

func (u Union3DataObjectOrIntOrString) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "String":
        return json.Marshal(u.variant_String)
    
    case "Int":
        return json.Marshal(u.variant_Int)
    
    case "DataObject":
        return json.Marshal(u.variant_DataObject)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3DataObjectOrIntOrString) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_String)
    if err == nil {
        u.variant = "String"
        return nil
    } else {
        u.variant_String = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Int)
    if err == nil {
        u.variant = "Int"
        return nil
    } else {
        u.variant_Int = nil
    }
    
    err = json.Unmarshal(data, &u.variant_DataObject)
    if err == nil {
        u.variant = "DataObject"
        return nil
    } else {
        u.variant_DataObject = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3DataObjectOrIntOrString__NewString(v string) Union3DataObjectOrIntOrString {
    
    return Union3DataObjectOrIntOrString{
        variant: "String",
        variant_String: &v,
    }
}

func (u *Union3DataObjectOrIntOrString) SetString(v string) {
    
    u.variant = "String"
    u.variant_String = &v
    
    u.variant_Int = nil
    
    u.variant_DataObject = nil
    
}

func (u *Union3DataObjectOrIntOrString) IsString() bool {
    return u.variant == "String"
}

func (u *Union3DataObjectOrIntOrString) AsString() *string {
    if u.variant != "String" {
        return nil
    }
    return u.variant_String
}

func Union3DataObjectOrIntOrString__NewInt(v int64) Union3DataObjectOrIntOrString {
    
    return Union3DataObjectOrIntOrString{
        variant: "Int",
        variant_Int: &v,
    }
}

func (u *Union3DataObjectOrIntOrString) SetInt(v int64) {
    
    u.variant = "Int"
    u.variant_Int = &v
    
    u.variant_String = nil
    
    u.variant_DataObject = nil
    
}

func (u *Union3DataObjectOrIntOrString) IsInt() bool {
    return u.variant == "Int"
}

func (u *Union3DataObjectOrIntOrString) AsInt() *int64 {
    if u.variant != "Int" {
        return nil
    }
    return u.variant_Int
}

func Union3DataObjectOrIntOrString__NewDataObject(v DataObject) Union3DataObjectOrIntOrString {
    
    return Union3DataObjectOrIntOrString{
        variant: "DataObject",
        variant_DataObject: &v,
    }
}

func (u *Union3DataObjectOrIntOrString) SetDataObject(v DataObject) {
    
    u.variant = "DataObject"
    u.variant_DataObject = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
}

func (u *Union3DataObjectOrIntOrString) IsDataObject() bool {
    return u.variant == "DataObject"
}

func (u *Union3DataObjectOrIntOrString) AsDataObject() *DataObject {
    if u.variant != "DataObject" {
        return nil
    }
    return u.variant_DataObject
}
type Union4IntOrListNodeOrMapStringKeyNodeValueOrString struct {
    variant string
    
    variant_String *string
    
    variant_Int *int64
    
    variant_ListNode *[]Node
    
    variant_MapStringKeyNodeValue *map[string]Node
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string":
            u.variant = "String"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_String = &value
    case "int":
            u.variant = "Int"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_Int = &value
    case "List__Node":
            u.variant = "ListNode"
            value := baml.Decode(valueHolder).Interface().([]Node)
            u.variant_ListNode = &value
    case "Map__string_Node":
            u.variant = "MapStringKeyNodeValue"
            value := baml.Decode(valueHolder).Interface().(map[string]Node)
            u.variant_MapStringKeyNodeValue = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union4IntOrListNodeOrMapStringKeyNodeValueOrString) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "String":
        return baml.EncodeUnion(u.BamlEncodeName, "string", *u.variant_String)
    
    case "Int":
        return baml.EncodeUnion(u.BamlEncodeName, "int", *u.variant_Int)
    
    case "ListNode":
        return baml.EncodeUnion(u.BamlEncodeName, "List__Node", *u.variant_ListNode)
    
    case "MapStringKeyNodeValue":
        return baml.EncodeUnion(u.BamlEncodeName, "Map__string_Node", *u.variant_MapStringKeyNodeValue)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union4IntOrListNodeOrMapStringKeyNodeValueOrString) BamlTypeName() string {
    return "Union4IntOrListNodeOrMapStringKeyNodeValueOrString"
}

func (u Union4IntOrListNodeOrMapStringKeyNodeValueOrString) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__List__Node__Map__string_Node__int__string",
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
    }
}

func (u Union4IntOrListNodeOrMapStringKeyNodeValueOrString) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "String":
        return json.Marshal(u.variant_String)
    
    case "Int":
        return json.Marshal(u.variant_Int)
    
    case "ListNode":
        return json.Marshal(u.variant_ListNode)
    
    case "MapStringKeyNodeValue":
        return json.Marshal(u.variant_MapStringKeyNodeValue)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_String)
    if err == nil {
        u.variant = "String"
        return nil
    } else {
        u.variant_String = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Int)
    if err == nil {
        u.variant = "Int"
        return nil
    } else {
        u.variant_Int = nil
    }
    
    err = json.Unmarshal(data, &u.variant_ListNode)
    if err == nil {
        u.variant = "ListNode"
        return nil
    } else {
        u.variant_ListNode = nil
    }
    
    err = json.Unmarshal(data, &u.variant_MapStringKeyNodeValue)
    if err == nil {
        u.variant = "MapStringKeyNodeValue"
        return nil
    } else {
        u.variant_MapStringKeyNodeValue = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union4IntOrListNodeOrMapStringKeyNodeValueOrString__NewString(v string) Union4IntOrListNodeOrMapStringKeyNodeValueOrString {
    
    return Union4IntOrListNodeOrMapStringKeyNodeValueOrString{
        variant: "String",
        variant_String: &v,
    }
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) SetString(v string) {
    
    u.variant = "String"
    u.variant_String = &v
    
    u.variant_Int = nil
    
    u.variant_ListNode = nil
    
    u.variant_MapStringKeyNodeValue = nil
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) IsString() bool {
    return u.variant == "String"
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) AsString() *string {
    if u.variant != "String" {
        return nil
    }
    return u.variant_String
}

func Union4IntOrListNodeOrMapStringKeyNodeValueOrString__NewInt(v int64) Union4IntOrListNodeOrMapStringKeyNodeValueOrString {
    
    return Union4IntOrListNodeOrMapStringKeyNodeValueOrString{
        variant: "Int",
        variant_Int: &v,
    }
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) SetInt(v int64) {
    
    u.variant = "Int"
    u.variant_Int = &v
    
    u.variant_String = nil
    
    u.variant_ListNode = nil
    
    u.variant_MapStringKeyNodeValue = nil
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) IsInt() bool {
    return u.variant == "Int"
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) AsInt() *int64 {
    if u.variant != "Int" {
        return nil
    }
    return u.variant_Int
}

func Union4IntOrListNodeOrMapStringKeyNodeValueOrString__NewListNode(v []Node) Union4IntOrListNodeOrMapStringKeyNodeValueOrString {
    
    return Union4IntOrListNodeOrMapStringKeyNodeValueOrString{
        variant: "ListNode",
        variant_ListNode: &v,
    }
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) SetListNode(v []Node) {
    
    u.variant = "ListNode"
    u.variant_ListNode = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
    u.variant_MapStringKeyNodeValue = nil
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) IsListNode() bool {
    return u.variant == "ListNode"
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) AsListNode() *[]Node {
    if u.variant != "ListNode" {
        return nil
    }
    return u.variant_ListNode
}

func Union4IntOrListNodeOrMapStringKeyNodeValueOrString__NewMapStringKeyNodeValue(v map[string]Node) Union4IntOrListNodeOrMapStringKeyNodeValueOrString {
    
    return Union4IntOrListNodeOrMapStringKeyNodeValueOrString{
        variant: "MapStringKeyNodeValue",
        variant_MapStringKeyNodeValue: &v,
    }
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) SetMapStringKeyNodeValue(v map[string]Node) {
    
    u.variant = "MapStringKeyNodeValue"
    u.variant_MapStringKeyNodeValue = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
    u.variant_ListNode = nil
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) IsMapStringKeyNodeValue() bool {
    return u.variant == "MapStringKeyNodeValue"
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) AsMapStringKeyNodeValue() *map[string]Node {
    if u.variant != "MapStringKeyNodeValue" {
        return nil
    }
    return u.variant_MapStringKeyNodeValue
}
