# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (0)
# #########################################################################

# #########################################################################
# Generated classes (35)
# #########################################################################

class Action(BaseModel):
    type: str
    parameters: typing.Dict[str, typing.Union[str, int, bool]]
    async_: bool

class Asset(BaseModel):
    id: int
    type: typing.Union[typing_extensions.Literal['image'], typing_extensions.Literal['audio'], typing_extensions.Literal['document']]
    metadata: "AssetMetadata"
    tags: typing.List[str]

class AssetMetadata(BaseModel):
    filename: str
    size: int
    mimeType: str
    uploaded: str
    checksum: str

class ButtonWidget(BaseModel):
    label: str
    action: str
    style: typing.Dict[str, str]

class ComplexData(BaseModel):
    primary: "PrimaryData"
    secondary: typing.Optional["SecondaryData"] = None
    tertiary: typing.Optional["TertiaryData"] = None

class Condition(BaseModel):
    type: typing.Union[typing_extensions.Literal['and'], typing_extensions.Literal['or'], typing_extensions.Literal['not']]
    conditions: typing.List[typing.Union["Condition", "SimpleCondition"]]

class Configuration(BaseModel):
    version: str
    features: typing.List["Feature"]
    environments: typing.Dict[str, "Environment"]
    rules: typing.List["Rule"]

class ContainerWidget(BaseModel):
    layout: typing.Union[typing_extensions.Literal['flex'], typing_extensions.Literal['grid'], typing_extensions.Literal['stack']]
    children: typing.List["Widget"]
    style: typing.Dict[str, str]

class DataObject(BaseModel):
    type: typing_extensions.Literal['object']
    value: typing.Dict[str, str]

class Dimensions(BaseModel):
    width: int
    height: int

class Environment(BaseModel):
    name: str
    url: str
    variables: typing.Dict[str, str]
    secrets: typing.Optional[typing.Dict[str, str]] = None

class Error(BaseModel):
    type: typing_extensions.Literal['error']
    message: str
    code: int

class ErrorDetail(BaseModel):
    code: str
    message: str
    details: typing.Optional[typing.Dict[str, str]] = None

class Feature(BaseModel):
    name: str
    enabled: bool
    config: typing.Optional[typing.Dict[str, typing.Union[str, int, bool]]] = None
    dependencies: typing.List[str]

class ImageWidget(BaseModel):
    alt: str
    dimensions: "Dimensions"

class Item(BaseModel):
    id: int
    name: str
    variants: typing.List["Variant"]
    attributes: typing.Dict[str, typing.Union[str, int, float, bool]]

class KitchenSink(BaseModel):
    id: int
    name: str
    score: float
    active: bool
    nothing: typing.Any
    status: typing.Union[typing_extensions.Literal['draft'], typing_extensions.Literal['published'], typing_extensions.Literal['archived']]
    priority: typing.Union[typing_extensions.Literal[1], typing_extensions.Literal[2], typing_extensions.Literal[3], typing_extensions.Literal[4], typing_extensions.Literal[5]]
    tags: typing.List[str]
    numbers: typing.List[int]
    matrix: typing.List[typing.List[int]]
    metadata: typing.Dict[str, str]
    scores: typing.Dict[str, float]
    description: typing.Optional[str] = None
    notes: typing.Optional[str] = None
    data: typing.Union[str, int, "DataObject"]
    result: typing.Union["Success", "Error"]
    user: "User"
    items: typing.List["Item"]
    config: "Configuration"

class Node(BaseModel):
    id: int
    type: typing.Union[typing_extensions.Literal['leaf'], typing_extensions.Literal['branch']]
    value: typing.Union[str, int, typing.List["Node"], typing.Dict[str, "Node"]]
    metadata: typing.Optional["NodeMetadata"] = None

class NodeMetadata(BaseModel):
    created: str
    modified: str
    tags: typing.List[str]
    attributes: typing.Dict[str, typing.Optional[typing.Union[str, int, bool]]]

class PrimaryData(BaseModel):
    values: typing.List[typing.Union[str, int, float]]
    mappings: typing.Dict[str, typing.Dict[str, str]]
    flags: typing.List[bool]

class Record(BaseModel):
    id: int
    data: typing.Dict[str, typing.Optional[typing.Union[str, int, bool]]]
    related: typing.Optional[typing.List["Record"]] = None

class ResponseMetadata(BaseModel):
    timestamp: str
    requestId: str
    duration: int
    retries: int

class Rule(BaseModel):
    id: int
    name: str
    condition: "Condition"
    actions: typing.List["Action"]
    priority: int

class SecondaryData(BaseModel):
    records: typing.List["Record"]
    index: typing.Dict[str, "Record"]

class Setting(BaseModel):
    key: str
    value: typing.Union[str, int, bool]
    metadata: typing.Optional[typing.Dict[str, str]] = None

class SimpleCondition(BaseModel):
    field: str
    operator: typing.Union[typing_extensions.Literal['eq'], typing_extensions.Literal['ne'], typing_extensions.Literal['gt'], typing_extensions.Literal['lt'], typing_extensions.Literal['contains']]
    value: typing.Union[str, int, float, bool]

class Success(BaseModel):
    type: typing_extensions.Literal['success']
    data: typing.Dict[str, str]

class TertiaryData(BaseModel):
    raw: str
    parsed: typing.Optional[typing.Dict[str, str]] = None
    valid: bool

class TextWidget(BaseModel):
    content: str
    format: typing.Union[typing_extensions.Literal['plain'], typing_extensions.Literal['markdown'], typing_extensions.Literal['html']]
    style: typing.Dict[str, str]

class UltraComplex(BaseModel):
    tree: "Node"
    widgets: typing.List["Widget"]
    data: typing.Optional["ComplexData"] = None
    response: "UserResponse"
    assets: typing.List["Asset"]

class User(BaseModel):
    id: int
    profile: "UserProfile"
    settings: typing.Dict[str, "Setting"]

class UserProfile(BaseModel):
    name: str
    email: str
    bio: typing.Optional[str] = None
    links: typing.List[str]

class UserResponse(BaseModel):
    status: typing.Union[typing_extensions.Literal['success'], typing_extensions.Literal['error']]
    data: typing.Optional["User"] = None
    error: typing.Optional["ErrorDetail"] = None
    metadata: "ResponseMetadata"

class Variant(BaseModel):
    sku: str
    price: float
    stock: int
    options: typing.Dict[str, str]

class Widget(BaseModel):
    type: typing.Union[typing_extensions.Literal['button'], typing_extensions.Literal['text'], typing_extensions.Literal['image'], typing_extensions.Literal['container']]
    button: typing.Optional["ButtonWidget"] = None
    text: typing.Optional["TextWidget"] = None
    image: typing.Optional["ImageWidget"] = None
    container: typing.Optional["ContainerWidget"] = None

# #########################################################################
# Generated type aliases (0)
# #########################################################################
