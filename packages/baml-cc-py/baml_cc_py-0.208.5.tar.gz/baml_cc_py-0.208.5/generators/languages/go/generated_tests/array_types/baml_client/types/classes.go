// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package types

import (
    "encoding/json"
    "fmt"

    baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
    "github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)


type ArrayWithConstraints struct {
    
NonEmptyStrings []string `json:"nonEmptyStrings"`
LimitedInts []int64 `json:"limitedInts"`
PositiveFloats []float64 `json:"positiveFloats"`
    
}

func (c *ArrayWithConstraints) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ArrayWithConstraints" {
		panic(fmt.Sprintf("expected ArrayWithConstraints, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "nonEmptyStrings":
					c.NonEmptyStrings = baml.Decode(valueHolder).Interface().([]string)
				
				case "limitedInts":
					c.LimitedInts = baml.Decode(valueHolder).Interface().([]int64)
				
				case "positiveFloats":
					c.PositiveFloats = baml.Decode(valueHolder).Interface().([]float64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ArrayWithConstraints", key))
			
		}
	}

}

func (c ArrayWithConstraints) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["nonEmptyStrings"] = c.NonEmptyStrings
    
    fields["limitedInts"] = c.LimitedInts
    
    fields["positiveFloats"] = c.PositiveFloats
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ArrayWithConstraints) BamlTypeName() string {
    return "ArrayWithConstraints"
}

func (u ArrayWithConstraints) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "ArrayWithConstraints",
    }
}

type MixedArrays struct {
    
PrimitiveArray []Union4BoolOrFloatOrIntOrString `json:"primitiveArray"`
NullableArray []*string `json:"nullableArray"`
OptionalItems []*string `json:"optionalItems"`
ArrayOfArrays [][]string `json:"arrayOfArrays"`
ComplexMixed []Union3ProductOrTagOrUser `json:"complexMixed"`
    
}

func (c *MixedArrays) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "MixedArrays" {
		panic(fmt.Sprintf("expected MixedArrays, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "primitiveArray":
					c.PrimitiveArray = baml.Decode(valueHolder).Interface().([]Union4BoolOrFloatOrIntOrString)
				
				case "nullableArray":
					c.NullableArray = baml.Decode(valueHolder).Interface().([]*string)
				
				case "optionalItems":
					c.OptionalItems = baml.Decode(valueHolder).Interface().([]*string)
				
				case "arrayOfArrays":
					c.ArrayOfArrays = baml.Decode(valueHolder).Interface().([][]string)
				
				case "complexMixed":
					c.ComplexMixed = baml.Decode(valueHolder).Interface().([]Union3ProductOrTagOrUser)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class MixedArrays", key))
			
		}
	}

}

func (c MixedArrays) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["primitiveArray"] = c.PrimitiveArray
    
    fields["nullableArray"] = c.NullableArray
    
    fields["optionalItems"] = c.OptionalItems
    
    fields["arrayOfArrays"] = c.ArrayOfArrays
    
    fields["complexMixed"] = c.ComplexMixed
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c MixedArrays) BamlTypeName() string {
    return "MixedArrays"
}

func (u MixedArrays) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "MixedArrays",
    }
}

type NestedArrays struct {
    
Matrix [][]int64 `json:"matrix"`
StringMatrix [][]string `json:"stringMatrix"`
ThreeDimensional [][][]float64 `json:"threeDimensional"`
    
}

func (c *NestedArrays) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "NestedArrays" {
		panic(fmt.Sprintf("expected NestedArrays, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "matrix":
					c.Matrix = baml.Decode(valueHolder).Interface().([][]int64)
				
				case "stringMatrix":
					c.StringMatrix = baml.Decode(valueHolder).Interface().([][]string)
				
				case "threeDimensional":
					c.ThreeDimensional = baml.Decode(valueHolder).Interface().([][][]float64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class NestedArrays", key))
			
		}
	}

}

func (c NestedArrays) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["matrix"] = c.Matrix
    
    fields["stringMatrix"] = c.StringMatrix
    
    fields["threeDimensional"] = c.ThreeDimensional
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c NestedArrays) BamlTypeName() string {
    return "NestedArrays"
}

func (u NestedArrays) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "NestedArrays",
    }
}

type ObjectArrays struct {
    
Users []User `json:"users"`
Products []Product `json:"products"`
Tags []Tag `json:"tags"`
    
}

func (c *ObjectArrays) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ObjectArrays" {
		panic(fmt.Sprintf("expected ObjectArrays, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "users":
					c.Users = baml.Decode(valueHolder).Interface().([]User)
				
				case "products":
					c.Products = baml.Decode(valueHolder).Interface().([]Product)
				
				case "tags":
					c.Tags = baml.Decode(valueHolder).Interface().([]Tag)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ObjectArrays", key))
			
		}
	}

}

func (c ObjectArrays) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["users"] = c.Users
    
    fields["products"] = c.Products
    
    fields["tags"] = c.Tags
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ObjectArrays) BamlTypeName() string {
    return "ObjectArrays"
}

func (u ObjectArrays) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "ObjectArrays",
    }
}

type Product struct {
    
Id int64 `json:"id"`
Name string `json:"name"`
Price float64 `json:"price"`
Tags []string `json:"tags"`
InStock bool `json:"inStock"`
    
}

func (c *Product) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Product" {
		panic(fmt.Sprintf("expected Product, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(string)
				
				case "price":
					c.Price = baml.Decode(valueHolder).Interface().(float64)
				
				case "tags":
					c.Tags = baml.Decode(valueHolder).Interface().([]string)
				
				case "inStock":
					c.InStock = baml.Decode(valueHolder).Interface().(bool)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Product", key))
			
		}
	}

}

func (c Product) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["price"] = c.Price
    
    fields["tags"] = c.Tags
    
    fields["inStock"] = c.InStock
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Product) BamlTypeName() string {
    return "Product"
}

func (u Product) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Product",
    }
}

type SimpleArrays struct {
    
Strings []string `json:"strings"`
Integers []int64 `json:"integers"`
Floats []float64 `json:"floats"`
Booleans []bool `json:"booleans"`
    
}

func (c *SimpleArrays) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "SimpleArrays" {
		panic(fmt.Sprintf("expected SimpleArrays, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "strings":
					c.Strings = baml.Decode(valueHolder).Interface().([]string)
				
				case "integers":
					c.Integers = baml.Decode(valueHolder).Interface().([]int64)
				
				case "floats":
					c.Floats = baml.Decode(valueHolder).Interface().([]float64)
				
				case "booleans":
					c.Booleans = baml.Decode(valueHolder).Interface().([]bool)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class SimpleArrays", key))
			
		}
	}

}

func (c SimpleArrays) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["strings"] = c.Strings
    
    fields["integers"] = c.Integers
    
    fields["floats"] = c.Floats
    
    fields["booleans"] = c.Booleans
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c SimpleArrays) BamlTypeName() string {
    return "SimpleArrays"
}

func (u SimpleArrays) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "SimpleArrays",
    }
}

type Tag struct {
    
Id int64 `json:"id"`
Name string `json:"name"`
Color string `json:"color"`
    
}

func (c *Tag) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Tag" {
		panic(fmt.Sprintf("expected Tag, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(string)
				
				case "color":
					c.Color = baml.Decode(valueHolder).Interface().(string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Tag", key))
			
		}
	}

}

func (c Tag) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["color"] = c.Color
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Tag) BamlTypeName() string {
    return "Tag"
}

func (u Tag) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Tag",
    }
}

type User struct {
    
Id int64 `json:"id"`
Name string `json:"name"`
Email string `json:"email"`
IsActive bool `json:"isActive"`
    
}

func (c *User) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "User" {
		panic(fmt.Sprintf("expected User, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(string)
				
				case "email":
					c.Email = baml.Decode(valueHolder).Interface().(string)
				
				case "isActive":
					c.IsActive = baml.Decode(valueHolder).Interface().(bool)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class User", key))
			
		}
	}

}

func (c User) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["email"] = c.Email
    
    fields["isActive"] = c.IsActive
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c User) BamlTypeName() string {
    return "User"
}

func (u User) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "User",
    }
}

