// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package types

import (
    "encoding/json"
    "fmt"

    baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
    "github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)


type Admin struct {
    
Id int64 `json:"id"`
Name string `json:"name"`
Permissions []string `json:"permissions"`
Type string `json:"type"`
    
}

func (c *Admin) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Admin" {
		panic(fmt.Sprintf("expected Admin, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(string)
				
				case "permissions":
					c.Permissions = baml.Decode(valueHolder).Interface().([]string)
				
				case "type":
					c.Type = baml.Decode(valueHolder).Interface().(string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Admin", key))
			
		}
	}

}

func (c Admin) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["permissions"] = c.Permissions
    
    fields["type"] = c.Type
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Admin) BamlTypeName() string {
    return "Admin"
}

func (u Admin) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Admin",
    }
}

type ApiError struct {
    
Status string `json:"status"`
Message string `json:"message"`
Code int64 `json:"code"`
    
}

func (c *ApiError) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ApiError" {
		panic(fmt.Sprintf("expected ApiError, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "status":
					c.Status = baml.Decode(valueHolder).Interface().(string)
				
				case "message":
					c.Message = baml.Decode(valueHolder).Interface().(string)
				
				case "code":
					c.Code = baml.Decode(valueHolder).Interface().(int64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ApiError", key))
			
		}
	}

}

func (c ApiError) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["status"] = c.Status
    
    fields["message"] = c.Message
    
    fields["code"] = c.Code
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ApiError) BamlTypeName() string {
    return "ApiError"
}

func (u ApiError) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "ApiError",
    }
}

type ApiPending struct {
    
Status string `json:"status"`
Progress float64 `json:"progress"`
Eta *int64 `json:"eta"`
    
}

func (c *ApiPending) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ApiPending" {
		panic(fmt.Sprintf("expected ApiPending, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "status":
					c.Status = baml.Decode(valueHolder).Interface().(string)
				
				case "progress":
					c.Progress = baml.Decode(valueHolder).Interface().(float64)
				
				case "eta":
					c.Eta = baml.Decode(valueHolder).Interface().(*int64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ApiPending", key))
			
		}
	}

}

func (c ApiPending) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["status"] = c.Status
    
    fields["progress"] = c.Progress
    
    fields["eta"] = c.Eta
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ApiPending) BamlTypeName() string {
    return "ApiPending"
}

func (u ApiPending) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "ApiPending",
    }
}

type ApiSuccess struct {
    
Status string `json:"status"`
Data map[string]string `json:"data"`
    
}

func (c *ApiSuccess) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ApiSuccess" {
		panic(fmt.Sprintf("expected ApiSuccess, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "status":
					c.Status = baml.Decode(valueHolder).Interface().(string)
				
				case "data":
					c.Data = baml.Decode(valueHolder).Interface().(map[string]string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ApiSuccess", key))
			
		}
	}

}

func (c ApiSuccess) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["status"] = c.Status
    
    fields["data"] = c.Data
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ApiSuccess) BamlTypeName() string {
    return "ApiSuccess"
}

func (u ApiSuccess) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "ApiSuccess",
    }
}

type Bird struct {
    
Species string `json:"species"`
CanFly bool `json:"canFly"`
Wingspan *float64 `json:"wingspan"`
    
}

func (c *Bird) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Bird" {
		panic(fmt.Sprintf("expected Bird, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "species":
					c.Species = baml.Decode(valueHolder).Interface().(string)
				
				case "canFly":
					c.CanFly = baml.Decode(valueHolder).Interface().(bool)
				
				case "wingspan":
					c.Wingspan = baml.Decode(valueHolder).Interface().(*float64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Bird", key))
			
		}
	}

}

func (c Bird) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["species"] = c.Species
    
    fields["canFly"] = c.CanFly
    
    fields["wingspan"] = c.Wingspan
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Bird) BamlTypeName() string {
    return "Bird"
}

func (u Bird) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Bird",
    }
}

type Cat struct {
    
Species string `json:"species"`
Color string `json:"color"`
Lives int64 `json:"lives"`
    
}

func (c *Cat) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Cat" {
		panic(fmt.Sprintf("expected Cat, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "species":
					c.Species = baml.Decode(valueHolder).Interface().(string)
				
				case "color":
					c.Color = baml.Decode(valueHolder).Interface().(string)
				
				case "lives":
					c.Lives = baml.Decode(valueHolder).Interface().(int64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Cat", key))
			
		}
	}

}

func (c Cat) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["species"] = c.Species
    
    fields["color"] = c.Color
    
    fields["lives"] = c.Lives
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Cat) BamlTypeName() string {
    return "Cat"
}

func (u Cat) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Cat",
    }
}

type Circle struct {
    
Shape string `json:"shape"`
Radius float64 `json:"radius"`
    
}

func (c *Circle) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Circle" {
		panic(fmt.Sprintf("expected Circle, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "shape":
					c.Shape = baml.Decode(valueHolder).Interface().(string)
				
				case "radius":
					c.Radius = baml.Decode(valueHolder).Interface().(float64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Circle", key))
			
		}
	}

}

func (c Circle) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["shape"] = c.Shape
    
    fields["radius"] = c.Radius
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Circle) BamlTypeName() string {
    return "Circle"
}

func (u Circle) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Circle",
    }
}

type ComplexUnions struct {
    
UserOrProduct Union2ProductOrUser `json:"userOrProduct"`
UserOrProductOrAdmin Union3AdminOrProductOrUser `json:"userOrProductOrAdmin"`
DataOrError Union2DataResponseOrErrorResponse `json:"dataOrError"`
ResultOrNull *Result `json:"resultOrNull"`
MultiTypeResult Union3ErrorOrSuccessOrWarning `json:"multiTypeResult"`
    
}

func (c *ComplexUnions) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ComplexUnions" {
		panic(fmt.Sprintf("expected ComplexUnions, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "userOrProduct":
					c.UserOrProduct = baml.Decode(valueHolder).Interface().(Union2ProductOrUser)
				
				case "userOrProductOrAdmin":
					c.UserOrProductOrAdmin = baml.Decode(valueHolder).Interface().(Union3AdminOrProductOrUser)
				
				case "dataOrError":
					c.DataOrError = baml.Decode(valueHolder).Interface().(Union2DataResponseOrErrorResponse)
				
				case "resultOrNull":
					c.ResultOrNull = baml.Decode(valueHolder).Interface().(*Result)
				
				case "multiTypeResult":
					c.MultiTypeResult = baml.Decode(valueHolder).Interface().(Union3ErrorOrSuccessOrWarning)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ComplexUnions", key))
			
		}
	}

}

func (c ComplexUnions) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["userOrProduct"] = c.UserOrProduct
    
    fields["userOrProductOrAdmin"] = c.UserOrProductOrAdmin
    
    fields["dataOrError"] = c.DataOrError
    
    fields["resultOrNull"] = c.ResultOrNull
    
    fields["multiTypeResult"] = c.MultiTypeResult
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ComplexUnions) BamlTypeName() string {
    return "ComplexUnions"
}

func (u ComplexUnions) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "ComplexUnions",
    }
}

type DataResponse struct {
    
Data string `json:"data"`
Timestamp int64 `json:"timestamp"`
Status string `json:"status"`
    
}

func (c *DataResponse) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "DataResponse" {
		panic(fmt.Sprintf("expected DataResponse, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "data":
					c.Data = baml.Decode(valueHolder).Interface().(string)
				
				case "timestamp":
					c.Timestamp = baml.Decode(valueHolder).Interface().(int64)
				
				case "status":
					c.Status = baml.Decode(valueHolder).Interface().(string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class DataResponse", key))
			
		}
	}

}

func (c DataResponse) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["data"] = c.Data
    
    fields["timestamp"] = c.Timestamp
    
    fields["status"] = c.Status
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c DataResponse) BamlTypeName() string {
    return "DataResponse"
}

func (u DataResponse) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "DataResponse",
    }
}

type DiscriminatedUnions struct {
    
Shape Union3CircleOrRectangleOrTriangle `json:"shape"`
Animal Union3BirdOrCatOrDog `json:"animal"`
Response Union3ApiErrorOrApiPendingOrApiSuccess `json:"response"`
    
}

func (c *DiscriminatedUnions) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "DiscriminatedUnions" {
		panic(fmt.Sprintf("expected DiscriminatedUnions, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "shape":
					c.Shape = baml.Decode(valueHolder).Interface().(Union3CircleOrRectangleOrTriangle)
				
				case "animal":
					c.Animal = baml.Decode(valueHolder).Interface().(Union3BirdOrCatOrDog)
				
				case "response":
					c.Response = baml.Decode(valueHolder).Interface().(Union3ApiErrorOrApiPendingOrApiSuccess)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class DiscriminatedUnions", key))
			
		}
	}

}

func (c DiscriminatedUnions) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["shape"] = c.Shape
    
    fields["animal"] = c.Animal
    
    fields["response"] = c.Response
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c DiscriminatedUnions) BamlTypeName() string {
    return "DiscriminatedUnions"
}

func (u DiscriminatedUnions) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "DiscriminatedUnions",
    }
}

type Dog struct {
    
Species string `json:"species"`
Breed string `json:"breed"`
GoodBoy bool `json:"goodBoy"`
    
}

func (c *Dog) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Dog" {
		panic(fmt.Sprintf("expected Dog, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "species":
					c.Species = baml.Decode(valueHolder).Interface().(string)
				
				case "breed":
					c.Breed = baml.Decode(valueHolder).Interface().(string)
				
				case "goodBoy":
					c.GoodBoy = baml.Decode(valueHolder).Interface().(bool)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Dog", key))
			
		}
	}

}

func (c Dog) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["species"] = c.Species
    
    fields["breed"] = c.Breed
    
    fields["goodBoy"] = c.GoodBoy
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Dog) BamlTypeName() string {
    return "Dog"
}

func (u Dog) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Dog",
    }
}

type Error struct {
    
Type string `json:"type"`
Message string `json:"message"`
Code int64 `json:"code"`
Details *string `json:"details"`
    
}

func (c *Error) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Error" {
		panic(fmt.Sprintf("expected Error, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "type":
					c.Type = baml.Decode(valueHolder).Interface().(string)
				
				case "message":
					c.Message = baml.Decode(valueHolder).Interface().(string)
				
				case "code":
					c.Code = baml.Decode(valueHolder).Interface().(int64)
				
				case "details":
					c.Details = baml.Decode(valueHolder).Interface().(*string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Error", key))
			
		}
	}

}

func (c Error) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["type"] = c.Type
    
    fields["message"] = c.Message
    
    fields["code"] = c.Code
    
    fields["details"] = c.Details
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Error) BamlTypeName() string {
    return "Error"
}

func (u Error) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Error",
    }
}

type ErrorResponse struct {
    
Error string `json:"error"`
Code int64 `json:"code"`
Status string `json:"status"`
    
}

func (c *ErrorResponse) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ErrorResponse" {
		panic(fmt.Sprintf("expected ErrorResponse, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "error":
					c.Error = baml.Decode(valueHolder).Interface().(string)
				
				case "code":
					c.Code = baml.Decode(valueHolder).Interface().(int64)
				
				case "status":
					c.Status = baml.Decode(valueHolder).Interface().(string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ErrorResponse", key))
			
		}
	}

}

func (c ErrorResponse) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["error"] = c.Error
    
    fields["code"] = c.Code
    
    fields["status"] = c.Status
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ErrorResponse) BamlTypeName() string {
    return "ErrorResponse"
}

func (u ErrorResponse) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "ErrorResponse",
    }
}

type PrimitiveUnions struct {
    
StringOrInt Union2IntOrString `json:"stringOrInt"`
StringOrFloat Union2FloatOrString `json:"stringOrFloat"`
IntOrFloat Union2FloatOrInt `json:"intOrFloat"`
BoolOrString Union2BoolOrString `json:"boolOrString"`
AnyPrimitive Union4BoolOrFloatOrIntOrString `json:"anyPrimitive"`
    
}

func (c *PrimitiveUnions) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "PrimitiveUnions" {
		panic(fmt.Sprintf("expected PrimitiveUnions, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "stringOrInt":
					c.StringOrInt = baml.Decode(valueHolder).Interface().(Union2IntOrString)
				
				case "stringOrFloat":
					c.StringOrFloat = baml.Decode(valueHolder).Interface().(Union2FloatOrString)
				
				case "intOrFloat":
					c.IntOrFloat = baml.Decode(valueHolder).Interface().(Union2FloatOrInt)
				
				case "boolOrString":
					c.BoolOrString = baml.Decode(valueHolder).Interface().(Union2BoolOrString)
				
				case "anyPrimitive":
					c.AnyPrimitive = baml.Decode(valueHolder).Interface().(Union4BoolOrFloatOrIntOrString)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class PrimitiveUnions", key))
			
		}
	}

}

func (c PrimitiveUnions) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["stringOrInt"] = c.StringOrInt
    
    fields["stringOrFloat"] = c.StringOrFloat
    
    fields["intOrFloat"] = c.IntOrFloat
    
    fields["boolOrString"] = c.BoolOrString
    
    fields["anyPrimitive"] = c.AnyPrimitive
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c PrimitiveUnions) BamlTypeName() string {
    return "PrimitiveUnions"
}

func (u PrimitiveUnions) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "PrimitiveUnions",
    }
}

type Product struct {
    
Id int64 `json:"id"`
Name string `json:"name"`
Price float64 `json:"price"`
Type string `json:"type"`
    
}

func (c *Product) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Product" {
		panic(fmt.Sprintf("expected Product, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(string)
				
				case "price":
					c.Price = baml.Decode(valueHolder).Interface().(float64)
				
				case "type":
					c.Type = baml.Decode(valueHolder).Interface().(string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Product", key))
			
		}
	}

}

func (c Product) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["price"] = c.Price
    
    fields["type"] = c.Type
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Product) BamlTypeName() string {
    return "Product"
}

func (u Product) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Product",
    }
}

type Rectangle struct {
    
Shape string `json:"shape"`
Width float64 `json:"width"`
Height float64 `json:"height"`
    
}

func (c *Rectangle) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Rectangle" {
		panic(fmt.Sprintf("expected Rectangle, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "shape":
					c.Shape = baml.Decode(valueHolder).Interface().(string)
				
				case "width":
					c.Width = baml.Decode(valueHolder).Interface().(float64)
				
				case "height":
					c.Height = baml.Decode(valueHolder).Interface().(float64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Rectangle", key))
			
		}
	}

}

func (c Rectangle) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["shape"] = c.Shape
    
    fields["width"] = c.Width
    
    fields["height"] = c.Height
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Rectangle) BamlTypeName() string {
    return "Rectangle"
}

func (u Rectangle) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Rectangle",
    }
}

type RecursiveUnion struct {
    
Value Union3IntOrRecursiveUnionOrString `json:"value"`
Children []Union2RecursiveUnionOrString `json:"children"`
    
}

func (c *RecursiveUnion) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "RecursiveUnion" {
		panic(fmt.Sprintf("expected RecursiveUnion, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "value":
					c.Value = baml.Decode(valueHolder).Interface().(Union3IntOrRecursiveUnionOrString)
				
				case "children":
					c.Children = baml.Decode(valueHolder).Interface().([]Union2RecursiveUnionOrString)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class RecursiveUnion", key))
			
		}
	}

}

func (c RecursiveUnion) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["value"] = c.Value
    
    fields["children"] = c.Children
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c RecursiveUnion) BamlTypeName() string {
    return "RecursiveUnion"
}

func (u RecursiveUnion) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "RecursiveUnion",
    }
}

type Result struct {
    
Value Union3FloatOrIntOrString `json:"value"`
Metadata map[string]string `json:"metadata"`
    
}

func (c *Result) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Result" {
		panic(fmt.Sprintf("expected Result, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "value":
					c.Value = baml.Decode(valueHolder).Interface().(Union3FloatOrIntOrString)
				
				case "metadata":
					c.Metadata = baml.Decode(valueHolder).Interface().(map[string]string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Result", key))
			
		}
	}

}

func (c Result) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["value"] = c.Value
    
    fields["metadata"] = c.Metadata
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Result) BamlTypeName() string {
    return "Result"
}

func (u Result) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Result",
    }
}

type Success struct {
    
Type string `json:"type"`
Message string `json:"message"`
Data map[string]string `json:"data"`
    
}

func (c *Success) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Success" {
		panic(fmt.Sprintf("expected Success, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "type":
					c.Type = baml.Decode(valueHolder).Interface().(string)
				
				case "message":
					c.Message = baml.Decode(valueHolder).Interface().(string)
				
				case "data":
					c.Data = baml.Decode(valueHolder).Interface().(map[string]string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Success", key))
			
		}
	}

}

func (c Success) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["type"] = c.Type
    
    fields["message"] = c.Message
    
    fields["data"] = c.Data
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Success) BamlTypeName() string {
    return "Success"
}

func (u Success) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Success",
    }
}

type Triangle struct {
    
Shape string `json:"shape"`
Base float64 `json:"base"`
Height float64 `json:"height"`
    
}

func (c *Triangle) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Triangle" {
		panic(fmt.Sprintf("expected Triangle, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "shape":
					c.Shape = baml.Decode(valueHolder).Interface().(string)
				
				case "base":
					c.Base = baml.Decode(valueHolder).Interface().(float64)
				
				case "height":
					c.Height = baml.Decode(valueHolder).Interface().(float64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Triangle", key))
			
		}
	}

}

func (c Triangle) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["shape"] = c.Shape
    
    fields["base"] = c.Base
    
    fields["height"] = c.Height
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Triangle) BamlTypeName() string {
    return "Triangle"
}

func (u Triangle) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Triangle",
    }
}

type UnionArrays struct {
    
MixedArray []Union2IntOrString `json:"mixedArray"`
NullableItems []*string `json:"nullableItems"`
ObjectArray []Union2ProductOrUser `json:"objectArray"`
NestedUnionArray []Union2ListIntOrString `json:"nestedUnionArray"`
    
}

func (c *UnionArrays) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "UnionArrays" {
		panic(fmt.Sprintf("expected UnionArrays, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "mixedArray":
					c.MixedArray = baml.Decode(valueHolder).Interface().([]Union2IntOrString)
				
				case "nullableItems":
					c.NullableItems = baml.Decode(valueHolder).Interface().([]*string)
				
				case "objectArray":
					c.ObjectArray = baml.Decode(valueHolder).Interface().([]Union2ProductOrUser)
				
				case "nestedUnionArray":
					c.NestedUnionArray = baml.Decode(valueHolder).Interface().([]Union2ListIntOrString)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class UnionArrays", key))
			
		}
	}

}

func (c UnionArrays) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["mixedArray"] = c.MixedArray
    
    fields["nullableItems"] = c.NullableItems
    
    fields["objectArray"] = c.ObjectArray
    
    fields["nestedUnionArray"] = c.NestedUnionArray
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c UnionArrays) BamlTypeName() string {
    return "UnionArrays"
}

func (u UnionArrays) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "UnionArrays",
    }
}

type User struct {
    
Id int64 `json:"id"`
Name string `json:"name"`
Type string `json:"type"`
    
}

func (c *User) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "User" {
		panic(fmt.Sprintf("expected User, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(string)
				
				case "type":
					c.Type = baml.Decode(valueHolder).Interface().(string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class User", key))
			
		}
	}

}

func (c User) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["type"] = c.Type
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c User) BamlTypeName() string {
    return "User"
}

func (u User) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "User",
    }
}

type Warning struct {
    
Type string `json:"type"`
Message string `json:"message"`
Level int64 `json:"level"`
    
}

func (c *Warning) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Warning" {
		panic(fmt.Sprintf("expected Warning, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "type":
					c.Type = baml.Decode(valueHolder).Interface().(string)
				
				case "message":
					c.Message = baml.Decode(valueHolder).Interface().(string)
				
				case "level":
					c.Level = baml.Decode(valueHolder).Interface().(int64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Warning", key))
			
		}
	}

}

func (c Warning) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["type"] = c.Type
    
    fields["message"] = c.Message
    
    fields["level"] = c.Level
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Warning) BamlTypeName() string {
    return "Warning"
}

func (u Warning) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_TYPES,
        Name:      "Warning",
    }
}

