// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package stream_types

import (
    "encoding/json"
    "fmt"

    baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
    "github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"

    "nested_structures/baml_client/types"
)


type Address struct {
    
Street *string `json:"street"`
City *string `json:"city"`
State *string `json:"state"`
Country *string `json:"country"`
PostalCode *string `json:"postalCode"`
Coordinates *Coordinates `json:"coordinates"`
    
}

func (c *Address) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Address" {
		panic(fmt.Sprintf("expected Address, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "street":
					c.Street = baml.Decode(valueHolder).Interface().(*string)
				
				case "city":
					c.City = baml.Decode(valueHolder).Interface().(*string)
				
				case "state":
					c.State = baml.Decode(valueHolder).Interface().(*string)
				
				case "country":
					c.Country = baml.Decode(valueHolder).Interface().(*string)
				
				case "postalCode":
					c.PostalCode = baml.Decode(valueHolder).Interface().(*string)
				
				case "coordinates":
					c.Coordinates = baml.Decode(valueHolder).Interface().(*Coordinates)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Address", key))
			
		}
	}

}

func (c Address) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["street"] = c.Street
    
    fields["city"] = c.City
    
    fields["state"] = c.State
    
    fields["country"] = c.Country
    
    fields["postalCode"] = c.PostalCode
    
    fields["coordinates"] = c.Coordinates
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Address) BamlTypeName() string {
    return "Address"
}

func (u Address) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Address",
    }
}
type Approval struct {
    
Approver *string `json:"approver"`
Date *string `json:"date"`
Amount *float64 `json:"amount"`
Notes *string `json:"notes"`
    
}

func (c *Approval) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Approval" {
		panic(fmt.Sprintf("expected Approval, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "approver":
					c.Approver = baml.Decode(valueHolder).Interface().(*string)
				
				case "date":
					c.Date = baml.Decode(valueHolder).Interface().(*string)
				
				case "amount":
					c.Amount = baml.Decode(valueHolder).Interface().(*float64)
				
				case "notes":
					c.Notes = baml.Decode(valueHolder).Interface().(*string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Approval", key))
			
		}
	}

}

func (c Approval) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["approver"] = c.Approver
    
    fields["date"] = c.Date
    
    fields["amount"] = c.Amount
    
    fields["notes"] = c.Notes
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Approval) BamlTypeName() string {
    return "Approval"
}

func (u Approval) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Approval",
    }
}
type Budget struct {
    
Total *float64 `json:"total"`
Spent *float64 `json:"spent"`
Categories map[string]float64 `json:"categories"`
Approvals []Approval `json:"approvals"`
    
}

func (c *Budget) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Budget" {
		panic(fmt.Sprintf("expected Budget, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "total":
					c.Total = baml.Decode(valueHolder).Interface().(*float64)
				
				case "spent":
					c.Spent = baml.Decode(valueHolder).Interface().(*float64)
				
				case "categories":
					c.Categories = baml.Decode(valueHolder).Interface().(map[string]float64)
				
				case "approvals":
					c.Approvals = baml.Decode(valueHolder).Interface().([]Approval)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Budget", key))
			
		}
	}

}

func (c Budget) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["total"] = c.Total
    
    fields["spent"] = c.Spent
    
    fields["categories"] = c.Categories
    
    fields["approvals"] = c.Approvals
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Budget) BamlTypeName() string {
    return "Budget"
}

func (u Budget) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Budget",
    }
}
type Company struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
Address *Address `json:"address"`
Departments []Department `json:"departments"`
Metadata *CompanyMetadata `json:"metadata"`
    
}

func (c *Company) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Company" {
		panic(fmt.Sprintf("expected Company, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "address":
					c.Address = baml.Decode(valueHolder).Interface().(*Address)
				
				case "departments":
					c.Departments = baml.Decode(valueHolder).Interface().([]Department)
				
				case "metadata":
					c.Metadata = baml.Decode(valueHolder).Interface().(*CompanyMetadata)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Company", key))
			
		}
	}

}

func (c Company) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["address"] = c.Address
    
    fields["departments"] = c.Departments
    
    fields["metadata"] = c.Metadata
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Company) BamlTypeName() string {
    return "Company"
}

func (u Company) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Company",
    }
}
type CompanyMetadata struct {
    
Founded *string `json:"founded"`
Industry *string `json:"industry"`
Size *types.Union4KenterpriseOrKlargeOrKmediumOrKsmall `json:"size"`
Certifications []string `json:"certifications"`
Partnerships *[]Company `json:"partnerships"`
    
}

func (c *CompanyMetadata) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "CompanyMetadata" {
		panic(fmt.Sprintf("expected CompanyMetadata, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "founded":
					c.Founded = baml.Decode(valueHolder).Interface().(*string)
				
				case "industry":
					c.Industry = baml.Decode(valueHolder).Interface().(*string)
				
				case "size":
					c.Size = baml.Decode(valueHolder).Interface().(*types.Union4KenterpriseOrKlargeOrKmediumOrKsmall)
				
				case "certifications":
					c.Certifications = baml.Decode(valueHolder).Interface().([]string)
				
				case "partnerships":
					c.Partnerships = baml.Decode(valueHolder).Interface().(*[]Company)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class CompanyMetadata", key))
			
		}
	}

}

func (c CompanyMetadata) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["founded"] = c.Founded
    
    fields["industry"] = c.Industry
    
    fields["size"] = c.Size
    
    fields["certifications"] = c.Certifications
    
    fields["partnerships"] = c.Partnerships
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c CompanyMetadata) BamlTypeName() string {
    return "CompanyMetadata"
}

func (u CompanyMetadata) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "CompanyMetadata",
    }
}
type ComplexNested struct {
    
Company *Company `json:"company"`
Employees []Employee `json:"employees"`
Projects []Project `json:"projects"`
    
}

func (c *ComplexNested) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ComplexNested" {
		panic(fmt.Sprintf("expected ComplexNested, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "company":
					c.Company = baml.Decode(valueHolder).Interface().(*Company)
				
				case "employees":
					c.Employees = baml.Decode(valueHolder).Interface().([]Employee)
				
				case "projects":
					c.Projects = baml.Decode(valueHolder).Interface().([]Project)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ComplexNested", key))
			
		}
	}

}

func (c ComplexNested) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["company"] = c.Company
    
    fields["employees"] = c.Employees
    
    fields["projects"] = c.Projects
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ComplexNested) BamlTypeName() string {
    return "ComplexNested"
}

func (u ComplexNested) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "ComplexNested",
    }
}
type Contact struct {
    
Name *string `json:"name"`
Relationship *string `json:"relationship"`
Phone *string `json:"phone"`
Email *string `json:"email"`
    
}

func (c *Contact) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Contact" {
		panic(fmt.Sprintf("expected Contact, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "relationship":
					c.Relationship = baml.Decode(valueHolder).Interface().(*string)
				
				case "phone":
					c.Phone = baml.Decode(valueHolder).Interface().(*string)
				
				case "email":
					c.Email = baml.Decode(valueHolder).Interface().(*string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Contact", key))
			
		}
	}

}

func (c Contact) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["name"] = c.Name
    
    fields["relationship"] = c.Relationship
    
    fields["phone"] = c.Phone
    
    fields["email"] = c.Email
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Contact) BamlTypeName() string {
    return "Contact"
}

func (u Contact) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Contact",
    }
}
type Coordinates struct {
    
Latitude *float64 `json:"latitude"`
Longitude *float64 `json:"longitude"`
    
}

func (c *Coordinates) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Coordinates" {
		panic(fmt.Sprintf("expected Coordinates, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "latitude":
					c.Latitude = baml.Decode(valueHolder).Interface().(*float64)
				
				case "longitude":
					c.Longitude = baml.Decode(valueHolder).Interface().(*float64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Coordinates", key))
			
		}
	}

}

func (c Coordinates) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["latitude"] = c.Latitude
    
    fields["longitude"] = c.Longitude
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Coordinates) BamlTypeName() string {
    return "Coordinates"
}

func (u Coordinates) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Coordinates",
    }
}
type DeeplyNested struct {
    
Level1 *Level1 `json:"level1"`
    
}

func (c *DeeplyNested) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "DeeplyNested" {
		panic(fmt.Sprintf("expected DeeplyNested, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "level1":
					c.Level1 = baml.Decode(valueHolder).Interface().(*Level1)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class DeeplyNested", key))
			
		}
	}

}

func (c DeeplyNested) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["level1"] = c.Level1
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c DeeplyNested) BamlTypeName() string {
    return "DeeplyNested"
}

func (u DeeplyNested) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "DeeplyNested",
    }
}
type Department struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
Manager *Employee `json:"manager"`
Members []Employee `json:"members"`
Budget *float64 `json:"budget"`
Projects []Project `json:"projects"`
    
}

func (c *Department) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Department" {
		panic(fmt.Sprintf("expected Department, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "manager":
					c.Manager = baml.Decode(valueHolder).Interface().(*Employee)
				
				case "members":
					c.Members = baml.Decode(valueHolder).Interface().([]Employee)
				
				case "budget":
					c.Budget = baml.Decode(valueHolder).Interface().(*float64)
				
				case "projects":
					c.Projects = baml.Decode(valueHolder).Interface().([]Project)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Department", key))
			
		}
	}

}

func (c Department) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["manager"] = c.Manager
    
    fields["members"] = c.Members
    
    fields["budget"] = c.Budget
    
    fields["projects"] = c.Projects
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Department) BamlTypeName() string {
    return "Department"
}

func (u Department) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Department",
    }
}
type DisplaySettings struct {
    
FontSize *int64 `json:"fontSize"`
ColorScheme *string `json:"colorScheme"`
Layout *types.Union2KgridOrKlist `json:"layout"`
    
}

func (c *DisplaySettings) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "DisplaySettings" {
		panic(fmt.Sprintf("expected DisplaySettings, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "fontSize":
					c.FontSize = baml.Decode(valueHolder).Interface().(*int64)
				
				case "colorScheme":
					c.ColorScheme = baml.Decode(valueHolder).Interface().(*string)
				
				case "layout":
					c.Layout = baml.Decode(valueHolder).Interface().(*types.Union2KgridOrKlist)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class DisplaySettings", key))
			
		}
	}

}

func (c DisplaySettings) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["fontSize"] = c.FontSize
    
    fields["colorScheme"] = c.ColorScheme
    
    fields["layout"] = c.Layout
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c DisplaySettings) BamlTypeName() string {
    return "DisplaySettings"
}

func (u DisplaySettings) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "DisplaySettings",
    }
}
type Employee struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
Email *string `json:"email"`
Role *string `json:"role"`
Department *string `json:"department"`
Skills []string `json:"skills"`
Address *Address `json:"address"`
EmergencyContact *Contact `json:"emergencyContact"`
    
}

func (c *Employee) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Employee" {
		panic(fmt.Sprintf("expected Employee, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "email":
					c.Email = baml.Decode(valueHolder).Interface().(*string)
				
				case "role":
					c.Role = baml.Decode(valueHolder).Interface().(*string)
				
				case "department":
					c.Department = baml.Decode(valueHolder).Interface().(*string)
				
				case "skills":
					c.Skills = baml.Decode(valueHolder).Interface().([]string)
				
				case "address":
					c.Address = baml.Decode(valueHolder).Interface().(*Address)
				
				case "emergencyContact":
					c.EmergencyContact = baml.Decode(valueHolder).Interface().(*Contact)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Employee", key))
			
		}
	}

}

func (c Employee) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["email"] = c.Email
    
    fields["role"] = c.Role
    
    fields["department"] = c.Department
    
    fields["skills"] = c.Skills
    
    fields["address"] = c.Address
    
    fields["emergencyContact"] = c.EmergencyContact
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Employee) BamlTypeName() string {
    return "Employee"
}

func (u Employee) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Employee",
    }
}
type Level1 struct {
    
Data *string `json:"data"`
Level2 *Level2 `json:"level2"`
    
}

func (c *Level1) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Level1" {
		panic(fmt.Sprintf("expected Level1, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "data":
					c.Data = baml.Decode(valueHolder).Interface().(*string)
				
				case "level2":
					c.Level2 = baml.Decode(valueHolder).Interface().(*Level2)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Level1", key))
			
		}
	}

}

func (c Level1) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["data"] = c.Data
    
    fields["level2"] = c.Level2
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Level1) BamlTypeName() string {
    return "Level1"
}

func (u Level1) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Level1",
    }
}
type Level2 struct {
    
Data *string `json:"data"`
Level3 *Level3 `json:"level3"`
    
}

func (c *Level2) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Level2" {
		panic(fmt.Sprintf("expected Level2, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "data":
					c.Data = baml.Decode(valueHolder).Interface().(*string)
				
				case "level3":
					c.Level3 = baml.Decode(valueHolder).Interface().(*Level3)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Level2", key))
			
		}
	}

}

func (c Level2) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["data"] = c.Data
    
    fields["level3"] = c.Level3
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Level2) BamlTypeName() string {
    return "Level2"
}

func (u Level2) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Level2",
    }
}
type Level3 struct {
    
Data *string `json:"data"`
Level4 *Level4 `json:"level4"`
    
}

func (c *Level3) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Level3" {
		panic(fmt.Sprintf("expected Level3, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "data":
					c.Data = baml.Decode(valueHolder).Interface().(*string)
				
				case "level4":
					c.Level4 = baml.Decode(valueHolder).Interface().(*Level4)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Level3", key))
			
		}
	}

}

func (c Level3) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["data"] = c.Data
    
    fields["level4"] = c.Level4
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Level3) BamlTypeName() string {
    return "Level3"
}

func (u Level3) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Level3",
    }
}
type Level4 struct {
    
Data *string `json:"data"`
Level5 *Level5 `json:"level5"`
    
}

func (c *Level4) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Level4" {
		panic(fmt.Sprintf("expected Level4, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "data":
					c.Data = baml.Decode(valueHolder).Interface().(*string)
				
				case "level5":
					c.Level5 = baml.Decode(valueHolder).Interface().(*Level5)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Level4", key))
			
		}
	}

}

func (c Level4) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["data"] = c.Data
    
    fields["level5"] = c.Level5
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Level4) BamlTypeName() string {
    return "Level4"
}

func (u Level4) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Level4",
    }
}
type Level5 struct {
    
Data *string `json:"data"`
Items []string `json:"items"`
Mapping map[string]int64 `json:"mapping"`
    
}

func (c *Level5) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Level5" {
		panic(fmt.Sprintf("expected Level5, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "data":
					c.Data = baml.Decode(valueHolder).Interface().(*string)
				
				case "items":
					c.Items = baml.Decode(valueHolder).Interface().([]string)
				
				case "mapping":
					c.Mapping = baml.Decode(valueHolder).Interface().(map[string]int64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Level5", key))
			
		}
	}

}

func (c Level5) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["data"] = c.Data
    
    fields["items"] = c.Items
    
    fields["mapping"] = c.Mapping
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Level5) BamlTypeName() string {
    return "Level5"
}

func (u Level5) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Level5",
    }
}
type Metadata struct {
    
CreatedAt *string `json:"createdAt"`
UpdatedAt *string `json:"updatedAt"`
Version *int64 `json:"version"`
Tags []string `json:"tags"`
Attributes map[string]string `json:"attributes"`
    
}

func (c *Metadata) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Metadata" {
		panic(fmt.Sprintf("expected Metadata, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "createdAt":
					c.CreatedAt = baml.Decode(valueHolder).Interface().(*string)
				
				case "updatedAt":
					c.UpdatedAt = baml.Decode(valueHolder).Interface().(*string)
				
				case "version":
					c.Version = baml.Decode(valueHolder).Interface().(*int64)
				
				case "tags":
					c.Tags = baml.Decode(valueHolder).Interface().([]string)
				
				case "attributes":
					c.Attributes = baml.Decode(valueHolder).Interface().(map[string]string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Metadata", key))
			
		}
	}

}

func (c Metadata) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["createdAt"] = c.CreatedAt
    
    fields["updatedAt"] = c.UpdatedAt
    
    fields["version"] = c.Version
    
    fields["tags"] = c.Tags
    
    fields["attributes"] = c.Attributes
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Metadata) BamlTypeName() string {
    return "Metadata"
}

func (u Metadata) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Metadata",
    }
}
type Milestone struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
DueDate *string `json:"dueDate"`
Completed *bool `json:"completed"`
Tasks []Task `json:"tasks"`
    
}

func (c *Milestone) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Milestone" {
		panic(fmt.Sprintf("expected Milestone, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "dueDate":
					c.DueDate = baml.Decode(valueHolder).Interface().(*string)
				
				case "completed":
					c.Completed = baml.Decode(valueHolder).Interface().(*bool)
				
				case "tasks":
					c.Tasks = baml.Decode(valueHolder).Interface().([]Task)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Milestone", key))
			
		}
	}

}

func (c Milestone) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["dueDate"] = c.DueDate
    
    fields["completed"] = c.Completed
    
    fields["tasks"] = c.Tasks
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Milestone) BamlTypeName() string {
    return "Milestone"
}

func (u Milestone) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Milestone",
    }
}
type NotificationSettings struct {
    
Email *bool `json:"email"`
Push *bool `json:"push"`
Sms *bool `json:"sms"`
Frequency *types.Union3KdailyOrKimmediateOrKweekly `json:"frequency"`
    
}

func (c *NotificationSettings) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "NotificationSettings" {
		panic(fmt.Sprintf("expected NotificationSettings, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "email":
					c.Email = baml.Decode(valueHolder).Interface().(*bool)
				
				case "push":
					c.Push = baml.Decode(valueHolder).Interface().(*bool)
				
				case "sms":
					c.Sms = baml.Decode(valueHolder).Interface().(*bool)
				
				case "frequency":
					c.Frequency = baml.Decode(valueHolder).Interface().(*types.Union3KdailyOrKimmediateOrKweekly)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class NotificationSettings", key))
			
		}
	}

}

func (c NotificationSettings) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["email"] = c.Email
    
    fields["push"] = c.Push
    
    fields["sms"] = c.Sms
    
    fields["frequency"] = c.Frequency
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c NotificationSettings) BamlTypeName() string {
    return "NotificationSettings"
}

func (u NotificationSettings) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "NotificationSettings",
    }
}
type Preferences struct {
    
Theme *types.Union2KdarkOrKlight `json:"theme"`
Language *string `json:"language"`
Notifications *NotificationSettings `json:"notifications"`
    
}

func (c *Preferences) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Preferences" {
		panic(fmt.Sprintf("expected Preferences, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "theme":
					c.Theme = baml.Decode(valueHolder).Interface().(*types.Union2KdarkOrKlight)
				
				case "language":
					c.Language = baml.Decode(valueHolder).Interface().(*string)
				
				case "notifications":
					c.Notifications = baml.Decode(valueHolder).Interface().(*NotificationSettings)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Preferences", key))
			
		}
	}

}

func (c Preferences) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["theme"] = c.Theme
    
    fields["language"] = c.Language
    
    fields["notifications"] = c.Notifications
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Preferences) BamlTypeName() string {
    return "Preferences"
}

func (u Preferences) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Preferences",
    }
}
type PrivacySettings struct {
    
ProfileVisibility *types.Union3KfriendsOrKprivateOrKpublic `json:"profileVisibility"`
ShowEmail *bool `json:"showEmail"`
ShowPhone *bool `json:"showPhone"`
    
}

func (c *PrivacySettings) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "PrivacySettings" {
		panic(fmt.Sprintf("expected PrivacySettings, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "profileVisibility":
					c.ProfileVisibility = baml.Decode(valueHolder).Interface().(*types.Union3KfriendsOrKprivateOrKpublic)
				
				case "showEmail":
					c.ShowEmail = baml.Decode(valueHolder).Interface().(*bool)
				
				case "showPhone":
					c.ShowPhone = baml.Decode(valueHolder).Interface().(*bool)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class PrivacySettings", key))
			
		}
	}

}

func (c PrivacySettings) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["profileVisibility"] = c.ProfileVisibility
    
    fields["showEmail"] = c.ShowEmail
    
    fields["showPhone"] = c.ShowPhone
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c PrivacySettings) BamlTypeName() string {
    return "PrivacySettings"
}

func (u PrivacySettings) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "PrivacySettings",
    }
}
type Profile struct {
    
Bio *string `json:"bio"`
Avatar *string `json:"avatar"`
Social *SocialLinks `json:"social"`
Preferences *Preferences `json:"preferences"`
    
}

func (c *Profile) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Profile" {
		panic(fmt.Sprintf("expected Profile, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "bio":
					c.Bio = baml.Decode(valueHolder).Interface().(*string)
				
				case "avatar":
					c.Avatar = baml.Decode(valueHolder).Interface().(*string)
				
				case "social":
					c.Social = baml.Decode(valueHolder).Interface().(*SocialLinks)
				
				case "preferences":
					c.Preferences = baml.Decode(valueHolder).Interface().(*Preferences)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Profile", key))
			
		}
	}

}

func (c Profile) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["bio"] = c.Bio
    
    fields["avatar"] = c.Avatar
    
    fields["social"] = c.Social
    
    fields["preferences"] = c.Preferences
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Profile) BamlTypeName() string {
    return "Profile"
}

func (u Profile) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Profile",
    }
}
type Project struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
Description *string `json:"description"`
Status *types.Union4KactiveOrKcancelledOrKcompletedOrKplanning `json:"status"`
Team []Employee `json:"team"`
Milestones []Milestone `json:"milestones"`
Budget *Budget `json:"budget"`
    
}

func (c *Project) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Project" {
		panic(fmt.Sprintf("expected Project, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "description":
					c.Description = baml.Decode(valueHolder).Interface().(*string)
				
				case "status":
					c.Status = baml.Decode(valueHolder).Interface().(*types.Union4KactiveOrKcancelledOrKcompletedOrKplanning)
				
				case "team":
					c.Team = baml.Decode(valueHolder).Interface().([]Employee)
				
				case "milestones":
					c.Milestones = baml.Decode(valueHolder).Interface().([]Milestone)
				
				case "budget":
					c.Budget = baml.Decode(valueHolder).Interface().(*Budget)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Project", key))
			
		}
	}

}

func (c Project) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["description"] = c.Description
    
    fields["status"] = c.Status
    
    fields["team"] = c.Team
    
    fields["milestones"] = c.Milestones
    
    fields["budget"] = c.Budget
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Project) BamlTypeName() string {
    return "Project"
}

func (u Project) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Project",
    }
}
type RecursiveStructure struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
Children []RecursiveStructure `json:"children"`
Parent *RecursiveStructure `json:"parent"`
Metadata map[string]types.Union3BoolOrIntOrString `json:"metadata"`
    
}

func (c *RecursiveStructure) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "RecursiveStructure" {
		panic(fmt.Sprintf("expected RecursiveStructure, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "children":
					c.Children = baml.Decode(valueHolder).Interface().([]RecursiveStructure)
				
				case "parent":
					c.Parent = baml.Decode(valueHolder).Interface().(*RecursiveStructure)
				
				case "metadata":
					c.Metadata = baml.Decode(valueHolder).Interface().(map[string]types.Union3BoolOrIntOrString)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class RecursiveStructure", key))
			
		}
	}

}

func (c RecursiveStructure) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["children"] = c.Children
    
    fields["parent"] = c.Parent
    
    fields["metadata"] = c.Metadata
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c RecursiveStructure) BamlTypeName() string {
    return "RecursiveStructure"
}

func (u RecursiveStructure) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "RecursiveStructure",
    }
}
type SimpleNested struct {
    
User *User `json:"user"`
Address *Address `json:"address"`
Metadata *Metadata `json:"metadata"`
    
}

func (c *SimpleNested) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "SimpleNested" {
		panic(fmt.Sprintf("expected SimpleNested, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "user":
					c.User = baml.Decode(valueHolder).Interface().(*User)
				
				case "address":
					c.Address = baml.Decode(valueHolder).Interface().(*Address)
				
				case "metadata":
					c.Metadata = baml.Decode(valueHolder).Interface().(*Metadata)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class SimpleNested", key))
			
		}
	}

}

func (c SimpleNested) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["user"] = c.User
    
    fields["address"] = c.Address
    
    fields["metadata"] = c.Metadata
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c SimpleNested) BamlTypeName() string {
    return "SimpleNested"
}

func (u SimpleNested) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "SimpleNested",
    }
}
type SocialLinks struct {
    
Twitter *string `json:"twitter"`
Github *string `json:"github"`
Linkedin *string `json:"linkedin"`
Website *string `json:"website"`
    
}

func (c *SocialLinks) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "SocialLinks" {
		panic(fmt.Sprintf("expected SocialLinks, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "twitter":
					c.Twitter = baml.Decode(valueHolder).Interface().(*string)
				
				case "github":
					c.Github = baml.Decode(valueHolder).Interface().(*string)
				
				case "linkedin":
					c.Linkedin = baml.Decode(valueHolder).Interface().(*string)
				
				case "website":
					c.Website = baml.Decode(valueHolder).Interface().(*string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class SocialLinks", key))
			
		}
	}

}

func (c SocialLinks) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["twitter"] = c.Twitter
    
    fields["github"] = c.Github
    
    fields["linkedin"] = c.Linkedin
    
    fields["website"] = c.Website
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c SocialLinks) BamlTypeName() string {
    return "SocialLinks"
}

func (u SocialLinks) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "SocialLinks",
    }
}
type Task struct {
    
Id *int64 `json:"id"`
Title *string `json:"title"`
Description *string `json:"description"`
Assignee *string `json:"assignee"`
Priority *types.Union3KhighOrKlowOrKmedium `json:"priority"`
Status *types.Union3KdoneOrKin_progressOrKtodo `json:"status"`
Subtasks *[]Task `json:"subtasks"`
    
}

func (c *Task) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Task" {
		panic(fmt.Sprintf("expected Task, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "title":
					c.Title = baml.Decode(valueHolder).Interface().(*string)
				
				case "description":
					c.Description = baml.Decode(valueHolder).Interface().(*string)
				
				case "assignee":
					c.Assignee = baml.Decode(valueHolder).Interface().(*string)
				
				case "priority":
					c.Priority = baml.Decode(valueHolder).Interface().(*types.Union3KhighOrKlowOrKmedium)
				
				case "status":
					c.Status = baml.Decode(valueHolder).Interface().(*types.Union3KdoneOrKin_progressOrKtodo)
				
				case "subtasks":
					c.Subtasks = baml.Decode(valueHolder).Interface().(*[]Task)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Task", key))
			
		}
	}

}

func (c Task) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["title"] = c.Title
    
    fields["description"] = c.Description
    
    fields["assignee"] = c.Assignee
    
    fields["priority"] = c.Priority
    
    fields["status"] = c.Status
    
    fields["subtasks"] = c.Subtasks
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Task) BamlTypeName() string {
    return "Task"
}

func (u Task) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Task",
    }
}
type User struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
Profile *Profile `json:"profile"`
Settings *UserSettings `json:"settings"`
    
}

func (c *User) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "User" {
		panic(fmt.Sprintf("expected User, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "profile":
					c.Profile = baml.Decode(valueHolder).Interface().(*Profile)
				
				case "settings":
					c.Settings = baml.Decode(valueHolder).Interface().(*UserSettings)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class User", key))
			
		}
	}

}

func (c User) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["profile"] = c.Profile
    
    fields["settings"] = c.Settings
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c User) BamlTypeName() string {
    return "User"
}

func (u User) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "User",
    }
}
type UserSettings struct {
    
Privacy *PrivacySettings `json:"privacy"`
Display *DisplaySettings `json:"display"`
Advanced map[string]string `json:"advanced"`
    
}

func (c *UserSettings) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "UserSettings" {
		panic(fmt.Sprintf("expected UserSettings, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "privacy":
					c.Privacy = baml.Decode(valueHolder).Interface().(*PrivacySettings)
				
				case "display":
					c.Display = baml.Decode(valueHolder).Interface().(*DisplaySettings)
				
				case "advanced":
					c.Advanced = baml.Decode(valueHolder).Interface().(map[string]string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class UserSettings", key))
			
		}
	}

}

func (c UserSettings) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["privacy"] = c.Privacy
    
    fields["display"] = c.Display
    
    fields["advanced"] = c.Advanced
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c UserSettings) BamlTypeName() string {
    return "UserSettings"
}

func (u UserSettings) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "UserSettings",
    }
}