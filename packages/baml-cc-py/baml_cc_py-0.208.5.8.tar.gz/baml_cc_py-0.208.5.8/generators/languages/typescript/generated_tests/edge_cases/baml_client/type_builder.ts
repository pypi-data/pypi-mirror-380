/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    AllNullable: ClassViewer<'AllNullable', "nullString" | "nullInt" | "nullFloat" | "nullBool" | "nullArray" | "nullObject">;
    
    BooleanEdgeCases: ClassViewer<'BooleanEdgeCases', "explicitTrue" | "explicitFalse" | "arrayOfTrue" | "arrayOfFalse" | "mixedBoolArray">;
    
    CircularReference: ClassViewer<'CircularReference', "id" | "name" | "parent" | "children" | "relatedItems">;
    
    DeepRecursion: ClassViewer<'DeepRecursion', "value" | "next">;
    
    EmptyCollections: ClassViewer<'EmptyCollections', "emptyStringArray" | "emptyIntArray" | "emptyObjectArray" | "emptyMap" | "emptyNestedArray">;
    
    InnerNullable: ClassViewer<'InnerNullable', "value">;
    
    LargeStructure: ClassViewer<'LargeStructure', "field1" | "field2" | "field3" | "field4" | "field5" | "field6" | "field7" | "field8" | "field9" | "field10" | "field11" | "field12" | "field13" | "field14" | "field15" | "field16" | "field17" | "field18" | "field19" | "field20" | "array1" | "array2" | "array3" | "array4" | "array5" | "map1" | "map2" | "map3" | "map4" | "map5">;
    
    MixedEdgeCases: ClassViewer<'MixedEdgeCases', "emptyString" | "singleChar" | "veryLongArray" | "deeplyNestedMap" | "mixedTypeArray" | "optionalEverything">;
    
    NestedNullable: ClassViewer<'NestedNullable', "outer">;
    
    NullEdgeCases: ClassViewer<'NullEdgeCases', "allNull" | "someNull" | "nestedNull">;
    
    NumberEdgeCases: ClassViewer<'NumberEdgeCases', "zero" | "negativeInt" | "largeInt" | "veryLargeInt" | "smallFloat" | "largeFloat" | "negativeFloat" | "scientificNotation" | "infinity" | "notANumber">;
    
    OptionalEverything: ClassViewer<'OptionalEverything', "optString" | "optInt" | "optFloat" | "optBool" | "optArray" | "optMap" | "optObject">;
    
    OuterNullable: ClassViewer<'OuterNullable', "inner">;
    
    SomeNullable: ClassViewer<'SomeNullable', "presentString" | "nullString" | "presentInt" | "nullInt">;
    
    SpecialCharacters: ClassViewer<'SpecialCharacters', "normalText" | "withNewlines" | "withTabs" | "withQuotes" | "withBackslashes" | "withUnicode" | "withEmoji" | "withMixedSpecial">;
    
    User: ClassViewer<'User', "id" | "name">;
    
    VeryLongStrings: ClassViewer<'VeryLongStrings', "shortString" | "mediumString" | "longString" | "veryLongString" | "extremelyLongString">;
    
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "AllNullable","BooleanEdgeCases","CircularReference","DeepRecursion","EmptyCollections","InnerNullable","LargeStructure","MixedEdgeCases","NestedNullable","NullEdgeCases","NumberEdgeCases","OptionalEverything","OuterNullable","SomeNullable","SpecialCharacters","User","VeryLongStrings",
          ]),
          enums: new Set([
            
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.AllNullable = this.tb.classViewer("AllNullable", [
          "nullString","nullInt","nullFloat","nullBool","nullArray","nullObject",
        ]);
        
        this.BooleanEdgeCases = this.tb.classViewer("BooleanEdgeCases", [
          "explicitTrue","explicitFalse","arrayOfTrue","arrayOfFalse","mixedBoolArray",
        ]);
        
        this.CircularReference = this.tb.classViewer("CircularReference", [
          "id","name","parent","children","relatedItems",
        ]);
        
        this.DeepRecursion = this.tb.classViewer("DeepRecursion", [
          "value","next",
        ]);
        
        this.EmptyCollections = this.tb.classViewer("EmptyCollections", [
          "emptyStringArray","emptyIntArray","emptyObjectArray","emptyMap","emptyNestedArray",
        ]);
        
        this.InnerNullable = this.tb.classViewer("InnerNullable", [
          "value",
        ]);
        
        this.LargeStructure = this.tb.classViewer("LargeStructure", [
          "field1","field2","field3","field4","field5","field6","field7","field8","field9","field10","field11","field12","field13","field14","field15","field16","field17","field18","field19","field20","array1","array2","array3","array4","array5","map1","map2","map3","map4","map5",
        ]);
        
        this.MixedEdgeCases = this.tb.classViewer("MixedEdgeCases", [
          "emptyString","singleChar","veryLongArray","deeplyNestedMap","mixedTypeArray","optionalEverything",
        ]);
        
        this.NestedNullable = this.tb.classViewer("NestedNullable", [
          "outer",
        ]);
        
        this.NullEdgeCases = this.tb.classViewer("NullEdgeCases", [
          "allNull","someNull","nestedNull",
        ]);
        
        this.NumberEdgeCases = this.tb.classViewer("NumberEdgeCases", [
          "zero","negativeInt","largeInt","veryLargeInt","smallFloat","largeFloat","negativeFloat","scientificNotation","infinity","notANumber",
        ]);
        
        this.OptionalEverything = this.tb.classViewer("OptionalEverything", [
          "optString","optInt","optFloat","optBool","optArray","optMap","optObject",
        ]);
        
        this.OuterNullable = this.tb.classViewer("OuterNullable", [
          "inner",
        ]);
        
        this.SomeNullable = this.tb.classViewer("SomeNullable", [
          "presentString","nullString","presentInt","nullInt",
        ]);
        
        this.SpecialCharacters = this.tb.classViewer("SpecialCharacters", [
          "normalText","withNewlines","withTabs","withQuotes","withBackslashes","withUnicode","withEmoji","withMixedSpecial",
        ]);
        
        this.User = this.tb.classViewer("User", [
          "id","name",
        ]);
        
        this.VeryLongStrings = this.tb.classViewer("VeryLongStrings", [
          "shortString","mediumString","longString","veryLongString","extremelyLongString",
        ]);
        
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}