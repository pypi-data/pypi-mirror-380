/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    ComplexOptional: ClassViewer<'ComplexOptional', "data" | "items" | "mapping">;
    
    MixedOptionalNullable: ClassViewer<'MixedOptionalNullable', "id" | "description" | "metadata" | "notes" | "tags" | "categories" | "keywords" | "primaryUser" | "secondaryUser" | "tertiaryUser">;
    
    NullableTypes: ClassViewer<'NullableTypes', "nullableString" | "nullableInt" | "nullableFloat" | "nullableBool" | "nullableArray" | "nullableObject">;
    
    OptionalData: ClassViewer<'OptionalData', "value" | "count" | "enabled">;
    
    OptionalFields: ClassViewer<'OptionalFields', "requiredString" | "optionalString" | "requiredInt" | "optionalInt" | "requiredBool" | "optionalBool" | "optionalArray" | "optionalMap">;
    
    OptionalItem: ClassViewer<'OptionalItem', "id" | "name" | "description" | "metadata">;
    
    OptionalValue: ClassViewer<'OptionalValue', "data" | "optional">;
    
    Product: ClassViewer<'Product', "id" | "name" | "price">;
    
    UnionWithNull: ClassViewer<'UnionWithNull', "simpleUnion" | "nullableUnion" | "optionalUnion" | "complexUnion">;
    
    User: ClassViewer<'User', "id" | "name" | "email" | "phone">;
    
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "ComplexOptional","MixedOptionalNullable","NullableTypes","OptionalData","OptionalFields","OptionalItem","OptionalValue","Product","UnionWithNull","User",
          ]),
          enums: new Set([
            
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.ComplexOptional = this.tb.classViewer("ComplexOptional", [
          "data","items","mapping",
        ]);
        
        this.MixedOptionalNullable = this.tb.classViewer("MixedOptionalNullable", [
          "id","description","metadata","notes","tags","categories","keywords","primaryUser","secondaryUser","tertiaryUser",
        ]);
        
        this.NullableTypes = this.tb.classViewer("NullableTypes", [
          "nullableString","nullableInt","nullableFloat","nullableBool","nullableArray","nullableObject",
        ]);
        
        this.OptionalData = this.tb.classViewer("OptionalData", [
          "value","count","enabled",
        ]);
        
        this.OptionalFields = this.tb.classViewer("OptionalFields", [
          "requiredString","optionalString","requiredInt","optionalInt","requiredBool","optionalBool","optionalArray","optionalMap",
        ]);
        
        this.OptionalItem = this.tb.classViewer("OptionalItem", [
          "id","name","description","metadata",
        ]);
        
        this.OptionalValue = this.tb.classViewer("OptionalValue", [
          "data","optional",
        ]);
        
        this.Product = this.tb.classViewer("Product", [
          "id","name","price",
        ]);
        
        this.UnionWithNull = this.tb.classViewer("UnionWithNull", [
          "simpleUnion","nullableUnion","optionalUnion","complexUnion",
        ]);
        
        this.User = this.tb.classViewer("User", [
          "id","name","email","phone",
        ]);
        
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}