syntax = "proto3";
package baml.cffi;

option go_package = "./cffi";

// -----------------------------------------------------------------------------
// CFFIValue definition
// -----------------------------------------------------------------------------

// The wrapper message for CFFIValue.
message CFFIValueHolder {
  // we must include this because we might be a "string"
  // but in a container type like (string | int) and some languages
  // require we decode this.
  //
  // Required for BAML -> CFFI
  // But not for CFFI -> BAML (BAML always does type validation again at
  // boundaries)
  oneof value {
    CFFIValueNull null_value = 2;
    string string_value = 3;
    int64 int_value = 4;
    double float_value = 5;
    bool bool_value = 6;
    CFFIValueList list_value = 7;
    CFFIValueMap map_value = 8;
    CFFIValueClass class_value = 9;
    CFFIValueEnum enum_value = 10;
    CFFIValueRawObject object_value = 11;
    CFFIValueTuple tuple_value = 12;
    CFFIValueUnionVariant union_variant_value = 13;
    CFFIValueChecked checked_value = 14;
    CFFIValueStreamingState streaming_state_value = 15;
  }
  CFFIFieldTypeHolder type = 16;
}

enum CFFITypeNamespace {
  INTERNAL = 0;
  TYPES = 1;
  STREAM_TYPES = 2;
}

// wrapper for the name of a type
message CFFITypeName {
  CFFITypeNamespace namespace = 1;
  // the name of the type
  string name = 2;
}

message CFFIValueNull {}

// Each variant as a message.
message CFFIValueList {
  CFFIFieldTypeHolder value_type = 1;
  repeated CFFIValueHolder values = 2;
}

// A helper message to represent map entries (used also in Class).
message CFFIMapEntry {
  string key = 1;
  CFFIValueHolder value = 2;
}

message CFFIValueMap {
  CFFIFieldTypeHolder key_type = 1;
  CFFIFieldTypeHolder value_type = 2;
  repeated CFFIMapEntry entries = 3;
}

message CFFIValueClass {
  CFFITypeName name = 1;
  repeated CFFIMapEntry fields = 2;
  // repeated CFFIMapEntry dynamic_fields = 3;
}

message CFFIValueEnum {
  CFFITypeName name = 1;
  string value = 2;
  bool is_dynamic = 3;
}

message CFFIValueRawObject {
  oneof object {
    CFFIRawObject media = 1;
    CFFIRawObject type = 2;
  }
}

message CFFIValueTuple { repeated CFFIValueHolder values = 1; }

// For the Rust variant `Union(Vec<CFFIFieldType>, Box<CFFIValue>)`
message CFFIValueUnionVariant {
  CFFITypeName name = 1;
  string variant_name = 2;
  repeated CFFIFieldTypeHolder field_types = 3;
  int32 value_type_index = 4;
  CFFIValueHolder value = 5;
}

message CFFIValueChecked {
  CFFIValueHolder value = 1;
  repeated CFFICheckValue checks = 2;
}

// -----------------------------------------------------------------------------
// CFFIMedia definitions
// -----------------------------------------------------------------------------

// We need to handle CFFIMediaType. Since one variant is "Other(String)",
// we represent it as a message with an enum tag and an optional string.
enum MediaTypeEnum {
  IMAGE = 0;
  AUDIO = 1;
  PDF = 2;
  VIDEO = 3;
}

// -----------------------------------------------------------------------------
// CFFIFieldType definition
// -----------------------------------------------------------------------------

// The wrapper message for CFFIFieldType.
message CFFIFieldTypeHolder {
  oneof type {
    CFFIFieldTypeString string_type = 1;
    CFFIFieldTypeInt int_type = 2;
    CFFIFieldTypeFloat float_type = 3;
    CFFIFieldTypeBool bool_type = 4;
    CFFIFieldTypeNull null_type = 5;
    CFFIFieldTypeLiteral literal_type = 6;
    CFFIFieldTypeMedia media_type = 7;
    CFFIFieldTypeEnum enum_type = 8;
    CFFIFieldTypeClass class_type = 9;
    CFFIFieldTypeTypeAlias type_alias_type = 10;
    CFFIFieldTypeList list_type = 11;
    CFFIFieldTypeMap map_type = 12;
    CFFIFieldTypeTuple tuple_type = 13;
    CFFIFieldTypeUnionVariant union_variant_type = 14;
    CFFIFieldTypeOptional optional_type = 15;
    CFFIFieldTypeChecked checked_type = 16;
    CFFIFieldTypeStreamState stream_state_type = 17;
    CFFIFieldTypeAny any_type = 18;
  }
}

// Simple marker messages for primitive types.
message CFFIFieldTypeString {}
message CFFIFieldTypeInt {}
message CFFIFieldTypeFloat {}
message CFFIFieldTypeBool {}
message CFFIFieldTypeNull {}
message CFFIFieldTypeAny {}

// Literal: wraps a literal oneof.
message CFFILiteralString { string value = 1; }

message CFFILiteralInt { int64 value = 1; }

message CFFILiteralBool { bool value = 1; }

message CFFIFieldTypeLiteral {
  oneof literal {
    CFFILiteralString string_literal = 1;
    CFFILiteralInt int_literal = 2;
    CFFILiteralBool bool_literal = 3;
  }
}

// For Media, reuse the CFFIMediaType message.
message CFFIFieldTypeMedia { MediaTypeEnum media = 1; }

message CFFIFieldTypeEnum { string name = 1; }

message CFFIFieldTypeClass { CFFITypeName name = 1; }

message CFFIFieldTypeTypeAlias { CFFITypeName name = 1; }

message CFFIFieldTypeList { CFFIFieldTypeHolder element = 1; }

message CFFIFieldTypeMap {
  CFFIFieldTypeHolder key = 1;
  CFFIFieldTypeHolder value = 2;
}

message CFFIFieldTypeTuple { repeated CFFIFieldTypeHolder elements = 1; }

message CFFIFieldTypeUnionVariant {
  CFFITypeName name = 1;
  repeated CFFIFieldTypeHolder options = 2;
}

message CFFIFieldTypeOptional { CFFIFieldTypeHolder value = 1; }

message CFFIFieldTypeChecked {
  CFFIFieldTypeHolder value = 1;
  repeated CFFICheckType checks = 2;
}

message CFFIFieldTypeStreamState { CFFIFieldTypeHolder value = 1; }

message CFFIEnvVar {
  string key = 1;
  string value = 2;
}

message CFFIFunctionArguments {
  repeated CFFIMapEntry kwargs = 1;
  CFFIClientRegistry client_registry = 2;
  repeated CFFIEnvVar env = 3;
  // collectors only
  repeated CFFIRawObject collectors = 4;
  // type builder only
  CFFIRawObject type_builder = 5;
}

message CFFIObjectMethodArguments {
  CFFIRawObject object = 1;
  string method_name = 2;
  repeated CFFIMapEntry kwargs = 3;
}

message CFFIObjectConstructorArgs {
  CFFIObjectType type = 1;
  repeated CFFIMapEntry kwargs = 2;
}

// only one of these will be set
// proto doesn't allow oneofs with repeated fields
message CFFIObjectResponseSuccess {
  oneof result {
    CFFIRawObject object = 1;
    MultipleRawObjectResponse objects = 2;
    CFFIValueHolder value = 3;
  }
}

message MultipleRawObjectResponse { repeated CFFIRawObject objects = 1; }

message CFFIObjectResponseError { string error = 1; }

message CFFIObjectResponse {
  oneof response {
    CFFIObjectResponseSuccess success = 1;
    CFFIObjectResponseError error = 2;
  }
}

// Enum for all possible object types
message CFFIPointerType { int64 pointer = 1; }

enum CFFIObjectType {
  OBJECT_UNSPECIFIED = 0;
  OBJECT_COLLECTOR = 1;
  OBJECT_FUNCTION_LOG = 2;
  OBJECT_USAGE = 3;
  OBJECT_TIMING = 4;
  OBJECT_STREAM_TIMING = 5;
  OBJECT_LLM_CALL = 6;
  OBJECT_LLM_STREAM_CALL = 7;
  OBJECT_HTTP_REQUEST = 8;
  OBJECT_HTTP_RESPONSE = 9;
  OBJECT_HTTP_BODY = 10;
  OBJECT_SSE_RESPONSE = 11;
  OBJECT_MEDIA_IMAGE = 12;
  OBJECT_MEDIA_AUDIO = 13;
  OBJECT_MEDIA_PDF = 14;
  OBJECT_MEDIA_VIDEO = 15;
  OBJECT_TYPE_BUILDER = 16;
  OBJECT_TYPE = 17;
  OBJECT_ENUM_BUILDER = 18;
  OBJECT_ENUM_VALUE_BUILDER = 19;
  OBJECT_CLASS_BUILDER = 20;
  OBJECT_CLASS_PROPERTY_BUILDER = 21;
}

// Raw object with type information
message CFFIRawObject {
  oneof object {
    CFFIPointerType collector = 1;
    CFFIPointerType function_log = 2;
    CFFIPointerType usage = 3;
    CFFIPointerType timing = 4;
    CFFIPointerType stream_timing = 5;
    CFFIPointerType llm_call = 6;
    CFFIPointerType llm_stream_call = 7;
    CFFIPointerType http_request = 8;
    CFFIPointerType http_response = 9;
    CFFIPointerType http_body = 10;
    CFFIPointerType sse_response = 11;
    CFFIPointerType media_image = 12;
    CFFIPointerType media_audio = 13;
    CFFIPointerType media_pdf = 14;
    CFFIPointerType media_video = 15;
    CFFIPointerType type_builder = 16;
    CFFIPointerType type = 17;
    CFFIPointerType enum_builder = 18;
    CFFIPointerType enum_value_builder = 19;
    CFFIPointerType class_builder = 20;
    CFFIPointerType class_property_builder = 21;
  }
}

message CFFIClientRegistry {
  optional string primary = 1;
  repeated CFFIClientProperty clients = 2;
}

message CFFIClientProperty {
  string name = 1;
  string provider = 2;
  optional string retry_policy = 3;
  repeated CFFIMapEntry options = 4;
}

// -----------------------------------------------------------------------------
// CFFICheck definitions
// -----------------------------------------------------------------------------

message CFFICheckType {
  string name = 1;
  CFFIFieldTypeHolder returns = 2;
}

message CFFICheckValue {
  string name = 1;
  string expression = 2;
  string status = 3;
  CFFIValueHolder value = 4;
}

// -----------------------------------------------------------------------------
// Other Enums
// -----------------------------------------------------------------------------

enum CFFIStreamState {
  PENDING = 0;
  STARTED = 1;
  DONE = 2;
}

// -----------------------------------------------------------------------------
// CFFIValue definitions
// -----------------------------------------------------------------------------

// The wrapper message for CFFIValue.
message CFFIValueStreamingState {
  CFFIValueHolder value = 1;
  CFFIStreamState state = 2;
}
