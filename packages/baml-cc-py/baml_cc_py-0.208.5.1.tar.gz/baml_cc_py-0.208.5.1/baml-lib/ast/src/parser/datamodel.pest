schema = {
    SOI ~ (mdx_header | expr_fn | top_level_assignment | value_expression_block | type_expression_block | template_declaration | type_alias | comment_block | raw_string_literal | empty_lines | CATCH_ALL)* ~ EOI
}

// ######################################
// Unified Block for Class and Enum
// ######################################
type_expression_block = { identifier ~ identifier ~ named_argument_list? ~ BLOCK_OPEN ~ type_expression_contents ~ BLOCK_CLOSE }

// Dynamic declarations start with the dynamic keyword followed by a normal type expression.
dynamic_type_expression_block = { identifier ~ type_expression_block }

type_expression_contents = {
    (expr_fn | type_expression | block_attribute | comment_block | empty_lines | BLOCK_LEVEL_CATCH_ALL)*
}
type_expression          = {
    identifier ~ field_type_chain? ~ (NEWLINE? ~ (field_attribute | trailing_comment))* ~ NEWLINE?
}

field_operator       = { "|" }
field_type_chain     = { field_type_with_attr ~ (field_operator ~ field_type_with_attr)* }
field_type_with_attr = { field_type ~ (NEWLINE? ~ (field_attribute | trailing_comment))* }

// ######################################
// Unified Block for Function, Test, Client, Generator
// ######################################
value_expression_keyword  = { FUNCTION_KEYWORD | TEST_KEYWORD | CLIENT_KEYWORD | RETRY_POLICY_KEYWORD | GENERATOR_KEYWORD }
value_expression_block    = { value_expression_keyword ~ identifier ~ named_argument_list? ~ ARROW? ~ field_type_chain? ~ SPACER_TEXT ~ BLOCK_OPEN ~ value_expression_contents ~ BLOCK_CLOSE }
value_expression_contents = {
    (mdx_header | stmt | type_builder_block | value_expression | comment_block | block_attribute | empty_lines | BLOCK_LEVEL_CATCH_ALL)*
}
value_expression          = { identifier ~ config_expression? ~ (NEWLINE? ~ field_attribute)* ~ trailing_comment? }

// ######################################
// Type builder
// ######################################

type_builder_block    = {
    TYPE_BUILDER_KEYWORD ~ BLOCK_OPEN ~ type_builder_contents ~ BLOCK_CLOSE
}
type_builder_contents = { (dynamic_type_expression_block | type_expression_block | type_alias | comment_block | empty_lines | BLOCK_LEVEL_CATCH_ALL)* }

// ######################################
ARROW = { SPACER_TEXT ~ "->" ~ SPACER_TEXT }

// ######################################
// Template Declaration
// ######################################
assignment           = { "=" }
template_declaration = { TEMPLATE_KEYWORD ~ identifier ~ assignment? ~ named_argument_list? ~ raw_string_literal }

named_argument = { identifier ~ ((COLON ~ field_type_chain) | COLON)? }
// Be forgiving and allow trailing comma
named_argument_list = { openParen ~ SPACER_TEXT ~ named_argument? ~ ("," ~ SPACER_TEXT ~ named_argument)* ~ ","? ~ SPACER_TEXT ~ closeParen }

// ######################################
// Attributes
// ######################################
block_attribute = { "@@" ~ (path_identifier | identifier) ~ arguments_list? }
field_attribute = { "@" ~ (path_identifier | identifier) ~ arguments_list? }

// Pest is greedy, order is very important here.
field_type          = { (union | non_union) ~ optional_token? }
optional_token      = { "?" }
union               = { base_type_with_attr ~ (field_operator ~ base_type_with_attr)+ }
literal_type        = { numeric_literal | quoted_string_literal }
base_type_with_attr = { base_type ~ (NEWLINE? ~ field_attribute)* }
base_type           = { array_notation | map | path_identifier | identifier | group | tuple | parenthesized_type | literal_type }

array_suffix   = { "[]" }
array_notation = { base_type_without_array ~ array_suffix+ ~ optional_token? }

map = { "map" ~ "<" ~ field_type ~ "," ~ field_type ~ ">" ~ optional_token? }

openParen  = { "(" }
closeParen = { ")" }
group      = { openParen ~ field_type ~ (field_attribute)* ~ closeParen }
tuple      = { openParen ~ field_type_with_attr ~ ("," ~ field_type_with_attr)+ ~ closeParen }

base_type_without_array = { map | path_identifier | identifier | group | tuple }

non_union = { array_notation | map | path_identifier | identifier | group | tuple | literal_type }

parenthesized_type = { openParen ~ field_type_with_attr ~ closeParen }

path_identifier       =  { single_word ~ ("." ~ single_word)+ }
identifier            =  { namespaced_identifier | single_word }
single_word           = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "-")* }
namespaced_identifier = ${ single_word ~ ("::" ~ single_word)+ }

// ######################################
// Type Alias
// ######################################
type_alias = { identifier ~ identifier ~ assignment ~ field_type_with_attr }

// ######################################
// Arguments
// ######################################
arguments_list = { "(" ~ (NEWLINE?) ~ config_expression? ~ ("," ~ (NEWLINE?) ~ config_expression)? ~ (NEWLINE?) ~ ")" }

// ######################################
// Expressions & Functions
// ######################################

ident_map_entry = { identifier ~ !COLON ~ expression }
// We'll make colon optional so that parser doesn't choke on missing ":"
// This will make `ident <missing colon> expression` pass as a string key. We'll report inconsistencies
// like this within the parser
expr_map_entry = {  expression ~ COLON? ~ expression }


splitter          = _{ ("," ~ NEWLINE?) | NEWLINE }
map_expression    =  { "{" ~ NEWLINE* ~ ((ident_map_entry | expr_map_entry) ~ splitter?)* ~ NEWLINE* ~ "}" }
array_expression  =  { "[" ~ empty_lines? ~ ((expression | ARRAY_CATCH_ALL) ~ trailing_comment? ~ (splitter ~ (comment_block | empty_lines)* ~ (expression | ARRAY_CATCH_ALL) ~ trailing_comment?)*)? ~ (comment_block | empty_lines)* ~ splitter? ~ "]" }
jinja_block_open  = _{ "{{" }
jinja_block_close = _{ "}}" }
jinja_body        =  { (!(jinja_block_open | jinja_block_close) ~ ANY)* }
jinja_expression  =  { jinja_block_open ~ jinja_body ~ jinja_block_close }

expression =  {
    prefix_operator*
    ~ primary_expression
    ~ postfix_operator*
    ~ (infix_operator ~ prefix_operator* ~ primary_expression ~ postfix_operator*)*
}

postfix_operator = _{ array_accessor | method_call | field_accessor }
infix_operator = _{ INSTANCE_OF | AND | OR | EQ | NEQ | LTEQ | GTEQ | BIT_SHL | BIT_SHR | BIT_AND | BIT_OR | BIT_XOR | LT | GT | ADD | SUB | MUL | DIV | MOD }
prefix_operator = _{ NOT | NEG }

array_accessor = { "[" ~ expression ~ "]" }
field_accessor = { "." ~ identifier }
method_call    = { "." ~ (generic_fn_app | fn_app) }

primary_expression = {
    if_expression |
    generic_fn_app |
    fn_app |
    lambda |
    jinja_expression |
    map_expression |
    expr_block |
    array_expression |
    numeric_literal |
    class_constructor |
    identifier |
    string_literal |
    "(" ~ expression ~ ")"
}

ARRAY_CATCH_ALL   =  { !"]" ~ CATCH_ALL }
ENTRY_CATCH_ALL   =  { field_attribute | BLOCK_LEVEL_CATCH_ALL }

// ######################################
// Config expressions for value_expression blocks
// ######################################
// Like expression, but prioritizes string literals over identifiers
// to allow unquoted strings like "python/pydantic" to parse correctly
config_expression = { config_primary_expression }

config_primary_expression = {
    jinja_expression |
    config_map_expression |
    config_array_expression |
    numeric_literal |
    string_literal |
    identifier
}

config_map_key   = { identifier | quoted_string_literal }
// Allow an optional colon between key and value. Without this, a leading ':'
// could be captured into the value token (e.g., ": env.MY_KEY").
config_map_entry = { (comment_block | empty_lines)* ~ config_map_key ~ COLON? ~ (config_expression | ENTRY_CATCH_ALL)? ~ trailing_comment? }

config_map_expression    =  { "{" ~ empty_lines? ~ (config_map_entry ~ (splitter ~ config_map_entry)*)? ~ (comment_block | empty_lines)* ~ "}" }

// Array expression that nests config expressions for elements
config_array_expression  =  { "[" ~ empty_lines? ~ ((config_expression | ARRAY_CATCH_ALL) ~ trailing_comment? ~ (splitter ~ (comment_block | empty_lines)* ~ (config_expression | ARRAY_CATCH_ALL) ~ trailing_comment?)*)? ~ (comment_block | empty_lines)* ~ splitter? ~ "]" }

// ######################################
// Literals / Values
// ######################################
numeric_literal = @{ ("-")? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }

// ######################################
// String literals. These behave specially in BAML.
// ######################################
banned_chars            = @{ "#" | "@" | "{" | "(" | "[" | "<" | "}" | ")" | "]" | ">" | "," | "'" | ";" | " //" | NEWLINE }
banned_start_chars      =  { WHITESPACE | banned_chars }
banned_end_chars        =  { WHITESPACE | banned_chars }
unquoted_string_literal = @{ (!banned_start_chars ~ ANY) ~ (!banned_chars ~ !"\"" ~ ANY)* ~ (!banned_end_chars ~ ANY)* }
quoted_string_content   = @{ (("\\\"" | !("\"" | NEWLINE) ~ ANY))* }
quoted_string_literal   = ${ "\"" ~ quoted_string_content ~ "\"" }

// TODO: Support comments in raw string literals
raw_string_literal_content_1 = @{ (!"\"#" ~ ANY)* }
raw_string_literal_content_2 = @{ (!"\"##" ~ ANY)* }
raw_string_literal_content_3 = @{ (!"\"###" ~ ANY)* }
raw_string_literal_content_4 = @{ (!"\"####" ~ ANY)* }
raw_string_literal_content_5 = @{ (!"\"#####" ~ ANY)* }

raw_string_start_5 = _{ (single_word)? ~ "#####\"" }
raw_string_start_4 = _{ (single_word)? ~ "####\"" }
raw_string_start_3 = _{ (single_word)? ~ "###\"" }
raw_string_start_2 = _{ (single_word)? ~ "##\"" }
raw_string_start_1 = _{ (single_word)? ~ "#\"" }

raw_string_literal                 =  {
    (raw_string_start_5 ~ raw_string_literal_content_5 ~ "\"#####")
  | (raw_string_start_4 ~ raw_string_literal_content_4 ~ "\"####")
  | (raw_string_start_3 ~ raw_string_literal_content_3 ~ "\"###")
  | (raw_string_start_2 ~ raw_string_literal_content_2 ~ "\"##")
  | (raw_string_start_1 ~ raw_string_literal_content_1 ~ "\"#")
}
unterminated_raw_string_literal    = ${
    (raw_string_start_5 ~ raw_string_literal_content_5)
  | (raw_string_start_4 ~ raw_string_literal_content_4)
  | (raw_string_start_3 ~ raw_string_literal_content_3)
  | (raw_string_start_2 ~ raw_string_literal_content_2)
  | (raw_string_start_1 ~ raw_string_literal_content_1)
}
unterminated_quoted_string_literal = ${ "\"" ~ quoted_string_content }
unterminated_string_literal        = ${ unterminated_raw_string_literal | unterminated_quoted_string_literal }
string_literal                     =  { raw_string_literal | quoted_string_literal | unquoted_string_literal | unterminated_string_literal }

// ######################################
// Comments and Documentation Comments
// ######################################
comment_block    = ${ ((block_comment | doc_comment | comment) ~ NEWLINE?)+ }
trailing_comment = ${ doc_comment | comment }
doc_comment      =  { WHITESPACE* ~ "///" ~ doc_content }
comment          =  { WHITESPACE* ~ (!"///") ~ "//" ~ doc_content }
block_content    = @{ (!"//}" ~ ANY)* }
block_comment    =  { WHITESPACE* ~ "{//" ~ block_content ~ "//}" }
doc_content      = @{ (!NEWLINE ~ ANY)* }

// ######################################
// Shared Building Blocks and Comments
// ######################################
WHITESPACE  = _{ " " | "\t" }
NEWLINE     =  { "\n" | "\r\n" | "\r" }
empty_lines = @{ (WHITESPACE* ~ NEWLINE)+ }

// ######################################
// Utilities
// ######################################
SPACER_TEXT = { (comment_block | empty_lines)* }

// the any part is to not crash on comments next to an open block, see test `parse_comments_without_crasing_or_loosing_info`
BLOCK_OPEN  = { "{" }
BLOCK_CLOSE = { "}" }

BLOCK_LEVEL_CATCH_ALL = { !BLOCK_CLOSE ~ CATCH_ALL }
CATCH_ALL             = { (!NEWLINE ~ ANY)+ ~ NEWLINE? }

FUNCTION_KEYWORD     = { "function" }
TEMPLATE_KEYWORD     = { "template_string" | "string_template" }
TEST_KEYWORD         = { "test" }
TYPE_BUILDER_KEYWORD = { "type_builder" }
CLIENT_KEYWORD       = { "client<llm>" | "client" }
GENERATOR_KEYWORD    = { "generator" }
RETRY_POLICY_KEYWORD = { "retry_policy" }
BREAK_KEYWORD        = { "break" }
CONTINUE_KEYWORD     = { "continue" }
SEMICOLON = { ";" }
COLON = { ":" }
COMMA = { "," }
INVALID_STMT_STARTING_CHAR = { !ASCII_ALPHA ~ !WHITESPACE ~ !NEWLINE ~ !BLOCK_OPEN ~ !comment ~ ANY }

// #################################################
// Operators
// #################################################

// NOTE: ~ !"=" is needed to allow assignments like `a += 1`
// If not used, PEST assumes this is an addition and right hand side is "= 1".

// Arithmetic
ADD = { "+" ~ !"=" }
SUB = { "-" ~ !"=" }
MUL = { "*" ~ !"=" }
DIV = { "/" ~ !("=" | "/") } // Needed for trailing comments.
MOD = { "%" ~ !"=" }

// Bitwise
BIT_AND = { "&" ~ !"=" }
BIT_OR = { "|" ~ !"=" }
BIT_XOR = { "^" ~ !"=" }
BIT_SHL = { "<<" ~ !"=" }
BIT_SHR = { ">>" ~ !"=" }

// Comparison
EQ = { "==" }
NEQ = { "!=" }
LT = { "<" }
LTEQ = { "<=" }
GT = { ">" }
GTEQ = { ">=" }

// Instance of
INSTANCE_OF = { "instanceof" }

// Logical
AND = { "&&" }
OR = { "||" }

// Unary
NOT = { "!" }
NEG = { "-" } // NOTE: Can't reuse SUB here. Read this: https://docs.rs/pest/latest/pest/pratt_parser/struct.PrattParser.html

// #################################################
// BAML Expressions
// #################################################

// Top-level variable declarations. e.g.:
//   - `let x = go(1,2)`
//   - `let z = { let b = 2; [b, 3] }
// Although operators and variable updates are allowed by the grammar,
// they are ruled out later by the parser.
top_level_assignment = { top_level_stmt }

// More forgiving statement rule for top-level - similar to expr_body_stmt but more restrictive
top_level_stmt = {
    (
        let_expr
        | assign_op_stmt
        | assign_stmt
    )
    ~ SEMICOLON?
    ~ trailing_comment?
    ~ NEWLINE?
}

// Regular function.
// e.g.:
// function foo(x:int, y: bool?) -> string {
//   go(x,y)
// }
expr_fn = { "function" ~ identifier ~ named_argument_list ~ ARROW? ~ field_type_chain? ~ expr_block }

// Body of a function (including curly brackets).
expr_block = { BLOCK_OPEN ~ NEWLINE? ~ (mdx_header | expr_body_stmt | stmt | comment_block | empty_lines)* ~ expression? ~ (comment_block | empty_lines)* ~ BLOCK_CLOSE }

// More forgiving statement rule for function bodies - only for statements that commonly miss semicolons
expr_body_stmt = {
    (
        INVALID_STMT_STARTING_CHAR* ~
        (
            let_expr
            | assign_op_stmt
            | assign_stmt
        )
        ~ SEMICOLON?
    )
    ~ trailing_comment?
    ~ NEWLINE?
}

// Headers can include any characters except a newline; do not use unquoted_string_literal restrictions
mdx_header = { WHITESPACE* ~ "#"+ ~ WHITESPACE* ~ (!NEWLINE ~ ANY)* ~ NEWLINE? }

// Statement.
stmt = {
    INVALID_STMT_STARTING_CHAR* ~
    (
        for_loop
        | while_loop
        | if_expression
        | (
            (
                BREAK_KEYWORD
                | CONTINUE_KEYWORD
                | let_expr
                | return_stmt
                | assert_stmt
                | assign_op_stmt
                | assign_stmt
                | expression
            )
            ~ SEMICOLON
        )
        | expr_block
    )
    ~ trailing_comment?
    ~ NEWLINE?
}

// Let-binding statement with optional type annotation.
// e.g. `let x: int|float = 10.0;` or `let x = 10.0;`
let_type_annotation = { COLON ~ field_type_chain }
let_expr = { "let" ~ identifier ~ let_type_annotation? ~ "=" ~ expression }

// NOTE: Needs to supports things like `object.getter().field[x + y] = value`,
// so can't be just `identifier ~ "=" ~ expression`.
//
// Though having expression as LHS is also tricky since we need to make sure
// that `a += 1` is not treaded as `a` + `= 1` (addition, infix operator).
// This is solved by forcing infix operators like `+` to not be followed by `=`.
//
// Another solution if this fails at some point is having an assignable_expression
// rule with no infix operators:
//
// assignable_expression = { prefix_operator* ~ primary_expression ~ postfix_operator* }
assign_stmt = { expression ~ "=" ~ expression }
assign_op_stmt = { expression ~ assign_op ~ expression }

assign_op = _{ BIT_SHL_ASSIGN | BIT_SHR_ASSIGN | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | BIT_AND_ASSIGN | BIT_OR_ASSIGN | BIT_XOR_ASSIGN }

ADD_ASSIGN = { "+=" }
SUB_ASSIGN = { "-=" }
MUL_ASSIGN = { "*=" }
DIV_ASSIGN = { "/=" }
MOD_ASSIGN = { "%=" }
BIT_AND_ASSIGN = { "&=" }
BIT_OR_ASSIGN = { "|=" }
BIT_XOR_ASSIGN = { "^=" }
BIT_SHL_ASSIGN = { "<<=" }
BIT_SHR_ASSIGN = { ">>=" }

fn_args = { expression? ~ ("," ~ expression)* }

// Function application.
fn_app = { identifier ~ "(" ~ fn_args ~ ")" }

// If expression.
if_expression = { "if" ~ condition_and_block ~ ( "else" ~ (expr_block | if_expression) )? }

// like <expression>, but will avoid consuming `{` in a class_constructor if there are no more blocks.
// the lookahead match these cases:
// - `ident { } { ...` -> `class_constructor` (as expression)
// - `ident { ...`     -> consume only `identifier` (will have to be manually converted to expression)
// ` otherwise, not a problematic class_constructor ->  we can have expression.
// This allows the parser to continue even in the case of missing a right parentheses
block_aware_tail_expression = { (&class_constructor ~ (&"{" ~ expression | identifier)) | expression }

condition_and_block = _{ openParen? ~  block_aware_tail_expression ~ closeParen? ~ expr_block }

while_loop = { "while" ~ condition_and_block }


// For loop, e.g.
// for r in resumes {
//   ExtractResume(x)
// }
for_loop = { "for" ~ openParen? ~ (iterator_for_loop | c_for_loop) ~ closeParen? ~ expr_block }
// Allow optional `let` before the loop variable in iterator-style for loops
LET_KEYWORD = { "let" }
iterator_for_loop = { (LET_KEYWORD ~ identifier | identifier) ~ "in" ~ block_aware_tail_expression }
c_for_loop = { c_for_init_stmt? ~ ";" ~ expression? ~ ";" ~ c_for_after_stmt?  }
// NOTE: let_expr ... list copied from `stmt` rule, discarding nonsensical stmts
c_for_init_stmt = { let_expr | assign_op_stmt | assign_stmt | fn_app | generic_fn_app }
// same as above but without `let`.
c_for_after_stmt = {  block_aware_assign_op_stmt | block_aware_assign_stmt | fn_app | generic_fn_app }

// statements with a block-aware tail expression. Read `block_aware_tail_expression` for more info.
block_aware_assign_op_stmt = { expression ~ assign_op ~ block_aware_tail_expression }
block_aware_assign_stmt = { expression ~ "=" ~ block_aware_tail_expression }

return_stmt = { "return" ~ expression? }

assert_stmt = { "assert" ~ expression }

// Anonymous function.
lambda = { named_argument_list ~ "=>" ~ expression }

// Class constructors.
// e.g. `new MyClass { x = 1, y = 2 }`.
//
class_constructor = { identifier ~ "{" ~ NEWLINE? ~ (class_field_value_pair ~ COMMA? ~ NEWLINE?)* ~ NEWLINE? ~ "}" }

// A single field in a class constructor.
class_field_value_pair = { (identifier ~ COLON ~ expression) | struct_spread }

// struct spread a.k.a struct update syntax.
// e.g. `..other_struct`
// Used in constructors to initialize fields of a new struct from some other struct.
// e.g. `new MyClass { a: 1, b: 2, ..other_struct }`
struct_spread = { "..." ~ expression }

// No whitespaces for "func_call<", needs to be atomic.
// Actually "compound atomic" because of Pest stuff, read here:
// https://pest.rs/book/grammars/syntax.html#atomic
generic_fn_app_identifier = ${ identifier ~ "<" }

// But then allow whitespaces inside angle brackets and after:
// func_call<    Type    >(a, b)
generic_fn_app_args = { field_type_chain ~ ">" ~ "(" ~ fn_args ~ ")" }

generic_fn_app = { generic_fn_app_identifier ~ generic_fn_app_args }
