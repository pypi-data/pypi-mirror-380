// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package types

import (
    "encoding/json"
    "fmt"

    baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
    "github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)

type Union2ConditionOrSimpleCondition struct {
    variant string
    
    variant_Condition *Condition
    
    variant_SimpleCondition *SimpleCondition
    
}

func (u *Union2ConditionOrSimpleCondition) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "Condition":
            u.variant = "Condition"
            value := baml.Decode(valueHolder).Interface().(Condition)
            u.variant_Condition = &value
    case "SimpleCondition":
            u.variant = "SimpleCondition"
            value := baml.Decode(valueHolder).Interface().(SimpleCondition)
            u.variant_SimpleCondition = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union2ConditionOrSimpleCondition) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Condition":
        return baml.EncodeUnion(u.BamlEncodeName, "Condition", *u.variant_Condition)
    
    case "SimpleCondition":
        return baml.EncodeUnion(u.BamlEncodeName, "SimpleCondition", *u.variant_SimpleCondition)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union2ConditionOrSimpleCondition) BamlTypeName() string {
    return "Union2ConditionOrSimpleCondition"
}

func (u Union2ConditionOrSimpleCondition) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__Condition__SimpleCondition",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union2ConditionOrSimpleCondition) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Condition":
        return json.Marshal(u.variant_Condition)
    
    case "SimpleCondition":
        return json.Marshal(u.variant_SimpleCondition)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union2ConditionOrSimpleCondition) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Condition)
    if err == nil {
        u.variant = "Condition"
        return nil
    } else {
        u.variant_Condition = nil
    }
    
    err = json.Unmarshal(data, &u.variant_SimpleCondition)
    if err == nil {
        u.variant = "SimpleCondition"
        return nil
    } else {
        u.variant_SimpleCondition = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union2ConditionOrSimpleCondition__NewCondition(v Condition) Union2ConditionOrSimpleCondition {
    
    return Union2ConditionOrSimpleCondition{
        variant: "Condition",
        variant_Condition: &v,
    }
}

func (u *Union2ConditionOrSimpleCondition) SetCondition(v Condition) {
    
    u.variant = "Condition"
    u.variant_Condition = &v
    
    u.variant_SimpleCondition = nil
    
}

func (u *Union2ConditionOrSimpleCondition) IsCondition() bool {
    return u.variant == "Condition"
}

func (u *Union2ConditionOrSimpleCondition) AsCondition() *Condition {
    if u.variant != "Condition" {
        return nil
    }
    return u.variant_Condition
}

func Union2ConditionOrSimpleCondition__NewSimpleCondition(v SimpleCondition) Union2ConditionOrSimpleCondition {
    
    return Union2ConditionOrSimpleCondition{
        variant: "SimpleCondition",
        variant_SimpleCondition: &v,
    }
}

func (u *Union2ConditionOrSimpleCondition) SetSimpleCondition(v SimpleCondition) {
    
    u.variant = "SimpleCondition"
    u.variant_SimpleCondition = &v
    
    u.variant_Condition = nil
    
}

func (u *Union2ConditionOrSimpleCondition) IsSimpleCondition() bool {
    return u.variant == "SimpleCondition"
}

func (u *Union2ConditionOrSimpleCondition) AsSimpleCondition() *SimpleCondition {
    if u.variant != "SimpleCondition" {
        return nil
    }
    return u.variant_SimpleCondition
}

type Union2ErrorOrSuccess struct {
    variant string
    
    variant_Success *Success
    
    variant_Error *Error
    
}

func (u *Union2ErrorOrSuccess) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "Success":
            u.variant = "Success"
            value := baml.Decode(valueHolder).Interface().(Success)
            u.variant_Success = &value
    case "Error":
            u.variant = "Error"
            value := baml.Decode(valueHolder).Interface().(Error)
            u.variant_Error = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union2ErrorOrSuccess) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Success":
        return baml.EncodeUnion(u.BamlEncodeName, "Success", *u.variant_Success)
    
    case "Error":
        return baml.EncodeUnion(u.BamlEncodeName, "Error", *u.variant_Error)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union2ErrorOrSuccess) BamlTypeName() string {
    return "Union2ErrorOrSuccess"
}

func (u Union2ErrorOrSuccess) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__Error__Success",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union2ErrorOrSuccess) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Success":
        return json.Marshal(u.variant_Success)
    
    case "Error":
        return json.Marshal(u.variant_Error)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union2ErrorOrSuccess) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Success)
    if err == nil {
        u.variant = "Success"
        return nil
    } else {
        u.variant_Success = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Error)
    if err == nil {
        u.variant = "Error"
        return nil
    } else {
        u.variant_Error = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union2ErrorOrSuccess__NewSuccess(v Success) Union2ErrorOrSuccess {
    
    return Union2ErrorOrSuccess{
        variant: "Success",
        variant_Success: &v,
    }
}

func (u *Union2ErrorOrSuccess) SetSuccess(v Success) {
    
    u.variant = "Success"
    u.variant_Success = &v
    
    u.variant_Error = nil
    
}

func (u *Union2ErrorOrSuccess) IsSuccess() bool {
    return u.variant == "Success"
}

func (u *Union2ErrorOrSuccess) AsSuccess() *Success {
    if u.variant != "Success" {
        return nil
    }
    return u.variant_Success
}

func Union2ErrorOrSuccess__NewError(v Error) Union2ErrorOrSuccess {
    
    return Union2ErrorOrSuccess{
        variant: "Error",
        variant_Error: &v,
    }
}

func (u *Union2ErrorOrSuccess) SetError(v Error) {
    
    u.variant = "Error"
    u.variant_Error = &v
    
    u.variant_Success = nil
    
}

func (u *Union2ErrorOrSuccess) IsError() bool {
    return u.variant == "Error"
}

func (u *Union2ErrorOrSuccess) AsError() *Error {
    if u.variant != "Error" {
        return nil
    }
    return u.variant_Error
}

type Union2KbranchOrKleaf struct {
    variant string
    
    variant_Kleaf *string
    
    variant_Kbranch *string
    
}

func (u *Union2KbranchOrKleaf) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_leaf":
            u.variant = "Kleaf"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kleaf = &value
    case "string_branch":
            u.variant = "Kbranch"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kbranch = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union2KbranchOrKleaf) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kleaf":
        return baml.EncodeUnion(u.BamlEncodeName, "string_leaf", *u.variant_Kleaf)
    
    case "Kbranch":
        return baml.EncodeUnion(u.BamlEncodeName, "string_branch", *u.variant_Kbranch)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union2KbranchOrKleaf) BamlTypeName() string {
    return "Union2KbranchOrKleaf"
}

func (u Union2KbranchOrKleaf) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_branch__string_leaf",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union2KbranchOrKleaf) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kleaf":
        return json.Marshal(u.variant_Kleaf)
    
    case "Kbranch":
        return json.Marshal(u.variant_Kbranch)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union2KbranchOrKleaf) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kleaf)
    if err == nil {
        u.variant = "Kleaf"
        return nil
    } else {
        u.variant_Kleaf = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kbranch)
    if err == nil {
        u.variant = "Kbranch"
        return nil
    } else {
        u.variant_Kbranch = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union2KbranchOrKleaf__NewKleaf() Union2KbranchOrKleaf {
    
    var v string = "leaf"
    
    return Union2KbranchOrKleaf{
        variant: "Kleaf",
        variant_Kleaf: &v,
    }
}

func (u *Union2KbranchOrKleaf) SetKleaf() {
    
    var v string = "leaf"
    
    u.variant = "Kleaf"
    u.variant_Kleaf = &v
    
    u.variant_Kbranch = nil
    
}

func (u *Union2KbranchOrKleaf) IsKleaf() bool {
    return u.variant == "Kleaf"
}

func (u *Union2KbranchOrKleaf) AsKleaf() *string {
    if u.variant != "Kleaf" {
        return nil
    }
    return u.variant_Kleaf
}

func Union2KbranchOrKleaf__NewKbranch() Union2KbranchOrKleaf {
    
    var v string = "branch"
    
    return Union2KbranchOrKleaf{
        variant: "Kbranch",
        variant_Kbranch: &v,
    }
}

func (u *Union2KbranchOrKleaf) SetKbranch() {
    
    var v string = "branch"
    
    u.variant = "Kbranch"
    u.variant_Kbranch = &v
    
    u.variant_Kleaf = nil
    
}

func (u *Union2KbranchOrKleaf) IsKbranch() bool {
    return u.variant == "Kbranch"
}

func (u *Union2KbranchOrKleaf) AsKbranch() *string {
    if u.variant != "Kbranch" {
        return nil
    }
    return u.variant_Kbranch
}

type Union2KerrorOrKsuccess struct {
    variant string
    
    variant_Ksuccess *string
    
    variant_Kerror *string
    
}

func (u *Union2KerrorOrKsuccess) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_success":
            u.variant = "Ksuccess"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Ksuccess = &value
    case "string_error":
            u.variant = "Kerror"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kerror = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union2KerrorOrKsuccess) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Ksuccess":
        return baml.EncodeUnion(u.BamlEncodeName, "string_success", *u.variant_Ksuccess)
    
    case "Kerror":
        return baml.EncodeUnion(u.BamlEncodeName, "string_error", *u.variant_Kerror)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union2KerrorOrKsuccess) BamlTypeName() string {
    return "Union2KerrorOrKsuccess"
}

func (u Union2KerrorOrKsuccess) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_error__string_success",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union2KerrorOrKsuccess) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Ksuccess":
        return json.Marshal(u.variant_Ksuccess)
    
    case "Kerror":
        return json.Marshal(u.variant_Kerror)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union2KerrorOrKsuccess) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Ksuccess)
    if err == nil {
        u.variant = "Ksuccess"
        return nil
    } else {
        u.variant_Ksuccess = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kerror)
    if err == nil {
        u.variant = "Kerror"
        return nil
    } else {
        u.variant_Kerror = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union2KerrorOrKsuccess__NewKsuccess() Union2KerrorOrKsuccess {
    
    var v string = "success"
    
    return Union2KerrorOrKsuccess{
        variant: "Ksuccess",
        variant_Ksuccess: &v,
    }
}

func (u *Union2KerrorOrKsuccess) SetKsuccess() {
    
    var v string = "success"
    
    u.variant = "Ksuccess"
    u.variant_Ksuccess = &v
    
    u.variant_Kerror = nil
    
}

func (u *Union2KerrorOrKsuccess) IsKsuccess() bool {
    return u.variant == "Ksuccess"
}

func (u *Union2KerrorOrKsuccess) AsKsuccess() *string {
    if u.variant != "Ksuccess" {
        return nil
    }
    return u.variant_Ksuccess
}

func Union2KerrorOrKsuccess__NewKerror() Union2KerrorOrKsuccess {
    
    var v string = "error"
    
    return Union2KerrorOrKsuccess{
        variant: "Kerror",
        variant_Kerror: &v,
    }
}

func (u *Union2KerrorOrKsuccess) SetKerror() {
    
    var v string = "error"
    
    u.variant = "Kerror"
    u.variant_Kerror = &v
    
    u.variant_Ksuccess = nil
    
}

func (u *Union2KerrorOrKsuccess) IsKerror() bool {
    return u.variant == "Kerror"
}

func (u *Union2KerrorOrKsuccess) AsKerror() *string {
    if u.variant != "Kerror" {
        return nil
    }
    return u.variant_Kerror
}

type Union3BoolOrIntOrString struct {
    variant string
    
    variant_String *string
    
    variant_Int *int64
    
    variant_Bool *bool
    
}

func (u *Union3BoolOrIntOrString) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string":
            u.variant = "String"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_String = &value
    case "int":
            u.variant = "Int"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_Int = &value
    case "bool":
            u.variant = "Bool"
            value := baml.Decode(valueHolder).Interface().(bool)
            u.variant_Bool = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3BoolOrIntOrString) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "String":
        return baml.EncodeUnion(u.BamlEncodeName, "string", *u.variant_String)
    
    case "Int":
        return baml.EncodeUnion(u.BamlEncodeName, "int", *u.variant_Int)
    
    case "Bool":
        return baml.EncodeUnion(u.BamlEncodeName, "bool", *u.variant_Bool)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3BoolOrIntOrString) BamlTypeName() string {
    return "Union3BoolOrIntOrString"
}

func (u Union3BoolOrIntOrString) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__bool__int__string",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3BoolOrIntOrString) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "String":
        return json.Marshal(u.variant_String)
    
    case "Int":
        return json.Marshal(u.variant_Int)
    
    case "Bool":
        return json.Marshal(u.variant_Bool)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3BoolOrIntOrString) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_String)
    if err == nil {
        u.variant = "String"
        return nil
    } else {
        u.variant_String = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Int)
    if err == nil {
        u.variant = "Int"
        return nil
    } else {
        u.variant_Int = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Bool)
    if err == nil {
        u.variant = "Bool"
        return nil
    } else {
        u.variant_Bool = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3BoolOrIntOrString__NewString(v string) Union3BoolOrIntOrString {
    
    return Union3BoolOrIntOrString{
        variant: "String",
        variant_String: &v,
    }
}

func (u *Union3BoolOrIntOrString) SetString(v string) {
    
    u.variant = "String"
    u.variant_String = &v
    
    u.variant_Int = nil
    
    u.variant_Bool = nil
    
}

func (u *Union3BoolOrIntOrString) IsString() bool {
    return u.variant == "String"
}

func (u *Union3BoolOrIntOrString) AsString() *string {
    if u.variant != "String" {
        return nil
    }
    return u.variant_String
}

func Union3BoolOrIntOrString__NewInt(v int64) Union3BoolOrIntOrString {
    
    return Union3BoolOrIntOrString{
        variant: "Int",
        variant_Int: &v,
    }
}

func (u *Union3BoolOrIntOrString) SetInt(v int64) {
    
    u.variant = "Int"
    u.variant_Int = &v
    
    u.variant_String = nil
    
    u.variant_Bool = nil
    
}

func (u *Union3BoolOrIntOrString) IsInt() bool {
    return u.variant == "Int"
}

func (u *Union3BoolOrIntOrString) AsInt() *int64 {
    if u.variant != "Int" {
        return nil
    }
    return u.variant_Int
}

func Union3BoolOrIntOrString__NewBool(v bool) Union3BoolOrIntOrString {
    
    return Union3BoolOrIntOrString{
        variant: "Bool",
        variant_Bool: &v,
    }
}

func (u *Union3BoolOrIntOrString) SetBool(v bool) {
    
    u.variant = "Bool"
    u.variant_Bool = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
}

func (u *Union3BoolOrIntOrString) IsBool() bool {
    return u.variant == "Bool"
}

func (u *Union3BoolOrIntOrString) AsBool() *bool {
    if u.variant != "Bool" {
        return nil
    }
    return u.variant_Bool
}

type Union3DataObjectOrIntOrString struct {
    variant string
    
    variant_String *string
    
    variant_Int *int64
    
    variant_DataObject *DataObject
    
}

func (u *Union3DataObjectOrIntOrString) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string":
            u.variant = "String"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_String = &value
    case "int":
            u.variant = "Int"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_Int = &value
    case "DataObject":
            u.variant = "DataObject"
            value := baml.Decode(valueHolder).Interface().(DataObject)
            u.variant_DataObject = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3DataObjectOrIntOrString) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "String":
        return baml.EncodeUnion(u.BamlEncodeName, "string", *u.variant_String)
    
    case "Int":
        return baml.EncodeUnion(u.BamlEncodeName, "int", *u.variant_Int)
    
    case "DataObject":
        return baml.EncodeUnion(u.BamlEncodeName, "DataObject", *u.variant_DataObject)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3DataObjectOrIntOrString) BamlTypeName() string {
    return "Union3DataObjectOrIntOrString"
}

func (u Union3DataObjectOrIntOrString) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__DataObject__int__string",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3DataObjectOrIntOrString) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "String":
        return json.Marshal(u.variant_String)
    
    case "Int":
        return json.Marshal(u.variant_Int)
    
    case "DataObject":
        return json.Marshal(u.variant_DataObject)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3DataObjectOrIntOrString) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_String)
    if err == nil {
        u.variant = "String"
        return nil
    } else {
        u.variant_String = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Int)
    if err == nil {
        u.variant = "Int"
        return nil
    } else {
        u.variant_Int = nil
    }
    
    err = json.Unmarshal(data, &u.variant_DataObject)
    if err == nil {
        u.variant = "DataObject"
        return nil
    } else {
        u.variant_DataObject = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3DataObjectOrIntOrString__NewString(v string) Union3DataObjectOrIntOrString {
    
    return Union3DataObjectOrIntOrString{
        variant: "String",
        variant_String: &v,
    }
}

func (u *Union3DataObjectOrIntOrString) SetString(v string) {
    
    u.variant = "String"
    u.variant_String = &v
    
    u.variant_Int = nil
    
    u.variant_DataObject = nil
    
}

func (u *Union3DataObjectOrIntOrString) IsString() bool {
    return u.variant == "String"
}

func (u *Union3DataObjectOrIntOrString) AsString() *string {
    if u.variant != "String" {
        return nil
    }
    return u.variant_String
}

func Union3DataObjectOrIntOrString__NewInt(v int64) Union3DataObjectOrIntOrString {
    
    return Union3DataObjectOrIntOrString{
        variant: "Int",
        variant_Int: &v,
    }
}

func (u *Union3DataObjectOrIntOrString) SetInt(v int64) {
    
    u.variant = "Int"
    u.variant_Int = &v
    
    u.variant_String = nil
    
    u.variant_DataObject = nil
    
}

func (u *Union3DataObjectOrIntOrString) IsInt() bool {
    return u.variant == "Int"
}

func (u *Union3DataObjectOrIntOrString) AsInt() *int64 {
    if u.variant != "Int" {
        return nil
    }
    return u.variant_Int
}

func Union3DataObjectOrIntOrString__NewDataObject(v DataObject) Union3DataObjectOrIntOrString {
    
    return Union3DataObjectOrIntOrString{
        variant: "DataObject",
        variant_DataObject: &v,
    }
}

func (u *Union3DataObjectOrIntOrString) SetDataObject(v DataObject) {
    
    u.variant = "DataObject"
    u.variant_DataObject = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
}

func (u *Union3DataObjectOrIntOrString) IsDataObject() bool {
    return u.variant == "DataObject"
}

func (u *Union3DataObjectOrIntOrString) AsDataObject() *DataObject {
    if u.variant != "DataObject" {
        return nil
    }
    return u.variant_DataObject
}

type Union3FloatOrIntOrString struct {
    variant string
    
    variant_String *string
    
    variant_Int *int64
    
    variant_Float *float64
    
}

func (u *Union3FloatOrIntOrString) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string":
            u.variant = "String"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_String = &value
    case "int":
            u.variant = "Int"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_Int = &value
    case "float":
            u.variant = "Float"
            value := baml.Decode(valueHolder).Interface().(float64)
            u.variant_Float = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3FloatOrIntOrString) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "String":
        return baml.EncodeUnion(u.BamlEncodeName, "string", *u.variant_String)
    
    case "Int":
        return baml.EncodeUnion(u.BamlEncodeName, "int", *u.variant_Int)
    
    case "Float":
        return baml.EncodeUnion(u.BamlEncodeName, "float", *u.variant_Float)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3FloatOrIntOrString) BamlTypeName() string {
    return "Union3FloatOrIntOrString"
}

func (u Union3FloatOrIntOrString) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__float__int__string",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3FloatOrIntOrString) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "String":
        return json.Marshal(u.variant_String)
    
    case "Int":
        return json.Marshal(u.variant_Int)
    
    case "Float":
        return json.Marshal(u.variant_Float)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3FloatOrIntOrString) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_String)
    if err == nil {
        u.variant = "String"
        return nil
    } else {
        u.variant_String = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Int)
    if err == nil {
        u.variant = "Int"
        return nil
    } else {
        u.variant_Int = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Float)
    if err == nil {
        u.variant = "Float"
        return nil
    } else {
        u.variant_Float = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3FloatOrIntOrString__NewString(v string) Union3FloatOrIntOrString {
    
    return Union3FloatOrIntOrString{
        variant: "String",
        variant_String: &v,
    }
}

func (u *Union3FloatOrIntOrString) SetString(v string) {
    
    u.variant = "String"
    u.variant_String = &v
    
    u.variant_Int = nil
    
    u.variant_Float = nil
    
}

func (u *Union3FloatOrIntOrString) IsString() bool {
    return u.variant == "String"
}

func (u *Union3FloatOrIntOrString) AsString() *string {
    if u.variant != "String" {
        return nil
    }
    return u.variant_String
}

func Union3FloatOrIntOrString__NewInt(v int64) Union3FloatOrIntOrString {
    
    return Union3FloatOrIntOrString{
        variant: "Int",
        variant_Int: &v,
    }
}

func (u *Union3FloatOrIntOrString) SetInt(v int64) {
    
    u.variant = "Int"
    u.variant_Int = &v
    
    u.variant_String = nil
    
    u.variant_Float = nil
    
}

func (u *Union3FloatOrIntOrString) IsInt() bool {
    return u.variant == "Int"
}

func (u *Union3FloatOrIntOrString) AsInt() *int64 {
    if u.variant != "Int" {
        return nil
    }
    return u.variant_Int
}

func Union3FloatOrIntOrString__NewFloat(v float64) Union3FloatOrIntOrString {
    
    return Union3FloatOrIntOrString{
        variant: "Float",
        variant_Float: &v,
    }
}

func (u *Union3FloatOrIntOrString) SetFloat(v float64) {
    
    u.variant = "Float"
    u.variant_Float = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
}

func (u *Union3FloatOrIntOrString) IsFloat() bool {
    return u.variant == "Float"
}

func (u *Union3FloatOrIntOrString) AsFloat() *float64 {
    if u.variant != "Float" {
        return nil
    }
    return u.variant_Float
}

type Union3KandOrKnotOrKor struct {
    variant string
    
    variant_Kand *string
    
    variant_Kor *string
    
    variant_Knot *string
    
}

func (u *Union3KandOrKnotOrKor) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_and":
            u.variant = "Kand"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kand = &value
    case "string_or":
            u.variant = "Kor"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kor = &value
    case "string_not":
            u.variant = "Knot"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Knot = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KandOrKnotOrKor) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kand":
        return baml.EncodeUnion(u.BamlEncodeName, "string_and", *u.variant_Kand)
    
    case "Kor":
        return baml.EncodeUnion(u.BamlEncodeName, "string_or", *u.variant_Kor)
    
    case "Knot":
        return baml.EncodeUnion(u.BamlEncodeName, "string_not", *u.variant_Knot)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KandOrKnotOrKor) BamlTypeName() string {
    return "Union3KandOrKnotOrKor"
}

func (u Union3KandOrKnotOrKor) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_and__string_not__string_or",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KandOrKnotOrKor) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kand":
        return json.Marshal(u.variant_Kand)
    
    case "Kor":
        return json.Marshal(u.variant_Kor)
    
    case "Knot":
        return json.Marshal(u.variant_Knot)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KandOrKnotOrKor) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kand)
    if err == nil {
        u.variant = "Kand"
        return nil
    } else {
        u.variant_Kand = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kor)
    if err == nil {
        u.variant = "Kor"
        return nil
    } else {
        u.variant_Kor = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Knot)
    if err == nil {
        u.variant = "Knot"
        return nil
    } else {
        u.variant_Knot = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KandOrKnotOrKor__NewKand() Union3KandOrKnotOrKor {
    
    var v string = "and"
    
    return Union3KandOrKnotOrKor{
        variant: "Kand",
        variant_Kand: &v,
    }
}

func (u *Union3KandOrKnotOrKor) SetKand() {
    
    var v string = "and"
    
    u.variant = "Kand"
    u.variant_Kand = &v
    
    u.variant_Kor = nil
    
    u.variant_Knot = nil
    
}

func (u *Union3KandOrKnotOrKor) IsKand() bool {
    return u.variant == "Kand"
}

func (u *Union3KandOrKnotOrKor) AsKand() *string {
    if u.variant != "Kand" {
        return nil
    }
    return u.variant_Kand
}

func Union3KandOrKnotOrKor__NewKor() Union3KandOrKnotOrKor {
    
    var v string = "or"
    
    return Union3KandOrKnotOrKor{
        variant: "Kor",
        variant_Kor: &v,
    }
}

func (u *Union3KandOrKnotOrKor) SetKor() {
    
    var v string = "or"
    
    u.variant = "Kor"
    u.variant_Kor = &v
    
    u.variant_Kand = nil
    
    u.variant_Knot = nil
    
}

func (u *Union3KandOrKnotOrKor) IsKor() bool {
    return u.variant == "Kor"
}

func (u *Union3KandOrKnotOrKor) AsKor() *string {
    if u.variant != "Kor" {
        return nil
    }
    return u.variant_Kor
}

func Union3KandOrKnotOrKor__NewKnot() Union3KandOrKnotOrKor {
    
    var v string = "not"
    
    return Union3KandOrKnotOrKor{
        variant: "Knot",
        variant_Knot: &v,
    }
}

func (u *Union3KandOrKnotOrKor) SetKnot() {
    
    var v string = "not"
    
    u.variant = "Knot"
    u.variant_Knot = &v
    
    u.variant_Kand = nil
    
    u.variant_Kor = nil
    
}

func (u *Union3KandOrKnotOrKor) IsKnot() bool {
    return u.variant == "Knot"
}

func (u *Union3KandOrKnotOrKor) AsKnot() *string {
    if u.variant != "Knot" {
        return nil
    }
    return u.variant_Knot
}

type Union3KarchivedOrKdraftOrKpublished struct {
    variant string
    
    variant_Kdraft *string
    
    variant_Kpublished *string
    
    variant_Karchived *string
    
}

func (u *Union3KarchivedOrKdraftOrKpublished) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_draft":
            u.variant = "Kdraft"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kdraft = &value
    case "string_published":
            u.variant = "Kpublished"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kpublished = &value
    case "string_archived":
            u.variant = "Karchived"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Karchived = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KarchivedOrKdraftOrKpublished) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kdraft":
        return baml.EncodeUnion(u.BamlEncodeName, "string_draft", *u.variant_Kdraft)
    
    case "Kpublished":
        return baml.EncodeUnion(u.BamlEncodeName, "string_published", *u.variant_Kpublished)
    
    case "Karchived":
        return baml.EncodeUnion(u.BamlEncodeName, "string_archived", *u.variant_Karchived)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KarchivedOrKdraftOrKpublished) BamlTypeName() string {
    return "Union3KarchivedOrKdraftOrKpublished"
}

func (u Union3KarchivedOrKdraftOrKpublished) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_archived__string_draft__string_published",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KarchivedOrKdraftOrKpublished) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kdraft":
        return json.Marshal(u.variant_Kdraft)
    
    case "Kpublished":
        return json.Marshal(u.variant_Kpublished)
    
    case "Karchived":
        return json.Marshal(u.variant_Karchived)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KarchivedOrKdraftOrKpublished) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kdraft)
    if err == nil {
        u.variant = "Kdraft"
        return nil
    } else {
        u.variant_Kdraft = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kpublished)
    if err == nil {
        u.variant = "Kpublished"
        return nil
    } else {
        u.variant_Kpublished = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Karchived)
    if err == nil {
        u.variant = "Karchived"
        return nil
    } else {
        u.variant_Karchived = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KarchivedOrKdraftOrKpublished__NewKdraft() Union3KarchivedOrKdraftOrKpublished {
    
    var v string = "draft"
    
    return Union3KarchivedOrKdraftOrKpublished{
        variant: "Kdraft",
        variant_Kdraft: &v,
    }
}

func (u *Union3KarchivedOrKdraftOrKpublished) SetKdraft() {
    
    var v string = "draft"
    
    u.variant = "Kdraft"
    u.variant_Kdraft = &v
    
    u.variant_Kpublished = nil
    
    u.variant_Karchived = nil
    
}

func (u *Union3KarchivedOrKdraftOrKpublished) IsKdraft() bool {
    return u.variant == "Kdraft"
}

func (u *Union3KarchivedOrKdraftOrKpublished) AsKdraft() *string {
    if u.variant != "Kdraft" {
        return nil
    }
    return u.variant_Kdraft
}

func Union3KarchivedOrKdraftOrKpublished__NewKpublished() Union3KarchivedOrKdraftOrKpublished {
    
    var v string = "published"
    
    return Union3KarchivedOrKdraftOrKpublished{
        variant: "Kpublished",
        variant_Kpublished: &v,
    }
}

func (u *Union3KarchivedOrKdraftOrKpublished) SetKpublished() {
    
    var v string = "published"
    
    u.variant = "Kpublished"
    u.variant_Kpublished = &v
    
    u.variant_Kdraft = nil
    
    u.variant_Karchived = nil
    
}

func (u *Union3KarchivedOrKdraftOrKpublished) IsKpublished() bool {
    return u.variant == "Kpublished"
}

func (u *Union3KarchivedOrKdraftOrKpublished) AsKpublished() *string {
    if u.variant != "Kpublished" {
        return nil
    }
    return u.variant_Kpublished
}

func Union3KarchivedOrKdraftOrKpublished__NewKarchived() Union3KarchivedOrKdraftOrKpublished {
    
    var v string = "archived"
    
    return Union3KarchivedOrKdraftOrKpublished{
        variant: "Karchived",
        variant_Karchived: &v,
    }
}

func (u *Union3KarchivedOrKdraftOrKpublished) SetKarchived() {
    
    var v string = "archived"
    
    u.variant = "Karchived"
    u.variant_Karchived = &v
    
    u.variant_Kdraft = nil
    
    u.variant_Kpublished = nil
    
}

func (u *Union3KarchivedOrKdraftOrKpublished) IsKarchived() bool {
    return u.variant == "Karchived"
}

func (u *Union3KarchivedOrKdraftOrKpublished) AsKarchived() *string {
    if u.variant != "Karchived" {
        return nil
    }
    return u.variant_Karchived
}

type Union3KaudioOrKdocumentOrKimage struct {
    variant string
    
    variant_Kimage *string
    
    variant_Kaudio *string
    
    variant_Kdocument *string
    
}

func (u *Union3KaudioOrKdocumentOrKimage) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_image":
            u.variant = "Kimage"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kimage = &value
    case "string_audio":
            u.variant = "Kaudio"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kaudio = &value
    case "string_document":
            u.variant = "Kdocument"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kdocument = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KaudioOrKdocumentOrKimage) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kimage":
        return baml.EncodeUnion(u.BamlEncodeName, "string_image", *u.variant_Kimage)
    
    case "Kaudio":
        return baml.EncodeUnion(u.BamlEncodeName, "string_audio", *u.variant_Kaudio)
    
    case "Kdocument":
        return baml.EncodeUnion(u.BamlEncodeName, "string_document", *u.variant_Kdocument)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KaudioOrKdocumentOrKimage) BamlTypeName() string {
    return "Union3KaudioOrKdocumentOrKimage"
}

func (u Union3KaudioOrKdocumentOrKimage) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_audio__string_document__string_image",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KaudioOrKdocumentOrKimage) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kimage":
        return json.Marshal(u.variant_Kimage)
    
    case "Kaudio":
        return json.Marshal(u.variant_Kaudio)
    
    case "Kdocument":
        return json.Marshal(u.variant_Kdocument)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KaudioOrKdocumentOrKimage) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kimage)
    if err == nil {
        u.variant = "Kimage"
        return nil
    } else {
        u.variant_Kimage = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kaudio)
    if err == nil {
        u.variant = "Kaudio"
        return nil
    } else {
        u.variant_Kaudio = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kdocument)
    if err == nil {
        u.variant = "Kdocument"
        return nil
    } else {
        u.variant_Kdocument = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KaudioOrKdocumentOrKimage__NewKimage() Union3KaudioOrKdocumentOrKimage {
    
    var v string = "image"
    
    return Union3KaudioOrKdocumentOrKimage{
        variant: "Kimage",
        variant_Kimage: &v,
    }
}

func (u *Union3KaudioOrKdocumentOrKimage) SetKimage() {
    
    var v string = "image"
    
    u.variant = "Kimage"
    u.variant_Kimage = &v
    
    u.variant_Kaudio = nil
    
    u.variant_Kdocument = nil
    
}

func (u *Union3KaudioOrKdocumentOrKimage) IsKimage() bool {
    return u.variant == "Kimage"
}

func (u *Union3KaudioOrKdocumentOrKimage) AsKimage() *string {
    if u.variant != "Kimage" {
        return nil
    }
    return u.variant_Kimage
}

func Union3KaudioOrKdocumentOrKimage__NewKaudio() Union3KaudioOrKdocumentOrKimage {
    
    var v string = "audio"
    
    return Union3KaudioOrKdocumentOrKimage{
        variant: "Kaudio",
        variant_Kaudio: &v,
    }
}

func (u *Union3KaudioOrKdocumentOrKimage) SetKaudio() {
    
    var v string = "audio"
    
    u.variant = "Kaudio"
    u.variant_Kaudio = &v
    
    u.variant_Kimage = nil
    
    u.variant_Kdocument = nil
    
}

func (u *Union3KaudioOrKdocumentOrKimage) IsKaudio() bool {
    return u.variant == "Kaudio"
}

func (u *Union3KaudioOrKdocumentOrKimage) AsKaudio() *string {
    if u.variant != "Kaudio" {
        return nil
    }
    return u.variant_Kaudio
}

func Union3KaudioOrKdocumentOrKimage__NewKdocument() Union3KaudioOrKdocumentOrKimage {
    
    var v string = "document"
    
    return Union3KaudioOrKdocumentOrKimage{
        variant: "Kdocument",
        variant_Kdocument: &v,
    }
}

func (u *Union3KaudioOrKdocumentOrKimage) SetKdocument() {
    
    var v string = "document"
    
    u.variant = "Kdocument"
    u.variant_Kdocument = &v
    
    u.variant_Kimage = nil
    
    u.variant_Kaudio = nil
    
}

func (u *Union3KaudioOrKdocumentOrKimage) IsKdocument() bool {
    return u.variant == "Kdocument"
}

func (u *Union3KaudioOrKdocumentOrKimage) AsKdocument() *string {
    if u.variant != "Kdocument" {
        return nil
    }
    return u.variant_Kdocument
}

type Union3KflexOrKgridOrKstack struct {
    variant string
    
    variant_Kflex *string
    
    variant_Kgrid *string
    
    variant_Kstack *string
    
}

func (u *Union3KflexOrKgridOrKstack) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_flex":
            u.variant = "Kflex"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kflex = &value
    case "string_grid":
            u.variant = "Kgrid"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kgrid = &value
    case "string_stack":
            u.variant = "Kstack"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kstack = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KflexOrKgridOrKstack) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kflex":
        return baml.EncodeUnion(u.BamlEncodeName, "string_flex", *u.variant_Kflex)
    
    case "Kgrid":
        return baml.EncodeUnion(u.BamlEncodeName, "string_grid", *u.variant_Kgrid)
    
    case "Kstack":
        return baml.EncodeUnion(u.BamlEncodeName, "string_stack", *u.variant_Kstack)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KflexOrKgridOrKstack) BamlTypeName() string {
    return "Union3KflexOrKgridOrKstack"
}

func (u Union3KflexOrKgridOrKstack) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_flex__string_grid__string_stack",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KflexOrKgridOrKstack) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kflex":
        return json.Marshal(u.variant_Kflex)
    
    case "Kgrid":
        return json.Marshal(u.variant_Kgrid)
    
    case "Kstack":
        return json.Marshal(u.variant_Kstack)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KflexOrKgridOrKstack) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kflex)
    if err == nil {
        u.variant = "Kflex"
        return nil
    } else {
        u.variant_Kflex = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kgrid)
    if err == nil {
        u.variant = "Kgrid"
        return nil
    } else {
        u.variant_Kgrid = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kstack)
    if err == nil {
        u.variant = "Kstack"
        return nil
    } else {
        u.variant_Kstack = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KflexOrKgridOrKstack__NewKflex() Union3KflexOrKgridOrKstack {
    
    var v string = "flex"
    
    return Union3KflexOrKgridOrKstack{
        variant: "Kflex",
        variant_Kflex: &v,
    }
}

func (u *Union3KflexOrKgridOrKstack) SetKflex() {
    
    var v string = "flex"
    
    u.variant = "Kflex"
    u.variant_Kflex = &v
    
    u.variant_Kgrid = nil
    
    u.variant_Kstack = nil
    
}

func (u *Union3KflexOrKgridOrKstack) IsKflex() bool {
    return u.variant == "Kflex"
}

func (u *Union3KflexOrKgridOrKstack) AsKflex() *string {
    if u.variant != "Kflex" {
        return nil
    }
    return u.variant_Kflex
}

func Union3KflexOrKgridOrKstack__NewKgrid() Union3KflexOrKgridOrKstack {
    
    var v string = "grid"
    
    return Union3KflexOrKgridOrKstack{
        variant: "Kgrid",
        variant_Kgrid: &v,
    }
}

func (u *Union3KflexOrKgridOrKstack) SetKgrid() {
    
    var v string = "grid"
    
    u.variant = "Kgrid"
    u.variant_Kgrid = &v
    
    u.variant_Kflex = nil
    
    u.variant_Kstack = nil
    
}

func (u *Union3KflexOrKgridOrKstack) IsKgrid() bool {
    return u.variant == "Kgrid"
}

func (u *Union3KflexOrKgridOrKstack) AsKgrid() *string {
    if u.variant != "Kgrid" {
        return nil
    }
    return u.variant_Kgrid
}

func Union3KflexOrKgridOrKstack__NewKstack() Union3KflexOrKgridOrKstack {
    
    var v string = "stack"
    
    return Union3KflexOrKgridOrKstack{
        variant: "Kstack",
        variant_Kstack: &v,
    }
}

func (u *Union3KflexOrKgridOrKstack) SetKstack() {
    
    var v string = "stack"
    
    u.variant = "Kstack"
    u.variant_Kstack = &v
    
    u.variant_Kflex = nil
    
    u.variant_Kgrid = nil
    
}

func (u *Union3KflexOrKgridOrKstack) IsKstack() bool {
    return u.variant == "Kstack"
}

func (u *Union3KflexOrKgridOrKstack) AsKstack() *string {
    if u.variant != "Kstack" {
        return nil
    }
    return u.variant_Kstack
}

type Union3KhtmlOrKmarkdownOrKplain struct {
    variant string
    
    variant_Kplain *string
    
    variant_Kmarkdown *string
    
    variant_Khtml *string
    
}

func (u *Union3KhtmlOrKmarkdownOrKplain) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_plain":
            u.variant = "Kplain"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kplain = &value
    case "string_markdown":
            u.variant = "Kmarkdown"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kmarkdown = &value
    case "string_html":
            u.variant = "Khtml"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Khtml = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union3KhtmlOrKmarkdownOrKplain) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kplain":
        return baml.EncodeUnion(u.BamlEncodeName, "string_plain", *u.variant_Kplain)
    
    case "Kmarkdown":
        return baml.EncodeUnion(u.BamlEncodeName, "string_markdown", *u.variant_Kmarkdown)
    
    case "Khtml":
        return baml.EncodeUnion(u.BamlEncodeName, "string_html", *u.variant_Khtml)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union3KhtmlOrKmarkdownOrKplain) BamlTypeName() string {
    return "Union3KhtmlOrKmarkdownOrKplain"
}

func (u Union3KhtmlOrKmarkdownOrKplain) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_html__string_markdown__string_plain",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union3KhtmlOrKmarkdownOrKplain) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kplain":
        return json.Marshal(u.variant_Kplain)
    
    case "Kmarkdown":
        return json.Marshal(u.variant_Kmarkdown)
    
    case "Khtml":
        return json.Marshal(u.variant_Khtml)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union3KhtmlOrKmarkdownOrKplain) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kplain)
    if err == nil {
        u.variant = "Kplain"
        return nil
    } else {
        u.variant_Kplain = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kmarkdown)
    if err == nil {
        u.variant = "Kmarkdown"
        return nil
    } else {
        u.variant_Kmarkdown = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Khtml)
    if err == nil {
        u.variant = "Khtml"
        return nil
    } else {
        u.variant_Khtml = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union3KhtmlOrKmarkdownOrKplain__NewKplain() Union3KhtmlOrKmarkdownOrKplain {
    
    var v string = "plain"
    
    return Union3KhtmlOrKmarkdownOrKplain{
        variant: "Kplain",
        variant_Kplain: &v,
    }
}

func (u *Union3KhtmlOrKmarkdownOrKplain) SetKplain() {
    
    var v string = "plain"
    
    u.variant = "Kplain"
    u.variant_Kplain = &v
    
    u.variant_Kmarkdown = nil
    
    u.variant_Khtml = nil
    
}

func (u *Union3KhtmlOrKmarkdownOrKplain) IsKplain() bool {
    return u.variant == "Kplain"
}

func (u *Union3KhtmlOrKmarkdownOrKplain) AsKplain() *string {
    if u.variant != "Kplain" {
        return nil
    }
    return u.variant_Kplain
}

func Union3KhtmlOrKmarkdownOrKplain__NewKmarkdown() Union3KhtmlOrKmarkdownOrKplain {
    
    var v string = "markdown"
    
    return Union3KhtmlOrKmarkdownOrKplain{
        variant: "Kmarkdown",
        variant_Kmarkdown: &v,
    }
}

func (u *Union3KhtmlOrKmarkdownOrKplain) SetKmarkdown() {
    
    var v string = "markdown"
    
    u.variant = "Kmarkdown"
    u.variant_Kmarkdown = &v
    
    u.variant_Kplain = nil
    
    u.variant_Khtml = nil
    
}

func (u *Union3KhtmlOrKmarkdownOrKplain) IsKmarkdown() bool {
    return u.variant == "Kmarkdown"
}

func (u *Union3KhtmlOrKmarkdownOrKplain) AsKmarkdown() *string {
    if u.variant != "Kmarkdown" {
        return nil
    }
    return u.variant_Kmarkdown
}

func Union3KhtmlOrKmarkdownOrKplain__NewKhtml() Union3KhtmlOrKmarkdownOrKplain {
    
    var v string = "html"
    
    return Union3KhtmlOrKmarkdownOrKplain{
        variant: "Khtml",
        variant_Khtml: &v,
    }
}

func (u *Union3KhtmlOrKmarkdownOrKplain) SetKhtml() {
    
    var v string = "html"
    
    u.variant = "Khtml"
    u.variant_Khtml = &v
    
    u.variant_Kplain = nil
    
    u.variant_Kmarkdown = nil
    
}

func (u *Union3KhtmlOrKmarkdownOrKplain) IsKhtml() bool {
    return u.variant == "Khtml"
}

func (u *Union3KhtmlOrKmarkdownOrKplain) AsKhtml() *string {
    if u.variant != "Khtml" {
        return nil
    }
    return u.variant_Khtml
}

type Union4BoolOrFloatOrIntOrString struct {
    variant string
    
    variant_String *string
    
    variant_Int *int64
    
    variant_Float *float64
    
    variant_Bool *bool
    
}

func (u *Union4BoolOrFloatOrIntOrString) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string":
            u.variant = "String"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_String = &value
    case "int":
            u.variant = "Int"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_Int = &value
    case "float":
            u.variant = "Float"
            value := baml.Decode(valueHolder).Interface().(float64)
            u.variant_Float = &value
    case "bool":
            u.variant = "Bool"
            value := baml.Decode(valueHolder).Interface().(bool)
            u.variant_Bool = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union4BoolOrFloatOrIntOrString) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "String":
        return baml.EncodeUnion(u.BamlEncodeName, "string", *u.variant_String)
    
    case "Int":
        return baml.EncodeUnion(u.BamlEncodeName, "int", *u.variant_Int)
    
    case "Float":
        return baml.EncodeUnion(u.BamlEncodeName, "float", *u.variant_Float)
    
    case "Bool":
        return baml.EncodeUnion(u.BamlEncodeName, "bool", *u.variant_Bool)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union4BoolOrFloatOrIntOrString) BamlTypeName() string {
    return "Union4BoolOrFloatOrIntOrString"
}

func (u Union4BoolOrFloatOrIntOrString) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__bool__float__int__string",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union4BoolOrFloatOrIntOrString) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "String":
        return json.Marshal(u.variant_String)
    
    case "Int":
        return json.Marshal(u.variant_Int)
    
    case "Float":
        return json.Marshal(u.variant_Float)
    
    case "Bool":
        return json.Marshal(u.variant_Bool)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union4BoolOrFloatOrIntOrString) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_String)
    if err == nil {
        u.variant = "String"
        return nil
    } else {
        u.variant_String = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Int)
    if err == nil {
        u.variant = "Int"
        return nil
    } else {
        u.variant_Int = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Float)
    if err == nil {
        u.variant = "Float"
        return nil
    } else {
        u.variant_Float = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Bool)
    if err == nil {
        u.variant = "Bool"
        return nil
    } else {
        u.variant_Bool = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union4BoolOrFloatOrIntOrString__NewString(v string) Union4BoolOrFloatOrIntOrString {
    
    return Union4BoolOrFloatOrIntOrString{
        variant: "String",
        variant_String: &v,
    }
}

func (u *Union4BoolOrFloatOrIntOrString) SetString(v string) {
    
    u.variant = "String"
    u.variant_String = &v
    
    u.variant_Int = nil
    
    u.variant_Float = nil
    
    u.variant_Bool = nil
    
}

func (u *Union4BoolOrFloatOrIntOrString) IsString() bool {
    return u.variant == "String"
}

func (u *Union4BoolOrFloatOrIntOrString) AsString() *string {
    if u.variant != "String" {
        return nil
    }
    return u.variant_String
}

func Union4BoolOrFloatOrIntOrString__NewInt(v int64) Union4BoolOrFloatOrIntOrString {
    
    return Union4BoolOrFloatOrIntOrString{
        variant: "Int",
        variant_Int: &v,
    }
}

func (u *Union4BoolOrFloatOrIntOrString) SetInt(v int64) {
    
    u.variant = "Int"
    u.variant_Int = &v
    
    u.variant_String = nil
    
    u.variant_Float = nil
    
    u.variant_Bool = nil
    
}

func (u *Union4BoolOrFloatOrIntOrString) IsInt() bool {
    return u.variant == "Int"
}

func (u *Union4BoolOrFloatOrIntOrString) AsInt() *int64 {
    if u.variant != "Int" {
        return nil
    }
    return u.variant_Int
}

func Union4BoolOrFloatOrIntOrString__NewFloat(v float64) Union4BoolOrFloatOrIntOrString {
    
    return Union4BoolOrFloatOrIntOrString{
        variant: "Float",
        variant_Float: &v,
    }
}

func (u *Union4BoolOrFloatOrIntOrString) SetFloat(v float64) {
    
    u.variant = "Float"
    u.variant_Float = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
    u.variant_Bool = nil
    
}

func (u *Union4BoolOrFloatOrIntOrString) IsFloat() bool {
    return u.variant == "Float"
}

func (u *Union4BoolOrFloatOrIntOrString) AsFloat() *float64 {
    if u.variant != "Float" {
        return nil
    }
    return u.variant_Float
}

func Union4BoolOrFloatOrIntOrString__NewBool(v bool) Union4BoolOrFloatOrIntOrString {
    
    return Union4BoolOrFloatOrIntOrString{
        variant: "Bool",
        variant_Bool: &v,
    }
}

func (u *Union4BoolOrFloatOrIntOrString) SetBool(v bool) {
    
    u.variant = "Bool"
    u.variant_Bool = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
    u.variant_Float = nil
    
}

func (u *Union4BoolOrFloatOrIntOrString) IsBool() bool {
    return u.variant == "Bool"
}

func (u *Union4BoolOrFloatOrIntOrString) AsBool() *bool {
    if u.variant != "Bool" {
        return nil
    }
    return u.variant_Bool
}

type Union4IntOrListNodeOrMapStringKeyNodeValueOrString struct {
    variant string
    
    variant_String *string
    
    variant_Int *int64
    
    variant_ListNode *[]Node
    
    variant_MapStringKeyNodeValue *map[string]Node
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string":
            u.variant = "String"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_String = &value
    case "int":
            u.variant = "Int"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_Int = &value
    case "List__Node":
            u.variant = "ListNode"
            value := baml.Decode(valueHolder).Interface().([]Node)
            u.variant_ListNode = &value
    case "Map__string_Node":
            u.variant = "MapStringKeyNodeValue"
            value := baml.Decode(valueHolder).Interface().(map[string]Node)
            u.variant_MapStringKeyNodeValue = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union4IntOrListNodeOrMapStringKeyNodeValueOrString) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "String":
        return baml.EncodeUnion(u.BamlEncodeName, "string", *u.variant_String)
    
    case "Int":
        return baml.EncodeUnion(u.BamlEncodeName, "int", *u.variant_Int)
    
    case "ListNode":
        return baml.EncodeUnion(u.BamlEncodeName, "List__Node", *u.variant_ListNode)
    
    case "MapStringKeyNodeValue":
        return baml.EncodeUnion(u.BamlEncodeName, "Map__string_Node", *u.variant_MapStringKeyNodeValue)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union4IntOrListNodeOrMapStringKeyNodeValueOrString) BamlTypeName() string {
    return "Union4IntOrListNodeOrMapStringKeyNodeValueOrString"
}

func (u Union4IntOrListNodeOrMapStringKeyNodeValueOrString) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__List__Node__Map__string_Node__int__string",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union4IntOrListNodeOrMapStringKeyNodeValueOrString) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "String":
        return json.Marshal(u.variant_String)
    
    case "Int":
        return json.Marshal(u.variant_Int)
    
    case "ListNode":
        return json.Marshal(u.variant_ListNode)
    
    case "MapStringKeyNodeValue":
        return json.Marshal(u.variant_MapStringKeyNodeValue)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_String)
    if err == nil {
        u.variant = "String"
        return nil
    } else {
        u.variant_String = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Int)
    if err == nil {
        u.variant = "Int"
        return nil
    } else {
        u.variant_Int = nil
    }
    
    err = json.Unmarshal(data, &u.variant_ListNode)
    if err == nil {
        u.variant = "ListNode"
        return nil
    } else {
        u.variant_ListNode = nil
    }
    
    err = json.Unmarshal(data, &u.variant_MapStringKeyNodeValue)
    if err == nil {
        u.variant = "MapStringKeyNodeValue"
        return nil
    } else {
        u.variant_MapStringKeyNodeValue = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union4IntOrListNodeOrMapStringKeyNodeValueOrString__NewString(v string) Union4IntOrListNodeOrMapStringKeyNodeValueOrString {
    
    return Union4IntOrListNodeOrMapStringKeyNodeValueOrString{
        variant: "String",
        variant_String: &v,
    }
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) SetString(v string) {
    
    u.variant = "String"
    u.variant_String = &v
    
    u.variant_Int = nil
    
    u.variant_ListNode = nil
    
    u.variant_MapStringKeyNodeValue = nil
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) IsString() bool {
    return u.variant == "String"
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) AsString() *string {
    if u.variant != "String" {
        return nil
    }
    return u.variant_String
}

func Union4IntOrListNodeOrMapStringKeyNodeValueOrString__NewInt(v int64) Union4IntOrListNodeOrMapStringKeyNodeValueOrString {
    
    return Union4IntOrListNodeOrMapStringKeyNodeValueOrString{
        variant: "Int",
        variant_Int: &v,
    }
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) SetInt(v int64) {
    
    u.variant = "Int"
    u.variant_Int = &v
    
    u.variant_String = nil
    
    u.variant_ListNode = nil
    
    u.variant_MapStringKeyNodeValue = nil
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) IsInt() bool {
    return u.variant == "Int"
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) AsInt() *int64 {
    if u.variant != "Int" {
        return nil
    }
    return u.variant_Int
}

func Union4IntOrListNodeOrMapStringKeyNodeValueOrString__NewListNode(v []Node) Union4IntOrListNodeOrMapStringKeyNodeValueOrString {
    
    return Union4IntOrListNodeOrMapStringKeyNodeValueOrString{
        variant: "ListNode",
        variant_ListNode: &v,
    }
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) SetListNode(v []Node) {
    
    u.variant = "ListNode"
    u.variant_ListNode = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
    u.variant_MapStringKeyNodeValue = nil
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) IsListNode() bool {
    return u.variant == "ListNode"
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) AsListNode() *[]Node {
    if u.variant != "ListNode" {
        return nil
    }
    return u.variant_ListNode
}

func Union4IntOrListNodeOrMapStringKeyNodeValueOrString__NewMapStringKeyNodeValue(v map[string]Node) Union4IntOrListNodeOrMapStringKeyNodeValueOrString {
    
    return Union4IntOrListNodeOrMapStringKeyNodeValueOrString{
        variant: "MapStringKeyNodeValue",
        variant_MapStringKeyNodeValue: &v,
    }
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) SetMapStringKeyNodeValue(v map[string]Node) {
    
    u.variant = "MapStringKeyNodeValue"
    u.variant_MapStringKeyNodeValue = &v
    
    u.variant_String = nil
    
    u.variant_Int = nil
    
    u.variant_ListNode = nil
    
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) IsMapStringKeyNodeValue() bool {
    return u.variant == "MapStringKeyNodeValue"
}

func (u *Union4IntOrListNodeOrMapStringKeyNodeValueOrString) AsMapStringKeyNodeValue() *map[string]Node {
    if u.variant != "MapStringKeyNodeValue" {
        return nil
    }
    return u.variant_MapStringKeyNodeValue
}

type Union4KbuttonOrKcontainerOrKimageOrKtext struct {
    variant string
    
    variant_Kbutton *string
    
    variant_Ktext *string
    
    variant_Kimage *string
    
    variant_Kcontainer *string
    
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_button":
            u.variant = "Kbutton"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kbutton = &value
    case "string_text":
            u.variant = "Ktext"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Ktext = &value
    case "string_image":
            u.variant = "Kimage"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kimage = &value
    case "string_container":
            u.variant = "Kcontainer"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kcontainer = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union4KbuttonOrKcontainerOrKimageOrKtext) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Kbutton":
        return baml.EncodeUnion(u.BamlEncodeName, "string_button", *u.variant_Kbutton)
    
    case "Ktext":
        return baml.EncodeUnion(u.BamlEncodeName, "string_text", *u.variant_Ktext)
    
    case "Kimage":
        return baml.EncodeUnion(u.BamlEncodeName, "string_image", *u.variant_Kimage)
    
    case "Kcontainer":
        return baml.EncodeUnion(u.BamlEncodeName, "string_container", *u.variant_Kcontainer)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union4KbuttonOrKcontainerOrKimageOrKtext) BamlTypeName() string {
    return "Union4KbuttonOrKcontainerOrKimageOrKtext"
}

func (u Union4KbuttonOrKcontainerOrKimageOrKtext) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_button__string_container__string_image__string_text",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union4KbuttonOrKcontainerOrKimageOrKtext) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Kbutton":
        return json.Marshal(u.variant_Kbutton)
    
    case "Ktext":
        return json.Marshal(u.variant_Ktext)
    
    case "Kimage":
        return json.Marshal(u.variant_Kimage)
    
    case "Kcontainer":
        return json.Marshal(u.variant_Kcontainer)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Kbutton)
    if err == nil {
        u.variant = "Kbutton"
        return nil
    } else {
        u.variant_Kbutton = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Ktext)
    if err == nil {
        u.variant = "Ktext"
        return nil
    } else {
        u.variant_Ktext = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kimage)
    if err == nil {
        u.variant = "Kimage"
        return nil
    } else {
        u.variant_Kimage = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kcontainer)
    if err == nil {
        u.variant = "Kcontainer"
        return nil
    } else {
        u.variant_Kcontainer = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union4KbuttonOrKcontainerOrKimageOrKtext__NewKbutton() Union4KbuttonOrKcontainerOrKimageOrKtext {
    
    var v string = "button"
    
    return Union4KbuttonOrKcontainerOrKimageOrKtext{
        variant: "Kbutton",
        variant_Kbutton: &v,
    }
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) SetKbutton() {
    
    var v string = "button"
    
    u.variant = "Kbutton"
    u.variant_Kbutton = &v
    
    u.variant_Ktext = nil
    
    u.variant_Kimage = nil
    
    u.variant_Kcontainer = nil
    
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) IsKbutton() bool {
    return u.variant == "Kbutton"
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) AsKbutton() *string {
    if u.variant != "Kbutton" {
        return nil
    }
    return u.variant_Kbutton
}

func Union4KbuttonOrKcontainerOrKimageOrKtext__NewKtext() Union4KbuttonOrKcontainerOrKimageOrKtext {
    
    var v string = "text"
    
    return Union4KbuttonOrKcontainerOrKimageOrKtext{
        variant: "Ktext",
        variant_Ktext: &v,
    }
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) SetKtext() {
    
    var v string = "text"
    
    u.variant = "Ktext"
    u.variant_Ktext = &v
    
    u.variant_Kbutton = nil
    
    u.variant_Kimage = nil
    
    u.variant_Kcontainer = nil
    
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) IsKtext() bool {
    return u.variant == "Ktext"
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) AsKtext() *string {
    if u.variant != "Ktext" {
        return nil
    }
    return u.variant_Ktext
}

func Union4KbuttonOrKcontainerOrKimageOrKtext__NewKimage() Union4KbuttonOrKcontainerOrKimageOrKtext {
    
    var v string = "image"
    
    return Union4KbuttonOrKcontainerOrKimageOrKtext{
        variant: "Kimage",
        variant_Kimage: &v,
    }
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) SetKimage() {
    
    var v string = "image"
    
    u.variant = "Kimage"
    u.variant_Kimage = &v
    
    u.variant_Kbutton = nil
    
    u.variant_Ktext = nil
    
    u.variant_Kcontainer = nil
    
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) IsKimage() bool {
    return u.variant == "Kimage"
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) AsKimage() *string {
    if u.variant != "Kimage" {
        return nil
    }
    return u.variant_Kimage
}

func Union4KbuttonOrKcontainerOrKimageOrKtext__NewKcontainer() Union4KbuttonOrKcontainerOrKimageOrKtext {
    
    var v string = "container"
    
    return Union4KbuttonOrKcontainerOrKimageOrKtext{
        variant: "Kcontainer",
        variant_Kcontainer: &v,
    }
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) SetKcontainer() {
    
    var v string = "container"
    
    u.variant = "Kcontainer"
    u.variant_Kcontainer = &v
    
    u.variant_Kbutton = nil
    
    u.variant_Ktext = nil
    
    u.variant_Kimage = nil
    
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) IsKcontainer() bool {
    return u.variant == "Kcontainer"
}

func (u *Union4KbuttonOrKcontainerOrKimageOrKtext) AsKcontainer() *string {
    if u.variant != "Kcontainer" {
        return nil
    }
    return u.variant_Kcontainer
}

type Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 struct {
    variant string
    
    variant_IntK1 *int64
    
    variant_IntK2 *int64
    
    variant_IntK3 *int64
    
    variant_IntK4 *int64
    
    variant_IntK5 *int64
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "int_1":
            u.variant = "IntK1"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK1 = &value
    case "int_2":
            u.variant = "IntK2"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK2 = &value
    case "int_3":
            u.variant = "IntK3"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK3 = &value
    case "int_4":
            u.variant = "IntK4"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK4 = &value
    case "int_5":
            u.variant = "IntK5"
            value := baml.Decode(valueHolder).Interface().(int64)
            u.variant_IntK5 = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "IntK1":
        return baml.EncodeUnion(u.BamlEncodeName, "int_1", *u.variant_IntK1)
    
    case "IntK2":
        return baml.EncodeUnion(u.BamlEncodeName, "int_2", *u.variant_IntK2)
    
    case "IntK3":
        return baml.EncodeUnion(u.BamlEncodeName, "int_3", *u.variant_IntK3)
    
    case "IntK4":
        return baml.EncodeUnion(u.BamlEncodeName, "int_4", *u.variant_IntK4)
    
    case "IntK5":
        return baml.EncodeUnion(u.BamlEncodeName, "int_5", *u.variant_IntK5)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) BamlTypeName() string {
    return "Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5"
}

func (u Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__int_1__int_2__int_3__int_4__int_5",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "IntK1":
        return json.Marshal(u.variant_IntK1)
    
    case "IntK2":
        return json.Marshal(u.variant_IntK2)
    
    case "IntK3":
        return json.Marshal(u.variant_IntK3)
    
    case "IntK4":
        return json.Marshal(u.variant_IntK4)
    
    case "IntK5":
        return json.Marshal(u.variant_IntK5)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_IntK1)
    if err == nil {
        u.variant = "IntK1"
        return nil
    } else {
        u.variant_IntK1 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK2)
    if err == nil {
        u.variant = "IntK2"
        return nil
    } else {
        u.variant_IntK2 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK3)
    if err == nil {
        u.variant = "IntK3"
        return nil
    } else {
        u.variant_IntK3 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK4)
    if err == nil {
        u.variant = "IntK4"
        return nil
    } else {
        u.variant_IntK4 = nil
    }
    
    err = json.Unmarshal(data, &u.variant_IntK5)
    if err == nil {
        u.variant = "IntK5"
        return nil
    } else {
        u.variant_IntK5 = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK1() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 1
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK1",
        variant_IntK1: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK1() {
    
    var v int64 = 1
    
    u.variant = "IntK1"
    u.variant_IntK1 = &v
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK4 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK1() bool {
    return u.variant == "IntK1"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK1() *int64 {
    if u.variant != "IntK1" {
        return nil
    }
    return u.variant_IntK1
}

func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK2() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 2
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK2",
        variant_IntK2: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK2() {
    
    var v int64 = 2
    
    u.variant = "IntK2"
    u.variant_IntK2 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK4 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK2() bool {
    return u.variant == "IntK2"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK2() *int64 {
    if u.variant != "IntK2" {
        return nil
    }
    return u.variant_IntK2
}

func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK3() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 3
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK3",
        variant_IntK3: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK3() {
    
    var v int64 = 3
    
    u.variant = "IntK3"
    u.variant_IntK3 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK4 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK3() bool {
    return u.variant == "IntK3"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK3() *int64 {
    if u.variant != "IntK3" {
        return nil
    }
    return u.variant_IntK3
}

func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK4() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 4
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK4",
        variant_IntK4: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK4() {
    
    var v int64 = 4
    
    u.variant = "IntK4"
    u.variant_IntK4 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK5 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK4() bool {
    return u.variant == "IntK4"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK4() *int64 {
    if u.variant != "IntK4" {
        return nil
    }
    return u.variant_IntK4
}

func Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5__NewIntK5() Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5 {
    
    var v int64 = 5
    
    return Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5{
        variant: "IntK5",
        variant_IntK5: &v,
    }
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) SetIntK5() {
    
    var v int64 = 5
    
    u.variant = "IntK5"
    u.variant_IntK5 = &v
    
    u.variant_IntK1 = nil
    
    u.variant_IntK2 = nil
    
    u.variant_IntK3 = nil
    
    u.variant_IntK4 = nil
    
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) IsIntK5() bool {
    return u.variant == "IntK5"
}

func (u *Union5IntK1OrIntK2OrIntK3OrIntK4OrIntK5) AsIntK5() *int64 {
    if u.variant != "IntK5" {
        return nil
    }
    return u.variant_IntK5
}

type Union5KcontainsOrKeqOrKgtOrKltOrKne struct {
    variant string
    
    variant_Keq *string
    
    variant_Kne *string
    
    variant_Kgt *string
    
    variant_Klt *string
    
    variant_Kcontains *string
    
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) Decode(holder *cffi.CFFIValueUnionVariant, typeMap baml.TypeMap) {
    valueHolder := holder.Value
    variantName := holder.VariantName
	switch variantName {
    case "string_eq":
            u.variant = "Keq"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Keq = &value
    case "string_ne":
            u.variant = "Kne"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kne = &value
    case "string_gt":
            u.variant = "Kgt"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kgt = &value
    case "string_lt":
            u.variant = "Klt"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Klt = &value
    case "string_contains":
            u.variant = "Kcontains"
            value := baml.Decode(valueHolder).Interface().(string)
            u.variant_Kcontains = &value
    
    default:
        panic(fmt.Sprintf("invalid union variant: %s", variantName))
	}
}


func (u Union5KcontainsOrKeqOrKgtOrKltOrKne) Encode() (*cffi.CFFIValueHolder, error) {
    switch u.variant {
    
    case "Keq":
        return baml.EncodeUnion(u.BamlEncodeName, "string_eq", *u.variant_Keq)
    
    case "Kne":
        return baml.EncodeUnion(u.BamlEncodeName, "string_ne", *u.variant_Kne)
    
    case "Kgt":
        return baml.EncodeUnion(u.BamlEncodeName, "string_gt", *u.variant_Kgt)
    
    case "Klt":
        return baml.EncodeUnion(u.BamlEncodeName, "string_lt", *u.variant_Klt)
    
    case "Kcontains":
        return baml.EncodeUnion(u.BamlEncodeName, "string_contains", *u.variant_Kcontains)
    
    case "":
        return nil, fmt.Errorf("invalid union variant: [unset]")
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u Union5KcontainsOrKeqOrKgtOrKltOrKne) BamlTypeName() string {
    return "Union5KcontainsOrKeqOrKgtOrKltOrKne"
}

func (u Union5KcontainsOrKeqOrKgtOrKltOrKne) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Name:      "Union__string_contains__string_eq__string_gt__string_lt__string_ne",
        Namespace: cffi.CFFITypeNamespace_TYPES,
    }
}

func (u Union5KcontainsOrKeqOrKgtOrKltOrKne) MarshalJSON() ([]byte, error) {
    switch u.variant {
    
    case "Keq":
        return json.Marshal(u.variant_Keq)
    
    case "Kne":
        return json.Marshal(u.variant_Kne)
    
    case "Kgt":
        return json.Marshal(u.variant_Kgt)
    
    case "Klt":
        return json.Marshal(u.variant_Klt)
    
    case "Kcontains":
        return json.Marshal(u.variant_Kcontains)
    
    }

    return nil, fmt.Errorf("invalid union variant: %s", u.variant)
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) UnmarshalJSON(data []byte) error {
    var err error
    
    err = json.Unmarshal(data, &u.variant_Keq)
    if err == nil {
        u.variant = "Keq"
        return nil
    } else {
        u.variant_Keq = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kne)
    if err == nil {
        u.variant = "Kne"
        return nil
    } else {
        u.variant_Kne = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kgt)
    if err == nil {
        u.variant = "Kgt"
        return nil
    } else {
        u.variant_Kgt = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Klt)
    if err == nil {
        u.variant = "Klt"
        return nil
    } else {
        u.variant_Klt = nil
    }
    
    err = json.Unmarshal(data, &u.variant_Kcontains)
    if err == nil {
        u.variant = "Kcontains"
        return nil
    } else {
        u.variant_Kcontains = nil
    }
    
    return fmt.Errorf("invalid union variant: %s", string(data))
}


func Union5KcontainsOrKeqOrKgtOrKltOrKne__NewKeq() Union5KcontainsOrKeqOrKgtOrKltOrKne {
    
    var v string = "eq"
    
    return Union5KcontainsOrKeqOrKgtOrKltOrKne{
        variant: "Keq",
        variant_Keq: &v,
    }
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) SetKeq() {
    
    var v string = "eq"
    
    u.variant = "Keq"
    u.variant_Keq = &v
    
    u.variant_Kne = nil
    
    u.variant_Kgt = nil
    
    u.variant_Klt = nil
    
    u.variant_Kcontains = nil
    
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) IsKeq() bool {
    return u.variant == "Keq"
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) AsKeq() *string {
    if u.variant != "Keq" {
        return nil
    }
    return u.variant_Keq
}

func Union5KcontainsOrKeqOrKgtOrKltOrKne__NewKne() Union5KcontainsOrKeqOrKgtOrKltOrKne {
    
    var v string = "ne"
    
    return Union5KcontainsOrKeqOrKgtOrKltOrKne{
        variant: "Kne",
        variant_Kne: &v,
    }
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) SetKne() {
    
    var v string = "ne"
    
    u.variant = "Kne"
    u.variant_Kne = &v
    
    u.variant_Keq = nil
    
    u.variant_Kgt = nil
    
    u.variant_Klt = nil
    
    u.variant_Kcontains = nil
    
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) IsKne() bool {
    return u.variant == "Kne"
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) AsKne() *string {
    if u.variant != "Kne" {
        return nil
    }
    return u.variant_Kne
}

func Union5KcontainsOrKeqOrKgtOrKltOrKne__NewKgt() Union5KcontainsOrKeqOrKgtOrKltOrKne {
    
    var v string = "gt"
    
    return Union5KcontainsOrKeqOrKgtOrKltOrKne{
        variant: "Kgt",
        variant_Kgt: &v,
    }
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) SetKgt() {
    
    var v string = "gt"
    
    u.variant = "Kgt"
    u.variant_Kgt = &v
    
    u.variant_Keq = nil
    
    u.variant_Kne = nil
    
    u.variant_Klt = nil
    
    u.variant_Kcontains = nil
    
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) IsKgt() bool {
    return u.variant == "Kgt"
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) AsKgt() *string {
    if u.variant != "Kgt" {
        return nil
    }
    return u.variant_Kgt
}

func Union5KcontainsOrKeqOrKgtOrKltOrKne__NewKlt() Union5KcontainsOrKeqOrKgtOrKltOrKne {
    
    var v string = "lt"
    
    return Union5KcontainsOrKeqOrKgtOrKltOrKne{
        variant: "Klt",
        variant_Klt: &v,
    }
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) SetKlt() {
    
    var v string = "lt"
    
    u.variant = "Klt"
    u.variant_Klt = &v
    
    u.variant_Keq = nil
    
    u.variant_Kne = nil
    
    u.variant_Kgt = nil
    
    u.variant_Kcontains = nil
    
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) IsKlt() bool {
    return u.variant == "Klt"
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) AsKlt() *string {
    if u.variant != "Klt" {
        return nil
    }
    return u.variant_Klt
}

func Union5KcontainsOrKeqOrKgtOrKltOrKne__NewKcontains() Union5KcontainsOrKeqOrKgtOrKltOrKne {
    
    var v string = "contains"
    
    return Union5KcontainsOrKeqOrKgtOrKltOrKne{
        variant: "Kcontains",
        variant_Kcontains: &v,
    }
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) SetKcontains() {
    
    var v string = "contains"
    
    u.variant = "Kcontains"
    u.variant_Kcontains = &v
    
    u.variant_Keq = nil
    
    u.variant_Kne = nil
    
    u.variant_Kgt = nil
    
    u.variant_Klt = nil
    
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) IsKcontains() bool {
    return u.variant == "Kcontains"
}

func (u *Union5KcontainsOrKeqOrKgtOrKltOrKne) AsKcontains() *string {
    if u.variant != "Kcontains" {
        return nil
    }
    return u.variant_Kcontains
}


