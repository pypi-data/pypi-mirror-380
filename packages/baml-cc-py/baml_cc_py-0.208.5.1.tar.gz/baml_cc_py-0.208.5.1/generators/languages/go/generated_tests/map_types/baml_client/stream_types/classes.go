// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package stream_types

import (
    "encoding/json"
    "fmt"

    baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
    "github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"

    "map_types/baml_client/types"
)


type ComplexMaps struct {
    
UserMap map[string]User `json:"userMap"`
ProductMap map[string]Product `json:"productMap"`
NestedMap map[string]map[string]string `json:"nestedMap"`
ArrayMap map[string][]int64 `json:"arrayMap"`
MapArray []map[string]string `json:"mapArray"`
    
}

func (c *ComplexMaps) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ComplexMaps" {
		panic(fmt.Sprintf("expected ComplexMaps, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "userMap":
					c.UserMap = baml.Decode(valueHolder).Interface().(map[string]User)
				
				case "productMap":
					c.ProductMap = baml.Decode(valueHolder).Interface().(map[string]Product)
				
				case "nestedMap":
					c.NestedMap = baml.Decode(valueHolder).Interface().(map[string]map[string]string)
				
				case "arrayMap":
					c.ArrayMap = baml.Decode(valueHolder).Interface().(map[string][]int64)
				
				case "mapArray":
					c.MapArray = baml.Decode(valueHolder).Interface().([]map[string]string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class ComplexMaps", key))
			
		}
	}

}

func (c ComplexMaps) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["userMap"] = c.UserMap
    
    fields["productMap"] = c.ProductMap
    
    fields["nestedMap"] = c.NestedMap
    
    fields["arrayMap"] = c.ArrayMap
    
    fields["mapArray"] = c.MapArray
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c ComplexMaps) BamlTypeName() string {
    return "ComplexMaps"
}

func (u ComplexMaps) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "ComplexMaps",
    }
}
type Config struct {
    
Url *string `json:"url"`
Port *int64 `json:"port"`
Debug *bool `json:"debug"`
    
}

func (c *Config) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Config" {
		panic(fmt.Sprintf("expected Config, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "url":
					c.Url = baml.Decode(valueHolder).Interface().(*string)
				
				case "port":
					c.Port = baml.Decode(valueHolder).Interface().(*int64)
				
				case "debug":
					c.Debug = baml.Decode(valueHolder).Interface().(*bool)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Config", key))
			
		}
	}

}

func (c Config) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["url"] = c.Url
    
    fields["port"] = c.Port
    
    fields["debug"] = c.Debug
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Config) BamlTypeName() string {
    return "Config"
}

func (u Config) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Config",
    }
}
type EdgeCaseMaps struct {
    
EmptyMap map[string]string `json:"emptyMap"`
NullableValues map[string]*string `json:"nullableValues"`
OptionalValues map[string]*string `json:"optionalValues"`
UnionValues map[string]types.Union3BoolOrIntOrString `json:"unionValues"`
    
}

func (c *EdgeCaseMaps) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "EdgeCaseMaps" {
		panic(fmt.Sprintf("expected EdgeCaseMaps, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "emptyMap":
					c.EmptyMap = baml.Decode(valueHolder).Interface().(map[string]string)
				
				case "nullableValues":
					c.NullableValues = baml.Decode(valueHolder).Interface().(map[string]*string)
				
				case "optionalValues":
					c.OptionalValues = baml.Decode(valueHolder).Interface().(map[string]*string)
				
				case "unionValues":
					c.UnionValues = baml.Decode(valueHolder).Interface().(map[string]types.Union3BoolOrIntOrString)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class EdgeCaseMaps", key))
			
		}
	}

}

func (c EdgeCaseMaps) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["emptyMap"] = c.EmptyMap
    
    fields["nullableValues"] = c.NullableValues
    
    fields["optionalValues"] = c.OptionalValues
    
    fields["unionValues"] = c.UnionValues
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c EdgeCaseMaps) BamlTypeName() string {
    return "EdgeCaseMaps"
}

func (u EdgeCaseMaps) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "EdgeCaseMaps",
    }
}
type MixedKeyMaps struct {
    
StringIntMap map[string]int64 `json:"stringIntMap"`
IntStringMap map[string]string `json:"intStringMap"`
EnumMap map[string]string `json:"enumMap"`
LiteralMap map[string]Config `json:"literalMap"`
    
}

func (c *MixedKeyMaps) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "MixedKeyMaps" {
		panic(fmt.Sprintf("expected MixedKeyMaps, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "stringIntMap":
					c.StringIntMap = baml.Decode(valueHolder).Interface().(map[string]int64)
				
				case "intStringMap":
					c.IntStringMap = baml.Decode(valueHolder).Interface().(map[string]string)
				
				case "enumMap":
					c.EnumMap = baml.Decode(valueHolder).Interface().(map[string]string)
				
				case "literalMap":
					c.LiteralMap = baml.Decode(valueHolder).Interface().(map[string]Config)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class MixedKeyMaps", key))
			
		}
	}

}

func (c MixedKeyMaps) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["stringIntMap"] = c.StringIntMap
    
    fields["intStringMap"] = c.IntStringMap
    
    fields["enumMap"] = c.EnumMap
    
    fields["literalMap"] = c.LiteralMap
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c MixedKeyMaps) BamlTypeName() string {
    return "MixedKeyMaps"
}

func (u MixedKeyMaps) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "MixedKeyMaps",
    }
}
type NestedMaps struct {
    
Simple map[string]string `json:"simple"`
OneLevelNested map[string]map[string]int64 `json:"oneLevelNested"`
TwoLevelNested map[string]map[string]map[string]bool `json:"twoLevelNested"`
MapOfArrays map[string][]string `json:"mapOfArrays"`
MapOfMaps map[string]map[string]float64 `json:"mapOfMaps"`
    
}

func (c *NestedMaps) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "NestedMaps" {
		panic(fmt.Sprintf("expected NestedMaps, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "simple":
					c.Simple = baml.Decode(valueHolder).Interface().(map[string]string)
				
				case "oneLevelNested":
					c.OneLevelNested = baml.Decode(valueHolder).Interface().(map[string]map[string]int64)
				
				case "twoLevelNested":
					c.TwoLevelNested = baml.Decode(valueHolder).Interface().(map[string]map[string]map[string]bool)
				
				case "mapOfArrays":
					c.MapOfArrays = baml.Decode(valueHolder).Interface().(map[string][]string)
				
				case "mapOfMaps":
					c.MapOfMaps = baml.Decode(valueHolder).Interface().(map[string]map[string]float64)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class NestedMaps", key))
			
		}
	}

}

func (c NestedMaps) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["simple"] = c.Simple
    
    fields["oneLevelNested"] = c.OneLevelNested
    
    fields["twoLevelNested"] = c.TwoLevelNested
    
    fields["mapOfArrays"] = c.MapOfArrays
    
    fields["mapOfMaps"] = c.MapOfMaps
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c NestedMaps) BamlTypeName() string {
    return "NestedMaps"
}

func (u NestedMaps) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "NestedMaps",
    }
}
type Product struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
Price *float64 `json:"price"`
Tags []string `json:"tags"`
    
}

func (c *Product) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Product" {
		panic(fmt.Sprintf("expected Product, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "price":
					c.Price = baml.Decode(valueHolder).Interface().(*float64)
				
				case "tags":
					c.Tags = baml.Decode(valueHolder).Interface().([]string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class Product", key))
			
		}
	}

}

func (c Product) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["price"] = c.Price
    
    fields["tags"] = c.Tags
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c Product) BamlTypeName() string {
    return "Product"
}

func (u Product) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "Product",
    }
}
type SimpleMaps struct {
    
StringToString map[string]string `json:"stringToString"`
StringToInt map[string]int64 `json:"stringToInt"`
StringToFloat map[string]float64 `json:"stringToFloat"`
StringToBool map[string]bool `json:"stringToBool"`
IntToString map[string]string `json:"intToString"`
    
}

func (c *SimpleMaps) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "SimpleMaps" {
		panic(fmt.Sprintf("expected SimpleMaps, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "stringToString":
					c.StringToString = baml.Decode(valueHolder).Interface().(map[string]string)
				
				case "stringToInt":
					c.StringToInt = baml.Decode(valueHolder).Interface().(map[string]int64)
				
				case "stringToFloat":
					c.StringToFloat = baml.Decode(valueHolder).Interface().(map[string]float64)
				
				case "stringToBool":
					c.StringToBool = baml.Decode(valueHolder).Interface().(map[string]bool)
				
				case "intToString":
					c.IntToString = baml.Decode(valueHolder).Interface().(map[string]string)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class SimpleMaps", key))
			
		}
	}

}

func (c SimpleMaps) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["stringToString"] = c.StringToString
    
    fields["stringToInt"] = c.StringToInt
    
    fields["stringToFloat"] = c.StringToFloat
    
    fields["stringToBool"] = c.StringToBool
    
    fields["intToString"] = c.IntToString
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c SimpleMaps) BamlTypeName() string {
    return "SimpleMaps"
}

func (u SimpleMaps) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "SimpleMaps",
    }
}
type User struct {
    
Id *int64 `json:"id"`
Name *string `json:"name"`
Email *string `json:"email"`
Active *bool `json:"active"`
    
}

func (c *User) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "User" {
		panic(fmt.Sprintf("expected User, got %s", typeName.Name))
	}

   

	
	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
			switch key {
				
				case "id":
					c.Id = baml.Decode(valueHolder).Interface().(*int64)
				
				case "name":
					c.Name = baml.Decode(valueHolder).Interface().(*string)
				
				case "email":
					c.Email = baml.Decode(valueHolder).Interface().(*string)
				
				case "active":
					c.Active = baml.Decode(valueHolder).Interface().(*bool)
				
		default:
			
			panic(fmt.Sprintf("unexpected field: %s in class User", key))
			
		}
	}

}

func (c User) Encode() (*cffi.CFFIValueHolder, error) {
    fields := map[string]any{}
    
    fields["id"] = c.Id
    
    fields["name"] = c.Name
    
    fields["email"] = c.Email
    
    fields["active"] = c.Active
    
    return baml.EncodeClass(c.BamlEncodeName, fields, nil)
}

func (c User) BamlTypeName() string {
    return "User"
}

func (u User) BamlEncodeName() *cffi.CFFITypeName {
    return &cffi.CFFITypeName{
        Namespace: cffi.CFFITypeNamespace_STREAM_TYPES,
        Name:      "User",
    }
}