# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
# These are exports, not used here, hence the linter is disabled
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder # noqa: F401 # pylint: disable=unused-import
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AllNullable","BooleanEdgeCases","CircularReference","DeepRecursion","EmptyCollections","InnerNullable","LargeStructure","MixedEdgeCases","NestedNullable","NullEdgeCases","NumberEdgeCases","OptionalEverything","OuterNullable","SomeNullable","SpecialCharacters","User","VeryLongStrings",]
        ), enums=set(
          []
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 0
    # #########################################################################


    # #########################################################################
    # Generated classes 17
    # #########################################################################

    @property
    def AllNullable(self) -> "AllNullableViewer":
        return AllNullableViewer(self)

    @property
    def BooleanEdgeCases(self) -> "BooleanEdgeCasesViewer":
        return BooleanEdgeCasesViewer(self)

    @property
    def CircularReference(self) -> "CircularReferenceViewer":
        return CircularReferenceViewer(self)

    @property
    def DeepRecursion(self) -> "DeepRecursionViewer":
        return DeepRecursionViewer(self)

    @property
    def EmptyCollections(self) -> "EmptyCollectionsViewer":
        return EmptyCollectionsViewer(self)

    @property
    def InnerNullable(self) -> "InnerNullableViewer":
        return InnerNullableViewer(self)

    @property
    def LargeStructure(self) -> "LargeStructureViewer":
        return LargeStructureViewer(self)

    @property
    def MixedEdgeCases(self) -> "MixedEdgeCasesViewer":
        return MixedEdgeCasesViewer(self)

    @property
    def NestedNullable(self) -> "NestedNullableViewer":
        return NestedNullableViewer(self)

    @property
    def NullEdgeCases(self) -> "NullEdgeCasesViewer":
        return NullEdgeCasesViewer(self)

    @property
    def NumberEdgeCases(self) -> "NumberEdgeCasesViewer":
        return NumberEdgeCasesViewer(self)

    @property
    def OptionalEverything(self) -> "OptionalEverythingViewer":
        return OptionalEverythingViewer(self)

    @property
    def OuterNullable(self) -> "OuterNullableViewer":
        return OuterNullableViewer(self)

    @property
    def SomeNullable(self) -> "SomeNullableViewer":
        return SomeNullableViewer(self)

    @property
    def SpecialCharacters(self) -> "SpecialCharactersViewer":
        return SpecialCharactersViewer(self)

    @property
    def User(self) -> "UserViewer":
        return UserViewer(self)

    @property
    def VeryLongStrings(self) -> "VeryLongStringsViewer":
        return VeryLongStringsViewer(self)



# #########################################################################
# Generated enums 0
# #########################################################################


# #########################################################################
# Generated classes 17
# #########################################################################

class AllNullableAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AllNullable")
        self._properties: typing.Set[str] = set([  "nullString",  "nullInt",  "nullFloat",  "nullBool",  "nullArray",  "nullObject",  ])
        self._props = AllNullableProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AllNullableProperties":
        return self._props


class AllNullableViewer(AllNullableAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AllNullableProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def nullString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nullString"))
    
    @property
    def nullInt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nullInt"))
    
    @property
    def nullFloat(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nullFloat"))
    
    @property
    def nullBool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nullBool"))
    
    @property
    def nullArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nullArray"))
    
    @property
    def nullObject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nullObject"))
    
    


class BooleanEdgeCasesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BooleanEdgeCases")
        self._properties: typing.Set[str] = set([  "explicitTrue",  "explicitFalse",  "arrayOfTrue",  "arrayOfFalse",  "mixedBoolArray",  ])
        self._props = BooleanEdgeCasesProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BooleanEdgeCasesProperties":
        return self._props


class BooleanEdgeCasesViewer(BooleanEdgeCasesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class BooleanEdgeCasesProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def explicitTrue(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explicitTrue"))
    
    @property
    def explicitFalse(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explicitFalse"))
    
    @property
    def arrayOfTrue(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("arrayOfTrue"))
    
    @property
    def arrayOfFalse(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("arrayOfFalse"))
    
    @property
    def mixedBoolArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mixedBoolArray"))
    
    


class CircularReferenceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CircularReference")
        self._properties: typing.Set[str] = set([  "id",  "name",  "parent",  "children",  "relatedItems",  ])
        self._props = CircularReferenceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CircularReferenceProperties":
        return self._props


class CircularReferenceViewer(CircularReferenceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CircularReferenceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def parent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parent"))
    
    @property
    def children(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("children"))
    
    @property
    def relatedItems(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("relatedItems"))
    
    


class DeepRecursionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DeepRecursion")
        self._properties: typing.Set[str] = set([  "value",  "next",  ])
        self._props = DeepRecursionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DeepRecursionProperties":
        return self._props


class DeepRecursionViewer(DeepRecursionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DeepRecursionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def value(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("value"))
    
    @property
    def next(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("next"))
    
    


class EmptyCollectionsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EmptyCollections")
        self._properties: typing.Set[str] = set([  "emptyStringArray",  "emptyIntArray",  "emptyObjectArray",  "emptyMap",  "emptyNestedArray",  ])
        self._props = EmptyCollectionsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EmptyCollectionsProperties":
        return self._props


class EmptyCollectionsViewer(EmptyCollectionsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EmptyCollectionsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def emptyStringArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("emptyStringArray"))
    
    @property
    def emptyIntArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("emptyIntArray"))
    
    @property
    def emptyObjectArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("emptyObjectArray"))
    
    @property
    def emptyMap(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("emptyMap"))
    
    @property
    def emptyNestedArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("emptyNestedArray"))
    
    


class InnerNullableAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("InnerNullable")
        self._properties: typing.Set[str] = set([  "value",  ])
        self._props = InnerNullableProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "InnerNullableProperties":
        return self._props


class InnerNullableViewer(InnerNullableAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class InnerNullableProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def value(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("value"))
    
    


class LargeStructureAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("LargeStructure")
        self._properties: typing.Set[str] = set([  "field1",  "field2",  "field3",  "field4",  "field5",  "field6",  "field7",  "field8",  "field9",  "field10",  "field11",  "field12",  "field13",  "field14",  "field15",  "field16",  "field17",  "field18",  "field19",  "field20",  "array1",  "array2",  "array3",  "array4",  "array5",  "map1",  "map2",  "map3",  "map4",  "map5",  ])
        self._props = LargeStructureProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LargeStructureProperties":
        return self._props


class LargeStructureViewer(LargeStructureAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class LargeStructureProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def field1(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field1"))
    
    @property
    def field2(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field2"))
    
    @property
    def field3(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field3"))
    
    @property
    def field4(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field4"))
    
    @property
    def field5(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field5"))
    
    @property
    def field6(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field6"))
    
    @property
    def field7(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field7"))
    
    @property
    def field8(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field8"))
    
    @property
    def field9(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field9"))
    
    @property
    def field10(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field10"))
    
    @property
    def field11(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field11"))
    
    @property
    def field12(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field12"))
    
    @property
    def field13(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field13"))
    
    @property
    def field14(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field14"))
    
    @property
    def field15(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field15"))
    
    @property
    def field16(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field16"))
    
    @property
    def field17(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field17"))
    
    @property
    def field18(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field18"))
    
    @property
    def field19(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field19"))
    
    @property
    def field20(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("field20"))
    
    @property
    def array1(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("array1"))
    
    @property
    def array2(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("array2"))
    
    @property
    def array3(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("array3"))
    
    @property
    def array4(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("array4"))
    
    @property
    def array5(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("array5"))
    
    @property
    def map1(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("map1"))
    
    @property
    def map2(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("map2"))
    
    @property
    def map3(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("map3"))
    
    @property
    def map4(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("map4"))
    
    @property
    def map5(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("map5"))
    
    


class MixedEdgeCasesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("MixedEdgeCases")
        self._properties: typing.Set[str] = set([  "emptyString",  "singleChar",  "veryLongArray",  "deeplyNestedMap",  "mixedTypeArray",  "optionalEverything",  ])
        self._props = MixedEdgeCasesProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MixedEdgeCasesProperties":
        return self._props


class MixedEdgeCasesViewer(MixedEdgeCasesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class MixedEdgeCasesProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def emptyString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("emptyString"))
    
    @property
    def singleChar(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("singleChar"))
    
    @property
    def veryLongArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("veryLongArray"))
    
    @property
    def deeplyNestedMap(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("deeplyNestedMap"))
    
    @property
    def mixedTypeArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mixedTypeArray"))
    
    @property
    def optionalEverything(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optionalEverything"))
    
    


class NestedNullableAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NestedNullable")
        self._properties: typing.Set[str] = set([  "outer",  ])
        self._props = NestedNullableProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NestedNullableProperties":
        return self._props


class NestedNullableViewer(NestedNullableAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NestedNullableProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def outer(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("outer"))
    
    


class NullEdgeCasesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NullEdgeCases")
        self._properties: typing.Set[str] = set([  "allNull",  "someNull",  "nestedNull",  ])
        self._props = NullEdgeCasesProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NullEdgeCasesProperties":
        return self._props


class NullEdgeCasesViewer(NullEdgeCasesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NullEdgeCasesProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def allNull(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("allNull"))
    
    @property
    def someNull(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("someNull"))
    
    @property
    def nestedNull(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nestedNull"))
    
    


class NumberEdgeCasesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NumberEdgeCases")
        self._properties: typing.Set[str] = set([  "zero",  "negativeInt",  "largeInt",  "veryLargeInt",  "smallFloat",  "largeFloat",  "negativeFloat",  "scientificNotation",  "infinity",  "notANumber",  ])
        self._props = NumberEdgeCasesProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NumberEdgeCasesProperties":
        return self._props


class NumberEdgeCasesViewer(NumberEdgeCasesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NumberEdgeCasesProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def zero(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("zero"))
    
    @property
    def negativeInt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("negativeInt"))
    
    @property
    def largeInt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("largeInt"))
    
    @property
    def veryLargeInt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("veryLargeInt"))
    
    @property
    def smallFloat(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("smallFloat"))
    
    @property
    def largeFloat(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("largeFloat"))
    
    @property
    def negativeFloat(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("negativeFloat"))
    
    @property
    def scientificNotation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scientificNotation"))
    
    @property
    def infinity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("infinity"))
    
    @property
    def notANumber(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notANumber"))
    
    


class OptionalEverythingAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OptionalEverything")
        self._properties: typing.Set[str] = set([  "optString",  "optInt",  "optFloat",  "optBool",  "optArray",  "optMap",  "optObject",  ])
        self._props = OptionalEverythingProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OptionalEverythingProperties":
        return self._props


class OptionalEverythingViewer(OptionalEverythingAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OptionalEverythingProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def optString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optString"))
    
    @property
    def optInt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optInt"))
    
    @property
    def optFloat(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optFloat"))
    
    @property
    def optBool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optBool"))
    
    @property
    def optArray(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optArray"))
    
    @property
    def optMap(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optMap"))
    
    @property
    def optObject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optObject"))
    
    


class OuterNullableAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OuterNullable")
        self._properties: typing.Set[str] = set([  "inner",  ])
        self._props = OuterNullableProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OuterNullableProperties":
        return self._props


class OuterNullableViewer(OuterNullableAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OuterNullableProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def inner(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("inner"))
    
    


class SomeNullableAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SomeNullable")
        self._properties: typing.Set[str] = set([  "presentString",  "nullString",  "presentInt",  "nullInt",  ])
        self._props = SomeNullableProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SomeNullableProperties":
        return self._props


class SomeNullableViewer(SomeNullableAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SomeNullableProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def presentString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("presentString"))
    
    @property
    def nullString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nullString"))
    
    @property
    def presentInt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("presentInt"))
    
    @property
    def nullInt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nullInt"))
    
    


class SpecialCharactersAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SpecialCharacters")
        self._properties: typing.Set[str] = set([  "normalText",  "withNewlines",  "withTabs",  "withQuotes",  "withBackslashes",  "withUnicode",  "withEmoji",  "withMixedSpecial",  ])
        self._props = SpecialCharactersProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SpecialCharactersProperties":
        return self._props


class SpecialCharactersViewer(SpecialCharactersAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SpecialCharactersProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def normalText(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("normalText"))
    
    @property
    def withNewlines(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("withNewlines"))
    
    @property
    def withTabs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("withTabs"))
    
    @property
    def withQuotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("withQuotes"))
    
    @property
    def withBackslashes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("withBackslashes"))
    
    @property
    def withUnicode(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("withUnicode"))
    
    @property
    def withEmoji(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("withEmoji"))
    
    @property
    def withMixedSpecial(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("withMixedSpecial"))
    
    


class UserAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("User")
        self._properties: typing.Set[str] = set([  "id",  "name",  ])
        self._props = UserProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UserProperties":
        return self._props


class UserViewer(UserAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UserProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    


class VeryLongStringsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VeryLongStrings")
        self._properties: typing.Set[str] = set([  "shortString",  "mediumString",  "longString",  "veryLongString",  "extremelyLongString",  ])
        self._props = VeryLongStringsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VeryLongStringsProperties":
        return self._props


class VeryLongStringsViewer(VeryLongStringsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VeryLongStringsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def shortString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("shortString"))
    
    @property
    def mediumString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mediumString"))
    
    @property
    def longString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("longString"))
    
    @property
    def veryLongString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("veryLongString"))
    
    @property
    def extremelyLongString(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("extremelyLongString"))
    
    

