# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (0)
# #########################################################################

# #########################################################################
# Generated classes (17)
# #########################################################################

class AllNullable(BaseModel):
    nullString: typing.Optional[str] = None
    nullInt: typing.Optional[int] = None
    nullFloat: typing.Optional[float] = None
    nullBool: typing.Optional[bool] = None
    nullArray: typing.Optional[typing.List[str]] = None
    nullObject: typing.Optional["User"] = None

class BooleanEdgeCases(BaseModel):
    explicitTrue: bool
    explicitFalse: bool
    arrayOfTrue: typing.List[bool]
    arrayOfFalse: typing.List[bool]
    mixedBoolArray: typing.List[bool]

class CircularReference(BaseModel):
    id: int
    name: str
    parent: typing.Optional["CircularReference"] = None
    children: typing.List["CircularReference"]
    relatedItems: typing.List["CircularReference"]

class DeepRecursion(BaseModel):
    value: str
    next: typing.Optional["DeepRecursion"] = None

class EmptyCollections(BaseModel):
    emptyStringArray: typing.List[str]
    emptyIntArray: typing.List[int]
    emptyObjectArray: typing.List["User"]
    emptyMap: typing.Dict[str, str]
    emptyNestedArray: typing.List[typing.List[str]]

class InnerNullable(BaseModel):
    value: typing.Optional[str] = None

class LargeStructure(BaseModel):
    field1: str
    field2: str
    field3: str
    field4: str
    field5: str
    field6: int
    field7: int
    field8: int
    field9: int
    field10: int
    field11: float
    field12: float
    field13: float
    field14: float
    field15: float
    field16: bool
    field17: bool
    field18: bool
    field19: bool
    field20: bool
    array1: typing.List[str]
    array2: typing.List[int]
    array3: typing.List[float]
    array4: typing.List[bool]
    array5: typing.List["User"]
    map1: typing.Dict[str, str]
    map2: typing.Dict[str, int]
    map3: typing.Dict[str, float]
    map4: typing.Dict[str, bool]
    map5: typing.Dict[str, "User"]

class MixedEdgeCases(BaseModel):
    emptyString: str
    singleChar: str
    veryLongArray: typing.List[str]
    deeplyNestedMap: typing.Dict[str, typing.Dict[str, typing.Dict[str, str]]]
    mixedTypeArray: typing.List[typing.Optional[typing.Union[str, int, bool]]]
    optionalEverything: typing.Optional["OptionalEverything"] = None

class NestedNullable(BaseModel):
    outer: typing.Optional["OuterNullable"] = None

class NullEdgeCases(BaseModel):
    allNull: "AllNullable"
    someNull: "SomeNullable"
    nestedNull: "NestedNullable"

class NumberEdgeCases(BaseModel):
    zero: int
    negativeInt: int
    largeInt: int
    veryLargeInt: int
    smallFloat: float
    largeFloat: float
    negativeFloat: float
    scientificNotation: float
    infinity: typing.Optional[float] = None
    notANumber: typing.Optional[float] = None

class OptionalEverything(BaseModel):
    optString: typing.Optional[str] = None
    optInt: typing.Optional[int] = None
    optFloat: typing.Optional[float] = None
    optBool: typing.Optional[bool] = None
    optArray: typing.Optional[typing.List[str]] = None
    optMap: typing.Optional[typing.Dict[str, str]] = None
    optObject: typing.Optional["User"] = None

class OuterNullable(BaseModel):
    inner: typing.Optional["InnerNullable"] = None

class SomeNullable(BaseModel):
    presentString: typing.Optional[str] = None
    nullString: typing.Optional[str] = None
    presentInt: typing.Optional[int] = None
    nullInt: typing.Optional[int] = None

class SpecialCharacters(BaseModel):
    normalText: str
    withNewlines: str
    withTabs: str
    withQuotes: str
    withBackslashes: str
    withUnicode: str
    withEmoji: str
    withMixedSpecial: str

class User(BaseModel):
    id: int
    name: str

class VeryLongStrings(BaseModel):
    shortString: str
    mediumString: str
    longString: str
    veryLongString: str
    extremelyLongString: str

# #########################################################################
# Generated type aliases (0)
# #########################################################################
