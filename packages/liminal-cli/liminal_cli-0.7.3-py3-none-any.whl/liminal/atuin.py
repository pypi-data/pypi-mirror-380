import logging
import os
import shutil
import sqlite3
import subprocess
import time
from dataclasses import dataclass
from pathlib import Path
from uuid import uuid4

import tomlkit
from liminal import LIMINAL_PACKAGE_VERSION
from liminal.command_runner import run_command, run_test_login_command
from liminal.config import Config
from liminal.datetime_util import datetime_utcnow
from liminal.filesystem import path_metadata
from liminal.logging import LOGGER
from liminal.shell import Shell

ATUIN_VERSION = 'v18.7.1'
_ATUIN_VERSION_BARE = ATUIN_VERSION.removeprefix('v')

class Paths:
	CONFIG_DIR = Path.home() / '.config/atuin'
	ATUIN_DIR = Path.home() / '.atuin/'
	EXECUTABLE = Path.home() / '.atuin/bin/atuin' # since PATH for env/shell wont be updated
	SHARE = Path.home() / '.local/share/atuin/'
	HISTORY_DB = SHARE / 'history.db'
	CLIENT_CONFIG = CONFIG_DIR / 'config.toml'
	KEY_FILE = SHARE / 'key'
	HOST_ID = SHARE / 'host_id'

	LIMINAL_RECEIPT = ATUIN_DIR / 'liminal-receipt.json'

_INSTALLER_SCRIPT = Path(__file__).parent / 'atuin-installer.sh'


class HistoryNotFound(Exception):
	pass

def dict_factory(cursor, row):
	fields = [column[0] for column in cursor.description]
	return {key: value for key, value in zip(fields, row)}


def local_history_count() -> int:
	connection = sqlite3.connect(Paths.HISTORY_DB.as_posix())
	cursor = connection.cursor()

	count = cursor.execute('SELECT count(id) FROM history').fetchone()
	return count[0]


@dataclass
class LocalHistorySummary:
	command_count: int
	session_count: int
	date_oldest: int
	date_newest: int

def local_history_summary() -> LocalHistorySummary:
	"""
	This is so we can check on the first install sync's progress
	if we match these values, roughly everything has been synced to the server, and we can start generating a report
	(im sure there is a better way, both for us recording less info, and for robustness, but this
	heurstic will be good enough for our first go)
	"""
	command_count = local_history_count()
	connection = sqlite3.connect(Paths.HISTORY_DB.as_posix())
	cursor = connection.cursor()

	result = cursor.execute("""
	SELECT 
		COUNT(DISTINCT session),
		MIN(timestamp),
		MAX(timestamp)
	FROM history""").fetchone()

	session_count, date_oldest, date_newest = result
	return LocalHistorySummary(command_count, session_count, date_oldest, date_newest)


def local_history_row(command_to_query: str) -> dict | None:
	LOGGER.debug(f'Searching for command: "{command_to_query}"')
	connection = sqlite3.connect(Paths.HISTORY_DB.as_posix())
	connection.row_factory = dict_factory
	cursor = connection.cursor()
	
	cursor.execute('SELECT * FROM history WHERE command=?', (command_to_query,))
	result = cursor.fetchone()
	LOGGER.debug(f'Query result: {result}')
	connection.close()
	return result


def get_host_id() -> str:
	file_path = Paths.HOST_ID
	if not file_path.exists():

		import uuid
		host_id = str(uuid.uuid4()).replace('-', '')
		LOGGER.debug(f'creating our own host id = {host_id}')
		file_path.write_text(host_id)
		# hell yeah creating our own works! TODO: can simplify some server stuff now!!


		# running code below causes a `export PS1` to go into the history, which breaks decryption of the first (this) command 
		# because we need the host_id to query properly

		# for atuin.Paths.HOST_ID file to be generated by atuin, you need to do a real instantiation/startup of atuin. not all atuin commands do this. like `atuin info` doesnt work but `atuin stats` does
		# try:
		# 	run_login_command(Shell().exec_path, 'atuin stats', env=os.environ.copy() | neccessary_atuin_env_vars())
		# except Exception as e:
		# 	# any error is fine as long as the host_id file is created
		# 	if not file_path.exists():
		# 		e.add_note(f'Expected file still does not exist: {file_path}')
		# 		raise e
	return file_path.read_text()

def backup(outdir: Path):
	outdir = Paths.SHARE.parent / 'atuin_liminal_backup' / 'date/installid'
	shutil.copytree(Paths.SHARE, outdir)

def uninstall_atuin(ignore_errors=False):
	shutil.rmtree(Paths.ATUIN_DIR.resolve(), ignore_errors=ignore_errors)
	shutil.rmtree(Paths.SHARE.resolve(), ignore_errors=ignore_errors)
	shutil.rmtree(Paths.CONFIG_DIR.resolve(), ignore_errors=ignore_errors)

def delete_account():
	run_command([Paths.EXECUTABLE, 'account', 'delete'])

def get_config(shell: Shell) -> dict:
	# atuin's config file isnt created until atuin is ran for the first time
	if not Paths.CLIENT_CONFIG.exists():
		shell_executable = shell.exec_path
		run_command([shell_executable, '-c', f'{Paths.EXECUTABLE} info'], env=os.environ.copy(), cmd_output_log_level=logging.INFO)
	return tomlkit.parse(Paths.CLIENT_CONFIG.read_text())



def set_config(config: dict):
	Paths.CLIENT_CONFIG.write_text(tomlkit.dumps(config))

def install_atuin(shell_exec: Path | str):
	LOGGER.info('Installing atuin')


	# resp = requests.get(f'https://github.com/atuinsh/atuin/releases/download/{ATUIN_VERSION}/atuin-installer.sh', timeout=10)
	# installer_script = Path('/tmp/atuin-installer.sh')
	# installer_script.write_bytes(resp.content)
	env_copy = os.environ.copy()
	env_copy['ATUIN_NO_MODIFY_PATH'] = '1' # dont update users' PATH, we will do that ourselves
	run_command(['/bin/sh', _INSTALLER_SCRIPT.as_posix(), '--verbose'], env=env_copy, cmd_output_log_level=logging.INFO)


def import_existing_history(shell: Shell) -> bool | str:
	"""returns True if sucessffuly imports history, False if failed, or NA string"""
	if Config.LIMINAL_INSTALLER_SKIP_ATUIN_IMPORT_HISTORY:
		# quick hack to at least allow transition for current atuin users 
		# (they can back up their history.db before install, then copy it back and `atuin sync`)
		return 'N/A: skipped'
	
	if Config.LIMINAL_INSTALLER_ATUIN_HISTORY_SEED_FILE:
		seed_file = Path(Config.LIMINAL_INSTALLER_ATUIN_HISTORY_SEED_FILE)
		assert seed_file.exists()
		# TODO: docs: only allowed if sqlite3 CLI is installed
		run_command(['sqlite3', Paths.HISTORY_DB, f'.import --csv --skip 1 {seed_file} history'])
		run_command(['sqlite3', Paths.HISTORY_DB, "UPDATE history SET deleted_at = NULL WHERE deleted_at = '';"])
		return True
	
	if not shell.history_file.exists():
		LOGGER.warning('No command history file found')
		return False

	try:
		out = run_command([Paths.EXECUTABLE, 'import', shell.exec_path.name], check=True)
		return True
	except subprocess.CalledProcessError as e:
		LOGGER.error(f'{e.stdout=}')
		LOGGER.error(f'{e.stderr=}')
		raise e
		# TODO: we could try and parse based on shellprofile envar histxxx value? 
			# bash: HISTTIMEFORMAT
		# TODO: warn user that couldnt import history
		if 'Importing history...\ncannot import' in e.stdout or e.stderr:
			input('We arent able to parse your history file correctly, would you like to continue anyways?')
	
	if 'Importing history...\ncannot import' in out.stdout:
		print(f'cant import history. {out.stdout=}')
		raise ValueError(f'cant import history')


def configure_atuin(shell: Shell, sync_address: str, freq='0'):
	LOGGER.debug(f'updating atuin sync config, {sync_address=} {freq=}')

	atuin_config = get_config(shell)
	atuin_config['sync_address'] =  sync_address
	atuin_config['sync_frequency'] = freq
	atuin_config['update_check'] = False # we will manage updates ourselves
	set_config(atuin_config)



def is_atuin_installed() -> bool:
	atuin_is_installed_in_path = False
	try:
		subprocess.run(['atuin', '--help'], check=True, capture_output=True)
		atuin_is_installed_in_path = True
	except (subprocess.CalledProcessError, FileNotFoundError):
		pass

	atuin_is_installed_in_home = Paths.EXECUTABLE.exists()
	return atuin_is_installed_in_home or atuin_is_installed_in_path

def upgrade():
	try:
		subprocess.run(['atuin', '--version'], timeout=2)
		subprocess.run(['atuin-update', '--version', _ATUIN_VERSION_BARE], check=True, capture_output=False, timeout=30)
	except (subprocess.CalledProcessError, FileNotFoundError):
		LOGGER.exception('unable to update atuin to {_ATUIN_VERSION_BARE}')
		raise

def status():
	return subprocess.run(['atuin', 'status'], capture_output=True, text=True, timeout=3)

def is_logged_in() -> bool:

	try:
		task = status()
	except (subprocess.CalledProcessError, FileNotFoundError):
		return False

	if 'You are not logged in to a sync server' in task.stdout:
		return False
	return True


def is_the_users_existing_atuin_env_supported(progress_setter: callable = None) -> bool:
	"""if someone has used our installer before, they should be good to go
	but an existing atuin user might be using sync, so we can't continue
	"""
	is_atuin_already_installed = is_atuin_installed()
	if progress_setter:
		progress_setter('is_atuin_already_installed', is_atuin_already_installed)

	if is_atuin_already_installed:
		return True
	
	is_user_logged_in = is_logged_in()
	if progress_setter:
		progress_setter('is_atuin_user_logged_in', is_user_logged_in)


	if not is_user_logged_in:
		return True

	status_output = status().stdout
	is_syncing_to_liminal = f"[Remote]\nAddress: {Config.ATUIN_SYNC_ADDRESS}\n" in status_output

	if progress_setter:
		progress_setter('is_atuin_syncing_to_liminal', is_syncing_to_liminal)

	if is_syncing_to_liminal:
		return True
	
	# TODO:
	# try:
	# 	if session.InstallationSession.load_most_recent().
	# except Exception:
	# 	pass
	return False


def check_login_user_is_expected(expected_username: str):
	"""raises assertionerror if logged into atuin, but not with `expected_username`
	"""
	if not is_logged_in():
		return

	try:
		status_process = status()
	except (subprocess.CalledProcessError, FileNotFoundError):
		status_process = None

	if not status_process:
		return
	
	if not f'Username: {expected_username}\n' in status_process.stdout:
		LOGGER.error(f'Unexpected username in {status_process.stdout=}')
		raise AssertionError('Expected username not found')



def neccessary_atuin_env_vars():
	import uuid
	return {
		'ATUIN_SESSION': str(uuid.uuid4()).replace('-', ''),
	}

def debug_info() -> dict:
	atuin_is_installed_in_path = False
	atuin_in_path_at = None
	try:
		which_atuin = subprocess.run(['which', 'atuin'], check=True, capture_output=True)
		atuin_in_path_at = which_atuin.stdout
		atuin_is_installed_in_path = True
	except (subprocess.CalledProcessError, FileNotFoundError):
		pass
	
	atuin_is_installed_in_home = Paths.EXECUTABLE.exists()

	atuin_doctor = None
	if atuin_is_installed_in_home:
		task = subprocess.run([Paths.EXECUTABLE, 'doctor'], capture_output=True, text=True, check=False)
		atuin_doctor = task.stdout
	
	return {
		'is_installed_in_path': atuin_is_installed_in_path,
		'atuin_in_path_at': atuin_in_path_at,
		'is_installed_in_home': atuin_is_installed_in_home,
		'atuin_doctor_output': atuin_doctor,
		'paths': [
			path_metadata(Paths.SHARE, ),
			path_metadata(Paths.CONFIG_DIR, ),
			path_metadata(Paths.ATUIN_DIR, ),
		],
	}


def test_atuin_recording_locally(shell: Shell) -> dict:
	"""
	- run a command and make sure it appears in atuin db
	"""
	try:
		count_before_test = local_history_count()
	except Exception:
		count_before_test = -1

	full_command = run_test_login_command(
		shell.exec_path,
		f'{LIMINAL_PACKAGE_VERSION=} {datetime_utcnow().astimezone().isoformat()} {uuid4()}',
	)

	test_command_record = None
	# check atuin's db a few times to make sure the test command appears
	# TODO: investigate: some times it takes 1 second for the history to update (perhaps for larger dbs?) (or just be created first time)
	max_attempts = 6
	for _i in range(max_attempts):
		time.sleep(0.5)
		try:
			test_command_record = local_history_row(full_command)
		except Exception as exception: 
			LOGGER.debug(f'Issue getting history: {_i}/{max_attempts}: {exception}')
		if test_command_record:
			LOGGER.debug(f'Found test command in local history after {_i} attempts')
			break
	count_after = local_history_count()

	if not test_command_record:
		raise HistoryNotFound(
			f'Test command not found in local history. {count_before_test=} {count_after=}.', 
			count_before_test, count_after,
		)

	return test_command_record
