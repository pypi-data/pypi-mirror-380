import importlib.util
import inspect
from pathlib import Path
from textwrap import dedent
from types import ModuleType
from typing import Any

import pytest
import pytest_alembic.tests.default
import pytest_alembic.tests.experimental
import pytest_asyncio
from brewinglib.db import Database
from brewinglib.db.migrate import (
    Migrations,
)
from brewinglib.db.settings import DatabaseType
from testing_samples import db_sample1


@pytest.fixture
def migrations(db_type: DatabaseType, running_db: Database[Any], tmp_path: Path):
    migrations = Migrations(
        database=Database[db_type.dialect().connection_config_type](
            db_sample1.Base.metadata
        ),
        revisions_dir=tmp_path / "revisions",
    )
    with migrations:
        yield migrations


@pytest.fixture
def alembic_config(migrations: Migrations):
    # Fixture required by pytest-alembic
    migrations.revisions_dir.mkdir()
    migrations.generate_revision("gen 1", autogenerate=True)
    migrations.upgrade()
    yield migrations.alembic
    migrations.downgrade("base")


@pytest_asyncio.fixture
async def alembic_engine(migrations: Migrations):
    # Fixture required by pytest-alembic
    try:
        yield migrations.engine
    finally:
        await migrations.engine.dispose()


def load_module_from_file(path: Path) -> ModuleType:
    spec = importlib.util.spec_from_file_location(path.name, str(path.resolve()))
    if not spec or not spec.loader:  # pragma: no cover
        raise ImportError(f"Could not load module from {path=!s}")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module


class TestMigrations:
    @staticmethod
    def test_generate_migration_without_autogenerate(migrations: Migrations):
        migrations.revisions_dir.mkdir()
        # If we call generate
        migrations.generate_revision("gen 1", autogenerate=False)
        # then there will be a file generated in the revisions dir
        revisions_files = list(migrations.revisions_dir.glob("*.py"))
        assert len(revisions_files) == 1
        assert revisions_files[0].name == "rev_00000_gen_1.py"
        # And inspect its module contents are as expected.
        module = load_module_from_file(revisions_files[0])
        assert callable(module.upgrade)
        assert (
            inspect.getsource(module.upgrade).strip()
            == dedent(
                '''
            def upgrade() -> None:
                """Upgrade schema."""
                pass
            '''
            ).strip()
        )
        assert callable(module.downgrade)
        assert (
            inspect.getsource(module.downgrade).strip()
            == dedent(
                '''
            def downgrade() -> None:
                """Downgrade schema."""
                pass
            '''
            ).strip()
        )

    @staticmethod
    def test_generate_migration_with_autogenerate(migrations: Migrations):
        # Given migrations instance
        migrations.revisions_dir.mkdir()
        # If we call generate
        migrations.generate_revision("gen 1", autogenerate=True)
        # then there will be a file generated in the revisions dir
        revisions_files = list(migrations.revisions_dir.glob("*.py"))
        assert len(revisions_files) == 1
        assert revisions_files[0].name == "rev_00000_gen_1.py"
        # And inspect its module contents are as expected.
        module = load_module_from_file(revisions_files[0])
        assert callable(module.upgrade)
        assert (
            inspect.getsource(module.upgrade).strip()
            == dedent(
                '''
            def upgrade() -> None:
                """Upgrade schema."""
                # ### commands auto generated by Alembic - please adjust! ###
                op.create_table('item',
                sa.Column('item_id', sa.Integer(), nullable=False),
                sa.Column('description', sa.String(length=30), nullable=False),
                sa.Column('price', sa.Float(), nullable=False),
                sa.PrimaryKeyConstraint('item_id')
                )
                op.create_table('order',
                sa.Column('order_id', sa.Integer(), nullable=False),
                sa.Column('customer_name', sa.String(length=30), nullable=False),
                sa.Column('order_date', sa.DateTime(timezone=True), nullable=False),
                sa.PrimaryKeyConstraint('order_id')
                )
                op.create_table('orderitem',
                sa.Column('order_id', sa.Integer(), nullable=False),
                sa.Column('item_id', sa.Integer(), nullable=False),
                sa.Column('price', sa.Float(), nullable=False),
                sa.ForeignKeyConstraint(['item_id'], ['item.item_id'], ),
                sa.ForeignKeyConstraint(['order_id'], ['order.order_id'], ),
                sa.PrimaryKeyConstraint('order_id', 'item_id')
                )
                # ### end Alembic commands ###
            '''
            ).strip()
        )
        assert callable(module.downgrade)
        assert (
            inspect.getsource(module.downgrade).strip()
            == dedent(
                '''
            def downgrade() -> None:
                """Downgrade schema."""
                # ### commands auto generated by Alembic - please adjust! ###
                op.drop_table('orderitem')
                op.drop_table('order')
                op.drop_table('item')
                # ### end Alembic commands ###
            '''
            ).strip()
        )

    test_model_definitions_match_ddl = staticmethod(
        pytest_alembic.tests.default.test_model_definitions_match_ddl
    )
    test_single_head_revision = staticmethod(
        pytest_alembic.tests.default.test_single_head_revision
    )
    test_up_down_consistency = staticmethod(
        pytest_alembic.tests.default.test_up_down_consistency
    )
    test_upgrade = staticmethod(pytest_alembic.tests.default.test_upgrade)
