import logging
import re
from typing import Any, Callable

from jsonpath_ng import parse  # type: ignore
from next_gen_ui_agent.data_transform.types import (
    IMAGE_DATA_PATH_SUFFIXES,
    IMAGE_URL_SUFFIXES,
    DataFieldArrayValue,
    DataFieldArrayValueDataType,
    DataFieldBasicDataType,
    DataFieldSimpleValue,
    DataFieldSimpleValueDataType,
)
from next_gen_ui_agent.data_transform.validation.assertions import is_url_http
from next_gen_ui_agent.types import DataField

logger = logging.getLogger(__name__)


def copy_simple_fields_from_ui_component_metadata(
    fields: list[DataField],
) -> list[DataFieldSimpleValue]:
    return [DataFieldSimpleValue(**field.model_dump()) for field in fields]


def copy_array_fields_from_ui_component_metadata(
    fields: list[DataField],
) -> list[DataFieldArrayValue]:
    return [DataFieldArrayValue(**field.model_dump()) for field in fields]


def sanitize_data_path(data_path: str | None) -> str | None:
    """Internal use: Sanitize data path generated by LLM so it can be used for data pickup by `get_data_value_for_path`. Returns `None` if data path is invalid."""

    if data_path:
        # strip data path from whitespaces
        data_path = data_path.strip()

        # patch occasional LLM errors
        if data_path == "$" or data_path == "":
            return None

        # `$` and `{` handling
        while (
            data_path.startswith("$")
            or data_path.startswith(".")
            or data_path.startswith("{")
        ):
            data_path = data_path[1:]
        data_path = data_path.replace("{", "").replace("}", "")

        # handle path elements like ['name'] by removing `['` and `']` but keeping the field name, add dot for cases like `['movie']['year']`
        data_path = data_path.replace("']['", ".").replace("['", "").replace("']", "")

        # Handle paths like `subscriptions[size up to 6].name` by removing content between []
        # Keep it if there are only numbers inside (like `[0]`, `[1]`, etc.)
        # this code is necessary for our array size reduction in LLM inference step
        data_path = re.sub(r"\[([^\]]*[^\d\]]+[^\]]*)\]", "[*]", data_path)

        # sanitization of [] and [*]
        data_path = data_path.replace("[][", "[")
        data_path = data_path.replace("[*][", "[")
        data_path = data_path.replace("[]", "[*]")

        # never `[*]` at the end as it selects content of the array into main returned array
        if data_path.endswith("[*]"):
            data_path = data_path[:-3]

        # data paths with more accesses to array are always invalid
        if len(data_path.split("[", 3)) > 2:
            return None

        # make sure data are picked in any depth
        if data_path and len(data_path) > 0:
            data_path = f"$..{data_path}"

        return data_path
    else:
        return None


def get_data_value_for_path(data_path: str | None, json_data: Any) -> list[Any] | None:
    """
    Get data for path generated by LLM from JSON parsed data.
    Both path and data value are sanitized inside of this method.
    Returns `None` if data_path is somehow invalid (Exception is thrown by JSONPath library during path parsing or data value pickup) or None or empty (returned from sanitization for invalid paths)
    """
    if not data_path:
        return None

    je = None
    try:
        je = parse(data_path)
    except Exception:
        logger.exception("Failed JSONPath expression parsing for '%s'", data_path)
        return None

    try:
        find = je.find(json_data)
        matched_data: list[Any] = []
        shortest_path = None
        # as we use JSONPaths starting with `$..` to adjust for LLM missing start of the path sometimes,
        # we have to only pickup values with the shortest paths not to mix together fields from different levels of nesting
        for match in find:
            # we have to remove array indices
            match_path = re.sub(r"\[\d+\]", "[]", str(match.full_path))
            if (not shortest_path) or len(match_path) < len(shortest_path):  # type: ignore
                shortest_path = match_path
                matched_data = []
            if shortest_path == match_path:
                matched_data.append(match.value)
        return matched_data
    except Exception:
        # patch for "object in array in root" case, where used JSONPath library can't get values correctly for path starting with `$..` which are correct when I try them on web JSONPath playground
        if data_path.startswith("$..["):
            return get_data_value_for_path(data_path.replace("$..[", "$["), json_data)
        logger.exception("Cannot match data for JSONPath '%s'", data_path)
        return None


def sanitize_matched_simple_data(
    matched_data_list: list[Any] | None,
) -> DataFieldSimpleValueDataType:
    """Check JSONPath matched data if they match the expected layout and types for simple value - internal use only"""

    result = []

    if matched_data_list:
        # remove None values
        for r in matched_data_list:
            # r may contain Boolean values, so we need to check explicitly if the value is not None
            if r is not None:
                result.append(r)

        # Array with array of values - transform to array with values
        if len(result) == 1 and isinstance(result[0], list):
            result = result[0]

        # remove objects from the array not to be sent to rendering
        if len(result) > 0 and isinstance(result[0], dict):
            logger.warning(
                "Objects in the array of simple values are not supported - removing them"
            )
            return []

    return result


def fill_fields_with_simple_data(fields: list[DataFieldSimpleValue], json_data: Any):
    """Fills fields with simple value data values from JSON data based on paths generated by LLM"""
    for field in fields:
        sp = sanitize_data_path(field.data_path)
        field.data_path = sp if sp else ""
        field.data = sanitize_matched_simple_data(
            get_data_value_for_path(sp, json_data)
        )


def sanitize_matched_array_data(
    matched_data_list: list[Any] | None,
) -> DataFieldArrayValueDataType:
    """Check JSONPath matched data if they match the expected layout and types for array value - internal use only"""

    # this happens if LLM generated path is invalid
    if not matched_data_list:
        return []

    result: DataFieldArrayValueDataType = []
    for r in matched_data_list:
        # further sanitize array values
        if isinstance(r, list):
            sr = sanitize_matched_simple_data(r)
            if len(sr) > 0:
                result.append(sr)
            else:
                result.append(None)
        else:
            result.append(r)

    return result


def fill_fields_with_array_data(fields: list[DataFieldArrayValue], json_data: Any):
    """Fills fields with array data values from JSON data based on paths generated by LLM"""
    for field in fields:
        sp = sanitize_data_path(field.data_path)
        field.data_path = sp if sp else ""
        d = get_data_value_for_path(sp, json_data)
        field.data = sanitize_matched_array_data(d)


def find_field_by_simple_data_value(
    fields: list[DataFieldSimpleValue],
    field_data_predicate: Callable[[DataFieldBasicDataType], bool],
) -> DataFieldSimpleValue | None:
    """Helper methods for to find field based on predicate."""
    return next(
        (field for field in fields for d in field.data if field_data_predicate(d)),
        None,
    )


def find_simple_value_field_by_data_path(
    fields: list[DataFieldSimpleValue],
    data_path_predicate: Callable[[str], bool],
) -> DataFieldSimpleValue | None:
    """Helper methods for to find field based on its data_path predicate. Predicate's argument is lowered field `data_path`"""
    return next(
        (
            field
            for field in fields
            if field.data_path and data_path_predicate(field.data_path.lower())
        ),
        None,
    )


def find_simple_data_value_in_field(
    items: DataFieldSimpleValueDataType,
    data_value_predicate: Callable[[DataFieldBasicDataType], bool],
) -> DataFieldBasicDataType | None:
    """Helper methods for to find field data value based on predicate."""
    return next(
        (value for value in items if data_value_predicate(value)),
        None,
    )


def find_image(
    fields: list[DataFieldSimpleValue],
) -> tuple[str, DataFieldSimpleValue] | tuple[None, None]:
    """Find image field with image. Return tuple with data value and DataField"""
    field_with_image_suffix = find_field_by_simple_data_value(
        fields,
        lambda data: isinstance(data, str)
        and data.lower().endswith(IMAGE_URL_SUFFIXES),
    )
    if field_with_image_suffix:
        image = find_simple_data_value_in_field(
            field_with_image_suffix.data,
            lambda value: isinstance(value, str)
            and value.lower().endswith(IMAGE_URL_SUFFIXES),
        )
        if image and is_url_http(str(image)):
            return str(image), field_with_image_suffix

    # not found by image url, so try to find by field name suffix
    field_name_like_url = find_simple_value_field_by_data_path(
        fields,
        lambda name: name.lower().endswith(IMAGE_DATA_PATH_SUFFIXES),
    )
    if (
        field_name_like_url
        and len(field_name_like_url.data) > 0
        and is_url_http(str(field_name_like_url.data[0]))
    ):
        return str(field_name_like_url.data[0]), field_name_like_url

    return None, None
