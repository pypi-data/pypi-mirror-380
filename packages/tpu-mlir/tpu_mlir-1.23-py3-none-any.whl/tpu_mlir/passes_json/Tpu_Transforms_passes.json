{"!instanceof":{"InterfacePass":[],"ListOption":[],"Option":["anonymous_0","anonymous_1","anonymous_10","anonymous_11","anonymous_12","anonymous_13","anonymous_14","anonymous_15","anonymous_16","anonymous_17","anonymous_18","anonymous_19","anonymous_2","anonymous_20","anonymous_21","anonymous_22","anonymous_23","anonymous_24","anonymous_25","anonymous_26","anonymous_27","anonymous_28","anonymous_29","anonymous_3","anonymous_30","anonymous_31","anonymous_32","anonymous_4","anonymous_5","anonymous_6","anonymous_7","anonymous_8","anonymous_9"],"Pass":["AddressAssign","AfterLayerGroupWeightReorder","Codegen","CoreParallel","CutFinalMlir","DDRInterleave","DevParallel","FutureUpdate","LayerGroup","NetStatistic","OpDivide","OpReorder","OptPostProcessor","ProcessorOptimize","ShapeOptimize","ShowAddress","StripIOQuant","SubnetDivide","TimeFixedSubnet","TruncIO","TruncLayer","WeightFold","WeightReorder"],"PassBase":["AddressAssign","AfterLayerGroupWeightReorder","Codegen","CoreParallel","CutFinalMlir","DDRInterleave","DevParallel","FutureUpdate","LayerGroup","NetStatistic","OpDivide","OpReorder","OptPostProcessor","ProcessorOptimize","ShapeOptimize","ShowAddress","StripIOQuant","SubnetDivide","TimeFixedSubnet","TruncIO","TruncLayer","WeightFold","WeightReorder"],"Statistic":[]},"!tablegen_json_version":1,"AddressAssign":{"!anonymous":false,"!fields":[],"!name":"AddressAssign","!superclasses":["PassBase","Pass"],"argument":"address-assign","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createAddressAssignPass()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_12","kind":"def","printable":"anonymous_12"},{"def":"anonymous_13","kind":"def","printable":"anonymous_13"},{"def":"anonymous_14","kind":"def","printable":"anonymous_14"},{"def":"anonymous_15","kind":"def","printable":"anonymous_15"}],"statistics":[],"summary":"assign address in tpu by tpuc-opt"},"AfterLayerGroupWeightReorder":{"!anonymous":false,"!fields":[],"!name":"AfterLayerGroupWeightReorder","!superclasses":["PassBase","Pass"],"argument":"after-layergroup-weight-reorder","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createAfterLayerGroupWeightReorderPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"some idx weights allow split, but the output slice may use correspond to non-consecutive idxs, requiring a reordering of the idx weights."},"Codegen":{"!anonymous":false,"!fields":[],"!name":"Codegen","!superclasses":["PassBase","Pass"],"argument":"codegen","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createCodegenPass()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_17","kind":"def","printable":"anonymous_17"},{"def":"anonymous_18","kind":"def","printable":"anonymous_18"},{"def":"anonymous_19","kind":"def","printable":"anonymous_19"},{"def":"anonymous_20","kind":"def","printable":"anonymous_20"},{"def":"anonymous_21","kind":"def","printable":"anonymous_21"}],"statistics":[],"summary":"codegen in tpu by tpuc-opt"},"CoreParallel":{"!anonymous":false,"!fields":[],"!name":"CoreParallel","!superclasses":["PassBase","Pass"],"argument":"core-parallel","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createCoreParallelPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"split the operation to fine-grained and run it in parallel on TPU"},"CutFinalMlir":{"!anonymous":false,"!fields":[],"!name":"CutFinalMlir","!superclasses":["PassBase","Pass"],"argument":"cut-final-mlir","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createCutFinalMlirPass()","dependentDialects":[],"description":"","options":[{"def":"anonymous_22","kind":"def","printable":"anonymous_22"}],"statistics":[],"summary":"cut final mlir"},"DDRInterleave":{"!anonymous":false,"!fields":[],"!name":"DDRInterleave","!superclasses":["PassBase","Pass"],"argument":"ddr-interleave","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createDDRInterleavePass()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_11","kind":"def","printable":"anonymous_11"}],"statistics":[],"summary":"DDR interleave mode"},"DevParallel":{"!anonymous":false,"!fields":[],"!name":"DevParallel","!superclasses":["PassBase","Pass"],"argument":"dev-parallel","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createDevParallelPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"distribute module to multi modules to run in multi devices"},"FutureUpdate":{"!anonymous":false,"!fields":[],"!name":"FutureUpdate","!superclasses":["PassBase","Pass"],"argument":"future-update","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createFutureUpdatePass()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_0","kind":"def","printable":"anonymous_0"},{"def":"anonymous_1","kind":"def","printable":"anonymous_1"}],"statistics":[],"summary":"add some op for updating in future"},"LayerGroup":{"!anonymous":false,"!fields":[],"!name":"LayerGroup","!superclasses":["PassBase","Pass"],"argument":"layer-group","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createLayerGroupPass()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_3","kind":"def","printable":"anonymous_3"},{"def":"anonymous_4","kind":"def","printable":"anonymous_4"},{"def":"anonymous_5","kind":"def","printable":"anonymous_5"},{"def":"anonymous_6","kind":"def","printable":"anonymous_6"},{"def":"anonymous_7","kind":"def","printable":"anonymous_7"},{"def":"anonymous_8","kind":"def","printable":"anonymous_8"},{"def":"anonymous_9","kind":"def","printable":"anonymous_9"},{"def":"anonymous_10","kind":"def","printable":"anonymous_10"}],"statistics":[],"summary":"convert to layer group in tpu by tpuc-opt"},"NetStatistic":{"!anonymous":false,"!fields":[],"!name":"NetStatistic","!superclasses":["PassBase","Pass"],"argument":"net_statistic","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createNetStatisticPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"net statistic"},"OpDivide":{"!anonymous":false,"!fields":[],"!name":"OpDivide","!superclasses":["PassBase","Pass"],"argument":"op-divide","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createOpDividePass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"divide large global op to save global memory"},"OpReorder":{"!anonymous":false,"!fields":[],"!name":"OpReorder","!superclasses":["PassBase","Pass"],"argument":"op-reorder","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createOpReorderPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"op reorder in tpu by tpuc-opt"},"OptPostProcessor":{"!anonymous":false,"!fields":[],"!name":"OptPostProcessor","!superclasses":["PassBase","Pass"],"argument":"opt-post-processor","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createOptPostProcessorPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"Graph Optimization after LayerGroup but before AddressAssign"},"ProcessorOptimize":{"!anonymous":false,"!fields":[],"!name":"ProcessorOptimize","!superclasses":["PassBase","Pass"],"argument":"processor-tpu-optimize","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createProcessorOptimizePass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"aplly passes in tpu by tpuc-opt"},"ShapeOptimize":{"!anonymous":false,"!fields":[],"!name":"ShapeOptimize","!superclasses":["PassBase","Pass"],"argument":"shape-optimize","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createShapeOptimizePass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"optimize bad shape in tpu by tpuc-opt"},"ShowAddress":{"!anonymous":false,"!fields":[],"!name":"ShowAddress","!superclasses":["PassBase","Pass"],"argument":"show-address","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createShowAddressPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"print final mlir address by tpuc-opt"},"StripIOQuant":{"!anonymous":false,"!fields":[],"!name":"StripIOQuant","!superclasses":["PassBase","Pass"],"argument":"strip-io-quant","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createStripIOQuant()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_23","kind":"def","printable":"anonymous_23"},{"def":"anonymous_24","kind":"def","printable":"anonymous_24"},{"def":"anonymous_25","kind":"def","printable":"anonymous_25"},{"def":"anonymous_26","kind":"def","printable":"anonymous_26"},{"def":"anonymous_27","kind":"def","printable":"anonymous_27"}],"statistics":[],"summary":"remove input & output fp32<->int8 converiton in int8model"},"SubnetDivide":{"!anonymous":false,"!fields":[],"!name":"SubnetDivide","!superclasses":["PassBase","Pass"],"argument":"subnet-divide","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createSubnetDividePass()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_2","kind":"def","printable":"anonymous_2"}],"statistics":[],"summary":"subnet divide in tpu by tpuc-opt"},"TimeFixedSubnet":{"!anonymous":false,"!fields":[],"!name":"TimeFixedSubnet","!superclasses":["PassBase","Pass"],"argument":"time-fixed-subnet","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createTimeFixedSubnetPass()","dependentDialects":[],"description":"","options":[{"def":"anonymous_16","kind":"def","printable":"anonymous_16"}],"statistics":[],"summary":"Split the model by fixed duration intervals"},"TruncIO":{"!anonymous":false,"!fields":[],"!name":"TruncIO","!superclasses":["PassBase","Pass"],"argument":"trunc-io","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createTruncIOPass()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_28","kind":"def","printable":"anonymous_28"},{"def":"anonymous_29","kind":"def","printable":"anonymous_29"},{"def":"anonymous_30","kind":"def","printable":"anonymous_30"},{"def":"anonymous_31","kind":"def","printable":"anonymous_31"}],"statistics":[],"summary":"truncate final mlir according to inputs/outputs, keeping the structure as far as possible."},"TruncLayer":{"!anonymous":false,"!fields":[],"!name":"TruncLayer","!superclasses":["PassBase","Pass"],"argument":"trunc-layer","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createTruncLayerPass()","dependentDialects":["TpuDialect"],"description":"","options":[{"def":"anonymous_32","kind":"def","printable":"anonymous_32"}],"statistics":[],"summary":"Cut any mlir as sub mlir"},"WeightFold":{"!anonymous":false,"!fields":[],"!name":"WeightFold","!superclasses":["PassBase","Pass"],"argument":"weight-fold","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createWeightFoldPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"fold weight if all input of an operation is weight"},"WeightReorder":{"!anonymous":false,"!fields":[],"!name":"WeightReorder","!superclasses":["PassBase","Pass"],"argument":"weight-reorder","baseClass":"::mlir::OperationPass<ModuleOp>","constructor":"createWeightReorderPass()","dependentDialects":["TpuDialect"],"description":"","options":[],"statistics":[],"summary":"weight reorder in tpu by tpuc-opt"},"anonymous_0":{"!anonymous":true,"!fields":[],"!name":"anonymous_0","!superclasses":["Option"],"additionalOptFlags":"","argument":"rank","cppName":"rank","defaultValue":"0","description":"lora rank","type":"int64_t"},"anonymous_1":{"!anonymous":true,"!fields":[],"!name":"anonymous_1","!superclasses":["Option"],"additionalOptFlags":"","argument":"weight_list","cppName":"weight_list","defaultValue":"\"none\"","description":"which weight to update","type":"std::string"},"anonymous_10":{"!anonymous":true,"!fields":[],"!name":"anonymous_10","!superclasses":["Option"],"additionalOptFlags":"","argument":"config_filename","cppName":"config_filename","defaultValue":"\"\"","description":"config file name","type":"std::string"},"anonymous_11":{"!anonymous":true,"!fields":[],"!name":"anonymous_11","!superclasses":["Option"],"additionalOptFlags":"","argument":"interleave-region","cppName":"interleave_region","defaultValue":"1","description":"interleave_region:1 The DDRC is configured to balance performance across most use cases.","type":"int64_t"},"anonymous_12":{"!anonymous":true,"!fields":[],"!name":"anonymous_12","!superclasses":["Option"],"additionalOptFlags":"","argument":"reuse_addr","cppName":"reuse_addr","defaultValue":"true","description":"reuse tensor memory.","type":"bool"},"anonymous_13":{"!anonymous":true,"!fields":[],"!name":"anonymous_13","!superclasses":["Option"],"additionalOptFlags":"","argument":"merge_weight","cppName":"merge_weight","defaultValue":"false","description":"merge weight memory.","type":"bool"},"anonymous_14":{"!anonymous":true,"!fields":[],"!name":"anonymous_14","!superclasses":["Option"],"additionalOptFlags":"","argument":"compress_weight","cppName":"compress_weight","defaultValue":"true","description":"compress weight memory.","type":"bool"},"anonymous_15":{"!anonymous":true,"!fields":[],"!name":"anonymous_15","!superclasses":["Option"],"additionalOptFlags":"","argument":"weight_map_file","cppName":"weight_map_file","defaultValue":"\"_weight_map.csv\"","description":"record weight offset with its name into a csv map file.","type":"std::string"},"anonymous_16":{"!anonymous":true,"!fields":[],"!name":"anonymous_16","!superclasses":["Option"],"additionalOptFlags":"","argument":"json_file","cppName":"json_file","defaultValue":"","description":".subnets.json","type":"std::string"},"anonymous_17":{"!anonymous":true,"!fields":[],"!name":"anonymous_17","!superclasses":["Option"],"additionalOptFlags":"","argument":"model_file","cppName":"model_file","defaultValue":"","description":"save to model file","type":"std::string"},"anonymous_18":{"!anonymous":true,"!fields":[],"!name":"anonymous_18","!superclasses":["Option"],"additionalOptFlags":"","argument":"embed_debug_info","cppName":"embed_debug_info","defaultValue":"false","description":"embed debug and profiling data to model file.","type":"bool"},"anonymous_19":{"!anonymous":true,"!fields":[],"!name":"anonymous_19","!superclasses":["Option"],"additionalOptFlags":"","argument":"model_version","cppName":"model_version","defaultValue":"\"lastest\"","description":"model version.","type":"std::string"},"anonymous_2":{"!anonymous":true,"!fields":[],"!name":"anonymous_2","!superclasses":["Option"],"additionalOptFlags":"","argument":"dynamic","cppName":"dynamic","defaultValue":"false","description":"dynamic compiler or not.","type":"bool"},"anonymous_20":{"!anonymous":true,"!fields":[],"!name":"anonymous_20","!superclasses":["Option"],"additionalOptFlags":"","argument":"bmodel_only","cppName":"bmodel_only","defaultValue":"false","description":"dump bmodel only.","type":"bool"},"anonymous_21":{"!anonymous":true,"!fields":[],"!name":"anonymous_21","!superclasses":["Option"],"additionalOptFlags":"","argument":"gdma_check","cppName":"gdma_check","defaultValue":"true","description":"gdma address check.","type":"bool"},"anonymous_22":{"!anonymous":true,"!fields":[],"!name":"anonymous_22","!superclasses":["Option"],"additionalOptFlags":"","argument":"config_file","cppName":"config_file","defaultValue":"\"\"","description":"config json file","type":"std::string"},"anonymous_23":{"!anonymous":true,"!fields":[],"!name":"anonymous_23","!superclasses":["Option"],"additionalOptFlags":"","argument":"quant_input","cppName":"quant_input","defaultValue":"false","description":"strip input quant.","type":"bool"},"anonymous_24":{"!anonymous":true,"!fields":[],"!name":"anonymous_24","!superclasses":["Option"],"additionalOptFlags":"","argument":"quant_output","cppName":"quant_output","defaultValue":"false","description":"strip output quant.","type":"bool"},"anonymous_25":{"!anonymous":true,"!fields":[],"!name":"anonymous_25","!superclasses":["Option"],"additionalOptFlags":"","argument":"quant_input_list","cppName":"quant_input_list","defaultValue":"","description":"choose index to strip input quant.","type":"std::string"},"anonymous_26":{"!anonymous":true,"!fields":[],"!name":"anonymous_26","!superclasses":["Option"],"additionalOptFlags":"","argument":"quant_output_list","cppName":"quant_output_list","defaultValue":"","description":"choose index to strip output quant.","type":"std::string"},"anonymous_27":{"!anonymous":true,"!fields":[],"!name":"anonymous_27","!superclasses":["Option"],"additionalOptFlags":"","argument":"quant_output_bf16","cppName":"quant_output_bf16","defaultValue":"false","description":"force output to be bf16 type","type":"bool"},"anonymous_28":{"!anonymous":true,"!fields":[],"!name":"anonymous_28","!superclasses":["Option"],"additionalOptFlags":"","argument":"inputs","cppName":"inputs","defaultValue":"","description":"new input names","type":"std::string"},"anonymous_29":{"!anonymous":true,"!fields":[],"!name":"anonymous_29","!superclasses":["Option"],"additionalOptFlags":"","argument":"outputs","cppName":"outputs","defaultValue":"","description":"new output names","type":"std::string"},"anonymous_3":{"!anonymous":true,"!fields":[],"!name":"anonymous_3","!superclasses":["Option"],"additionalOptFlags":"","argument":"opt","cppName":"opt","defaultValue":"2","description":"opt=1: group layers as many as possible. opt=2: dynamic programming layer group","type":"int64_t"},"anonymous_30":{"!anonymous":true,"!fields":[],"!name":"anonymous_30","!superclasses":["Option"],"additionalOptFlags":"","argument":"weight_shared","cppName":"weight_shared","defaultValue":"false","description":"whether to share weight","type":"bool"},"anonymous_31":{"!anonymous":true,"!fields":[],"!name":"anonymous_31","!superclasses":["Option"],"additionalOptFlags":"","argument":"trunc_mode","cppName":"trunc_mode","defaultValue":"0","description":"determine how many END_OPs under consideration, optional values is: 0, 1.0 -> only one END_OP (default)1 -> one or more END_OPs","type":"int"},"anonymous_32":{"!anonymous":true,"!fields":[],"!name":"anonymous_32","!superclasses":["Option"],"additionalOptFlags":"","argument":"cutLocs","cppName":"cutLocs","defaultValue":"","description":"cut loc names, split by comma, like 0,1,2","type":"std::string"},"anonymous_4":{"!anonymous":true,"!fields":[],"!name":"anonymous_4","!superclasses":["Option"],"additionalOptFlags":"","argument":"group_by_cores","cppName":"group_by_cores","defaultValue":"\"auto\"","description":"whether force group by cores","type":"std::string"},"anonymous_5":{"!anonymous":true,"!fields":[],"!name":"anonymous_5","!superclasses":["Option"],"additionalOptFlags":"","argument":"compress_mode","cppName":"compress_mode","defaultValue":"\"none\"","description":"compress mode","type":"std::string"},"anonymous_6":{"!anonymous":true,"!fields":[],"!name":"anonymous_6","!superclasses":["Option"],"additionalOptFlags":"","argument":"lgcache","cppName":"lgcache","defaultValue":"\"true\"","description":"whether to dump cut_results","type":"std::string"},"anonymous_7":{"!anonymous":true,"!fields":[],"!name":"anonymous_7","!superclasses":["Option"],"additionalOptFlags":"","argument":"debugger","cppName":"debugger","defaultValue":"0","description":"0: do nothing; 1: do LayerGroup and create debugger file; 2: only create debugger file; 3: do LayerGroup with debugger file; 4: do partial LayerGroup with debugger file.","type":"int64_t"},"anonymous_8":{"!anonymous":true,"!fields":[],"!name":"anonymous_8","!superclasses":["Option"],"additionalOptFlags":"","argument":"debugger_filename","cppName":"debugger_filename","defaultValue":"\"\"","description":"debugger file name","type":"std::string"},"anonymous_9":{"!anonymous":true,"!fields":[],"!name":"anonymous_9","!superclasses":["Option"],"additionalOptFlags":"","argument":"disable_group_overlap","cppName":"disable_group_overlap","defaultValue":"false","description":"disable group overlap","type":"bool"}}
