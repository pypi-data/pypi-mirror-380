
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _top_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "top"
  pass


@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class A16MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "top.A16MatMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, scale, zp, bias, *, right_transpose=None, q_group_size=None, weight_bits=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(scale))
    operands.append(_get_op_result_or_value(zp))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if right_transpose is not None: attributes["right_transpose"] = (right_transpose if (
        issubclass(type(right_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(right_transpose, context=_ods_context))
    if q_group_size is not None: attributes["q_group_size"] = (q_group_size if (
        issubclass(type(q_group_size), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(q_group_size, context=_ods_context))
    if weight_bits is not None: attributes["weight_bits"] = (weight_bits if (
        issubclass(type(weight_bits), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(weight_bits, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def scale(self):
    return self.operation.operands[2]

  @builtins.property
  def zp(self):
    return self.operation.operands[3]

  @builtins.property
  def bias(self):
    return self.operation.operands[4]

  @builtins.property
  def right_transpose(self):
    return self.operation.attributes["right_transpose"]

  @right_transpose.setter
  def right_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["right_transpose"] = value

  @builtins.property
  def q_group_size(self):
    return self.operation.attributes["q_group_size"]

  @q_group_size.setter
  def q_group_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["q_group_size"] = value

  @builtins.property
  def weight_bits(self):
    return self.operation.attributes["weight_bits"]

  @weight_bits.setter
  def weight_bits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weight_bits"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AbsOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AdaptiveAvgPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "top.AdaptiveAvgPool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["output_size"] = (output_size if (
    issubclass(type(output_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_size, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output_size(self):
    return self.operation.attributes["output_size"]

  @output_size.setter
  def output_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_size"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AddConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.AddConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, do_relu=None, relu_limit=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Add"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, coeff=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if coeff is not None: attributes["coeff"] = (coeff if (
        issubclass(type(coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeff, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def coeff(self):
    if "coeff" not in self.operation.attributes:
      return None
    return self.operation.attributes["coeff"]

  @coeff.setter
  def coeff(self, value):
    if value is not None:
      self.operation.attributes["coeff"] = value
    elif "coeff" in self.operation.attributes:
      del self.operation.attributes["coeff"]

  @coeff.deleter
  def coeff(self):
    del self.operation.attributes["coeff"]

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ArangeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Arange"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, start, end, step, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(start))
    operands.append(_get_op_result_or_value(end))
    operands.append(_get_op_result_or_value(step))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def end(self):
    return self.operation.operands[1]

  @builtins.property
  def step(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ArccosOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Arccos"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ArctanhOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Arctanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ArgOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Arg"

  _ODS_REGIONS = (0, True)

  def __init__(self, indices, values, input, axis, keepdims, mode, *, select_last_index=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    attributes["keepdims"] = (keepdims if (
    issubclass(type(keepdims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArgModeAttr')) else
      _ods_ir.AttrBuilder.get('ArgModeAttr')(mode, context=_ods_context))
    if select_last_index is not None: attributes["select_last_index"] = (select_last_index if (
        issubclass(type(select_last_index), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(select_last_index, context=_ods_context))
    results.append(indices)
    results.append(values)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def select_last_index(self):
    return self.operation.attributes["select_last_index"]

  @select_last_index.setter
  def select_last_index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["select_last_index"] = value

  @builtins.property
  def indices(self):
    return self.operation.results[0]

  @builtins.property
  def values(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Attention"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, keys, values, queries_weight, queries_bias, keys_weight, keys_bias, values_weight, values_bias, out_weight, out_bias, mask, scale, head, *, dim=None, scale_param=None, zp_param=None, has_bias=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(keys))
    operands.append(_get_op_result_or_value(values))
    operands.append(_get_op_result_or_value(queries_weight))
    operands.append(_get_op_result_or_value(queries_bias))
    operands.append(_get_op_result_or_value(keys_weight))
    operands.append(_get_op_result_or_value(keys_bias))
    operands.append(_get_op_result_or_value(values_weight))
    operands.append(_get_op_result_or_value(values_bias))
    operands.append(_get_op_result_or_value(out_weight))
    operands.append(_get_op_result_or_value(out_bias))
    operands.append(_get_op_result_or_value(mask))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    attributes["head"] = (head if (
    issubclass(type(head), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(head, context=_ods_context))
    if dim is not None: attributes["dim"] = (dim if (
        issubclass(type(dim), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    if scale_param is not None: attributes["scale_param"] = (scale_param if (
        issubclass(type(scale_param), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale_param, context=_ods_context))
    if zp_param is not None: attributes["zp_param"] = (zp_param if (
        issubclass(type(zp_param), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(zp_param, context=_ods_context))
    if has_bias is not None: attributes["has_bias"] = (has_bias if (
        issubclass(type(has_bias), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(has_bias, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def keys(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def queries_weight(self):
    return self.operation.operands[3]

  @builtins.property
  def queries_bias(self):
    return self.operation.operands[4]

  @builtins.property
  def keys_weight(self):
    return self.operation.operands[5]

  @builtins.property
  def keys_bias(self):
    return self.operation.operands[6]

  @builtins.property
  def values_weight(self):
    return self.operation.operands[7]

  @builtins.property
  def values_bias(self):
    return self.operation.operands[8]

  @builtins.property
  def out_weight(self):
    return self.operation.operands[9]

  @builtins.property
  def out_bias(self):
    return self.operation.operands[10]

  @builtins.property
  def mask(self):
    return self.operation.operands[11]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def head(self):
    return self.operation.attributes["head"]

  @head.setter
  def head(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["head"] = value

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def scale_param(self):
    return self.operation.attributes["scale_param"]

  @scale_param.setter
  def scale_param(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_param"] = value

  @builtins.property
  def zp_param(self):
    return self.operation.attributes["zp_param"]

  @zp_param.setter
  def zp_param(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["zp_param"] = value

  @builtins.property
  def has_bias(self):
    return self.operation.attributes["has_bias"]

  @has_bias.setter
  def has_bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["has_bias"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AvgPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "top.AvgPool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel_shape, strides, pads, *, ceil_mode=None, auto_pad=None, is_adaptive=None, keepdims=None, pad_value=None, count_include_pad=None, do_relu=None, relu_limit=None, round_mode=None, first_round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if ceil_mode is not None: attributes["ceil_mode"] = (ceil_mode if (
        issubclass(type(ceil_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    if auto_pad is not None: attributes["auto_pad"] = (auto_pad if (
        issubclass(type(auto_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AutoPadModeAttr')) else
          _ods_ir.AttrBuilder.get('AutoPadModeAttr')(auto_pad, context=_ods_context))
    if is_adaptive is not None: attributes["is_adaptive"] = (is_adaptive if (
        issubclass(type(is_adaptive), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_adaptive, context=_ods_context))
    if keepdims is not None: attributes["keepdims"] = (keepdims if (
        issubclass(type(keepdims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(first_round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def ceil_mode(self):
    if "ceil_mode" not in self.operation.attributes:
      return None
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is not None:
      self.operation.attributes["ceil_mode"] = value
    elif "ceil_mode" in self.operation.attributes:
      del self.operation.attributes["ceil_mode"]

  @ceil_mode.deleter
  def ceil_mode(self):
    del self.operation.attributes["ceil_mode"]

  @builtins.property
  def auto_pad(self):
    if "auto_pad" not in self.operation.attributes:
      return None
    return self.operation.attributes["auto_pad"]

  @auto_pad.setter
  def auto_pad(self, value):
    if value is not None:
      self.operation.attributes["auto_pad"] = value
    elif "auto_pad" in self.operation.attributes:
      del self.operation.attributes["auto_pad"]

  @auto_pad.deleter
  def auto_pad(self):
    del self.operation.attributes["auto_pad"]

  @builtins.property
  def is_adaptive(self):
    return self.operation.attributes["is_adaptive"]

  @is_adaptive.setter
  def is_adaptive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_adaptive"] = value

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def pad_value(self):
    return self.operation.attributes["pad_value"]

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def count_include_pad(self):
    return self.operation.attributes["count_include_pad"]

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BatchNormBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "top.BatchNormBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_in, weight_grad, bias_grad, grad_out, input, weight_opt, saved_mean, saved_invstd, *, epsilon=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_out))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight_opt))
    operands.append(_get_op_result_or_value(saved_mean))
    operands.append(_get_op_result_or_value(saved_invstd))
    _ods_context = _ods_get_default_loc_context(loc)
    if epsilon is not None: attributes["epsilon"] = (epsilon if (
        issubclass(type(epsilon), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(epsilon, context=_ods_context))
    results.append(grad_in)
    results.append(weight_grad)
    results.append(bias_grad)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def weight_opt(self):
    return self.operation.operands[2]

  @builtins.property
  def saved_mean(self):
    return self.operation.operands[3]

  @builtins.property
  def saved_invstd(self):
    return self.operation.operands[4]

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def grad_in(self):
    return self.operation.results[0]

  @builtins.property
  def weight_grad(self):
    return self.operation.results[1]

  @builtins.property
  def bias_grad(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BatchNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.BatchNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mean, variance, gamma, beta, *, epsilon=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(variance))
    operands.append(_get_op_result_or_value(gamma))
    operands.append(_get_op_result_or_value(beta))
    _ods_context = _ods_get_default_loc_context(loc)
    if epsilon is not None: attributes["epsilon"] = (epsilon if (
        issubclass(type(epsilon), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(epsilon, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mean(self):
    return self.operation.operands[1]

  @builtins.property
  def variance(self):
    return self.operation.operands[2]

  @builtins.property
  def gamma(self):
    return self.operation.operands[3]

  @builtins.property
  def beta(self):
    return self.operation.operands[4]

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BatchNormTrainOp(_ods_ir.OpView):
  OPERATION_NAME = "top.BatchNormTrain"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mean_out, saved_invstd, running_mean, running_var, input, mean, var, gamma, beta, *, epsilon=None, momentum=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(var))
    operands.append(_get_op_result_or_value(gamma))
    operands.append(_get_op_result_or_value(beta))
    _ods_context = _ods_get_default_loc_context(loc)
    if epsilon is not None: attributes["epsilon"] = (epsilon if (
        issubclass(type(epsilon), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(epsilon, context=_ods_context))
    if momentum is not None: attributes["momentum"] = (momentum if (
        issubclass(type(momentum), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(momentum, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    results.append(mean_out)
    results.append(saved_invstd)
    results.append(running_mean)
    results.append(running_var)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mean(self):
    return self.operation.operands[1]

  @builtins.property
  def var(self):
    return self.operation.operands[2]

  @builtins.property
  def gamma(self):
    return self.operation.operands[3]

  @builtins.property
  def beta(self):
    return self.operation.operands[4]

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def momentum(self):
    return self.operation.attributes["momentum"]

  @momentum.setter
  def momentum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["momentum"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mean_out(self):
    return self.operation.results[1]

  @builtins.property
  def saved_invstd(self):
    return self.operation.results[2]

  @builtins.property
  def running_mean(self):
    return self.operation.results[3]

  @builtins.property
  def running_var(self):
    return self.operation.results[4]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CastOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CeilOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ClipOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Clip"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, min, max, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min"] = (min if (
    issubclass(type(min), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(min, context=_ods_context))
    attributes["max"] = (max if (
    issubclass(type(max), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(max, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.attributes["min"]

  @min.setter
  def min(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min"] = value

  @builtins.property
  def max(self):
    return self.operation.attributes["max"]

  @max.setter
  def max(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CompareConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.CompareConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mode, const_val, inversed, *, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CompareModeAttr')) else
      _ods_ir.AttrBuilder.get('CompareModeAttr')(mode, context=_ods_context))
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    attributes["inversed"] = (inversed if (
    issubclass(type(inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inversed, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def inversed(self):
    return self.operation.attributes["inversed"]

  @inversed.setter
  def inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inversed"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CompareOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Compare"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CompareModeAttr')) else
      _ods_ir.AttrBuilder.get('CompareModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, axis=None, do_relu=None, relu_limit=None, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConstantFillOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ConstantFill"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    issubclass(type(value), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(value, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConvBwdWeightOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ConvBwd_Weight"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, gradout, gradout_transpose, groups, input_shape, grad_out_shape, kernel_shape, stride, dilations, padding, grad_bias_enable, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(gradout))
    operands.append(_get_op_result_or_value(gradout_transpose))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["groups"] = (groups if (
    issubclass(type(groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(groups, context=_ods_context))
    attributes["input_shape"] = (input_shape if (
    issubclass(type(input_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_shape, context=_ods_context))
    attributes["grad_out_shape"] = (grad_out_shape if (
    issubclass(type(grad_out_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(grad_out_shape, context=_ods_context))
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["stride"] = (stride if (
    issubclass(type(stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    attributes["dilations"] = (dilations if (
    issubclass(type(dilations), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    attributes["padding"] = (padding if (
    issubclass(type(padding), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(padding, context=_ods_context))
    attributes["grad_bias_enable"] = (grad_bias_enable if (
    issubclass(type(grad_bias_enable), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(grad_bias_enable, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def gradout(self):
    return self.operation.operands[1]

  @builtins.property
  def gradout_transpose(self):
    return self.operation.operands[2]

  @builtins.property
  def groups(self):
    return self.operation.attributes["groups"]

  @groups.setter
  def groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groups"] = value

  @builtins.property
  def input_shape(self):
    return self.operation.attributes["input_shape"]

  @input_shape.setter
  def input_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_shape"] = value

  @builtins.property
  def grad_out_shape(self):
    return self.operation.attributes["grad_out_shape"]

  @grad_out_shape.setter
  def grad_out_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_out_shape"] = value

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def padding(self):
    return self.operation.attributes["padding"]

  @padding.setter
  def padding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding"] = value

  @builtins.property
  def grad_bias_enable(self):
    return self.operation.attributes["grad_bias_enable"]

  @grad_bias_enable.setter
  def grad_bias_enable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_bias_enable"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConvOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Conv"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, kernel_shape, strides, pads, *, group=None, dilations=None, inserts=None, do_relu=None, relu_limit=None, dynweight_reorderd=None, weight_is_coeff=None, do_winograd=None, auto_pad=None, in_int4_scale=None, in_int4_zp=None, out_int8_scale=None, out_int8_zp=None, weight_bits=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if inserts is not None: attributes["inserts"] = (inserts if (
        issubclass(type(inserts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(inserts, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if dynweight_reorderd is not None: attributes["dynweight_reorderd"] = (dynweight_reorderd if (
        issubclass(type(dynweight_reorderd), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(dynweight_reorderd, context=_ods_context))
    if weight_is_coeff is not None: attributes["weight_is_coeff"] = (weight_is_coeff if (
        issubclass(type(weight_is_coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(weight_is_coeff, context=_ods_context))
    if do_winograd is not None: attributes["do_winograd"] = (do_winograd if (
        issubclass(type(do_winograd), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_winograd, context=_ods_context))
    if auto_pad is not None: attributes["auto_pad"] = (auto_pad if (
        issubclass(type(auto_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AutoPadModeAttr')) else
          _ods_ir.AttrBuilder.get('AutoPadModeAttr')(auto_pad, context=_ods_context))
    if in_int4_scale is not None: attributes["in_int4_scale"] = (in_int4_scale if (
        issubclass(type(in_int4_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(in_int4_scale, context=_ods_context))
    if in_int4_zp is not None: attributes["in_int4_zp"] = (in_int4_zp if (
        issubclass(type(in_int4_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(in_int4_zp, context=_ods_context))
    if out_int8_scale is not None: attributes["out_int8_scale"] = (out_int8_scale if (
        issubclass(type(out_int8_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_int8_scale, context=_ods_context))
    if out_int8_zp is not None: attributes["out_int8_zp"] = (out_int8_zp if (
        issubclass(type(out_int8_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_int8_zp, context=_ods_context))
    if weight_bits is not None: attributes["weight_bits"] = (weight_bits if (
        issubclass(type(weight_bits), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(weight_bits, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def dilations(self):
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def inserts(self):
    if "inserts" not in self.operation.attributes:
      return None
    return self.operation.attributes["inserts"]

  @inserts.setter
  def inserts(self, value):
    if value is not None:
      self.operation.attributes["inserts"] = value
    elif "inserts" in self.operation.attributes:
      del self.operation.attributes["inserts"]

  @inserts.deleter
  def inserts(self):
    del self.operation.attributes["inserts"]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def dynweight_reorderd(self):
    return self.operation.attributes["dynweight_reorderd"]

  @dynweight_reorderd.setter
  def dynweight_reorderd(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dynweight_reorderd"] = value

  @builtins.property
  def weight_is_coeff(self):
    return self.operation.attributes["weight_is_coeff"]

  @weight_is_coeff.setter
  def weight_is_coeff(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weight_is_coeff"] = value

  @builtins.property
  def do_winograd(self):
    if "do_winograd" not in self.operation.attributes:
      return None
    return self.operation.attributes["do_winograd"]

  @do_winograd.setter
  def do_winograd(self, value):
    if value is not None:
      self.operation.attributes["do_winograd"] = value
    elif "do_winograd" in self.operation.attributes:
      del self.operation.attributes["do_winograd"]

  @do_winograd.deleter
  def do_winograd(self):
    del self.operation.attributes["do_winograd"]

  @builtins.property
  def auto_pad(self):
    if "auto_pad" not in self.operation.attributes:
      return None
    return self.operation.attributes["auto_pad"]

  @auto_pad.setter
  def auto_pad(self, value):
    if value is not None:
      self.operation.attributes["auto_pad"] = value
    elif "auto_pad" in self.operation.attributes:
      del self.operation.attributes["auto_pad"]

  @auto_pad.deleter
  def auto_pad(self):
    del self.operation.attributes["auto_pad"]

  @builtins.property
  def in_int4_scale(self):
    if "in_int4_scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["in_int4_scale"]

  @in_int4_scale.setter
  def in_int4_scale(self, value):
    if value is not None:
      self.operation.attributes["in_int4_scale"] = value
    elif "in_int4_scale" in self.operation.attributes:
      del self.operation.attributes["in_int4_scale"]

  @in_int4_scale.deleter
  def in_int4_scale(self):
    del self.operation.attributes["in_int4_scale"]

  @builtins.property
  def in_int4_zp(self):
    if "in_int4_zp" not in self.operation.attributes:
      return None
    return self.operation.attributes["in_int4_zp"]

  @in_int4_zp.setter
  def in_int4_zp(self, value):
    if value is not None:
      self.operation.attributes["in_int4_zp"] = value
    elif "in_int4_zp" in self.operation.attributes:
      del self.operation.attributes["in_int4_zp"]

  @in_int4_zp.deleter
  def in_int4_zp(self):
    del self.operation.attributes["in_int4_zp"]

  @builtins.property
  def out_int8_scale(self):
    if "out_int8_scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_int8_scale"]

  @out_int8_scale.setter
  def out_int8_scale(self, value):
    if value is not None:
      self.operation.attributes["out_int8_scale"] = value
    elif "out_int8_scale" in self.operation.attributes:
      del self.operation.attributes["out_int8_scale"]

  @out_int8_scale.deleter
  def out_int8_scale(self):
    del self.operation.attributes["out_int8_scale"]

  @builtins.property
  def out_int8_zp(self):
    if "out_int8_zp" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_int8_zp"]

  @out_int8_zp.setter
  def out_int8_zp(self, value):
    if value is not None:
      self.operation.attributes["out_int8_zp"] = value
    elif "out_int8_zp" in self.operation.attributes:
      del self.operation.attributes["out_int8_zp"]

  @out_int8_zp.deleter
  def out_int8_zp(self):
    del self.operation.attributes["out_int8_zp"]

  @builtins.property
  def weight_bits(self):
    if "weight_bits" not in self.operation.attributes:
      return None
    return self.operation.attributes["weight_bits"]

  @weight_bits.setter
  def weight_bits(self, value):
    if value is not None:
      self.operation.attributes["weight_bits"] = value
    elif "weight_bits" in self.operation.attributes:
      del self.operation.attributes["weight_bits"]

  @weight_bits.deleter
  def weight_bits(self):
    del self.operation.attributes["weight_bits"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConvbwdOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Convbwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_input, grad_weight, grad_bias, grad_out, input, kernel, groups, input_shape, grad_out_shape, kernel_shape, stride, dilations, padding, inserts, grad_input_enable, grad_weight_enable, grad_bias_enable, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_out))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(kernel))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["groups"] = (groups if (
    issubclass(type(groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(groups, context=_ods_context))
    attributes["input_shape"] = (input_shape if (
    issubclass(type(input_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_shape, context=_ods_context))
    attributes["grad_out_shape"] = (grad_out_shape if (
    issubclass(type(grad_out_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(grad_out_shape, context=_ods_context))
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["stride"] = (stride if (
    issubclass(type(stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    attributes["dilations"] = (dilations if (
    issubclass(type(dilations), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    attributes["padding"] = (padding if (
    issubclass(type(padding), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(padding, context=_ods_context))
    attributes["inserts"] = (inserts if (
    issubclass(type(inserts), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(inserts, context=_ods_context))
    attributes["grad_input_enable"] = (grad_input_enable if (
    issubclass(type(grad_input_enable), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(grad_input_enable, context=_ods_context))
    attributes["grad_weight_enable"] = (grad_weight_enable if (
    issubclass(type(grad_weight_enable), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(grad_weight_enable, context=_ods_context))
    attributes["grad_bias_enable"] = (grad_bias_enable if (
    issubclass(type(grad_bias_enable), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(grad_bias_enable, context=_ods_context))
    results.append(grad_input)
    results.append(grad_weight)
    results.append(grad_bias)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def kernel(self):
    return self.operation.operands[2]

  @builtins.property
  def groups(self):
    return self.operation.attributes["groups"]

  @groups.setter
  def groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groups"] = value

  @builtins.property
  def input_shape(self):
    return self.operation.attributes["input_shape"]

  @input_shape.setter
  def input_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_shape"] = value

  @builtins.property
  def grad_out_shape(self):
    return self.operation.attributes["grad_out_shape"]

  @grad_out_shape.setter
  def grad_out_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_out_shape"] = value

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def padding(self):
    return self.operation.attributes["padding"]

  @padding.setter
  def padding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding"] = value

  @builtins.property
  def inserts(self):
    return self.operation.attributes["inserts"]

  @inserts.setter
  def inserts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inserts"] = value

  @builtins.property
  def grad_input_enable(self):
    return self.operation.attributes["grad_input_enable"]

  @grad_input_enable.setter
  def grad_input_enable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_input_enable"] = value

  @builtins.property
  def grad_weight_enable(self):
    return self.operation.attributes["grad_weight_enable"]

  @grad_weight_enable.setter
  def grad_weight_enable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_weight_enable"] = value

  @builtins.property
  def grad_bias_enable(self):
    return self.operation.attributes["grad_bias_enable"]

  @grad_bias_enable.setter
  def grad_bias_enable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_bias_enable"] = value

  @builtins.property
  def grad_input(self):
    return self.operation.results[0]

  @builtins.property
  def grad_weight(self):
    return self.operation.results[1]

  @builtins.property
  def grad_bias(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CopyOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shape, input_stride, output_stride, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    issubclass(type(shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    attributes["input_stride"] = (input_stride if (
    issubclass(type(input_stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_stride, context=_ods_context))
    attributes["output_stride"] = (output_stride if (
    issubclass(type(output_stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_stride, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def input_stride(self):
    return self.operation.attributes["input_stride"]

  @input_stride.setter
  def input_stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_stride"] = value

  @builtins.property
  def output_stride(self):
    return self.operation.attributes["output_stride"]

  @output_stride.setter
  def output_stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_stride"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CorrelationOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Correlation"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, max_disp=None, num_groups=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if max_disp is not None: attributes["max_disp"] = (max_disp if (
        issubclass(type(max_disp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(max_disp, context=_ods_context))
    if num_groups is not None: attributes["num_groups"] = (num_groups if (
        issubclass(type(num_groups), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(num_groups, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def max_disp(self):
    return self.operation.attributes["max_disp"]

  @max_disp.setter
  def max_disp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_disp"] = value

  @builtins.property
  def num_groups(self):
    return self.operation.attributes["num_groups"]

  @num_groups.setter
  def num_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CosOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CoshOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Cosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CscOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Csc"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, pixel_format, aligned, y_align, w_align, channel_align, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pixel_format"] = (pixel_format if (
    issubclass(type(pixel_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(pixel_format, context=_ods_context))
    attributes["aligned"] = (aligned if (
    issubclass(type(aligned), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    attributes["y_align"] = (y_align if (
    issubclass(type(y_align), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(y_align, context=_ods_context))
    attributes["w_align"] = (w_align if (
    issubclass(type(w_align), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(w_align, context=_ods_context))
    attributes["channel_align"] = (channel_align if (
    issubclass(type(channel_align), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(channel_align, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def pixel_format(self):
    return self.operation.attributes["pixel_format"]

  @pixel_format.setter
  def pixel_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pixel_format"] = value

  @builtins.property
  def aligned(self):
    return self.operation.attributes["aligned"]

  @aligned.setter
  def aligned(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aligned"] = value

  @builtins.property
  def y_align(self):
    return self.operation.attributes["y_align"]

  @y_align.setter
  def y_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_align"] = value

  @builtins.property
  def w_align(self):
    return self.operation.attributes["w_align"]

  @w_align.setter
  def w_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["w_align"] = value

  @builtins.property
  def channel_align(self):
    return self.operation.attributes["channel_align"]

  @channel_align.setter
  def channel_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_align"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CumSumOp(_ods_ir.OpView):
  OPERATION_NAME = "top.CumSum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dim, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(dim))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CustomOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Custom"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, name, params, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    issubclass(type(name), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["params"] = (params if (
    issubclass(type(params), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
      _ods_ir.AttrBuilder.get('DictArrayAttr')(params, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def params(self):
    return self.operation.attributes["params"]

  @params.setter
  def params(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["params"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DeconvOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Deconv"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, kernel_shape, strides, pads, *, group=None, dilations=None, output_padding=None, dynweight_reorderd=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if output_padding is not None: attributes["output_padding"] = (output_padding if (
        issubclass(type(output_padding), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_padding, context=_ods_context))
    if dynweight_reorderd is not None: attributes["dynweight_reorderd"] = (dynweight_reorderd if (
        issubclass(type(dynweight_reorderd), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(dynweight_reorderd, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def dilations(self):
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def output_padding(self):
    if "output_padding" not in self.operation.attributes:
      return None
    return self.operation.attributes["output_padding"]

  @output_padding.setter
  def output_padding(self, value):
    if value is not None:
      self.operation.attributes["output_padding"] = value
    elif "output_padding" in self.operation.attributes:
      del self.operation.attributes["output_padding"]

  @output_padding.deleter
  def output_padding(self):
    del self.operation.attributes["output_padding"]

  @builtins.property
  def dynweight_reorderd(self):
    return self.operation.attributes["dynweight_reorderd"]

  @dynweight_reorderd.setter
  def dynweight_reorderd(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dynweight_reorderd"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DeformConv2DOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DeformConv2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, offset, mask, bias, kernel_shape, strides, pads, *, group=None, deform_group=None, use_mask=None, dilations=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(offset))
    operands.append(_get_op_result_or_value(mask))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if deform_group is not None: attributes["deform_group"] = (deform_group if (
        issubclass(type(deform_group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(deform_group, context=_ods_context))
    if use_mask is not None: attributes["use_mask"] = (use_mask if (
        issubclass(type(use_mask), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_mask, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def offset(self):
    return self.operation.operands[2]

  @builtins.property
  def mask(self):
    return self.operation.operands[3]

  @builtins.property
  def bias(self):
    return self.operation.operands[4]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def deform_group(self):
    return self.operation.attributes["deform_group"]

  @deform_group.setter
  def deform_group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["deform_group"] = value

  @builtins.property
  def use_mask(self):
    return self.operation.attributes["use_mask"]

  @use_mask.setter
  def use_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_mask"] = value

  @builtins.property
  def dilations(self):
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DepackRawOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DepackRaw"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, padding_h, padding_w, white_level, black_level, channel_order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["padding_h"] = (padding_h if (
    issubclass(type(padding_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(padding_h, context=_ods_context))
    attributes["padding_w"] = (padding_w if (
    issubclass(type(padding_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(padding_w, context=_ods_context))
    attributes["white_level"] = (white_level if (
    issubclass(type(white_level), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(white_level, context=_ods_context))
    attributes["black_level"] = (black_level if (
    issubclass(type(black_level), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(black_level, context=_ods_context))
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(channel_order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def padding_h(self):
    return self.operation.attributes["padding_h"]

  @padding_h.setter
  def padding_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_h"] = value

  @builtins.property
  def padding_w(self):
    return self.operation.attributes["padding_w"]

  @padding_w.setter
  def padding_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_w"] = value

  @builtins.property
  def white_level(self):
    return self.operation.attributes["white_level"]

  @white_level.setter
  def white_level(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["white_level"] = value

  @builtins.property
  def black_level(self):
    return self.operation.attributes["black_level"]

  @black_level.setter
  def black_level(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["black_level"] = value

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Depth2SpaceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Depth2Space"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, block_h, block_w, is_CRD, is_inversed, *, in_is_NCHW=None, out_is_NCHW=None, swap_cr=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["block_h"] = (block_h if (
    issubclass(type(block_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_h, context=_ods_context))
    attributes["block_w"] = (block_w if (
    issubclass(type(block_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_w, context=_ods_context))
    attributes["is_CRD"] = (is_CRD if (
    issubclass(type(is_CRD), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_CRD, context=_ods_context))
    attributes["is_inversed"] = (is_inversed if (
    issubclass(type(is_inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_inversed, context=_ods_context))
    if in_is_NCHW is not None: attributes["in_is_NCHW"] = (in_is_NCHW if (
        issubclass(type(in_is_NCHW), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(in_is_NCHW, context=_ods_context))
    if out_is_NCHW is not None: attributes["out_is_NCHW"] = (out_is_NCHW if (
        issubclass(type(out_is_NCHW), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(out_is_NCHW, context=_ods_context))
    if swap_cr is not None: attributes["swap_cr"] = (swap_cr if (
        issubclass(type(swap_cr), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(swap_cr, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def block_h(self):
    return self.operation.attributes["block_h"]

  @block_h.setter
  def block_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_h"] = value

  @builtins.property
  def block_w(self):
    return self.operation.attributes["block_w"]

  @block_w.setter
  def block_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_w"] = value

  @builtins.property
  def is_CRD(self):
    return self.operation.attributes["is_CRD"]

  @is_CRD.setter
  def is_CRD(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_CRD"] = value

  @builtins.property
  def is_inversed(self):
    return self.operation.attributes["is_inversed"]

  @is_inversed.setter
  def is_inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_inversed"] = value

  @builtins.property
  def in_is_NCHW(self):
    return self.operation.attributes["in_is_NCHW"]

  @in_is_NCHW.setter
  def in_is_NCHW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["in_is_NCHW"] = value

  @builtins.property
  def out_is_NCHW(self):
    return self.operation.attributes["out_is_NCHW"]

  @out_is_NCHW.setter
  def out_is_NCHW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["out_is_NCHW"] = value

  @builtins.property
  def swap_cr(self):
    return self.operation.attributes["swap_cr"]

  @swap_cr.setter
  def swap_cr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["swap_cr"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DequantIntOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DequantInt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, multiplier, shift, quant_mode, *, lshift=None, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["multiplier"] = (multiplier if (
    issubclass(type(multiplier), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(multiplier, context=_ods_context))
    attributes["shift"] = (shift if (
    issubclass(type(shift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(shift, context=_ods_context))
    if lshift is not None: attributes["lshift"] = (lshift if (
        issubclass(type(lshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(lshift, context=_ods_context))
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DequantModeAttr')) else
      _ods_ir.AttrBuilder.get('DequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def shift(self):
    return self.operation.attributes["shift"]

  @shift.setter
  def shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shift"] = value

  @builtins.property
  def lshift(self):
    return self.operation.attributes["lshift"]

  @lshift.setter
  def lshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lshift"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DequantizeLinearOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DequantizeLinear"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, x_scale, x_zero_point, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["x_scale"] = (x_scale if (
    issubclass(type(x_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(x_scale, context=_ods_context))
    attributes["x_zero_point"] = (x_zero_point if (
    issubclass(type(x_zero_point), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(x_zero_point, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def x_scale(self):
    return self.operation.attributes["x_scale"]

  @x_scale.setter
  def x_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["x_scale"] = value

  @builtins.property
  def x_zero_point(self):
    return self.operation.attributes["x_zero_point"]

  @x_zero_point.setter
  def x_zero_point(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["x_zero_point"] = value

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DetectionOutputOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DetectionOutput"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, num_classes, nms_threshold, top_k, code_type, keep_top_k, confidence_threshold, *, background_label_id=None, share_location=None, variance_encoded_in_target=None, eta=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_classes"] = (num_classes if (
    issubclass(type(num_classes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_classes, context=_ods_context))
    if background_label_id is not None: attributes["background_label_id"] = (background_label_id if (
        issubclass(type(background_label_id), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(background_label_id, context=_ods_context))
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["top_k"] = (top_k if (
    issubclass(type(top_k), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(top_k, context=_ods_context))
    attributes["code_type"] = (code_type if (
    issubclass(type(code_type), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DetectionOutputCodeTypeAttr')) else
      _ods_ir.AttrBuilder.get('DetectionOutputCodeTypeAttr')(code_type, context=_ods_context))
    attributes["keep_top_k"] = (keep_top_k if (
    issubclass(type(keep_top_k), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_top_k, context=_ods_context))
    attributes["confidence_threshold"] = (confidence_threshold if (
    issubclass(type(confidence_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(confidence_threshold, context=_ods_context))
    if share_location is not None: attributes["share_location"] = (share_location if (
        issubclass(type(share_location), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(share_location, context=_ods_context))
    if variance_encoded_in_target is not None: attributes["variance_encoded_in_target"] = (variance_encoded_in_target if (
        issubclass(type(variance_encoded_in_target), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(variance_encoded_in_target, context=_ods_context))
    if eta is not None: attributes["eta"] = (eta if (
        issubclass(type(eta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(eta, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def num_classes(self):
    return self.operation.attributes["num_classes"]

  @num_classes.setter
  def num_classes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_classes"] = value

  @builtins.property
  def background_label_id(self):
    return self.operation.attributes["background_label_id"]

  @background_label_id.setter
  def background_label_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["background_label_id"] = value

  @builtins.property
  def nms_threshold(self):
    return self.operation.attributes["nms_threshold"]

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def top_k(self):
    return self.operation.attributes["top_k"]

  @top_k.setter
  def top_k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["top_k"] = value

  @builtins.property
  def code_type(self):
    return self.operation.attributes["code_type"]

  @code_type.setter
  def code_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["code_type"] = value

  @builtins.property
  def keep_top_k(self):
    return self.operation.attributes["keep_top_k"]

  @keep_top_k.setter
  def keep_top_k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_top_k"] = value

  @builtins.property
  def confidence_threshold(self):
    return self.operation.attributes["confidence_threshold"]

  @confidence_threshold.setter
  def confidence_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["confidence_threshold"] = value

  @builtins.property
  def share_location(self):
    return self.operation.attributes["share_location"]

  @share_location.setter
  def share_location(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["share_location"] = value

  @builtins.property
  def variance_encoded_in_target(self):
    return self.operation.attributes["variance_encoded_in_target"]

  @variance_encoded_in_target.setter
  def variance_encoded_in_target(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variance_encoded_in_target"] = value

  @builtins.property
  def eta(self):
    return self.operation.attributes["eta"]

  @eta.setter
  def eta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eta"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DivConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DivConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, is_reverse=None, do_relu=None, relu_limit=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DivOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Div"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, is_reverse=None, do_relu=None, relu_limit=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DtypeCastOp(_ods_ir.OpView):
  OPERATION_NAME = "top.DtypeCast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class EinsumOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Einsum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('EinsumModeAttr')) else
      _ods_ir.AttrBuilder.get('EinsumModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class EluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Elu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, alpha, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["alpha"] = (alpha if (
    issubclass(type(alpha), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def alpha(self):
    return self.operation.attributes["alpha"]

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class EmbDenseBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "top.EmbDenseBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, grad_output, indices, num_weights, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_output))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_weights"] = (num_weights if (
    issubclass(type(num_weights), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(num_weights, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def num_weights(self):
    return self.operation.attributes["num_weights"]

  @num_weights.setter
  def num_weights(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_weights"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ErfOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ExpOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ExpandOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Expand"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, shape=None, shapeT=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if shapeT is not None: operands.append(_get_op_result_or_value(shapeT))
    _ods_context = _ods_get_default_loc_context(loc)
    if shape is not None: attributes["shape"] = (shape if (
        issubclass(type(shape), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shapeT(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FAttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.FAttention"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, queries, keys, values, mask, buffer, scale, batch, q_head, kv_head, dim, mq, mk, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(queries))
    operands.append(_get_op_result_or_value(keys))
    operands.append(_get_op_result_or_value(values))
    operands.append(_get_op_result_or_value(mask))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    attributes["batch"] = (batch if (
    issubclass(type(batch), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(batch, context=_ods_context))
    attributes["q_head"] = (q_head if (
    issubclass(type(q_head), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(q_head, context=_ods_context))
    attributes["kv_head"] = (kv_head if (
    issubclass(type(kv_head), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(kv_head, context=_ods_context))
    attributes["dim"] = (dim if (
    issubclass(type(dim), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    attributes["mq"] = (mq if (
    issubclass(type(mq), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(mq, context=_ods_context))
    attributes["mk"] = (mk if (
    issubclass(type(mk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(mk, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def queries(self):
    return self.operation.operands[0]

  @builtins.property
  def keys(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def mask(self):
    return self.operation.operands[3]

  @builtins.property
  def buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def batch(self):
    return self.operation.attributes["batch"]

  @batch.setter
  def batch(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch"] = value

  @builtins.property
  def q_head(self):
    return self.operation.attributes["q_head"]

  @q_head.setter
  def q_head(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["q_head"] = value

  @builtins.property
  def kv_head(self):
    return self.operation.attributes["kv_head"]

  @kv_head.setter
  def kv_head(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kv_head"] = value

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def mq(self):
    return self.operation.attributes["mq"]

  @mq.setter
  def mq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mq"] = value

  @builtins.property
  def mk(self):
    return self.operation.attributes["mk"]

  @mk.setter
  def mk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mk"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FlattenOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Flatten"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, start_dim=None, end_dim=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if start_dim is not None: attributes["start_dim"] = (start_dim if (
        issubclass(type(start_dim), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(start_dim, context=_ods_context))
    if end_dim is not None: attributes["end_dim"] = (end_dim if (
        issubclass(type(end_dim), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(end_dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start_dim(self):
    return self.operation.attributes["start_dim"]

  @start_dim.setter
  def start_dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["start_dim"] = value

  @builtins.property
  def end_dim(self):
    return self.operation.attributes["end_dim"]

  @end_dim.setter
  def end_dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end_dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FloorOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FrcnDetectionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.FrcnDetection"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, class_num, obj_threshold, nms_threshold, keep_topk, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["class_num"] = (class_num if (
    issubclass(type(class_num), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(class_num, context=_ods_context))
    attributes["obj_threshold"] = (obj_threshold if (
    issubclass(type(obj_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(obj_threshold, context=_ods_context))
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["keep_topk"] = (keep_topk if (
    issubclass(type(keep_topk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_topk, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def class_num(self):
    return self.operation.attributes["class_num"]

  @class_num.setter
  def class_num(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["class_num"] = value

  @builtins.property
  def obj_threshold(self):
    return self.operation.attributes["obj_threshold"]

  @obj_threshold.setter
  def obj_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["obj_threshold"] = value

  @builtins.property
  def nms_threshold(self):
    return self.operation.attributes["nms_threshold"]

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def keep_topk(self):
    return self.operation.attributes["keep_topk"]

  @keep_topk.setter
  def keep_topk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_topk"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GELUOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GELU"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, round_mode=None, approx_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    if approx_mode is not None: attributes["approx_mode"] = (approx_mode if (
        issubclass(type(approx_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('GELUModeAttr')) else
          _ods_ir.AttrBuilder.get('GELUModeAttr')(approx_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def approx_mode(self):
    return self.operation.attributes["approx_mode"]

  @approx_mode.setter
  def approx_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["approx_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GRUOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GRU"

  _ODS_REGIONS = (0, True)

  def __init__(self, Y, Y_h, input, filter, recurrence, bias, initial_h, hidden_size, bidirectional, *, linear_before_reset=None, batch_first=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(recurrence))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(initial_h))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["hidden_size"] = (hidden_size if (
    issubclass(type(hidden_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(hidden_size, context=_ods_context))
    attributes["bidirectional"] = (bidirectional if (
    issubclass(type(bidirectional), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(bidirectional, context=_ods_context))
    if linear_before_reset is not None: attributes["linear_before_reset"] = (linear_before_reset if (
        issubclass(type(linear_before_reset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(linear_before_reset, context=_ods_context))
    if batch_first is not None: attributes["batch_first"] = (batch_first if (
        issubclass(type(batch_first), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(batch_first, context=_ods_context))
    results.append(Y)
    results.append(Y_h)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def recurrence(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def initial_h(self):
    return self.operation.operands[4]

  @builtins.property
  def hidden_size(self):
    return self.operation.attributes["hidden_size"]

  @hidden_size.setter
  def hidden_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hidden_size"] = value

  @builtins.property
  def bidirectional(self):
    return self.operation.attributes["bidirectional"]

  @bidirectional.setter
  def bidirectional(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bidirectional"] = value

  @builtins.property
  def linear_before_reset(self):
    return self.operation.attributes["linear_before_reset"]

  @linear_before_reset.setter
  def linear_before_reset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["linear_before_reset"] = value

  @builtins.property
  def batch_first(self):
    return self.operation.attributes["batch_first"]

  @batch_first.setter
  def batch_first(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_first"] = value

  @builtins.property
  def Y(self):
    return self.operation.results[0]

  @builtins.property
  def Y_h(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GatherElements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherNDOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GatherND"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, *, indice_dims=None, batch_dims=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    if indice_dims is not None: attributes["indice_dims"] = (indice_dims if (
        issubclass(type(indice_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(indice_dims, context=_ods_context))
    if batch_dims is not None: attributes["batch_dims"] = (batch_dims if (
        issubclass(type(batch_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(batch_dims, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def indice_dims(self):
    if "indice_dims" not in self.operation.attributes:
      return None
    return self.operation.attributes["indice_dims"]

  @indice_dims.setter
  def indice_dims(self, value):
    if value is not None:
      self.operation.attributes["indice_dims"] = value
    elif "indice_dims" in self.operation.attributes:
      del self.operation.attributes["indice_dims"]

  @indice_dims.deleter
  def indice_dims(self):
    del self.operation.attributes["indice_dims"]

  @builtins.property
  def batch_dims(self):
    return self.operation.attributes["batch_dims"]

  @batch_dims.setter
  def batch_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_dims"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, *, keepdims=None, axis=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    if keepdims is not None: attributes["keepdims"] = (keepdims if (
        issubclass(type(keepdims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GridSamplerOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GridSampler"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, grid, mode, padding_mode, align_corners, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(grid))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(mode, context=_ods_context))
    attributes["padding_mode"] = (padding_mode if (
    issubclass(type(padding_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(padding_mode, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def grid(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def padding_mode(self):
    return self.operation.attributes["padding_mode"]

  @padding_mode.setter
  def padding_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_mode"] = value

  @builtins.property
  def align_corners(self):
    return self.operation.attributes["align_corners"]

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GroupNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GroupNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, num_groups, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_groups"] = (num_groups if (
    issubclass(type(num_groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_groups, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def num_groups(self):
    return self.operation.attributes["num_groups"]

  @num_groups.setter
  def num_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GroupNormTrainOp(_ods_ir.OpView):
  OPERATION_NAME = "top.GroupNormTrain"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mean, rstd, input, weight, bias, num_groups, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_groups"] = (num_groups if (
    issubclass(type(num_groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_groups, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    results.append(mean)
    results.append(rstd)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def num_groups(self):
    return self.operation.attributes["num_groups"]

  @num_groups.setter
  def num_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mean(self):
    return self.operation.results[1]

  @builtins.property
  def rstd(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class HardSigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "top.HardSigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, alpha, beta, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["alpha"] = (alpha if (
    issubclass(type(alpha), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    attributes["beta"] = (beta if (
    issubclass(type(beta), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def alpha(self):
    return self.operation.attributes["alpha"]

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def beta(self):
    return self.operation.attributes["beta"]

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class HardSwishOp(_ods_ir.OpView):
  OPERATION_NAME = "top.HardSwish"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class IfOp(_ods_ir.OpView):
  OPERATION_NAME = "top.If"

  _ODS_REGIONS = (2, True)

  def __init__(self, output, cond, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def then_branch(self):
    return self.regions[0]

  @builtins.property
  def else_branch(self):
    return self.regions[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class IndexPutOp(_ods_ir.OpView):
  OPERATION_NAME = "top.IndexPut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, values, *, accumulate=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(values))
    _ods_context = _ods_get_default_loc_context(loc)
    if accumulate is not None: attributes["accumulate"] = (accumulate if (
        issubclass(type(accumulate), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(accumulate, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def accumulate(self):
    return self.operation.attributes["accumulate"]

  @accumulate.setter
  def accumulate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["accumulate"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InputOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Input"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, shape_tensor=None, do_preprocess=None, pixel_format=None, channel_format=None, resize_dims=None, keep_aspect_ratio=None, keep_ratio_mode=None, pad_value=None, pad_type=None, scale=None, mean=None, customization_format=None, aligned=None, yuv_type=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if shape_tensor is not None: attributes["shape_tensor"] = (shape_tensor if (
        issubclass(type(shape_tensor), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape_tensor, context=_ods_context))
    if do_preprocess is not None: attributes["do_preprocess"] = (do_preprocess if (
        issubclass(type(do_preprocess), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_preprocess, context=_ods_context))
    if pixel_format is not None: attributes["pixel_format"] = (pixel_format if (
        issubclass(type(pixel_format), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('PixelFormatAttr')) else
          _ods_ir.AttrBuilder.get('PixelFormatAttr')(pixel_format, context=_ods_context))
    if channel_format is not None: attributes["channel_format"] = (channel_format if (
        issubclass(type(channel_format), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ChannelFormatAttr')) else
          _ods_ir.AttrBuilder.get('ChannelFormatAttr')(channel_format, context=_ods_context))
    if resize_dims is not None: attributes["resize_dims"] = (resize_dims if (
        issubclass(type(resize_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(resize_dims, context=_ods_context))
    if keep_aspect_ratio is not None: attributes["keep_aspect_ratio"] = (keep_aspect_ratio if (
        issubclass(type(keep_aspect_ratio), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keep_aspect_ratio, context=_ods_context))
    if keep_ratio_mode is not None: attributes["keep_ratio_mode"] = (keep_ratio_mode if (
        issubclass(type(keep_ratio_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(keep_ratio_mode, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if pad_type is not None: attributes["pad_type"] = (pad_type if (
        issubclass(type(pad_type), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('PadModeAttr')) else
          _ods_ir.AttrBuilder.get('PadModeAttr')(pad_type, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    if mean is not None: attributes["mean"] = (mean if (
        issubclass(type(mean), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(mean, context=_ods_context))
    if customization_format is not None: attributes["customization_format"] = (customization_format if (
        issubclass(type(customization_format), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(customization_format, context=_ods_context))
    if aligned is not None: attributes["aligned"] = (aligned if (
        issubclass(type(aligned), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    if yuv_type is not None: attributes["yuv_type"] = (yuv_type if (
        issubclass(type(yuv_type), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(yuv_type, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape_tensor(self):
    if "shape_tensor" not in self.operation.attributes:
      return None
    return self.operation.attributes["shape_tensor"]

  @shape_tensor.setter
  def shape_tensor(self, value):
    if value is not None:
      self.operation.attributes["shape_tensor"] = value
    elif "shape_tensor" in self.operation.attributes:
      del self.operation.attributes["shape_tensor"]

  @shape_tensor.deleter
  def shape_tensor(self):
    del self.operation.attributes["shape_tensor"]

  @builtins.property
  def do_preprocess(self):
    return self.operation.attributes["do_preprocess"]

  @do_preprocess.setter
  def do_preprocess(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_preprocess"] = value

  @builtins.property
  def pixel_format(self):
    if "pixel_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["pixel_format"]

  @pixel_format.setter
  def pixel_format(self, value):
    if value is not None:
      self.operation.attributes["pixel_format"] = value
    elif "pixel_format" in self.operation.attributes:
      del self.operation.attributes["pixel_format"]

  @pixel_format.deleter
  def pixel_format(self):
    del self.operation.attributes["pixel_format"]

  @builtins.property
  def channel_format(self):
    if "channel_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["channel_format"]

  @channel_format.setter
  def channel_format(self, value):
    if value is not None:
      self.operation.attributes["channel_format"] = value
    elif "channel_format" in self.operation.attributes:
      del self.operation.attributes["channel_format"]

  @channel_format.deleter
  def channel_format(self):
    del self.operation.attributes["channel_format"]

  @builtins.property
  def resize_dims(self):
    if "resize_dims" not in self.operation.attributes:
      return None
    return self.operation.attributes["resize_dims"]

  @resize_dims.setter
  def resize_dims(self, value):
    if value is not None:
      self.operation.attributes["resize_dims"] = value
    elif "resize_dims" in self.operation.attributes:
      del self.operation.attributes["resize_dims"]

  @resize_dims.deleter
  def resize_dims(self):
    del self.operation.attributes["resize_dims"]

  @builtins.property
  def keep_aspect_ratio(self):
    if "keep_aspect_ratio" not in self.operation.attributes:
      return None
    return self.operation.attributes["keep_aspect_ratio"]

  @keep_aspect_ratio.setter
  def keep_aspect_ratio(self, value):
    if value is not None:
      self.operation.attributes["keep_aspect_ratio"] = value
    elif "keep_aspect_ratio" in self.operation.attributes:
      del self.operation.attributes["keep_aspect_ratio"]

  @keep_aspect_ratio.deleter
  def keep_aspect_ratio(self):
    del self.operation.attributes["keep_aspect_ratio"]

  @builtins.property
  def keep_ratio_mode(self):
    if "keep_ratio_mode" not in self.operation.attributes:
      return None
    return self.operation.attributes["keep_ratio_mode"]

  @keep_ratio_mode.setter
  def keep_ratio_mode(self, value):
    if value is not None:
      self.operation.attributes["keep_ratio_mode"] = value
    elif "keep_ratio_mode" in self.operation.attributes:
      del self.operation.attributes["keep_ratio_mode"]

  @keep_ratio_mode.deleter
  def keep_ratio_mode(self):
    del self.operation.attributes["keep_ratio_mode"]

  @builtins.property
  def pad_value(self):
    if "pad_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["pad_value"]

  @pad_value.setter
  def pad_value(self, value):
    if value is not None:
      self.operation.attributes["pad_value"] = value
    elif "pad_value" in self.operation.attributes:
      del self.operation.attributes["pad_value"]

  @pad_value.deleter
  def pad_value(self):
    del self.operation.attributes["pad_value"]

  @builtins.property
  def pad_type(self):
    if "pad_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["pad_type"]

  @pad_type.setter
  def pad_type(self, value):
    if value is not None:
      self.operation.attributes["pad_type"] = value
    elif "pad_type" in self.operation.attributes:
      del self.operation.attributes["pad_type"]

  @pad_type.deleter
  def pad_type(self):
    del self.operation.attributes["pad_type"]

  @builtins.property
  def scale(self):
    if "scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is not None:
      self.operation.attributes["scale"] = value
    elif "scale" in self.operation.attributes:
      del self.operation.attributes["scale"]

  @scale.deleter
  def scale(self):
    del self.operation.attributes["scale"]

  @builtins.property
  def mean(self):
    if "mean" not in self.operation.attributes:
      return None
    return self.operation.attributes["mean"]

  @mean.setter
  def mean(self, value):
    if value is not None:
      self.operation.attributes["mean"] = value
    elif "mean" in self.operation.attributes:
      del self.operation.attributes["mean"]

  @mean.deleter
  def mean(self):
    del self.operation.attributes["mean"]

  @builtins.property
  def customization_format(self):
    if "customization_format" not in self.operation.attributes:
      return None
    return self.operation.attributes["customization_format"]

  @customization_format.setter
  def customization_format(self, value):
    if value is not None:
      self.operation.attributes["customization_format"] = value
    elif "customization_format" in self.operation.attributes:
      del self.operation.attributes["customization_format"]

  @customization_format.deleter
  def customization_format(self):
    del self.operation.attributes["customization_format"]

  @builtins.property
  def aligned(self):
    if "aligned" not in self.operation.attributes:
      return None
    return self.operation.attributes["aligned"]

  @aligned.setter
  def aligned(self, value):
    if value is not None:
      self.operation.attributes["aligned"] = value
    elif "aligned" in self.operation.attributes:
      del self.operation.attributes["aligned"]

  @aligned.deleter
  def aligned(self):
    del self.operation.attributes["aligned"]

  @builtins.property
  def yuv_type(self):
    if "yuv_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["yuv_type"]

  @yuv_type.setter
  def yuv_type(self, value):
    if value is not None:
      self.operation.attributes["yuv_type"] = value
    elif "yuv_type" in self.operation.attributes:
      del self.operation.attributes["yuv_type"]

  @yuv_type.deleter
  def yuv_type(self):
    del self.operation.attributes["yuv_type"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InstanceNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.InstanceNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InterpOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Interp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, target_shape, mode, coord_mode, *, scale_h=None, scale_w=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(target_shape))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InterpModeAttr')) else
      _ods_ir.AttrBuilder.get('InterpModeAttr')(mode, context=_ods_context))
    attributes["coord_mode"] = (coord_mode if (
    issubclass(type(coord_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('InterpCoordModeAttr')) else
      _ods_ir.AttrBuilder.get('InterpCoordModeAttr')(coord_mode, context=_ods_context))
    if scale_h is not None: attributes["scale_h"] = (scale_h if (
        issubclass(type(scale_h), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale_h, context=_ods_context))
    if scale_w is not None: attributes["scale_w"] = (scale_w if (
        issubclass(type(scale_w), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale_w, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def target_shape(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def coord_mode(self):
    return self.operation.attributes["coord_mode"]

  @coord_mode.setter
  def coord_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coord_mode"] = value

  @builtins.property
  def scale_h(self):
    return self.operation.attributes["scale_h"]

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return self.operation.attributes["scale_w"]

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LRNOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LRN"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, size, *, alpha=None, beta=None, bias=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    issubclass(type(size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(size, context=_ods_context))
    if alpha is not None: attributes["alpha"] = (alpha if (
        issubclass(type(alpha), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    if beta is not None: attributes["beta"] = (beta if (
        issubclass(type(beta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    if bias is not None: attributes["bias"] = (bias if (
        issubclass(type(bias), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(bias, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def alpha(self):
    return self.operation.attributes["alpha"]

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def beta(self):
    return self.operation.attributes["beta"]

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def bias(self):
    return self.operation.attributes["bias"]

  @bias.setter
  def bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bias"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LSTMOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LSTM"

  _ODS_REGIONS = (0, True)

  def __init__(self, Y, Y_h, Y_c, input, filter, recurrence, bias, initial_h, initial_c, cont, hidden_size, bidirectional, *, batch_first=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(recurrence))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(initial_h))
    operands.append(_get_op_result_or_value(initial_c))
    operands.append(_get_op_result_or_value(cont))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["hidden_size"] = (hidden_size if (
    issubclass(type(hidden_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(hidden_size, context=_ods_context))
    attributes["bidirectional"] = (bidirectional if (
    issubclass(type(bidirectional), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(bidirectional, context=_ods_context))
    if batch_first is not None: attributes["batch_first"] = (batch_first if (
        issubclass(type(batch_first), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(batch_first, context=_ods_context))
    results.append(Y)
    results.append(Y_h)
    results.append(Y_c)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def recurrence(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def initial_h(self):
    return self.operation.operands[4]

  @builtins.property
  def initial_c(self):
    return self.operation.operands[5]

  @builtins.property
  def cont(self):
    return self.operation.operands[6]

  @builtins.property
  def hidden_size(self):
    return self.operation.attributes["hidden_size"]

  @hidden_size.setter
  def hidden_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hidden_size"] = value

  @builtins.property
  def bidirectional(self):
    return self.operation.attributes["bidirectional"]

  @bidirectional.setter
  def bidirectional(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bidirectional"] = value

  @builtins.property
  def batch_first(self):
    return self.operation.attributes["batch_first"]

  @batch_first.setter
  def batch_first(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_first"] = value

  @builtins.property
  def Y(self):
    return self.operation.results[0]

  @builtins.property
  def Y_h(self):
    return self.operation.results[1]

  @builtins.property
  def Y_c(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LayerNormBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LayerNormBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_input, grad_weight, grad_bias, grad_out, input, mean, variance, weight, bias, normalized_shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_out))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(variance))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["normalized_shape"] = (normalized_shape if (
    issubclass(type(normalized_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(normalized_shape, context=_ods_context))
    results.append(grad_input)
    results.append(grad_weight)
    results.append(grad_bias)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def mean(self):
    return self.operation.operands[2]

  @builtins.property
  def variance(self):
    return self.operation.operands[3]

  @builtins.property
  def weight(self):
    return self.operation.operands[4]

  @builtins.property
  def bias(self):
    return self.operation.operands[5]

  @builtins.property
  def normalized_shape(self):
    return self.operation.attributes["normalized_shape"]

  @normalized_shape.setter
  def normalized_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["normalized_shape"] = value

  @builtins.property
  def grad_input(self):
    return self.operation.results[0]

  @builtins.property
  def grad_weight(self):
    return self.operation.results[1]

  @builtins.property
  def grad_bias(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LayerNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LayerNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, normalized_shape, axis, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["normalized_shape"] = (normalized_shape if (
    issubclass(type(normalized_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(normalized_shape, context=_ods_context))
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def normalized_shape(self):
    return self.operation.attributes["normalized_shape"]

  @normalized_shape.setter
  def normalized_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["normalized_shape"] = value

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LayerNormTrainOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LayerNormTrain"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mean, variance, input, weight, bias, normalized_shape, axis, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["normalized_shape"] = (normalized_shape if (
    issubclass(type(normalized_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(normalized_shape, context=_ods_context))
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    results.append(mean)
    results.append(variance)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def normalized_shape(self):
    return self.operation.attributes["normalized_shape"]

  @normalized_shape.setter
  def normalized_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["normalized_shape"] = value

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mean(self):
    return self.operation.results[1]

  @builtins.property
  def variance(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LeakyReluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LeakyRelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, alpha, *, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["alpha"] = (alpha if (
    issubclass(type(alpha), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def alpha(self):
    return self.operation.attributes["alpha"]

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ListOp(_ods_ir.OpView):
  OPERATION_NAME = "top.List"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LogBOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LogB"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, base, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["base"] = (base if (
    issubclass(type(base), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(base, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def base(self):
    return self.operation.attributes["base"]

  @base.setter
  def base(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LogOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Log"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LogicalAndOp(_ods_ir.OpView):
  OPERATION_NAME = "top.LogicalAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoopOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Loop"

  _ODS_REGIONS = (1, True)

  def __init__(self, v_final_and_scan_outputs, M, cond, v_initial, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(M))
    operands.append(_get_op_result_or_value(cond))
    operands.extend(_get_op_results_or_values(v_initial))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(v_final_and_scan_outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def M(self):
    return self.operation.operands[0]

  @builtins.property
  def cond(self):
    return self.operation.operands[1]

  @builtins.property
  def v_initial(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def v_final_and_scan_outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LutOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Lut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskRCNNBboxPoolerOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaskRCNN_BboxPooler"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_res, result_rois, ptr_feat0, ptr_feat1, ptr_feat2, ptr_feat3, rois_multi_batch, ROI_NUM_LEVELS, ROI_H, ROI_W, CHANNEL_ROI, ROI_SLICE, ROI_PH, ROI_PW, ROI_LEN, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr_feat0))
    operands.append(_get_op_result_or_value(ptr_feat1))
    operands.append(_get_op_result_or_value(ptr_feat2))
    operands.append(_get_op_result_or_value(ptr_feat3))
    operands.append(_get_op_result_or_value(rois_multi_batch))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ROI_NUM_LEVELS"] = (ROI_NUM_LEVELS if (
    issubclass(type(ROI_NUM_LEVELS), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_NUM_LEVELS, context=_ods_context))
    attributes["ROI_H"] = (ROI_H if (
    issubclass(type(ROI_H), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_H, context=_ods_context))
    attributes["ROI_W"] = (ROI_W if (
    issubclass(type(ROI_W), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_W, context=_ods_context))
    attributes["CHANNEL_ROI"] = (CHANNEL_ROI if (
    issubclass(type(CHANNEL_ROI), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(CHANNEL_ROI, context=_ods_context))
    attributes["ROI_SLICE"] = (ROI_SLICE if (
    issubclass(type(ROI_SLICE), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_SLICE, context=_ods_context))
    attributes["ROI_PH"] = (ROI_PH if (
    issubclass(type(ROI_PH), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_PH, context=_ods_context))
    attributes["ROI_PW"] = (ROI_PW if (
    issubclass(type(ROI_PW), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_PW, context=_ods_context))
    attributes["ROI_LEN"] = (ROI_LEN if (
    issubclass(type(ROI_LEN), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_LEN, context=_ods_context))
    results.append(result_res)
    results.append(result_rois)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr_feat0(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr_feat1(self):
    return self.operation.operands[1]

  @builtins.property
  def ptr_feat2(self):
    return self.operation.operands[2]

  @builtins.property
  def ptr_feat3(self):
    return self.operation.operands[3]

  @builtins.property
  def rois_multi_batch(self):
    return self.operation.operands[4]

  @builtins.property
  def ROI_NUM_LEVELS(self):
    return self.operation.attributes["ROI_NUM_LEVELS"]

  @ROI_NUM_LEVELS.setter
  def ROI_NUM_LEVELS(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_NUM_LEVELS"] = value

  @builtins.property
  def ROI_H(self):
    return self.operation.attributes["ROI_H"]

  @ROI_H.setter
  def ROI_H(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_H"] = value

  @builtins.property
  def ROI_W(self):
    return self.operation.attributes["ROI_W"]

  @ROI_W.setter
  def ROI_W(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_W"] = value

  @builtins.property
  def CHANNEL_ROI(self):
    return self.operation.attributes["CHANNEL_ROI"]

  @CHANNEL_ROI.setter
  def CHANNEL_ROI(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["CHANNEL_ROI"] = value

  @builtins.property
  def ROI_SLICE(self):
    return self.operation.attributes["ROI_SLICE"]

  @ROI_SLICE.setter
  def ROI_SLICE(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_SLICE"] = value

  @builtins.property
  def ROI_PH(self):
    return self.operation.attributes["ROI_PH"]

  @ROI_PH.setter
  def ROI_PH(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_PH"] = value

  @builtins.property
  def ROI_PW(self):
    return self.operation.attributes["ROI_PW"]

  @ROI_PW.setter
  def ROI_PW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_PW"] = value

  @builtins.property
  def ROI_LEN(self):
    return self.operation.attributes["ROI_LEN"]

  @ROI_LEN.setter
  def ROI_LEN(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_LEN"] = value

  @builtins.property
  def result_res(self):
    return self.operation.results[0]

  @builtins.property
  def result_rois(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskRCNNGetBboxBOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaskRCNN_GetBboxB"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_det_bboxes, result_det_labels, ptr_rois, ptr_bbox, ptr_score, max_val, scale_factor, threshold_score_eq, wh_ratio_log, nms_iou_thr, delta2bbox_means, delta2bbox_stds_0, delta2bbox_stds_1, NUM_INDEXES, NUM_CLASSES, TOPK_ONNX_NMS, NUM_CLASSES_getBboxB, MAX_NMS_LENGTH_GetBboxB, MAX_PER_IMG, MAX_PER_IMG_GetBboxB, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr_rois))
    operands.append(_get_op_result_or_value(ptr_bbox))
    operands.append(_get_op_result_or_value(ptr_score))
    operands.append(_get_op_result_or_value(max_val))
    operands.append(_get_op_result_or_value(scale_factor))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["threshold_score_eq"] = (threshold_score_eq if (
    issubclass(type(threshold_score_eq), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(threshold_score_eq, context=_ods_context))
    attributes["wh_ratio_log"] = (wh_ratio_log if (
    issubclass(type(wh_ratio_log), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(wh_ratio_log, context=_ods_context))
    attributes["nms_iou_thr"] = (nms_iou_thr if (
    issubclass(type(nms_iou_thr), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_iou_thr, context=_ods_context))
    attributes["delta2bbox_means"] = (delta2bbox_means if (
    issubclass(type(delta2bbox_means), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_means, context=_ods_context))
    attributes["delta2bbox_stds_0"] = (delta2bbox_stds_0 if (
    issubclass(type(delta2bbox_stds_0), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_stds_0, context=_ods_context))
    attributes["delta2bbox_stds_1"] = (delta2bbox_stds_1 if (
    issubclass(type(delta2bbox_stds_1), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_stds_1, context=_ods_context))
    attributes["NUM_INDEXES"] = (NUM_INDEXES if (
    issubclass(type(NUM_INDEXES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_INDEXES, context=_ods_context))
    attributes["NUM_CLASSES"] = (NUM_CLASSES if (
    issubclass(type(NUM_CLASSES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_CLASSES, context=_ods_context))
    attributes["TOPK_ONNX_NMS"] = (TOPK_ONNX_NMS if (
    issubclass(type(TOPK_ONNX_NMS), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(TOPK_ONNX_NMS, context=_ods_context))
    attributes["NUM_CLASSES_getBboxB"] = (NUM_CLASSES_getBboxB if (
    issubclass(type(NUM_CLASSES_getBboxB), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_CLASSES_getBboxB, context=_ods_context))
    attributes["MAX_NMS_LENGTH_GetBboxB"] = (MAX_NMS_LENGTH_GetBboxB if (
    issubclass(type(MAX_NMS_LENGTH_GetBboxB), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_NMS_LENGTH_GetBboxB, context=_ods_context))
    attributes["MAX_PER_IMG"] = (MAX_PER_IMG if (
    issubclass(type(MAX_PER_IMG), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_PER_IMG, context=_ods_context))
    attributes["MAX_PER_IMG_GetBboxB"] = (MAX_PER_IMG_GetBboxB if (
    issubclass(type(MAX_PER_IMG_GetBboxB), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_PER_IMG_GetBboxB, context=_ods_context))
    results.append(result_det_bboxes)
    results.append(result_det_labels)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr_rois(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr_bbox(self):
    return self.operation.operands[1]

  @builtins.property
  def ptr_score(self):
    return self.operation.operands[2]

  @builtins.property
  def max_val(self):
    return self.operation.operands[3]

  @builtins.property
  def scale_factor(self):
    return self.operation.operands[4]

  @builtins.property
  def threshold_score_eq(self):
    return self.operation.attributes["threshold_score_eq"]

  @threshold_score_eq.setter
  def threshold_score_eq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["threshold_score_eq"] = value

  @builtins.property
  def wh_ratio_log(self):
    return self.operation.attributes["wh_ratio_log"]

  @wh_ratio_log.setter
  def wh_ratio_log(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wh_ratio_log"] = value

  @builtins.property
  def nms_iou_thr(self):
    return self.operation.attributes["nms_iou_thr"]

  @nms_iou_thr.setter
  def nms_iou_thr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_iou_thr"] = value

  @builtins.property
  def delta2bbox_means(self):
    return self.operation.attributes["delta2bbox_means"]

  @delta2bbox_means.setter
  def delta2bbox_means(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_means"] = value

  @builtins.property
  def delta2bbox_stds_0(self):
    return self.operation.attributes["delta2bbox_stds_0"]

  @delta2bbox_stds_0.setter
  def delta2bbox_stds_0(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_stds_0"] = value

  @builtins.property
  def delta2bbox_stds_1(self):
    return self.operation.attributes["delta2bbox_stds_1"]

  @delta2bbox_stds_1.setter
  def delta2bbox_stds_1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_stds_1"] = value

  @builtins.property
  def NUM_INDEXES(self):
    return self.operation.attributes["NUM_INDEXES"]

  @NUM_INDEXES.setter
  def NUM_INDEXES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_INDEXES"] = value

  @builtins.property
  def NUM_CLASSES(self):
    return self.operation.attributes["NUM_CLASSES"]

  @NUM_CLASSES.setter
  def NUM_CLASSES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_CLASSES"] = value

  @builtins.property
  def TOPK_ONNX_NMS(self):
    return self.operation.attributes["TOPK_ONNX_NMS"]

  @TOPK_ONNX_NMS.setter
  def TOPK_ONNX_NMS(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["TOPK_ONNX_NMS"] = value

  @builtins.property
  def NUM_CLASSES_getBboxB(self):
    return self.operation.attributes["NUM_CLASSES_getBboxB"]

  @NUM_CLASSES_getBboxB.setter
  def NUM_CLASSES_getBboxB(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_CLASSES_getBboxB"] = value

  @builtins.property
  def MAX_NMS_LENGTH_GetBboxB(self):
    return self.operation.attributes["MAX_NMS_LENGTH_GetBboxB"]

  @MAX_NMS_LENGTH_GetBboxB.setter
  def MAX_NMS_LENGTH_GetBboxB(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_NMS_LENGTH_GetBboxB"] = value

  @builtins.property
  def MAX_PER_IMG(self):
    return self.operation.attributes["MAX_PER_IMG"]

  @MAX_PER_IMG.setter
  def MAX_PER_IMG(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_PER_IMG"] = value

  @builtins.property
  def MAX_PER_IMG_GetBboxB(self):
    return self.operation.attributes["MAX_PER_IMG_GetBboxB"]

  @MAX_PER_IMG_GetBboxB.setter
  def MAX_PER_IMG_GetBboxB(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_PER_IMG_GetBboxB"] = value

  @builtins.property
  def result_det_bboxes(self):
    return self.operation.results[0]

  @builtins.property
  def result_det_labels(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskRCNNMaskPoolerOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaskRCNN_MaskPooler"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_res, x_0, x_1, x_2, x_3, det_bboxes_multi_batch, det_labels_multi_batch, scale_factor, ROI_NUM_LEVELS, ROI_H, ROI_W, CHANNEL_ROI, ROI_SLICE, ROI_PH, ROI_PW, ROI_LEN, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(x_0))
    operands.append(_get_op_result_or_value(x_1))
    operands.append(_get_op_result_or_value(x_2))
    operands.append(_get_op_result_or_value(x_3))
    operands.append(_get_op_result_or_value(det_bboxes_multi_batch))
    operands.append(_get_op_result_or_value(det_labels_multi_batch))
    operands.append(_get_op_result_or_value(scale_factor))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ROI_NUM_LEVELS"] = (ROI_NUM_LEVELS if (
    issubclass(type(ROI_NUM_LEVELS), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_NUM_LEVELS, context=_ods_context))
    attributes["ROI_H"] = (ROI_H if (
    issubclass(type(ROI_H), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_H, context=_ods_context))
    attributes["ROI_W"] = (ROI_W if (
    issubclass(type(ROI_W), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_W, context=_ods_context))
    attributes["CHANNEL_ROI"] = (CHANNEL_ROI if (
    issubclass(type(CHANNEL_ROI), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(CHANNEL_ROI, context=_ods_context))
    attributes["ROI_SLICE"] = (ROI_SLICE if (
    issubclass(type(ROI_SLICE), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_SLICE, context=_ods_context))
    attributes["ROI_PH"] = (ROI_PH if (
    issubclass(type(ROI_PH), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_PH, context=_ods_context))
    attributes["ROI_PW"] = (ROI_PW if (
    issubclass(type(ROI_PW), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_PW, context=_ods_context))
    attributes["ROI_LEN"] = (ROI_LEN if (
    issubclass(type(ROI_LEN), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_LEN, context=_ods_context))
    results.append(result_res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def x_0(self):
    return self.operation.operands[0]

  @builtins.property
  def x_1(self):
    return self.operation.operands[1]

  @builtins.property
  def x_2(self):
    return self.operation.operands[2]

  @builtins.property
  def x_3(self):
    return self.operation.operands[3]

  @builtins.property
  def det_bboxes_multi_batch(self):
    return self.operation.operands[4]

  @builtins.property
  def det_labels_multi_batch(self):
    return self.operation.operands[5]

  @builtins.property
  def scale_factor(self):
    return self.operation.operands[6]

  @builtins.property
  def ROI_NUM_LEVELS(self):
    return self.operation.attributes["ROI_NUM_LEVELS"]

  @ROI_NUM_LEVELS.setter
  def ROI_NUM_LEVELS(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_NUM_LEVELS"] = value

  @builtins.property
  def ROI_H(self):
    return self.operation.attributes["ROI_H"]

  @ROI_H.setter
  def ROI_H(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_H"] = value

  @builtins.property
  def ROI_W(self):
    return self.operation.attributes["ROI_W"]

  @ROI_W.setter
  def ROI_W(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_W"] = value

  @builtins.property
  def CHANNEL_ROI(self):
    return self.operation.attributes["CHANNEL_ROI"]

  @CHANNEL_ROI.setter
  def CHANNEL_ROI(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["CHANNEL_ROI"] = value

  @builtins.property
  def ROI_SLICE(self):
    return self.operation.attributes["ROI_SLICE"]

  @ROI_SLICE.setter
  def ROI_SLICE(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_SLICE"] = value

  @builtins.property
  def ROI_PH(self):
    return self.operation.attributes["ROI_PH"]

  @ROI_PH.setter
  def ROI_PH(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_PH"] = value

  @builtins.property
  def ROI_PW(self):
    return self.operation.attributes["ROI_PW"]

  @ROI_PW.setter
  def ROI_PW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_PW"] = value

  @builtins.property
  def ROI_LEN(self):
    return self.operation.attributes["ROI_LEN"]

  @ROI_LEN.setter
  def ROI_LEN(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_LEN"] = value

  @builtins.property
  def result_res(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskRCNNRPNGetBboxesOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaskRCNN_RPNGetBboxes"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_list, cls_scores_0, cls_scores_1, cls_scores_2, cls_scores_3, cls_scores_4, bbox_preds_0, bbox_preds_1, bbox_preds_2, bbox_preds_3, bbox_preds_4, max_shape, mlvl_anchors_0, mlvl_anchors_1, mlvl_anchors_2, mlvl_anchors_3, mlvl_anchors_4, delta2bbox_mean_0, delta2bbox_mean_1, delta2bbox_mean_2, delta2bbox_mean_3, delta2bbox_std_0, delta2bbox_std_1, delta2bbox_std_2, delta2bbox_std_3, delta2bbox_max_scalar_c, iou_threshold, conf_threshold, MAX_LENGTH_STATIC_STRECHED, NUM_INDEXES, NUM_CLASSES, CHANNEL_RPN_BBOXES, CHANNEL_RPN_SCORES, NMS_PRE, HARDWARE_FACTOR_TOPK, NMS_MAX_LENGTH, TOPK_ONNX_NMS, H_RPN_DYN_MAX, W_RPN_DYN_MAX, MAX_PER_IMG, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cls_scores_0))
    operands.append(_get_op_result_or_value(cls_scores_1))
    operands.append(_get_op_result_or_value(cls_scores_2))
    operands.append(_get_op_result_or_value(cls_scores_3))
    operands.append(_get_op_result_or_value(cls_scores_4))
    operands.append(_get_op_result_or_value(bbox_preds_0))
    operands.append(_get_op_result_or_value(bbox_preds_1))
    operands.append(_get_op_result_or_value(bbox_preds_2))
    operands.append(_get_op_result_or_value(bbox_preds_3))
    operands.append(_get_op_result_or_value(bbox_preds_4))
    operands.append(_get_op_result_or_value(max_shape))
    operands.append(_get_op_result_or_value(mlvl_anchors_0))
    operands.append(_get_op_result_or_value(mlvl_anchors_1))
    operands.append(_get_op_result_or_value(mlvl_anchors_2))
    operands.append(_get_op_result_or_value(mlvl_anchors_3))
    operands.append(_get_op_result_or_value(mlvl_anchors_4))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["delta2bbox_mean_0"] = (delta2bbox_mean_0 if (
    issubclass(type(delta2bbox_mean_0), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_mean_0, context=_ods_context))
    attributes["delta2bbox_mean_1"] = (delta2bbox_mean_1 if (
    issubclass(type(delta2bbox_mean_1), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_mean_1, context=_ods_context))
    attributes["delta2bbox_mean_2"] = (delta2bbox_mean_2 if (
    issubclass(type(delta2bbox_mean_2), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_mean_2, context=_ods_context))
    attributes["delta2bbox_mean_3"] = (delta2bbox_mean_3 if (
    issubclass(type(delta2bbox_mean_3), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_mean_3, context=_ods_context))
    attributes["delta2bbox_std_0"] = (delta2bbox_std_0 if (
    issubclass(type(delta2bbox_std_0), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_std_0, context=_ods_context))
    attributes["delta2bbox_std_1"] = (delta2bbox_std_1 if (
    issubclass(type(delta2bbox_std_1), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_std_1, context=_ods_context))
    attributes["delta2bbox_std_2"] = (delta2bbox_std_2 if (
    issubclass(type(delta2bbox_std_2), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_std_2, context=_ods_context))
    attributes["delta2bbox_std_3"] = (delta2bbox_std_3 if (
    issubclass(type(delta2bbox_std_3), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_std_3, context=_ods_context))
    attributes["delta2bbox_max_scalar_c"] = (delta2bbox_max_scalar_c if (
    issubclass(type(delta2bbox_max_scalar_c), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_max_scalar_c, context=_ods_context))
    attributes["iou_threshold"] = (iou_threshold if (
    issubclass(type(iou_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(iou_threshold, context=_ods_context))
    attributes["conf_threshold"] = (conf_threshold if (
    issubclass(type(conf_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(conf_threshold, context=_ods_context))
    attributes["MAX_LENGTH_STATIC_STRECHED"] = (MAX_LENGTH_STATIC_STRECHED if (
    issubclass(type(MAX_LENGTH_STATIC_STRECHED), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_LENGTH_STATIC_STRECHED, context=_ods_context))
    attributes["NUM_INDEXES"] = (NUM_INDEXES if (
    issubclass(type(NUM_INDEXES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_INDEXES, context=_ods_context))
    attributes["NUM_CLASSES"] = (NUM_CLASSES if (
    issubclass(type(NUM_CLASSES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_CLASSES, context=_ods_context))
    attributes["CHANNEL_RPN_BBOXES"] = (CHANNEL_RPN_BBOXES if (
    issubclass(type(CHANNEL_RPN_BBOXES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(CHANNEL_RPN_BBOXES, context=_ods_context))
    attributes["CHANNEL_RPN_SCORES"] = (CHANNEL_RPN_SCORES if (
    issubclass(type(CHANNEL_RPN_SCORES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(CHANNEL_RPN_SCORES, context=_ods_context))
    attributes["NMS_PRE"] = (NMS_PRE if (
    issubclass(type(NMS_PRE), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NMS_PRE, context=_ods_context))
    attributes["HARDWARE_FACTOR_TOPK"] = (HARDWARE_FACTOR_TOPK if (
    issubclass(type(HARDWARE_FACTOR_TOPK), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(HARDWARE_FACTOR_TOPK, context=_ods_context))
    attributes["NMS_MAX_LENGTH"] = (NMS_MAX_LENGTH if (
    issubclass(type(NMS_MAX_LENGTH), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NMS_MAX_LENGTH, context=_ods_context))
    attributes["TOPK_ONNX_NMS"] = (TOPK_ONNX_NMS if (
    issubclass(type(TOPK_ONNX_NMS), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(TOPK_ONNX_NMS, context=_ods_context))
    attributes["H_RPN_DYN_MAX"] = (H_RPN_DYN_MAX if (
    issubclass(type(H_RPN_DYN_MAX), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(H_RPN_DYN_MAX, context=_ods_context))
    attributes["W_RPN_DYN_MAX"] = (W_RPN_DYN_MAX if (
    issubclass(type(W_RPN_DYN_MAX), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(W_RPN_DYN_MAX, context=_ods_context))
    attributes["MAX_PER_IMG"] = (MAX_PER_IMG if (
    issubclass(type(MAX_PER_IMG), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_PER_IMG, context=_ods_context))
    results.append(result_list)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cls_scores_0(self):
    return self.operation.operands[0]

  @builtins.property
  def cls_scores_1(self):
    return self.operation.operands[1]

  @builtins.property
  def cls_scores_2(self):
    return self.operation.operands[2]

  @builtins.property
  def cls_scores_3(self):
    return self.operation.operands[3]

  @builtins.property
  def cls_scores_4(self):
    return self.operation.operands[4]

  @builtins.property
  def bbox_preds_0(self):
    return self.operation.operands[5]

  @builtins.property
  def bbox_preds_1(self):
    return self.operation.operands[6]

  @builtins.property
  def bbox_preds_2(self):
    return self.operation.operands[7]

  @builtins.property
  def bbox_preds_3(self):
    return self.operation.operands[8]

  @builtins.property
  def bbox_preds_4(self):
    return self.operation.operands[9]

  @builtins.property
  def max_shape(self):
    return self.operation.operands[10]

  @builtins.property
  def mlvl_anchors_0(self):
    return self.operation.operands[11]

  @builtins.property
  def mlvl_anchors_1(self):
    return self.operation.operands[12]

  @builtins.property
  def mlvl_anchors_2(self):
    return self.operation.operands[13]

  @builtins.property
  def mlvl_anchors_3(self):
    return self.operation.operands[14]

  @builtins.property
  def mlvl_anchors_4(self):
    return self.operation.operands[15]

  @builtins.property
  def delta2bbox_mean_0(self):
    return self.operation.attributes["delta2bbox_mean_0"]

  @delta2bbox_mean_0.setter
  def delta2bbox_mean_0(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_mean_0"] = value

  @builtins.property
  def delta2bbox_mean_1(self):
    return self.operation.attributes["delta2bbox_mean_1"]

  @delta2bbox_mean_1.setter
  def delta2bbox_mean_1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_mean_1"] = value

  @builtins.property
  def delta2bbox_mean_2(self):
    return self.operation.attributes["delta2bbox_mean_2"]

  @delta2bbox_mean_2.setter
  def delta2bbox_mean_2(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_mean_2"] = value

  @builtins.property
  def delta2bbox_mean_3(self):
    return self.operation.attributes["delta2bbox_mean_3"]

  @delta2bbox_mean_3.setter
  def delta2bbox_mean_3(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_mean_3"] = value

  @builtins.property
  def delta2bbox_std_0(self):
    return self.operation.attributes["delta2bbox_std_0"]

  @delta2bbox_std_0.setter
  def delta2bbox_std_0(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_std_0"] = value

  @builtins.property
  def delta2bbox_std_1(self):
    return self.operation.attributes["delta2bbox_std_1"]

  @delta2bbox_std_1.setter
  def delta2bbox_std_1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_std_1"] = value

  @builtins.property
  def delta2bbox_std_2(self):
    return self.operation.attributes["delta2bbox_std_2"]

  @delta2bbox_std_2.setter
  def delta2bbox_std_2(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_std_2"] = value

  @builtins.property
  def delta2bbox_std_3(self):
    return self.operation.attributes["delta2bbox_std_3"]

  @delta2bbox_std_3.setter
  def delta2bbox_std_3(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_std_3"] = value

  @builtins.property
  def delta2bbox_max_scalar_c(self):
    return self.operation.attributes["delta2bbox_max_scalar_c"]

  @delta2bbox_max_scalar_c.setter
  def delta2bbox_max_scalar_c(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_max_scalar_c"] = value

  @builtins.property
  def iou_threshold(self):
    return self.operation.attributes["iou_threshold"]

  @iou_threshold.setter
  def iou_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iou_threshold"] = value

  @builtins.property
  def conf_threshold(self):
    return self.operation.attributes["conf_threshold"]

  @conf_threshold.setter
  def conf_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["conf_threshold"] = value

  @builtins.property
  def MAX_LENGTH_STATIC_STRECHED(self):
    return self.operation.attributes["MAX_LENGTH_STATIC_STRECHED"]

  @MAX_LENGTH_STATIC_STRECHED.setter
  def MAX_LENGTH_STATIC_STRECHED(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_LENGTH_STATIC_STRECHED"] = value

  @builtins.property
  def NUM_INDEXES(self):
    return self.operation.attributes["NUM_INDEXES"]

  @NUM_INDEXES.setter
  def NUM_INDEXES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_INDEXES"] = value

  @builtins.property
  def NUM_CLASSES(self):
    return self.operation.attributes["NUM_CLASSES"]

  @NUM_CLASSES.setter
  def NUM_CLASSES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_CLASSES"] = value

  @builtins.property
  def CHANNEL_RPN_BBOXES(self):
    return self.operation.attributes["CHANNEL_RPN_BBOXES"]

  @CHANNEL_RPN_BBOXES.setter
  def CHANNEL_RPN_BBOXES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["CHANNEL_RPN_BBOXES"] = value

  @builtins.property
  def CHANNEL_RPN_SCORES(self):
    return self.operation.attributes["CHANNEL_RPN_SCORES"]

  @CHANNEL_RPN_SCORES.setter
  def CHANNEL_RPN_SCORES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["CHANNEL_RPN_SCORES"] = value

  @builtins.property
  def NMS_PRE(self):
    return self.operation.attributes["NMS_PRE"]

  @NMS_PRE.setter
  def NMS_PRE(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NMS_PRE"] = value

  @builtins.property
  def HARDWARE_FACTOR_TOPK(self):
    return self.operation.attributes["HARDWARE_FACTOR_TOPK"]

  @HARDWARE_FACTOR_TOPK.setter
  def HARDWARE_FACTOR_TOPK(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["HARDWARE_FACTOR_TOPK"] = value

  @builtins.property
  def NMS_MAX_LENGTH(self):
    return self.operation.attributes["NMS_MAX_LENGTH"]

  @NMS_MAX_LENGTH.setter
  def NMS_MAX_LENGTH(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NMS_MAX_LENGTH"] = value

  @builtins.property
  def TOPK_ONNX_NMS(self):
    return self.operation.attributes["TOPK_ONNX_NMS"]

  @TOPK_ONNX_NMS.setter
  def TOPK_ONNX_NMS(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["TOPK_ONNX_NMS"] = value

  @builtins.property
  def H_RPN_DYN_MAX(self):
    return self.operation.attributes["H_RPN_DYN_MAX"]

  @H_RPN_DYN_MAX.setter
  def H_RPN_DYN_MAX(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["H_RPN_DYN_MAX"] = value

  @builtins.property
  def W_RPN_DYN_MAX(self):
    return self.operation.attributes["W_RPN_DYN_MAX"]

  @W_RPN_DYN_MAX.setter
  def W_RPN_DYN_MAX(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["W_RPN_DYN_MAX"] = value

  @builtins.property
  def MAX_PER_IMG(self):
    return self.operation.attributes["MAX_PER_IMG"]

  @MAX_PER_IMG.setter
  def MAX_PER_IMG(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_PER_IMG"] = value

  @builtins.property
  def result_list(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskedFillOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaskedFill"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, cond, brn, inversed, const_val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    operands.append(_get_op_result_or_value(brn))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inversed"] = (inversed if (
    issubclass(type(inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inversed, context=_ods_context))
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def brn(self):
    return self.operation.operands[1]

  @builtins.property
  def inversed(self):
    return self.operation.attributes["inversed"]

  @inversed.setter
  def inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inversed"] = value

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MatMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, right, bias, *, right_transpose=None, left_transpose=None, output_transpose=None, hdim_is_batch=None, keep_dims=None, do_relu=None, relu_limit=None, weight_bits=None, in_int4_scale=None, in_int4_zp=None, out_int8_scale=None, out_int8_zp=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(right))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if right_transpose is not None: attributes["right_transpose"] = (right_transpose if (
        issubclass(type(right_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(right_transpose, context=_ods_context))
    if left_transpose is not None: attributes["left_transpose"] = (left_transpose if (
        issubclass(type(left_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(left_transpose, context=_ods_context))
    if output_transpose is not None: attributes["output_transpose"] = (output_transpose if (
        issubclass(type(output_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(output_transpose, context=_ods_context))
    if hdim_is_batch is not None: attributes["hdim_is_batch"] = (hdim_is_batch if (
        issubclass(type(hdim_is_batch), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(hdim_is_batch, context=_ods_context))
    if keep_dims is not None: attributes["keep_dims"] = (keep_dims if (
        issubclass(type(keep_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keep_dims, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if weight_bits is not None: attributes["weight_bits"] = (weight_bits if (
        issubclass(type(weight_bits), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(weight_bits, context=_ods_context))
    if in_int4_scale is not None: attributes["in_int4_scale"] = (in_int4_scale if (
        issubclass(type(in_int4_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(in_int4_scale, context=_ods_context))
    if in_int4_zp is not None: attributes["in_int4_zp"] = (in_int4_zp if (
        issubclass(type(in_int4_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(in_int4_zp, context=_ods_context))
    if out_int8_scale is not None: attributes["out_int8_scale"] = (out_int8_scale if (
        issubclass(type(out_int8_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_int8_scale, context=_ods_context))
    if out_int8_zp is not None: attributes["out_int8_zp"] = (out_int8_zp if (
        issubclass(type(out_int8_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_int8_zp, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def right_transpose(self):
    return self.operation.attributes["right_transpose"]

  @right_transpose.setter
  def right_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["right_transpose"] = value

  @builtins.property
  def left_transpose(self):
    return self.operation.attributes["left_transpose"]

  @left_transpose.setter
  def left_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["left_transpose"] = value

  @builtins.property
  def output_transpose(self):
    return self.operation.attributes["output_transpose"]

  @output_transpose.setter
  def output_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_transpose"] = value

  @builtins.property
  def hdim_is_batch(self):
    return self.operation.attributes["hdim_is_batch"]

  @hdim_is_batch.setter
  def hdim_is_batch(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hdim_is_batch"] = value

  @builtins.property
  def keep_dims(self):
    return self.operation.attributes["keep_dims"]

  @keep_dims.setter
  def keep_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_dims"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def weight_bits(self):
    if "weight_bits" not in self.operation.attributes:
      return None
    return self.operation.attributes["weight_bits"]

  @weight_bits.setter
  def weight_bits(self, value):
    if value is not None:
      self.operation.attributes["weight_bits"] = value
    elif "weight_bits" in self.operation.attributes:
      del self.operation.attributes["weight_bits"]

  @weight_bits.deleter
  def weight_bits(self):
    del self.operation.attributes["weight_bits"]

  @builtins.property
  def in_int4_scale(self):
    if "in_int4_scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["in_int4_scale"]

  @in_int4_scale.setter
  def in_int4_scale(self, value):
    if value is not None:
      self.operation.attributes["in_int4_scale"] = value
    elif "in_int4_scale" in self.operation.attributes:
      del self.operation.attributes["in_int4_scale"]

  @in_int4_scale.deleter
  def in_int4_scale(self):
    del self.operation.attributes["in_int4_scale"]

  @builtins.property
  def in_int4_zp(self):
    if "in_int4_zp" not in self.operation.attributes:
      return None
    return self.operation.attributes["in_int4_zp"]

  @in_int4_zp.setter
  def in_int4_zp(self, value):
    if value is not None:
      self.operation.attributes["in_int4_zp"] = value
    elif "in_int4_zp" in self.operation.attributes:
      del self.operation.attributes["in_int4_zp"]

  @in_int4_zp.deleter
  def in_int4_zp(self):
    del self.operation.attributes["in_int4_zp"]

  @builtins.property
  def out_int8_scale(self):
    if "out_int8_scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_int8_scale"]

  @out_int8_scale.setter
  def out_int8_scale(self, value):
    if value is not None:
      self.operation.attributes["out_int8_scale"] = value
    elif "out_int8_scale" in self.operation.attributes:
      del self.operation.attributes["out_int8_scale"]

  @out_int8_scale.deleter
  def out_int8_scale(self):
    del self.operation.attributes["out_int8_scale"]

  @builtins.property
  def out_int8_zp(self):
    if "out_int8_zp" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_int8_zp"]

  @out_int8_zp.setter
  def out_int8_zp(self, value):
    if value is not None:
      self.operation.attributes["out_int8_zp"] = value
    elif "out_int8_zp" in self.operation.attributes:
      del self.operation.attributes["out_int8_zp"]

  @out_int8_zp.deleter
  def out_int8_zp(self):
    del self.operation.attributes["out_int8_zp"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MatchTemplateOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MatchTemplate"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, match, mode, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(match))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MatchTemplateModeAttr')) else
      _ods_ir.AttrBuilder.get('MatchTemplateModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def match(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaxConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Max"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxPoolOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaxPool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel_shape, strides, pads, *, ceil_mode=None, auto_pad=None, is_adaptive=None, keepdims=None, pad_value=None, count_include_pad=None, do_relu=None, relu_limit=None, round_mode=None, first_round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if ceil_mode is not None: attributes["ceil_mode"] = (ceil_mode if (
        issubclass(type(ceil_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    if auto_pad is not None: attributes["auto_pad"] = (auto_pad if (
        issubclass(type(auto_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AutoPadModeAttr')) else
          _ods_ir.AttrBuilder.get('AutoPadModeAttr')(auto_pad, context=_ods_context))
    if is_adaptive is not None: attributes["is_adaptive"] = (is_adaptive if (
        issubclass(type(is_adaptive), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_adaptive, context=_ods_context))
    if keepdims is not None: attributes["keepdims"] = (keepdims if (
        issubclass(type(keepdims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(first_round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def ceil_mode(self):
    if "ceil_mode" not in self.operation.attributes:
      return None
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is not None:
      self.operation.attributes["ceil_mode"] = value
    elif "ceil_mode" in self.operation.attributes:
      del self.operation.attributes["ceil_mode"]

  @ceil_mode.deleter
  def ceil_mode(self):
    del self.operation.attributes["ceil_mode"]

  @builtins.property
  def auto_pad(self):
    if "auto_pad" not in self.operation.attributes:
      return None
    return self.operation.attributes["auto_pad"]

  @auto_pad.setter
  def auto_pad(self, value):
    if value is not None:
      self.operation.attributes["auto_pad"] = value
    elif "auto_pad" in self.operation.attributes:
      del self.operation.attributes["auto_pad"]

  @auto_pad.deleter
  def auto_pad(self):
    del self.operation.attributes["auto_pad"]

  @builtins.property
  def is_adaptive(self):
    return self.operation.attributes["is_adaptive"]

  @is_adaptive.setter
  def is_adaptive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_adaptive"] = value

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def pad_value(self):
    return self.operation.attributes["pad_value"]

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def count_include_pad(self):
    return self.operation.attributes["count_include_pad"]

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxPoolWithMaskOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaxPoolWithMask"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mask, input, kernel_shape, strides, pads, *, ceil_mode=None, auto_pad=None, is_adaptive=None, keepdims=None, pad_value=None, count_include_pad=None, do_relu=None, relu_limit=None, round_mode=None, first_round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if ceil_mode is not None: attributes["ceil_mode"] = (ceil_mode if (
        issubclass(type(ceil_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    if auto_pad is not None: attributes["auto_pad"] = (auto_pad if (
        issubclass(type(auto_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AutoPadModeAttr')) else
          _ods_ir.AttrBuilder.get('AutoPadModeAttr')(auto_pad, context=_ods_context))
    if is_adaptive is not None: attributes["is_adaptive"] = (is_adaptive if (
        issubclass(type(is_adaptive), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_adaptive, context=_ods_context))
    if keepdims is not None: attributes["keepdims"] = (keepdims if (
        issubclass(type(keepdims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(first_round_mode, context=_ods_context))
    results.append(output)
    results.append(mask)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def ceil_mode(self):
    if "ceil_mode" not in self.operation.attributes:
      return None
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is not None:
      self.operation.attributes["ceil_mode"] = value
    elif "ceil_mode" in self.operation.attributes:
      del self.operation.attributes["ceil_mode"]

  @ceil_mode.deleter
  def ceil_mode(self):
    del self.operation.attributes["ceil_mode"]

  @builtins.property
  def auto_pad(self):
    if "auto_pad" not in self.operation.attributes:
      return None
    return self.operation.attributes["auto_pad"]

  @auto_pad.setter
  def auto_pad(self, value):
    if value is not None:
      self.operation.attributes["auto_pad"] = value
    elif "auto_pad" in self.operation.attributes:
      del self.operation.attributes["auto_pad"]

  @auto_pad.deleter
  def auto_pad(self):
    del self.operation.attributes["auto_pad"]

  @builtins.property
  def is_adaptive(self):
    return self.operation.attributes["is_adaptive"]

  @is_adaptive.setter
  def is_adaptive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_adaptive"] = value

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def pad_value(self):
    return self.operation.attributes["pad_value"]

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def count_include_pad(self):
    return self.operation.attributes["count_include_pad"]

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mask(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxPoolingIndicesBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaxPoolingIndicesBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_input, grad_output, indices, kernel_shape, strides, pads, dilations, input_shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_output))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    attributes["dilations"] = (dilations if (
    issubclass(type(dilations), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    attributes["input_shape"] = (input_shape if (
    issubclass(type(input_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_shape, context=_ods_context))
    results.append(grad_input)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def input_shape(self):
    return self.operation.attributes["input_shape"]

  @input_shape.setter
  def input_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_shape"] = value

  @builtins.property
  def grad_input(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxUnpoolOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MaxUnpool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mask, scale_h, scale_w, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mask))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale_h"] = (scale_h if (
    issubclass(type(scale_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_h, context=_ods_context))
    attributes["scale_w"] = (scale_w if (
    issubclass(type(scale_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_w, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def scale_h(self):
    return self.operation.attributes["scale_h"]

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return self.operation.attributes["scale_w"]

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MeanRstdOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MeanRstd"

  _ODS_REGIONS = (0, True)

  def __init__(self, mean, rstd, running_mean_update, running_var_update, scale, bias_new, input, running_mean, running_var, weight, bias, eps, momentum, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(running_mean))
    operands.append(_get_op_result_or_value(running_var))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    attributes["momentum"] = (momentum if (
    issubclass(type(momentum), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(momentum, context=_ods_context))
    results.append(mean)
    results.append(rstd)
    results.append(running_mean_update)
    results.append(running_var_update)
    results.append(scale)
    results.append(bias_new)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def running_mean(self):
    return self.operation.operands[1]

  @builtins.property
  def running_var(self):
    return self.operation.operands[2]

  @builtins.property
  def weight(self):
    return self.operation.operands[3]

  @builtins.property
  def bias(self):
    return self.operation.operands[4]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def momentum(self):
    return self.operation.attributes["momentum"]

  @momentum.setter
  def momentum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["momentum"] = value

  @builtins.property
  def mean(self):
    return self.operation.results[0]

  @builtins.property
  def rstd(self):
    return self.operation.results[1]

  @builtins.property
  def running_mean_update(self):
    return self.operation.results[2]

  @builtins.property
  def running_var_update(self):
    return self.operation.results[3]

  @builtins.property
  def scale(self):
    return self.operation.results[4]

  @builtins.property
  def bias_new(self):
    return self.operation.results[5]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MeanStdScaleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MeanStdScale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, quant_mode, customization_format, channel_order, scale, std, mean, zero_points, resize_dims, rounding_mode, *, sign=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(quant_mode, context=_ods_context))
    attributes["customization_format"] = (customization_format if (
    issubclass(type(customization_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(customization_format, context=_ods_context))
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(channel_order, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["std"] = (std if (
    issubclass(type(std), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(std, context=_ods_context))
    attributes["mean"] = (mean if (
    issubclass(type(mean), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(mean, context=_ods_context))
    attributes["zero_points"] = (zero_points if (
    issubclass(type(zero_points), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(zero_points, context=_ods_context))
    attributes["resize_dims"] = (resize_dims if (
    issubclass(type(resize_dims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(resize_dims, context=_ods_context))
    attributes["rounding_mode"] = (rounding_mode if (
    issubclass(type(rounding_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(rounding_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def customization_format(self):
    return self.operation.attributes["customization_format"]

  @customization_format.setter
  def customization_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["customization_format"] = value

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def sign(self):
    return self.operation.attributes["sign"]

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def std(self):
    return self.operation.attributes["std"]

  @std.setter
  def std(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["std"] = value

  @builtins.property
  def mean(self):
    return self.operation.attributes["mean"]

  @mean.setter
  def mean(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mean"] = value

  @builtins.property
  def zero_points(self):
    return self.operation.attributes["zero_points"]

  @zero_points.setter
  def zero_points(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["zero_points"] = value

  @builtins.property
  def resize_dims(self):
    return self.operation.attributes["resize_dims"]

  @resize_dims.setter
  def resize_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resize_dims"] = value

  @builtins.property
  def rounding_mode(self):
    return self.operation.attributes["rounding_mode"]

  @rounding_mode.setter
  def rounding_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rounding_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MeshGridOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MeshGrid"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, is_reverse, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["is_reverse"] = (is_reverse if (
    issubclass(type(is_reverse), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MinConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MinConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MinOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Min"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MishOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Mish"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Mmap2RgbmapOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Mmap2Rgbmap"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ModOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Mod"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MulConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.MulConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, do_relu=None, relu_limit=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NmsOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Nms"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, center_point_box, max_output_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["center_point_box"] = (center_point_box if (
    issubclass(type(center_point_box), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(center_point_box, context=_ods_context))
    attributes["max_output_size"] = (max_output_size if (
    issubclass(type(max_output_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(max_output_size, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def center_point_box(self):
    return self.operation.attributes["center_point_box"]

  @center_point_box.setter
  def center_point_box(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["center_point_box"] = value

  @builtins.property
  def max_output_size(self):
    return self.operation.attributes["max_output_size"]

  @max_output_size.setter
  def max_output_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_output_size"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NonZeroOp(_ods_ir.OpView):
  OPERATION_NAME = "top.NonZero"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    issubclass(type(order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('NonZeroOrderAttr')) else
      _ods_ir.AttrBuilder.get('NonZeroOrderAttr')(order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def order(self):
    return self.operation.attributes["order"]

  @order.setter
  def order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NoneOp(_ods_ir.OpView):
  OPERATION_NAME = "top.None"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NormalizeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Normalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, *, across_spatial=None, channel_shared=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(scale))
    _ods_context = _ods_get_default_loc_context(loc)
    if across_spatial is not None: attributes["across_spatial"] = (across_spatial if (
        issubclass(type(across_spatial), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(across_spatial, context=_ods_context))
    if channel_shared is not None: attributes["channel_shared"] = (channel_shared if (
        issubclass(type(channel_shared), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(channel_shared, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def across_spatial(self):
    return self.operation.attributes["across_spatial"]

  @across_spatial.setter
  def across_spatial(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["across_spatial"] = value

  @builtins.property
  def channel_shared(self):
    return self.operation.attributes["channel_shared"]

  @channel_shared.setter
  def channel_shared(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_shared"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PReluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.PRelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, slope, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(slope))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def slope(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PackOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Pack"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, axis, values_count, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["values_count"] = (values_count if (
    issubclass(type(values_count), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(values_count, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def values_count(self):
    return self.operation.attributes["values_count"]

  @values_count.setter
  def values_count(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values_count"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, paddings, mode, *, paddingsT=None, val=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if paddingsT is not None: operands.append(_get_op_result_or_value(paddingsT))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["paddings"] = (paddings if (
    issubclass(type(paddings), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(paddings, context=_ods_context))
    if val is not None: attributes["val"] = (val if (
        issubclass(type(val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(val, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('PaddingModeAttr')) else
      _ods_ir.AttrBuilder.get('PaddingModeAttr')(mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddingsT(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def paddings(self):
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def val(self):
    return self.operation.attributes["val"]

  @val.setter
  def val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["val"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PermuteOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Permute"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    issubclass(type(order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def order(self):
    return self.operation.attributes["order"]

  @order.setter
  def order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PixelNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.PixelNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, eps, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PoolMaskOp(_ods_ir.OpView):
  OPERATION_NAME = "top.PoolMask"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Pow2Op(_ods_ir.OpView):
  OPERATION_NAME = "top.Pow2"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, const_val, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Pow3Op(_ods_ir.OpView):
  OPERATION_NAME = "top.Pow3"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PowOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, exponent, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["exponent"] = (exponent if (
    issubclass(type(exponent), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(exponent, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def exponent(self):
    return self.operation.attributes["exponent"]

  @exponent.setter
  def exponent(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exponent"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PreprocessOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Preprocess"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, quant_mode, customization_format, channel_order, resize_dims, scale, mean, *, sign=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(quant_mode, context=_ods_context))
    attributes["customization_format"] = (customization_format if (
    issubclass(type(customization_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(customization_format, context=_ods_context))
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(channel_order, context=_ods_context))
    attributes["resize_dims"] = (resize_dims if (
    issubclass(type(resize_dims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(resize_dims, context=_ods_context))
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["mean"] = (mean if (
    issubclass(type(mean), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(mean, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def customization_format(self):
    return self.operation.attributes["customization_format"]

  @customization_format.setter
  def customization_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["customization_format"] = value

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def resize_dims(self):
    return self.operation.attributes["resize_dims"]

  @resize_dims.setter
  def resize_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resize_dims"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def mean(self):
    return self.operation.attributes["mean"]

  @mean.setter
  def mean(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mean"] = value

  @builtins.property
  def sign(self):
    return self.operation.attributes["sign"]

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PriorBoxOp(_ods_ir.OpView):
  OPERATION_NAME = "top.PriorBox"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, min_size, max_size, aspect_ratios, variance, step_h, step_w, img_h, img_w, num_priors, *, clip=None, offset=None, use_default_aspect_ratio=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min_size"] = (min_size if (
    issubclass(type(min_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(min_size, context=_ods_context))
    attributes["max_size"] = (max_size if (
    issubclass(type(max_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(max_size, context=_ods_context))
    attributes["aspect_ratios"] = (aspect_ratios if (
    issubclass(type(aspect_ratios), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(aspect_ratios, context=_ods_context))
    attributes["variance"] = (variance if (
    issubclass(type(variance), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(variance, context=_ods_context))
    if clip is not None: attributes["clip"] = (clip if (
        issubclass(type(clip), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(clip, context=_ods_context))
    attributes["step_h"] = (step_h if (
    issubclass(type(step_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(step_h, context=_ods_context))
    attributes["step_w"] = (step_w if (
    issubclass(type(step_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(step_w, context=_ods_context))
    attributes["img_h"] = (img_h if (
    issubclass(type(img_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(img_h, context=_ods_context))
    attributes["img_w"] = (img_w if (
    issubclass(type(img_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(img_w, context=_ods_context))
    if offset is not None: attributes["offset"] = (offset if (
        issubclass(type(offset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(offset, context=_ods_context))
    attributes["num_priors"] = (num_priors if (
    issubclass(type(num_priors), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_priors, context=_ods_context))
    if use_default_aspect_ratio is not None: attributes["use_default_aspect_ratio"] = (use_default_aspect_ratio if (
        issubclass(type(use_default_aspect_ratio), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_default_aspect_ratio, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def min_size(self):
    return self.operation.attributes["min_size"]

  @min_size.setter
  def min_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min_size"] = value

  @builtins.property
  def max_size(self):
    return self.operation.attributes["max_size"]

  @max_size.setter
  def max_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_size"] = value

  @builtins.property
  def aspect_ratios(self):
    return self.operation.attributes["aspect_ratios"]

  @aspect_ratios.setter
  def aspect_ratios(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aspect_ratios"] = value

  @builtins.property
  def variance(self):
    return self.operation.attributes["variance"]

  @variance.setter
  def variance(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variance"] = value

  @builtins.property
  def clip(self):
    return self.operation.attributes["clip"]

  @clip.setter
  def clip(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["clip"] = value

  @builtins.property
  def step_h(self):
    return self.operation.attributes["step_h"]

  @step_h.setter
  def step_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step_h"] = value

  @builtins.property
  def step_w(self):
    return self.operation.attributes["step_w"]

  @step_w.setter
  def step_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["step_w"] = value

  @builtins.property
  def img_h(self):
    return self.operation.attributes["img_h"]

  @img_h.setter
  def img_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["img_h"] = value

  @builtins.property
  def img_w(self):
    return self.operation.attributes["img_w"]

  @img_w.setter
  def img_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["img_w"] = value

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def num_priors(self):
    return self.operation.attributes["num_priors"]

  @num_priors.setter
  def num_priors(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_priors"] = value

  @builtins.property
  def use_default_aspect_ratio(self):
    return self.operation.attributes["use_default_aspect_ratio"]

  @use_default_aspect_ratio.setter
  def use_default_aspect_ratio(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_default_aspect_ratio"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ProposalOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Proposal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, net_input_h, net_input_w, feat_stride, anchor_base_size, rpn_obj_threshold, rpn_nms_threshold, rpn_nms_post_top_n, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["net_input_h"] = (net_input_h if (
    issubclass(type(net_input_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_h, context=_ods_context))
    attributes["net_input_w"] = (net_input_w if (
    issubclass(type(net_input_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_w, context=_ods_context))
    attributes["feat_stride"] = (feat_stride if (
    issubclass(type(feat_stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(feat_stride, context=_ods_context))
    attributes["anchor_base_size"] = (anchor_base_size if (
    issubclass(type(anchor_base_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(anchor_base_size, context=_ods_context))
    attributes["rpn_obj_threshold"] = (rpn_obj_threshold if (
    issubclass(type(rpn_obj_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(rpn_obj_threshold, context=_ods_context))
    attributes["rpn_nms_threshold"] = (rpn_nms_threshold if (
    issubclass(type(rpn_nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(rpn_nms_threshold, context=_ods_context))
    attributes["rpn_nms_post_top_n"] = (rpn_nms_post_top_n if (
    issubclass(type(rpn_nms_post_top_n), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(rpn_nms_post_top_n, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def net_input_h(self):
    return self.operation.attributes["net_input_h"]

  @net_input_h.setter
  def net_input_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_h"] = value

  @builtins.property
  def net_input_w(self):
    return self.operation.attributes["net_input_w"]

  @net_input_w.setter
  def net_input_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_w"] = value

  @builtins.property
  def feat_stride(self):
    return self.operation.attributes["feat_stride"]

  @feat_stride.setter
  def feat_stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["feat_stride"] = value

  @builtins.property
  def anchor_base_size(self):
    return self.operation.attributes["anchor_base_size"]

  @anchor_base_size.setter
  def anchor_base_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchor_base_size"] = value

  @builtins.property
  def rpn_obj_threshold(self):
    return self.operation.attributes["rpn_obj_threshold"]

  @rpn_obj_threshold.setter
  def rpn_obj_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rpn_obj_threshold"] = value

  @builtins.property
  def rpn_nms_threshold(self):
    return self.operation.attributes["rpn_nms_threshold"]

  @rpn_nms_threshold.setter
  def rpn_nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rpn_nms_threshold"] = value

  @builtins.property
  def rpn_nms_post_top_n(self):
    return self.operation.attributes["rpn_nms_post_top_n"]

  @rpn_nms_post_top_n.setter
  def rpn_nms_post_top_n(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rpn_nms_post_top_n"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class QuantizeLinearOp(_ods_ir.OpView):
  OPERATION_NAME = "top.QuantizeLinear"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, y_scale, y_zero_point, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["y_scale"] = (y_scale if (
    issubclass(type(y_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(y_scale, context=_ods_context))
    attributes["y_zero_point"] = (y_zero_point if (
    issubclass(type(y_zero_point), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(y_zero_point, context=_ods_context))
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def y_scale(self):
    return self.operation.attributes["y_scale"]

  @y_scale.setter
  def y_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_scale"] = value

  @builtins.property
  def y_zero_point(self):
    return self.operation.attributes["y_zero_point"]

  @y_zero_point.setter
  def y_zero_point(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_zero_point"] = value

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RMSNormOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RMSNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, gamma, eps, *, weight_keep_f32=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(gamma))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if weight_keep_f32 is not None: attributes["weight_keep_f32"] = (weight_keep_f32 if (
        issubclass(type(weight_keep_f32), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(weight_keep_f32, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def gamma(self):
    return self.operation.operands[1]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def weight_keep_f32(self):
    return self.operation.attributes["weight_keep_f32"]

  @weight_keep_f32.setter
  def weight_keep_f32(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weight_keep_f32"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ROIPoolingOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ROIPooling"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, pooled_h, pooled_w, spatial_scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pooled_h"] = (pooled_h if (
    issubclass(type(pooled_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(pooled_h, context=_ods_context))
    attributes["pooled_w"] = (pooled_w if (
    issubclass(type(pooled_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(pooled_w, context=_ods_context))
    attributes["spatial_scale"] = (spatial_scale if (
    issubclass(type(spatial_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(spatial_scale, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def pooled_h(self):
    return self.operation.attributes["pooled_h"]

  @pooled_h.setter
  def pooled_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pooled_h"] = value

  @builtins.property
  def pooled_w(self):
    return self.operation.attributes["pooled_w"]

  @pooled_w.setter
  def pooled_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pooled_w"] = value

  @builtins.property
  def spatial_scale(self):
    return self.operation.attributes["spatial_scale"]

  @spatial_scale.setter
  def spatial_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spatial_scale"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RandnLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RandnLike"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, randn_data, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(randn_data))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def randn_data(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RangeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Range"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, start, limit, delta, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(start))
    operands.append(_get_op_result_or_value(limit))
    operands.append(_get_op_result_or_value(delta))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def limit(self):
    return self.operation.operands[1]

  @builtins.property
  def delta(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReciprocalOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Reciprocal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, const_val=None, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if const_val is not None: attributes["const_val"] = (const_val if (
        issubclass(type(const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Reduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, keepdims, mode, *, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    attributes["keepdims"] = (keepdims if (
    issubclass(type(keepdims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ReduceModeAttr')) else
      _ods_ir.AttrBuilder.get('ReduceModeAttr')(mode, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RemainderOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Remainder"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RepeatOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Repeat"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, repeats, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(repeats))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def repeats(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RequantFpOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RequantFp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, offset, quant_mode, *, round_mode=None, first_round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(offset, context=_ods_context))
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RequantModeAttr')) else
      _ods_ir.AttrBuilder.get('RequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(first_round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RequantIntOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RequantInt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, multiplier, rshift, quant_mode, *, round_mode=None, rq_axis=None, fuse_rq=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["multiplier"] = (multiplier if (
    issubclass(type(multiplier), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(multiplier, context=_ods_context))
    attributes["rshift"] = (rshift if (
    issubclass(type(rshift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshift, context=_ods_context))
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RequantModeAttr')) else
      _ods_ir.AttrBuilder.get('RequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    if rq_axis is not None: attributes["rq_axis"] = (rq_axis if (
        issubclass(type(rq_axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rq_axis, context=_ods_context))
    if fuse_rq is not None: attributes["fuse_rq"] = (fuse_rq if (
        issubclass(type(fuse_rq), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(fuse_rq, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def rq_axis(self):
    return self.operation.attributes["rq_axis"]

  @rq_axis.setter
  def rq_axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rq_axis"] = value

  @builtins.property
  def fuse_rq(self):
    return self.operation.attributes["fuse_rq"]

  @fuse_rq.setter
  def fuse_rq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fuse_rq"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, shapeT=None, shape=None, flatten_start_dim=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if shapeT is not None: operands.append(_get_op_result_or_value(shapeT))
    _ods_context = _ods_get_default_loc_context(loc)
    if shape is not None: attributes["shape"] = (shape if (
        issubclass(type(shape), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    if flatten_start_dim is not None: attributes["flatten_start_dim"] = (flatten_start_dim if (
        issubclass(type(flatten_start_dim), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(flatten_start_dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shapeT(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def shape(self):
    if "shape" not in self.operation.attributes:
      return None
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is not None:
      self.operation.attributes["shape"] = value
    elif "shape" in self.operation.attributes:
      del self.operation.attributes["shape"]

  @shape.deleter
  def shape(self):
    del self.operation.attributes["shape"]

  @builtins.property
  def flatten_start_dim(self):
    return self.operation.attributes["flatten_start_dim"]

  @flatten_start_dim.setter
  def flatten_start_dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flatten_start_dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RetinaFaceDetectionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RetinaFaceDetection"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, nms_threshold, confidence_threshold, keep_topk, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["confidence_threshold"] = (confidence_threshold if (
    issubclass(type(confidence_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(confidence_threshold, context=_ods_context))
    attributes["keep_topk"] = (keep_topk if (
    issubclass(type(keep_topk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_topk, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def nms_threshold(self):
    return self.operation.attributes["nms_threshold"]

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def confidence_threshold(self):
    return self.operation.attributes["confidence_threshold"]

  @confidence_threshold.setter
  def confidence_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["confidence_threshold"] = value

  @builtins.property
  def keep_topk(self):
    return self.operation.attributes["keep_topk"]

  @keep_topk.setter
  def keep_topk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_topk"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReverseOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Reverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RoiAlignOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RoiAlign"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, rois, mode, output_height, output_width, sampling_ratio, spatial_scale, align_corners, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(rois))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RoiAlignModeAttr')) else
      _ods_ir.AttrBuilder.get('RoiAlignModeAttr')(mode, context=_ods_context))
    attributes["output_height"] = (output_height if (
    issubclass(type(output_height), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_height, context=_ods_context))
    attributes["output_width"] = (output_width if (
    issubclass(type(output_width), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_width, context=_ods_context))
    attributes["sampling_ratio"] = (sampling_ratio if (
    issubclass(type(sampling_ratio), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(sampling_ratio, context=_ods_context))
    attributes["spatial_scale"] = (spatial_scale if (
    issubclass(type(spatial_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(spatial_scale, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def rois(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output_height(self):
    return self.operation.attributes["output_height"]

  @output_height.setter
  def output_height(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_height"] = value

  @builtins.property
  def output_width(self):
    return self.operation.attributes["output_width"]

  @output_width.setter
  def output_width(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_width"] = value

  @builtins.property
  def sampling_ratio(self):
    return self.operation.attributes["sampling_ratio"]

  @sampling_ratio.setter
  def sampling_ratio(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sampling_ratio"] = value

  @builtins.property
  def spatial_scale(self):
    return self.operation.attributes["spatial_scale"]

  @spatial_scale.setter
  def spatial_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spatial_scale"] = value

  @builtins.property
  def align_corners(self):
    return self.operation.attributes["align_corners"]

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RoiExtractorOp(_ods_ir.OpView):
  OPERATION_NAME = "top.RoiExtractor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, rois, target_lvls, inputs, mode, num_levels, output_height, output_width, sampling_ratio, spatial_scales, align_corners, is_static, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(rois))
    operands.append(_get_op_result_or_value(target_lvls))
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RoiAlignModeAttr')) else
      _ods_ir.AttrBuilder.get('RoiAlignModeAttr')(mode, context=_ods_context))
    attributes["num_levels"] = (num_levels if (
    issubclass(type(num_levels), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_levels, context=_ods_context))
    attributes["output_height"] = (output_height if (
    issubclass(type(output_height), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_height, context=_ods_context))
    attributes["output_width"] = (output_width if (
    issubclass(type(output_width), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_width, context=_ods_context))
    attributes["sampling_ratio"] = (sampling_ratio if (
    issubclass(type(sampling_ratio), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(sampling_ratio, context=_ods_context))
    attributes["spatial_scales"] = (spatial_scales if (
    issubclass(type(spatial_scales), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(spatial_scales, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    attributes["is_static"] = (is_static if (
    issubclass(type(is_static), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_static, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def rois(self):
    return self.operation.operands[0]

  @builtins.property
  def target_lvls(self):
    return self.operation.operands[1]

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def num_levels(self):
    return self.operation.attributes["num_levels"]

  @num_levels.setter
  def num_levels(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_levels"] = value

  @builtins.property
  def output_height(self):
    return self.operation.attributes["output_height"]

  @output_height.setter
  def output_height(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_height"] = value

  @builtins.property
  def output_width(self):
    return self.operation.attributes["output_width"]

  @output_width.setter
  def output_width(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_width"] = value

  @builtins.property
  def sampling_ratio(self):
    return self.operation.attributes["sampling_ratio"]

  @sampling_ratio.setter
  def sampling_ratio(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sampling_ratio"] = value

  @builtins.property
  def spatial_scales(self):
    return self.operation.attributes["spatial_scales"]

  @spatial_scales.setter
  def spatial_scales(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spatial_scales"] = value

  @builtins.property
  def align_corners(self):
    return self.operation.attributes["align_corners"]

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def is_static(self):
    return self.operation.attributes["is_static"]

  @is_static.setter
  def is_static(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_static"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RoundOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Round"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RsqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScaleDotProductAttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ScaleDotProductAttention"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, query, key, value, mask, *, dropout_p=None, is_causal=None, scale=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(query))
    operands.append(_get_op_result_or_value(key))
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(mask))
    _ods_context = _ods_get_default_loc_context(loc)
    if dropout_p is not None: attributes["dropout_p"] = (dropout_p if (
        issubclass(type(dropout_p), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(dropout_p, context=_ods_context))
    if is_causal is not None: attributes["is_causal"] = (is_causal if (
        issubclass(type(is_causal), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_causal, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def query(self):
    return self.operation.operands[0]

  @builtins.property
  def key(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

  @builtins.property
  def mask(self):
    return self.operation.operands[3]

  @builtins.property
  def dropout_p(self):
    return self.operation.attributes["dropout_p"]

  @dropout_p.setter
  def dropout_p(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dropout_p"] = value

  @builtins.property
  def is_causal(self):
    return self.operation.attributes["is_causal"]

  @is_causal.setter
  def is_causal(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_causal"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScaleLutOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ScaleLut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, bias, *, sign=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["bias"] = (bias if (
    issubclass(type(bias), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(bias, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def bias(self):
    return self.operation.attributes["bias"]

  @bias.setter
  def bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bias"] = value

  @builtins.property
  def sign(self):
    return self.operation.attributes["sign"]

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScaleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Scale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, bias, *, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(scale))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScatterElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ScatterElements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, updates, axis, *, reduction=None, nc_can_split=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if reduction is not None: attributes["reduction"] = (reduction if (
        issubclass(type(reduction), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(reduction, context=_ods_context))
    if nc_can_split is not None: attributes["nc_can_split"] = (nc_can_split if (
        issubclass(type(nc_can_split), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(nc_can_split, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def reduction(self):
    return self.operation.attributes["reduction"]

  @reduction.setter
  def reduction(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction"] = value

  @builtins.property
  def nc_can_split(self):
    return self.operation.attributes["nc_can_split"]

  @nc_can_split.setter
  def nc_can_split(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nc_can_split"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScatterNDOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ScatterND"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input_data, indices, updates, *, reduction=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input_data))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    if reduction is not None: attributes["reduction"] = (reduction if (
        issubclass(type(reduction), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(reduction, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input_data(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def reduction(self):
    return self.operation.attributes["reduction"]

  @reduction.setter
  def reduction(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SelectiveScanOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SelectiveScan"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, Cs, deltaA, deltaB_u, us, Ds, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(Cs))
    operands.append(_get_op_result_or_value(deltaA))
    operands.append(_get_op_result_or_value(deltaB_u))
    operands.append(_get_op_result_or_value(us))
    operands.append(_get_op_result_or_value(Ds))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def Cs(self):
    return self.operation.operands[0]

  @builtins.property
  def deltaA(self):
    return self.operation.operands[1]

  @builtins.property
  def deltaB_u(self):
    return self.operation.operands[2]

  @builtins.property
  def us(self):
    return self.operation.operands[3]

  @builtins.property
  def Ds(self):
    return self.operation.operands[4]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, start=None, end=None, step=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if start is not None: attributes["start"] = (start if (
        issubclass(type(start), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(start, context=_ods_context))
    if end is not None: attributes["end"] = (end if (
        issubclass(type(end), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(end, context=_ods_context))
    if step is not None: attributes["step"] = (step if (
        issubclass(type(step), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(step, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def start(self):
    if "start" not in self.operation.attributes:
      return None
    return self.operation.attributes["start"]

  @start.setter
  def start(self, value):
    if value is not None:
      self.operation.attributes["start"] = value
    elif "start" in self.operation.attributes:
      del self.operation.attributes["start"]

  @start.deleter
  def start(self):
    del self.operation.attributes["start"]

  @builtins.property
  def end(self):
    if "end" not in self.operation.attributes:
      return None
    return self.operation.attributes["end"]

  @end.setter
  def end(self, value):
    if value is not None:
      self.operation.attributes["end"] = value
    elif "end" in self.operation.attributes:
      del self.operation.attributes["end"]

  @end.deleter
  def end(self):
    del self.operation.attributes["end"]

  @builtins.property
  def step(self):
    if "step" not in self.operation.attributes:
      return None
    return self.operation.attributes["step"]

  @step.setter
  def step(self, value):
    if value is not None:
      self.operation.attributes["step"] = value
    elif "step" in self.operation.attributes:
      del self.operation.attributes["step"]

  @step.deleter
  def step(self):
    del self.operation.attributes["step"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShuffleChannelOp(_ods_ir.OpView):
  OPERATION_NAME = "top.ShuffleChannel"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, group, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["group"] = (group if (
    issubclass(type(group), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SiLUOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SiLU"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SigmoidOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, scale=None, bias=None, log=None, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    if bias is not None: attributes["bias"] = (bias if (
        issubclass(type(bias), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(bias, context=_ods_context))
    if log is not None: attributes["log"] = (log if (
        issubclass(type(log), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(log, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def bias(self):
    return self.operation.attributes["bias"]

  @bias.setter
  def bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bias"] = value

  @builtins.property
  def log(self):
    return self.operation.attributes["log"]

  @log.setter
  def log(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["log"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SignOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sign"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SinOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SinhOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SizeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Size"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, axis=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    if "axis" not in self.operation.attributes:
      return None
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is not None:
      self.operation.attributes["axis"] = value
    elif "axis" in self.operation.attributes:
      del self.operation.attributes["axis"]

  @axis.deleter
  def axis(self):
    del self.operation.attributes["axis"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SliceAxisOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SliceAxis"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, start, step, end, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(axis))
    operands.append(_get_op_result_or_value(start))
    operands.append(_get_op_result_or_value(step))
    operands.append(_get_op_result_or_value(end))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.operands[1]

  @builtins.property
  def start(self):
    return self.operation.operands[2]

  @builtins.property
  def step(self):
    return self.operation.operands[3]

  @builtins.property
  def end(self):
    return self.operation.operands[4]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, offsetT, endsT, stepsT, offset, steps, ends, *, axes=None, hasparamConvert_axes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(offsetT))
    operands.append(_get_op_result_or_value(endsT))
    operands.append(_get_op_result_or_value(stepsT))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(offset, context=_ods_context))
    attributes["steps"] = (steps if (
    issubclass(type(steps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(steps, context=_ods_context))
    attributes["ends"] = (ends if (
    issubclass(type(ends), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(ends, context=_ods_context))
    if axes is not None: attributes["axes"] = (axes if (
        issubclass(type(axes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    if hasparamConvert_axes is not None: attributes["hasparamConvert_axes"] = (hasparamConvert_axes if (
        issubclass(type(hasparamConvert_axes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(hasparamConvert_axes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def offsetT(self):
    return self.operation.operands[1]

  @builtins.property
  def endsT(self):
    return self.operation.operands[2]

  @builtins.property
  def stepsT(self):
    return self.operation.operands[3]

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def steps(self):
    return self.operation.attributes["steps"]

  @steps.setter
  def steps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["steps"] = value

  @builtins.property
  def ends(self):
    return self.operation.attributes["ends"]

  @ends.setter
  def ends(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ends"] = value

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def hasparamConvert_axes(self):
    return self.operation.attributes["hasparamConvert_axes"]

  @hasparamConvert_axes.setter
  def hasparamConvert_axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hasparamConvert_axes"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftmaxBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SoftmaxBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_input, grad_output, output, dim, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_output))
    operands.append(_get_op_result_or_value(output))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    issubclass(type(dim), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(dim, context=_ods_context))
    results.append(grad_input)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def grad_input(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, log=None, beta=None, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if log is not None: attributes["log"] = (log if (
        issubclass(type(log), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(log, context=_ods_context))
    if beta is not None: attributes["beta"] = (beta if (
        issubclass(type(beta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def log(self):
    return self.operation.attributes["log"]

  @log.setter
  def log(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["log"] = value

  @builtins.property
  def beta(self):
    return self.operation.attributes["beta"]

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftplusOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Softplus"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftsignOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Softsign"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SortOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sort"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, axis, *, descending=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if descending is not None: attributes["descending"] = (descending if (
        issubclass(type(descending), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(descending, context=_ods_context))
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def descending(self):
    return self.operation.attributes["descending"]

  @descending.setter
  def descending(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["descending"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Split"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, input, axis, num, *, split_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["num"] = (num if (
    issubclass(type(num), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num, context=_ods_context))
    if split_size is not None: attributes["split_size"] = (split_size if (
        issubclass(type(split_size), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(split_size, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def num(self):
    return self.operation.attributes["num"]

  @num.setter
  def num(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num"] = value

  @builtins.property
  def split_size(self):
    if "split_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["split_size"]

  @split_size.setter
  def split_size(self, value):
    if value is not None:
      self.operation.attributes["split_size"] = value
    elif "split_size" in self.operation.attributes:
      del self.operation.attributes["split_size"]

  @split_size.deleter
  def split_size(self):
    del self.operation.attributes["split_size"]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SqrtOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Squeeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, *, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class StridedSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.StridedSlice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, starts, ends, strides, begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(starts))
    operands.append(_get_op_result_or_value(ends))
    operands.append(_get_op_result_or_value(strides))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["begin_mask"] = (begin_mask if (
    issubclass(type(begin_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(begin_mask, context=_ods_context))
    attributes["end_mask"] = (end_mask if (
    issubclass(type(end_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(end_mask, context=_ods_context))
    attributes["ellipsis_mask"] = (ellipsis_mask if (
    issubclass(type(ellipsis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ellipsis_mask, context=_ods_context))
    attributes["new_axis_mask"] = (new_axis_mask if (
    issubclass(type(new_axis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(new_axis_mask, context=_ods_context))
    attributes["shrink_axis_mask"] = (shrink_axis_mask if (
    issubclass(type(shrink_axis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(shrink_axis_mask, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def starts(self):
    return self.operation.operands[1]

  @builtins.property
  def ends(self):
    return self.operation.operands[2]

  @builtins.property
  def strides(self):
    return self.operation.operands[3]

  @builtins.property
  def begin_mask(self):
    return self.operation.attributes["begin_mask"]

  @begin_mask.setter
  def begin_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["begin_mask"] = value

  @builtins.property
  def end_mask(self):
    return self.operation.attributes["end_mask"]

  @end_mask.setter
  def end_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end_mask"] = value

  @builtins.property
  def ellipsis_mask(self):
    return self.operation.attributes["ellipsis_mask"]

  @ellipsis_mask.setter
  def ellipsis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ellipsis_mask"] = value

  @builtins.property
  def new_axis_mask(self):
    return self.operation.attributes["new_axis_mask"]

  @new_axis_mask.setter
  def new_axis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["new_axis_mask"] = value

  @builtins.property
  def shrink_axis_mask(self):
    return self.operation.attributes["shrink_axis_mask"]

  @shrink_axis_mask.setter
  def shrink_axis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shrink_axis_mask"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SubConstOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SubConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, is_reverse=None, do_relu=None, relu_limit=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SubOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, is_reverse=None, do_relu=None, relu_limit=None, coeff=None, is_scalar=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if coeff is not None: attributes["coeff"] = (coeff if (
        issubclass(type(coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeff, context=_ods_context))
    if is_scalar is not None: attributes["is_scalar"] = (is_scalar if (
        issubclass(type(is_scalar), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_scalar, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def coeff(self):
    if "coeff" not in self.operation.attributes:
      return None
    return self.operation.attributes["coeff"]

  @coeff.setter
  def coeff(self, value):
    if value is not None:
      self.operation.attributes["coeff"] = value
    elif "coeff" in self.operation.attributes:
      del self.operation.attributes["coeff"]

  @coeff.deleter
  def coeff(self):
    del self.operation.attributes["coeff"]

  @builtins.property
  def is_scalar(self):
    return self.operation.attributes["is_scalar"]

  @is_scalar.setter
  def is_scalar(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_scalar"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SwapChannelOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SwapChannel"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, channel_order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(channel_order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SwapDimInnerOp(_ods_ir.OpView):
  OPERATION_NAME = "top.SwapDimInner"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(offset, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SwishOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Swish"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, beta, *, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["beta"] = (beta if (
    issubclass(type(beta), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def beta(self):
    return self.operation.attributes["beta"]

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TanOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TanhOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, tileT=None, tile=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if tileT is not None: operands.append(_get_op_result_or_value(tileT))
    _ods_context = _ods_get_default_loc_context(loc)
    if tile is not None: attributes["tile"] = (tile if (
        issubclass(type(tile), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(tile, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tileT(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def tile(self):
    if "tile" not in self.operation.attributes:
      return None
    return self.operation.attributes["tile"]

  @tile.setter
  def tile(self, value):
    if value is not None:
      self.operation.attributes["tile"] = value
    elif "tile" in self.operation.attributes:
      del self.operation.attributes["tile"]

  @tile.deleter
  def tile(self):
    del self.operation.attributes["tile"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TopKOp(_ods_ir.OpView):
  OPERATION_NAME = "top.TopK"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, axis, *, K=None, largest=None, sorted=None, kT=None, replace_topk_indices=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if kT is not None: operands.append(_get_op_result_or_value(kT))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if K is not None: attributes["K"] = (K if (
        issubclass(type(K), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(K, context=_ods_context))
    if largest is not None: attributes["largest"] = (largest if (
        issubclass(type(largest), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(largest, context=_ods_context))
    if sorted is not None: attributes["sorted"] = (sorted if (
        issubclass(type(sorted), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sorted, context=_ods_context))
    if replace_topk_indices is not None: attributes["replace_topk_indices"] = (replace_topk_indices if (
        issubclass(type(replace_topk_indices), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(replace_topk_indices, context=_ods_context))
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kT(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def K(self):
    return self.operation.attributes["K"]

  @K.setter
  def K(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["K"] = value

  @builtins.property
  def largest(self):
    return self.operation.attributes["largest"]

  @largest.setter
  def largest(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["largest"] = value

  @builtins.property
  def sorted(self):
    return self.operation.attributes["sorted"]

  @sorted.setter
  def sorted(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sorted"] = value

  @builtins.property
  def replace_topk_indices(self):
    return self.operation.attributes["replace_topk_indices"]

  @replace_topk_indices.setter
  def replace_topk_indices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["replace_topk_indices"] = value

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dim0, dim1, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim0"] = (dim0 if (
    issubclass(type(dim0), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(dim0, context=_ods_context))
    attributes["dim1"] = (dim1 if (
    issubclass(type(dim1), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(dim1, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dim0(self):
    return self.operation.attributes["dim0"]

  @dim0.setter
  def dim0(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim0"] = value

  @builtins.property
  def dim1(self):
    return self.operation.attributes["dim1"]

  @dim1.setter
  def dim1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim1"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TriluOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Trilu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, upper, diagonal, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["upper"] = (upper if (
    issubclass(type(upper), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(upper, context=_ods_context))
    attributes["diagonal"] = (diagonal if (
    issubclass(type(diagonal), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(diagonal, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def upper(self):
    return self.operation.attributes["upper"]

  @upper.setter
  def upper(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["upper"] = value

  @builtins.property
  def diagonal(self):
    return self.operation.attributes["diagonal"]

  @diagonal.setter
  def diagonal(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["diagonal"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TupleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Tuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UnTupleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.UnTuple"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UnpackOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Unpack"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UnsqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Unsqueeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UpsampleOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Upsample"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale_h, scale_w, *, do_relu=None, relu_limit=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale_h"] = (scale_h if (
    issubclass(type(scale_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_h, context=_ods_context))
    attributes["scale_w"] = (scale_w if (
    issubclass(type(scale_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_w, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale_h(self):
    return self.operation.attributes["scale_h"]

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return self.operation.attributes["scale_w"]

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class VarianceOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Variance"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, reduce_list, correction, *, keep_dims=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reduce_list"] = (reduce_list if (
    issubclass(type(reduce_list), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(reduce_list, context=_ods_context))
    attributes["correction"] = (correction if (
    issubclass(type(correction), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(correction, context=_ods_context))
    if keep_dims is not None: attributes["keep_dims"] = (keep_dims if (
        issubclass(type(keep_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keep_dims, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def reduce_list(self):
    return self.operation.attributes["reduce_list"]

  @reduce_list.setter
  def reduce_list(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduce_list"] = value

  @builtins.property
  def correction(self):
    return self.operation.attributes["correction"]

  @correction.setter
  def correction(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["correction"] = value

  @builtins.property
  def keep_dims(self):
    return self.operation.attributes["keep_dims"]

  @keep_dims.setter
  def keep_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_dims"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ViewOp(_ods_ir.OpView):
  OPERATION_NAME = "top.View"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WeightOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Weight"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, *, scale=None, store_mode=None, allow_split=None, indices_idx=None, indices_slice=None, do_compress=None, bias0=None, bias1=None, is_signed=None, zero_guard=None, inline_bytes=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    if store_mode is not None: attributes["store_mode"] = (store_mode if (
        issubclass(type(store_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StoreModeAttr')) else
          _ods_ir.AttrBuilder.get('StoreModeAttr')(store_mode, context=_ods_context))
    if allow_split is not None: attributes["allow_split"] = (allow_split if (
        issubclass(type(allow_split), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(allow_split, context=_ods_context))
    if indices_idx is not None: attributes["indices_idx"] = (indices_idx if (
        issubclass(type(indices_idx), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(indices_idx, context=_ods_context))
    if indices_slice is not None: attributes["indices_slice"] = (indices_slice if (
        issubclass(type(indices_slice), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(indices_slice, context=_ods_context))
    if do_compress is not None: attributes["do_compress"] = (do_compress if (
        issubclass(type(do_compress), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_compress, context=_ods_context))
    if bias0 is not None: attributes["bias0"] = (bias0 if (
        issubclass(type(bias0), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(bias0, context=_ods_context))
    if bias1 is not None: attributes["bias1"] = (bias1 if (
        issubclass(type(bias1), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(bias1, context=_ods_context))
    if is_signed is not None: attributes["is_signed"] = (is_signed if (
        issubclass(type(is_signed), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_signed, context=_ods_context))
    if zero_guard is not None: attributes["zero_guard"] = (zero_guard if (
        issubclass(type(zero_guard), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(zero_guard, context=_ods_context))
    if inline_bytes is not None: attributes["inline_bytes"] = (inline_bytes if (
        issubclass(type(inline_bytes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(inline_bytes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def scale(self):
    if "scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is not None:
      self.operation.attributes["scale"] = value
    elif "scale" in self.operation.attributes:
      del self.operation.attributes["scale"]

  @scale.deleter
  def scale(self):
    del self.operation.attributes["scale"]

  @builtins.property
  def store_mode(self):
    if "store_mode" not in self.operation.attributes:
      return None
    return self.operation.attributes["store_mode"]

  @store_mode.setter
  def store_mode(self, value):
    if value is not None:
      self.operation.attributes["store_mode"] = value
    elif "store_mode" in self.operation.attributes:
      del self.operation.attributes["store_mode"]

  @store_mode.deleter
  def store_mode(self):
    del self.operation.attributes["store_mode"]

  @builtins.property
  def allow_split(self):
    if "allow_split" not in self.operation.attributes:
      return None
    return self.operation.attributes["allow_split"]

  @allow_split.setter
  def allow_split(self, value):
    if value is not None:
      self.operation.attributes["allow_split"] = value
    elif "allow_split" in self.operation.attributes:
      del self.operation.attributes["allow_split"]

  @allow_split.deleter
  def allow_split(self):
    del self.operation.attributes["allow_split"]

  @builtins.property
  def indices_idx(self):
    if "indices_idx" not in self.operation.attributes:
      return None
    return self.operation.attributes["indices_idx"]

  @indices_idx.setter
  def indices_idx(self, value):
    if value is not None:
      self.operation.attributes["indices_idx"] = value
    elif "indices_idx" in self.operation.attributes:
      del self.operation.attributes["indices_idx"]

  @indices_idx.deleter
  def indices_idx(self):
    del self.operation.attributes["indices_idx"]

  @builtins.property
  def indices_slice(self):
    if "indices_slice" not in self.operation.attributes:
      return None
    return self.operation.attributes["indices_slice"]

  @indices_slice.setter
  def indices_slice(self, value):
    if value is not None:
      self.operation.attributes["indices_slice"] = value
    elif "indices_slice" in self.operation.attributes:
      del self.operation.attributes["indices_slice"]

  @indices_slice.deleter
  def indices_slice(self):
    del self.operation.attributes["indices_slice"]

  @builtins.property
  def do_compress(self):
    if "do_compress" not in self.operation.attributes:
      return None
    return self.operation.attributes["do_compress"]

  @do_compress.setter
  def do_compress(self, value):
    if value is not None:
      self.operation.attributes["do_compress"] = value
    elif "do_compress" in self.operation.attributes:
      del self.operation.attributes["do_compress"]

  @do_compress.deleter
  def do_compress(self):
    del self.operation.attributes["do_compress"]

  @builtins.property
  def bias0(self):
    if "bias0" not in self.operation.attributes:
      return None
    return self.operation.attributes["bias0"]

  @bias0.setter
  def bias0(self, value):
    if value is not None:
      self.operation.attributes["bias0"] = value
    elif "bias0" in self.operation.attributes:
      del self.operation.attributes["bias0"]

  @bias0.deleter
  def bias0(self):
    del self.operation.attributes["bias0"]

  @builtins.property
  def bias1(self):
    if "bias1" not in self.operation.attributes:
      return None
    return self.operation.attributes["bias1"]

  @bias1.setter
  def bias1(self, value):
    if value is not None:
      self.operation.attributes["bias1"] = value
    elif "bias1" in self.operation.attributes:
      del self.operation.attributes["bias1"]

  @bias1.deleter
  def bias1(self):
    del self.operation.attributes["bias1"]

  @builtins.property
  def is_signed(self):
    if "is_signed" not in self.operation.attributes:
      return None
    return self.operation.attributes["is_signed"]

  @is_signed.setter
  def is_signed(self, value):
    if value is not None:
      self.operation.attributes["is_signed"] = value
    elif "is_signed" in self.operation.attributes:
      del self.operation.attributes["is_signed"]

  @is_signed.deleter
  def is_signed(self):
    del self.operation.attributes["is_signed"]

  @builtins.property
  def zero_guard(self):
    if "zero_guard" not in self.operation.attributes:
      return None
    return self.operation.attributes["zero_guard"]

  @zero_guard.setter
  def zero_guard(self, value):
    if value is not None:
      self.operation.attributes["zero_guard"] = value
    elif "zero_guard" in self.operation.attributes:
      del self.operation.attributes["zero_guard"]

  @zero_guard.deleter
  def zero_guard(self):
    del self.operation.attributes["zero_guard"]

  @builtins.property
  def inline_bytes(self):
    if "inline_bytes" not in self.operation.attributes:
      return None
    return self.operation.attributes["inline_bytes"]

  @inline_bytes.setter
  def inline_bytes(self, value):
    if value is not None:
      self.operation.attributes["inline_bytes"] = value
    elif "inline_bytes" in self.operation.attributes:
      del self.operation.attributes["inline_bytes"]

  @inline_bytes.deleter
  def inline_bytes(self):
    del self.operation.attributes["inline_bytes"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WeightReorderOp(_ods_ir.OpView):
  OPERATION_NAME = "top.WeightReorder"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, reorder_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if reorder_mode is not None: attributes["reorder_mode"] = (reorder_mode if (
        issubclass(type(reorder_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(reorder_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def reorder_mode(self):
    return self.operation.attributes["reorder_mode"]

  @reorder_mode.setter
  def reorder_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reorder_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WhereOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Where"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, cond, tbrn, fbrn, *, x_is_const=None, y_is_const=None, x_const_val=None, y_const_val=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    operands.append(_get_op_result_or_value(tbrn))
    operands.append(_get_op_result_or_value(fbrn))
    _ods_context = _ods_get_default_loc_context(loc)
    if x_is_const is not None: attributes["x_is_const"] = (x_is_const if (
        issubclass(type(x_is_const), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(x_is_const, context=_ods_context))
    if y_is_const is not None: attributes["y_is_const"] = (y_is_const if (
        issubclass(type(y_is_const), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(y_is_const, context=_ods_context))
    if x_const_val is not None: attributes["x_const_val"] = (x_const_val if (
        issubclass(type(x_const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(x_const_val, context=_ods_context))
    if y_const_val is not None: attributes["y_const_val"] = (y_const_val if (
        issubclass(type(y_const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(y_const_val, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def tbrn(self):
    return self.operation.operands[1]

  @builtins.property
  def fbrn(self):
    return self.operation.operands[2]

  @builtins.property
  def x_is_const(self):
    return self.operation.attributes["x_is_const"]

  @x_is_const.setter
  def x_is_const(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["x_is_const"] = value

  @builtins.property
  def y_is_const(self):
    return self.operation.attributes["y_is_const"]

  @y_is_const.setter
  def y_is_const(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_is_const"] = value

  @builtins.property
  def x_const_val(self):
    return self.operation.attributes["x_const_val"]

  @x_const_val.setter
  def x_const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["x_const_val"] = value

  @builtins.property
  def y_const_val(self):
    return self.operation.attributes["y_const_val"]

  @y_const_val.setter
  def y_const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_const_val"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class YoloDetectionOp(_ods_ir.OpView):
  OPERATION_NAME = "top.YoloDetection"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, net_input_h, net_input_w, nms_threshold, obj_threshold, keep_topk, anchors, version, *, class_num=None, num_boxes=None, agnostic_nms=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["net_input_h"] = (net_input_h if (
    issubclass(type(net_input_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_h, context=_ods_context))
    attributes["net_input_w"] = (net_input_w if (
    issubclass(type(net_input_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_w, context=_ods_context))
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["obj_threshold"] = (obj_threshold if (
    issubclass(type(obj_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(obj_threshold, context=_ods_context))
    attributes["keep_topk"] = (keep_topk if (
    issubclass(type(keep_topk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_topk, context=_ods_context))
    attributes["anchors"] = (anchors if (
    issubclass(type(anchors), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(anchors, context=_ods_context))
    attributes["version"] = (version if (
    issubclass(type(version), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('YoloVersionAttr')) else
      _ods_ir.AttrBuilder.get('YoloVersionAttr')(version, context=_ods_context))
    if class_num is not None: attributes["class_num"] = (class_num if (
        issubclass(type(class_num), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(class_num, context=_ods_context))
    if num_boxes is not None: attributes["num_boxes"] = (num_boxes if (
        issubclass(type(num_boxes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(num_boxes, context=_ods_context))
    if agnostic_nms is not None: attributes["agnostic_nms"] = (agnostic_nms if (
        issubclass(type(agnostic_nms), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(agnostic_nms, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def net_input_h(self):
    return self.operation.attributes["net_input_h"]

  @net_input_h.setter
  def net_input_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_h"] = value

  @builtins.property
  def net_input_w(self):
    return self.operation.attributes["net_input_w"]

  @net_input_w.setter
  def net_input_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_w"] = value

  @builtins.property
  def nms_threshold(self):
    return self.operation.attributes["nms_threshold"]

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def obj_threshold(self):
    return self.operation.attributes["obj_threshold"]

  @obj_threshold.setter
  def obj_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["obj_threshold"] = value

  @builtins.property
  def keep_topk(self):
    return self.operation.attributes["keep_topk"]

  @keep_topk.setter
  def keep_topk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_topk"] = value

  @builtins.property
  def anchors(self):
    return self.operation.attributes["anchors"]

  @anchors.setter
  def anchors(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchors"] = value

  @builtins.property
  def version(self):
    return self.operation.attributes["version"]

  @version.setter
  def version(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["version"] = value

  @builtins.property
  def class_num(self):
    return self.operation.attributes["class_num"]

  @class_num.setter
  def class_num(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["class_num"] = value

  @builtins.property
  def num_boxes(self):
    return self.operation.attributes["num_boxes"]

  @num_boxes.setter
  def num_boxes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_boxes"] = value

  @builtins.property
  def agnostic_nms(self):
    return self.operation.attributes["agnostic_nms"]

  @agnostic_nms.setter
  def agnostic_nms(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["agnostic_nms"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Yuv2rgbFormulaOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Yuv2rgbFormula"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, YUV, src_format, dst_format, image_format, formula_mode, *, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(YUV))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["src_format"] = (src_format if (
    issubclass(type(src_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('UI32Attr')) else
      _ods_ir.AttrBuilder.get('UI32Attr')(src_format, context=_ods_context))
    attributes["dst_format"] = (dst_format if (
    issubclass(type(dst_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('UI32Attr')) else
      _ods_ir.AttrBuilder.get('UI32Attr')(dst_format, context=_ods_context))
    attributes["image_format"] = (image_format if (
    issubclass(type(image_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ImageOutFormatAttr')) else
      _ods_ir.AttrBuilder.get('ImageOutFormatAttr')(image_format, context=_ods_context))
    attributes["formula_mode"] = (formula_mode if (
    issubclass(type(formula_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Yuv2rgbFormulaAttr')) else
      _ods_ir.AttrBuilder.get('Yuv2rgbFormulaAttr')(formula_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def YUV(self):
    return self.operation.operands[0]

  @builtins.property
  def src_format(self):
    return self.operation.attributes["src_format"]

  @src_format.setter
  def src_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["src_format"] = value

  @builtins.property
  def dst_format(self):
    return self.operation.attributes["dst_format"]

  @dst_format.setter
  def dst_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dst_format"] = value

  @builtins.property
  def image_format(self):
    return self.operation.attributes["image_format"]

  @image_format.setter
  def image_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["image_format"] = value

  @builtins.property
  def formula_mode(self):
    return self.operation.attributes["formula_mode"]

  @formula_mode.setter
  def formula_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formula_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BinaryConstShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "top.BinaryConstShift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, mode, shift, *, is_reverse=None, saturation=None, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(scale, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BinaryShiftAttr')) else
      _ods_ir.AttrBuilder.get('BinaryShiftAttr')(mode, context=_ods_context))
    attributes["shift"] = (shift if (
    issubclass(type(shift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(shift, context=_ods_context))
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if saturation is not None: attributes["saturation"] = (saturation if (
        issubclass(type(saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturation, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def shift(self):
    return self.operation.attributes["shift"]

  @shift.setter
  def shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shift"] = value

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def saturation(self):
    return self.operation.attributes["saturation"]

  @saturation.setter
  def saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturation"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BinaryShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "top.BinaryShift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, mode, shift, *, is_reverse=None, saturation=None, round_mode=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BinaryShiftAttr')) else
      _ods_ir.AttrBuilder.get('BinaryShiftAttr')(mode, context=_ods_context))
    attributes["shift"] = (shift if (
    issubclass(type(shift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(shift, context=_ods_context))
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if saturation is not None: attributes["saturation"] = (saturation if (
        issubclass(type(saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturation, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(round_mode, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def shift(self):
    return self.operation.attributes["shift"]

  @shift.setter
  def shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shift"] = value

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def saturation(self):
    return self.operation.attributes["saturation"]

  @saturation.setter
  def saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturation"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RopeOp(_ods_ir.OpView):
  OPERATION_NAME = "top.Rope"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, input3, *, is_permute_optimize=None, mul1_round_mode=None, mul2_round_mode=None, add_round_mode=None, mul1_shift=None, mul2_shift=None, add_shift=None, mul1_saturation=None, mul2_saturation=None, add_saturation=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    operands.append(_get_op_result_or_value(input3))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_permute_optimize is not None: attributes["is_permute_optimize"] = (is_permute_optimize if (
        issubclass(type(is_permute_optimize), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_permute_optimize, context=_ods_context))
    if mul1_round_mode is not None: attributes["mul1_round_mode"] = (mul1_round_mode if (
        issubclass(type(mul1_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(mul1_round_mode, context=_ods_context))
    if mul2_round_mode is not None: attributes["mul2_round_mode"] = (mul2_round_mode if (
        issubclass(type(mul2_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(mul2_round_mode, context=_ods_context))
    if add_round_mode is not None: attributes["add_round_mode"] = (add_round_mode if (
        issubclass(type(add_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('RoundModeAttr')(add_round_mode, context=_ods_context))
    if mul1_shift is not None: attributes["mul1_shift"] = (mul1_shift if (
        issubclass(type(mul1_shift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(mul1_shift, context=_ods_context))
    if mul2_shift is not None: attributes["mul2_shift"] = (mul2_shift if (
        issubclass(type(mul2_shift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(mul2_shift, context=_ods_context))
    if add_shift is not None: attributes["add_shift"] = (add_shift if (
        issubclass(type(add_shift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(add_shift, context=_ods_context))
    if mul1_saturation is not None: attributes["mul1_saturation"] = (mul1_saturation if (
        issubclass(type(mul1_saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(mul1_saturation, context=_ods_context))
    if mul2_saturation is not None: attributes["mul2_saturation"] = (mul2_saturation if (
        issubclass(type(mul2_saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(mul2_saturation, context=_ods_context))
    if add_saturation is not None: attributes["add_saturation"] = (add_saturation if (
        issubclass(type(add_saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(add_saturation, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def input3(self):
    return self.operation.operands[2]

  @builtins.property
  def is_permute_optimize(self):
    return self.operation.attributes["is_permute_optimize"]

  @is_permute_optimize.setter
  def is_permute_optimize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_permute_optimize"] = value

  @builtins.property
  def mul1_round_mode(self):
    return self.operation.attributes["mul1_round_mode"]

  @mul1_round_mode.setter
  def mul1_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul1_round_mode"] = value

  @builtins.property
  def mul2_round_mode(self):
    return self.operation.attributes["mul2_round_mode"]

  @mul2_round_mode.setter
  def mul2_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul2_round_mode"] = value

  @builtins.property
  def add_round_mode(self):
    return self.operation.attributes["add_round_mode"]

  @add_round_mode.setter
  def add_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["add_round_mode"] = value

  @builtins.property
  def mul1_shift(self):
    return self.operation.attributes["mul1_shift"]

  @mul1_shift.setter
  def mul1_shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul1_shift"] = value

  @builtins.property
  def mul2_shift(self):
    return self.operation.attributes["mul2_shift"]

  @mul2_shift.setter
  def mul2_shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul2_shift"] = value

  @builtins.property
  def add_shift(self):
    return self.operation.attributes["add_shift"]

  @add_shift.setter
  def add_shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["add_shift"] = value

  @builtins.property
  def mul1_saturation(self):
    return self.operation.attributes["mul1_saturation"]

  @mul1_saturation.setter
  def mul1_saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul1_saturation"] = value

  @builtins.property
  def mul2_saturation(self):
    return self.operation.attributes["mul2_saturation"]

  @mul2_saturation.setter
  def mul2_saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul2_saturation"] = value

  @builtins.property
  def add_saturation(self):
    return self.operation.attributes["add_saturation"]

  @add_saturation.setter
  def add_saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["add_saturation"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]
