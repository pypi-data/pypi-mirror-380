
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _tpu_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "tpu"
  pass


@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SwapChannelOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.SwapChannel"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, channel_order, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(channel_order, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SwapDimInnerOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.SwapDimInner"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, offset, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(offset, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class A16MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.A16MatMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, scale, zp, bias, weight_bits, *, sign=None, w_transpose=None, q_group_size=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(scale))
    operands.append(_get_op_result_or_value(zp))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["weight_bits"] = (weight_bits if (
    issubclass(type(weight_bits), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(weight_bits, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    if w_transpose is not None: attributes["w_transpose"] = (w_transpose if (
        issubclass(type(w_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(w_transpose, context=_ods_context))
    if q_group_size is not None: attributes["q_group_size"] = (q_group_size if (
        issubclass(type(q_group_size), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(q_group_size, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def scale(self):
    return self.operation.operands[2]

  @builtins.property
  def zp(self):
    return self.operation.operands[3]

  @builtins.property
  def bias(self):
    return self.operation.operands[4]

  @builtins.property
  def weight_bits(self):
    return self.operation.attributes["weight_bits"]

  @weight_bits.setter
  def weight_bits(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weight_bits"] = value

  @builtins.property
  def sign(self):
    return self.operation.attributes["sign"]

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def w_transpose(self):
    return self.operation.attributes["w_transpose"]

  @w_transpose.setter
  def w_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["w_transpose"] = value

  @builtins.property
  def q_group_size(self):
    return self.operation.attributes["q_group_size"]

  @q_group_size.setter
  def q_group_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["q_group_size"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ActiveOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Active"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mode, *, coeffs=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_ActiveModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_ActiveModeAttr')(mode, context=_ods_context))
    if coeffs is not None: attributes["coeffs"] = (coeffs if (
        issubclass(type(coeffs), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeffs, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def coeffs(self):
    if "coeffs" not in self.operation.attributes:
      return None
    return self.operation.attributes["coeffs"]

  @coeffs.setter
  def coeffs(self, value):
    if value is not None:
      self.operation.attributes["coeffs"] = value
    elif "coeffs" in self.operation.attributes:
      del self.operation.attributes["coeffs"]

  @coeffs.deleter
  def coeffs(self):
    del self.operation.attributes["coeffs"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AddConstOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.AddConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, do_relu=None, relu_limit=None, multiplier=None, rshift=None, f8_scale=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if f8_scale is not None: attributes["f8_scale"] = (f8_scale if (
        issubclass(type(f8_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(f8_scale, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def f8_scale(self):
    return self.operation.attributes["f8_scale"]

  @f8_scale.setter
  def f8_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["f8_scale"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AddOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Add"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, coeff=None, do_early_stride=None, early_stride_h=None, early_stride_w=None, multipliers=None, rshifts=None, f8_scales=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if coeff is not None: attributes["coeff"] = (coeff if (
        issubclass(type(coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeff, context=_ods_context))
    if do_early_stride is not None: attributes["do_early_stride"] = (do_early_stride if (
        issubclass(type(do_early_stride), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_early_stride, context=_ods_context))
    if early_stride_h is not None: attributes["early_stride_h"] = (early_stride_h if (
        issubclass(type(early_stride_h), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(early_stride_h, context=_ods_context))
    if early_stride_w is not None: attributes["early_stride_w"] = (early_stride_w if (
        issubclass(type(early_stride_w), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(early_stride_w, context=_ods_context))
    if multipliers is not None: attributes["multipliers"] = (multipliers if (
        issubclass(type(multipliers), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multipliers, context=_ods_context))
    if rshifts is not None: attributes["rshifts"] = (rshifts if (
        issubclass(type(rshifts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshifts, context=_ods_context))
    if f8_scales is not None: attributes["f8_scales"] = (f8_scales if (
        issubclass(type(f8_scales), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(f8_scales, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def coeff(self):
    if "coeff" not in self.operation.attributes:
      return None
    return self.operation.attributes["coeff"]

  @coeff.setter
  def coeff(self, value):
    if value is not None:
      self.operation.attributes["coeff"] = value
    elif "coeff" in self.operation.attributes:
      del self.operation.attributes["coeff"]

  @coeff.deleter
  def coeff(self):
    del self.operation.attributes["coeff"]

  @builtins.property
  def do_early_stride(self):
    if "do_early_stride" not in self.operation.attributes:
      return None
    return self.operation.attributes["do_early_stride"]

  @do_early_stride.setter
  def do_early_stride(self, value):
    if value is not None:
      self.operation.attributes["do_early_stride"] = value
    elif "do_early_stride" in self.operation.attributes:
      del self.operation.attributes["do_early_stride"]

  @do_early_stride.deleter
  def do_early_stride(self):
    del self.operation.attributes["do_early_stride"]

  @builtins.property
  def early_stride_h(self):
    if "early_stride_h" not in self.operation.attributes:
      return None
    return self.operation.attributes["early_stride_h"]

  @early_stride_h.setter
  def early_stride_h(self, value):
    if value is not None:
      self.operation.attributes["early_stride_h"] = value
    elif "early_stride_h" in self.operation.attributes:
      del self.operation.attributes["early_stride_h"]

  @early_stride_h.deleter
  def early_stride_h(self):
    del self.operation.attributes["early_stride_h"]

  @builtins.property
  def early_stride_w(self):
    if "early_stride_w" not in self.operation.attributes:
      return None
    return self.operation.attributes["early_stride_w"]

  @early_stride_w.setter
  def early_stride_w(self, value):
    if value is not None:
      self.operation.attributes["early_stride_w"] = value
    elif "early_stride_w" in self.operation.attributes:
      del self.operation.attributes["early_stride_w"]

  @early_stride_w.deleter
  def early_stride_w(self):
    del self.operation.attributes["early_stride_w"]

  @builtins.property
  def multipliers(self):
    if "multipliers" not in self.operation.attributes:
      return None
    return self.operation.attributes["multipliers"]

  @multipliers.setter
  def multipliers(self, value):
    if value is not None:
      self.operation.attributes["multipliers"] = value
    elif "multipliers" in self.operation.attributes:
      del self.operation.attributes["multipliers"]

  @multipliers.deleter
  def multipliers(self):
    del self.operation.attributes["multipliers"]

  @builtins.property
  def rshifts(self):
    if "rshifts" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshifts"]

  @rshifts.setter
  def rshifts(self, value):
    if value is not None:
      self.operation.attributes["rshifts"] = value
    elif "rshifts" in self.operation.attributes:
      del self.operation.attributes["rshifts"]

  @rshifts.deleter
  def rshifts(self):
    del self.operation.attributes["rshifts"]

  @builtins.property
  def f8_scales(self):
    if "f8_scales" not in self.operation.attributes:
      return None
    return self.operation.attributes["f8_scales"]

  @f8_scales.setter
  def f8_scales(self, value):
    if value is not None:
      self.operation.attributes["f8_scales"] = value
    elif "f8_scales" in self.operation.attributes:
      del self.operation.attributes["f8_scales"]

  @f8_scales.deleter
  def f8_scales(self):
    del self.operation.attributes["f8_scales"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ArgOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Arg"

  _ODS_REGIONS = (0, True)

  def __init__(self, indices, values, input, axis, keepdims, mode, *, select_last_index=None, use_int_input=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    attributes["keepdims"] = (keepdims if (
    issubclass(type(keepdims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArgModeAttr')) else
      _ods_ir.AttrBuilder.get('ArgModeAttr')(mode, context=_ods_context))
    if select_last_index is not None: attributes["select_last_index"] = (select_last_index if (
        issubclass(type(select_last_index), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(select_last_index, context=_ods_context))
    if use_int_input is not None: attributes["use_int_input"] = (use_int_input if (
        issubclass(type(use_int_input), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_int_input, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(indices)
    results.append(values)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def select_last_index(self):
    return self.operation.attributes["select_last_index"]

  @select_last_index.setter
  def select_last_index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["select_last_index"] = value

  @builtins.property
  def use_int_input(self):
    return self.operation.attributes["use_int_input"]

  @use_int_input.setter
  def use_int_input(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_int_input"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def indices(self):
    return self.operation.results[0]

  @builtins.property
  def values(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Attention"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, keys, values, queries_weight, queries_bias, keys_weight, keys_bias, values_weight, values_bias, out_weight, out_bias, mask, table, scale, head, dim, *, quant_param=None, has_bias=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(keys))
    operands.append(_get_op_result_or_value(values))
    operands.append(_get_op_result_or_value(queries_weight))
    operands.append(_get_op_result_or_value(queries_bias))
    operands.append(_get_op_result_or_value(keys_weight))
    operands.append(_get_op_result_or_value(keys_bias))
    operands.append(_get_op_result_or_value(values_weight))
    operands.append(_get_op_result_or_value(values_bias))
    operands.append(_get_op_result_or_value(out_weight))
    operands.append(_get_op_result_or_value(out_bias))
    operands.append(_get_op_result_or_value(mask))
    operands.append(_get_op_result_or_value(table))
    _ods_context = _ods_get_default_loc_context(loc)
    if quant_param is not None: attributes["quant_param"] = (quant_param if (
        issubclass(type(quant_param), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(quant_param, context=_ods_context))
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    attributes["head"] = (head if (
    issubclass(type(head), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(head, context=_ods_context))
    attributes["dim"] = (dim if (
    issubclass(type(dim), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    if has_bias is not None: attributes["has_bias"] = (has_bias if (
        issubclass(type(has_bias), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(has_bias, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def keys(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def queries_weight(self):
    return self.operation.operands[3]

  @builtins.property
  def queries_bias(self):
    return self.operation.operands[4]

  @builtins.property
  def keys_weight(self):
    return self.operation.operands[5]

  @builtins.property
  def keys_bias(self):
    return self.operation.operands[6]

  @builtins.property
  def values_weight(self):
    return self.operation.operands[7]

  @builtins.property
  def values_bias(self):
    return self.operation.operands[8]

  @builtins.property
  def out_weight(self):
    return self.operation.operands[9]

  @builtins.property
  def out_bias(self):
    return self.operation.operands[10]

  @builtins.property
  def mask(self):
    return self.operation.operands[11]

  @builtins.property
  def table(self):
    return self.operation.operands[12]

  @builtins.property
  def quant_param(self):
    return self.operation.attributes["quant_param"]

  @quant_param.setter
  def quant_param(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_param"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def head(self):
    return self.operation.attributes["head"]

  @head.setter
  def head(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["head"] = value

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def has_bias(self):
    return self.operation.attributes["has_bias"]

  @has_bias.setter
  def has_bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["has_bias"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class AutoIncreaseOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.AutoIncrease"

  _ODS_REGIONS = (0, True)

  def __init__(self, input, const_val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Batch2SpaceOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Batch2Space"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, block_h, block_w, crops, buffer, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["block_h"] = (block_h if (
    issubclass(type(block_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_h, context=_ods_context))
    attributes["block_w"] = (block_w if (
    issubclass(type(block_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_w, context=_ods_context))
    attributes["crops"] = (crops if (
    issubclass(type(crops), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(crops, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def block_h(self):
    return self.operation.attributes["block_h"]

  @block_h.setter
  def block_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_h"] = value

  @builtins.property
  def block_w(self):
    return self.operation.attributes["block_w"]

  @block_w.setter
  def block_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_w"] = value

  @builtins.property
  def crops(self):
    return self.operation.attributes["crops"]

  @crops.setter
  def crops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["crops"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BatchNormBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.BatchNormBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_in, weight_grad, bias_grad, grad_out, input, weight_opt, saved_mean, saved_invstd, buffer, *, epsilon=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_out))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight_opt))
    operands.append(_get_op_result_or_value(saved_mean))
    operands.append(_get_op_result_or_value(saved_invstd))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if epsilon is not None: attributes["epsilon"] = (epsilon if (
        issubclass(type(epsilon), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(epsilon, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(grad_in)
    results.append(weight_grad)
    results.append(bias_grad)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def weight_opt(self):
    return self.operation.operands[2]

  @builtins.property
  def saved_mean(self):
    return self.operation.operands[3]

  @builtins.property
  def saved_invstd(self):
    return self.operation.operands[4]

  @builtins.property
  def buffer(self):
    return self.operation.operands[5]

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def grad_in(self):
    return self.operation.results[0]

  @builtins.property
  def weight_grad(self):
    return self.operation.results[1]

  @builtins.property
  def bias_grad(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BatchNormTrainOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.BatchNormTrain"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mean_out, saved_invstd, running_mean, running_var, input, mean, var, gamma, beta, running_status_buffer, *, do_relu=None, epsilon=None, momentum=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(var))
    operands.append(_get_op_result_or_value(gamma))
    operands.append(_get_op_result_or_value(beta))
    operands.append(_get_op_result_or_value(running_status_buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if epsilon is not None: attributes["epsilon"] = (epsilon if (
        issubclass(type(epsilon), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(epsilon, context=_ods_context))
    if momentum is not None: attributes["momentum"] = (momentum if (
        issubclass(type(momentum), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(momentum, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    results.append(mean_out)
    results.append(saved_invstd)
    results.append(running_mean)
    results.append(running_var)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mean(self):
    return self.operation.operands[1]

  @builtins.property
  def var(self):
    return self.operation.operands[2]

  @builtins.property
  def gamma(self):
    return self.operation.operands[3]

  @builtins.property
  def beta(self):
    return self.operation.operands[4]

  @builtins.property
  def running_status_buffer(self):
    return self.operation.operands[5]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def momentum(self):
    return self.operation.attributes["momentum"]

  @momentum.setter
  def momentum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["momentum"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mean_out(self):
    return self.operation.results[1]

  @builtins.property
  def saved_invstd(self):
    return self.operation.results[2]

  @builtins.property
  def running_mean(self):
    return self.operation.results[3]

  @builtins.property
  def running_var(self):
    return self.operation.results[4]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BinaryConstShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.BinaryConstShift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, mode, shift, *, is_reverse=None, saturation=None, round_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(scale, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BinaryShiftAttr')) else
      _ods_ir.AttrBuilder.get('BinaryShiftAttr')(mode, context=_ods_context))
    attributes["shift"] = (shift if (
    issubclass(type(shift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(shift, context=_ods_context))
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if saturation is not None: attributes["saturation"] = (saturation if (
        issubclass(type(saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturation, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def shift(self):
    return self.operation.attributes["shift"]

  @shift.setter
  def shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shift"] = value

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def saturation(self):
    return self.operation.attributes["saturation"]

  @saturation.setter
  def saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturation"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BinaryShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.BinaryShift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, mode, shift, *, is_reverse=None, saturation=None, round_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BinaryShiftAttr')) else
      _ods_ir.AttrBuilder.get('BinaryShiftAttr')(mode, context=_ods_context))
    attributes["shift"] = (shift if (
    issubclass(type(shift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(shift, context=_ods_context))
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if saturation is not None: attributes["saturation"] = (saturation if (
        issubclass(type(saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(saturation, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def shift(self):
    return self.operation.attributes["shift"]

  @shift.setter
  def shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shift"] = value

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def saturation(self):
    return self.operation.attributes["saturation"]

  @saturation.setter
  def saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["saturation"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BufferOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, *, buffer_type=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if buffer_type is not None: attributes["buffer_type"] = (buffer_type if (
        issubclass(type(buffer_type), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_BufferTypeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_BufferTypeAttr')(buffer_type, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def buffer_type(self):
    return self.operation.attributes["buffer_type"]

  @buffer_type.setter
  def buffer_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["buffer_type"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CastAddOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.CastAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CastOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra_input=None, ginfo=None, with_scale=None, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if extra_input is not None: attributes["extra_input"] = (extra_input if (
        issubclass(type(extra_input), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(extra_input, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if with_scale is not None: attributes["with_scale"] = (with_scale if (
        issubclass(type(with_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(with_scale, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def extra_input(self):
    if "extra_input" not in self.operation.attributes:
      return None
    return self.operation.attributes["extra_input"]

  @extra_input.setter
  def extra_input(self, value):
    if value is not None:
      self.operation.attributes["extra_input"] = value
    elif "extra_input" in self.operation.attributes:
      del self.operation.attributes["extra_input"]

  @extra_input.deleter
  def extra_input(self):
    del self.operation.attributes["extra_input"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def with_scale(self):
    return self.operation.attributes["with_scale"]

  @with_scale.setter
  def with_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["with_scale"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ClipOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Clip"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, min, max, *, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min"] = (min if (
    issubclass(type(min), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(min, context=_ods_context))
    attributes["max"] = (max if (
    issubclass(type(max), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(max, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.attributes["min"]

  @min.setter
  def min(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min"] = value

  @builtins.property
  def max(self):
    return self.operation.attributes["max"]

  @max.setter
  def max(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CompareConstOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.CompareConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mode, const_val, inversed, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CompareModeAttr')) else
      _ods_ir.AttrBuilder.get('CompareModeAttr')(mode, context=_ods_context))
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    attributes["inversed"] = (inversed if (
    issubclass(type(inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inversed, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def inversed(self):
    return self.operation.attributes["inversed"]

  @inversed.setter
  def inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inversed"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CompareOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Compare"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, lhs, rhs, mode, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(lhs))
    operands.append(_get_op_result_or_value(rhs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('CompareModeAttr')) else
      _ods_ir.AttrBuilder.get('CompareModeAttr')(mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConcatOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, axis, *, only_merge=None, multipliers=None, rshifts=None, do_relu=None, relu_limit=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if only_merge is not None: attributes["only_merge"] = (only_merge if (
        issubclass(type(only_merge), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(only_merge, context=_ods_context))
    if multipliers is not None: attributes["multipliers"] = (multipliers if (
        issubclass(type(multipliers), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multipliers, context=_ods_context))
    if rshifts is not None: attributes["rshifts"] = (rshifts if (
        issubclass(type(rshifts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshifts, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def only_merge(self):
    return self.operation.attributes["only_merge"]

  @only_merge.setter
  def only_merge(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["only_merge"] = value

  @builtins.property
  def multipliers(self):
    if "multipliers" not in self.operation.attributes:
      return None
    return self.operation.attributes["multipliers"]

  @multipliers.setter
  def multipliers(self, value):
    if value is not None:
      self.operation.attributes["multipliers"] = value
    elif "multipliers" in self.operation.attributes:
      del self.operation.attributes["multipliers"]

  @multipliers.deleter
  def multipliers(self):
    del self.operation.attributes["multipliers"]

  @builtins.property
  def rshifts(self):
    if "rshifts" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshifts"]

  @rshifts.setter
  def rshifts(self, value):
    if value is not None:
      self.operation.attributes["rshifts"] = value
    elif "rshifts" in self.operation.attributes:
      del self.operation.attributes["rshifts"]

  @rshifts.deleter
  def rshifts(self):
    del self.operation.attributes["rshifts"]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConstantFillOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ConstantFill"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, value, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    issubclass(type(value), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(value, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Conv2DOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Conv2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, kernel_shape, strides, pads, with_bias, *, group=None, dilations=None, inserts=None, do_kernel_rotate=None, do_relu=None, relu_limit=None, weight_is_coeff=None, coeff_merged=None, use_3ic_optimize=None, kernel_zp=None, use_winograd=None, multiplier=None, rshift=None, weight_bits=None, quant_mode=None, round_mode=None, ginfo=None, do_leaky_relu=None, neg_slope=None, multiplier_pos=None, multiplier_neg=None, rshift_pos=None, rshift_neg=None, out_f8_scales=None, support_compress=None, compress_info=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if inserts is not None: attributes["inserts"] = (inserts if (
        issubclass(type(inserts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(inserts, context=_ods_context))
    if do_kernel_rotate is not None: attributes["do_kernel_rotate"] = (do_kernel_rotate if (
        issubclass(type(do_kernel_rotate), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_kernel_rotate, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    attributes["with_bias"] = (with_bias if (
    issubclass(type(with_bias), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(with_bias, context=_ods_context))
    if weight_is_coeff is not None: attributes["weight_is_coeff"] = (weight_is_coeff if (
        issubclass(type(weight_is_coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(weight_is_coeff, context=_ods_context))
    if coeff_merged is not None: attributes["coeff_merged"] = (coeff_merged if (
        issubclass(type(coeff_merged), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(coeff_merged, context=_ods_context))
    if use_3ic_optimize is not None: attributes["use_3ic_optimize"] = (use_3ic_optimize if (
        issubclass(type(use_3ic_optimize), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(use_3ic_optimize, context=_ods_context))
    if kernel_zp is not None: attributes["kernel_zp"] = (kernel_zp if (
        issubclass(type(kernel_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(kernel_zp, context=_ods_context))
    if use_winograd is not None: attributes["use_winograd"] = (use_winograd if (
        issubclass(type(use_winograd), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(use_winograd, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshift, context=_ods_context))
    if weight_bits is not None: attributes["weight_bits"] = (weight_bits if (
        issubclass(type(weight_bits), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(weight_bits, context=_ods_context))
    if quant_mode is not None: attributes["quant_mode"] = (quant_mode if (
        issubclass(type(quant_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if do_leaky_relu is not None: attributes["do_leaky_relu"] = (do_leaky_relu if (
        issubclass(type(do_leaky_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_leaky_relu, context=_ods_context))
    if neg_slope is not None: attributes["neg_slope"] = (neg_slope if (
        issubclass(type(neg_slope), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(neg_slope, context=_ods_context))
    if multiplier_pos is not None: attributes["multiplier_pos"] = (multiplier_pos if (
        issubclass(type(multiplier_pos), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier_pos, context=_ods_context))
    if multiplier_neg is not None: attributes["multiplier_neg"] = (multiplier_neg if (
        issubclass(type(multiplier_neg), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier_neg, context=_ods_context))
    if rshift_pos is not None: attributes["rshift_pos"] = (rshift_pos if (
        issubclass(type(rshift_pos), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift_pos, context=_ods_context))
    if rshift_neg is not None: attributes["rshift_neg"] = (rshift_neg if (
        issubclass(type(rshift_neg), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift_neg, context=_ods_context))
    if out_f8_scales is not None: attributes["out_f8_scales"] = (out_f8_scales if (
        issubclass(type(out_f8_scales), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(out_f8_scales, context=_ods_context))
    if support_compress is not None: attributes["support_compress"] = (support_compress if (
        issubclass(type(support_compress), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(support_compress, context=_ods_context))
    if compress_info is not None: attributes["compress_info"] = (compress_info if (
        issubclass(type(compress_info), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_CompressAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_CompressAttr')(compress_info, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def dilations(self):
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def inserts(self):
    if "inserts" not in self.operation.attributes:
      return None
    return self.operation.attributes["inserts"]

  @inserts.setter
  def inserts(self, value):
    if value is not None:
      self.operation.attributes["inserts"] = value
    elif "inserts" in self.operation.attributes:
      del self.operation.attributes["inserts"]

  @inserts.deleter
  def inserts(self):
    del self.operation.attributes["inserts"]

  @builtins.property
  def do_kernel_rotate(self):
    if "do_kernel_rotate" not in self.operation.attributes:
      return None
    return self.operation.attributes["do_kernel_rotate"]

  @do_kernel_rotate.setter
  def do_kernel_rotate(self, value):
    if value is not None:
      self.operation.attributes["do_kernel_rotate"] = value
    elif "do_kernel_rotate" in self.operation.attributes:
      del self.operation.attributes["do_kernel_rotate"]

  @do_kernel_rotate.deleter
  def do_kernel_rotate(self):
    del self.operation.attributes["do_kernel_rotate"]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def with_bias(self):
    return self.operation.attributes["with_bias"]

  @with_bias.setter
  def with_bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["with_bias"] = value

  @builtins.property
  def weight_is_coeff(self):
    return self.operation.attributes["weight_is_coeff"]

  @weight_is_coeff.setter
  def weight_is_coeff(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weight_is_coeff"] = value

  @builtins.property
  def coeff_merged(self):
    return self.operation.attributes["coeff_merged"]

  @coeff_merged.setter
  def coeff_merged(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coeff_merged"] = value

  @builtins.property
  def use_3ic_optimize(self):
    return self.operation.attributes["use_3ic_optimize"]

  @use_3ic_optimize.setter
  def use_3ic_optimize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_3ic_optimize"] = value

  @builtins.property
  def kernel_zp(self):
    return self.operation.attributes["kernel_zp"]

  @kernel_zp.setter
  def kernel_zp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_zp"] = value

  @builtins.property
  def use_winograd(self):
    if "use_winograd" not in self.operation.attributes:
      return None
    return self.operation.attributes["use_winograd"]

  @use_winograd.setter
  def use_winograd(self, value):
    if value is not None:
      self.operation.attributes["use_winograd"] = value
    elif "use_winograd" in self.operation.attributes:
      del self.operation.attributes["use_winograd"]

  @use_winograd.deleter
  def use_winograd(self):
    del self.operation.attributes["use_winograd"]

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def weight_bits(self):
    if "weight_bits" not in self.operation.attributes:
      return None
    return self.operation.attributes["weight_bits"]

  @weight_bits.setter
  def weight_bits(self, value):
    if value is not None:
      self.operation.attributes["weight_bits"] = value
    elif "weight_bits" in self.operation.attributes:
      del self.operation.attributes["weight_bits"]

  @weight_bits.deleter
  def weight_bits(self):
    del self.operation.attributes["weight_bits"]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def do_leaky_relu(self):
    if "do_leaky_relu" not in self.operation.attributes:
      return None
    return self.operation.attributes["do_leaky_relu"]

  @do_leaky_relu.setter
  def do_leaky_relu(self, value):
    if value is not None:
      self.operation.attributes["do_leaky_relu"] = value
    elif "do_leaky_relu" in self.operation.attributes:
      del self.operation.attributes["do_leaky_relu"]

  @do_leaky_relu.deleter
  def do_leaky_relu(self):
    del self.operation.attributes["do_leaky_relu"]

  @builtins.property
  def neg_slope(self):
    if "neg_slope" not in self.operation.attributes:
      return None
    return self.operation.attributes["neg_slope"]

  @neg_slope.setter
  def neg_slope(self, value):
    if value is not None:
      self.operation.attributes["neg_slope"] = value
    elif "neg_slope" in self.operation.attributes:
      del self.operation.attributes["neg_slope"]

  @neg_slope.deleter
  def neg_slope(self):
    del self.operation.attributes["neg_slope"]

  @builtins.property
  def multiplier_pos(self):
    if "multiplier_pos" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier_pos"]

  @multiplier_pos.setter
  def multiplier_pos(self, value):
    if value is not None:
      self.operation.attributes["multiplier_pos"] = value
    elif "multiplier_pos" in self.operation.attributes:
      del self.operation.attributes["multiplier_pos"]

  @multiplier_pos.deleter
  def multiplier_pos(self):
    del self.operation.attributes["multiplier_pos"]

  @builtins.property
  def multiplier_neg(self):
    if "multiplier_neg" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier_neg"]

  @multiplier_neg.setter
  def multiplier_neg(self, value):
    if value is not None:
      self.operation.attributes["multiplier_neg"] = value
    elif "multiplier_neg" in self.operation.attributes:
      del self.operation.attributes["multiplier_neg"]

  @multiplier_neg.deleter
  def multiplier_neg(self):
    del self.operation.attributes["multiplier_neg"]

  @builtins.property
  def rshift_pos(self):
    if "rshift_pos" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift_pos"]

  @rshift_pos.setter
  def rshift_pos(self, value):
    if value is not None:
      self.operation.attributes["rshift_pos"] = value
    elif "rshift_pos" in self.operation.attributes:
      del self.operation.attributes["rshift_pos"]

  @rshift_pos.deleter
  def rshift_pos(self):
    del self.operation.attributes["rshift_pos"]

  @builtins.property
  def rshift_neg(self):
    if "rshift_neg" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift_neg"]

  @rshift_neg.setter
  def rshift_neg(self, value):
    if value is not None:
      self.operation.attributes["rshift_neg"] = value
    elif "rshift_neg" in self.operation.attributes:
      del self.operation.attributes["rshift_neg"]

  @rshift_neg.deleter
  def rshift_neg(self):
    del self.operation.attributes["rshift_neg"]

  @builtins.property
  def out_f8_scales(self):
    if "out_f8_scales" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_f8_scales"]

  @out_f8_scales.setter
  def out_f8_scales(self, value):
    if value is not None:
      self.operation.attributes["out_f8_scales"] = value
    elif "out_f8_scales" in self.operation.attributes:
      del self.operation.attributes["out_f8_scales"]

  @out_f8_scales.deleter
  def out_f8_scales(self):
    del self.operation.attributes["out_f8_scales"]

  @builtins.property
  def support_compress(self):
    return self.operation.attributes["support_compress"]

  @support_compress.setter
  def support_compress(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["support_compress"] = value

  @builtins.property
  def compress_info(self):
    if "compress_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["compress_info"]

  @compress_info.setter
  def compress_info(self, value):
    if value is not None:
      self.operation.attributes["compress_info"] = value
    elif "compress_info" in self.operation.attributes:
      del self.operation.attributes["compress_info"]

  @compress_info.deleter
  def compress_info(self):
    del self.operation.attributes["compress_info"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Conv3DOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Conv3D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, kernel_shape, strides, pads, with_bias, *, group=None, dilations=None, inserts=None, do_relu=None, relu_limit=None, kernel_zp=None, multiplier=None, rshift=None, weight_bits=None, quant_mode=None, round_mode=None, ginfo=None, out_f8_scale=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if inserts is not None: attributes["inserts"] = (inserts if (
        issubclass(type(inserts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(inserts, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    attributes["with_bias"] = (with_bias if (
    issubclass(type(with_bias), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(with_bias, context=_ods_context))
    if kernel_zp is not None: attributes["kernel_zp"] = (kernel_zp if (
        issubclass(type(kernel_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(kernel_zp, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshift, context=_ods_context))
    if weight_bits is not None: attributes["weight_bits"] = (weight_bits if (
        issubclass(type(weight_bits), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(weight_bits, context=_ods_context))
    if quant_mode is not None: attributes["quant_mode"] = (quant_mode if (
        issubclass(type(quant_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if out_f8_scale is not None: attributes["out_f8_scale"] = (out_f8_scale if (
        issubclass(type(out_f8_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(out_f8_scale, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def dilations(self):
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def inserts(self):
    if "inserts" not in self.operation.attributes:
      return None
    return self.operation.attributes["inserts"]

  @inserts.setter
  def inserts(self, value):
    if value is not None:
      self.operation.attributes["inserts"] = value
    elif "inserts" in self.operation.attributes:
      del self.operation.attributes["inserts"]

  @inserts.deleter
  def inserts(self):
    del self.operation.attributes["inserts"]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def with_bias(self):
    return self.operation.attributes["with_bias"]

  @with_bias.setter
  def with_bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["with_bias"] = value

  @builtins.property
  def kernel_zp(self):
    return self.operation.attributes["kernel_zp"]

  @kernel_zp.setter
  def kernel_zp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_zp"] = value

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def weight_bits(self):
    if "weight_bits" not in self.operation.attributes:
      return None
    return self.operation.attributes["weight_bits"]

  @weight_bits.setter
  def weight_bits(self, value):
    if value is not None:
      self.operation.attributes["weight_bits"] = value
    elif "weight_bits" in self.operation.attributes:
      del self.operation.attributes["weight_bits"]

  @weight_bits.deleter
  def weight_bits(self):
    del self.operation.attributes["weight_bits"]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def out_f8_scale(self):
    if "out_f8_scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_f8_scale"]

  @out_f8_scale.setter
  def out_f8_scale(self, value):
    if value is not None:
      self.operation.attributes["out_f8_scale"] = value
    elif "out_f8_scale" in self.operation.attributes:
      del self.operation.attributes["out_f8_scale"]

  @out_f8_scale.deleter
  def out_f8_scale(self):
    del self.operation.attributes["out_f8_scale"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConvBwdWeightOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ConvBwd_Weight"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, gradout, gradout_transpose, groups, input_shape, grad_out_shape, kernel_shape, stride, dilations, padding, grad_bias_enable, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(gradout))
    operands.append(_get_op_result_or_value(gradout_transpose))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["groups"] = (groups if (
    issubclass(type(groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(groups, context=_ods_context))
    attributes["input_shape"] = (input_shape if (
    issubclass(type(input_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_shape, context=_ods_context))
    attributes["grad_out_shape"] = (grad_out_shape if (
    issubclass(type(grad_out_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(grad_out_shape, context=_ods_context))
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["stride"] = (stride if (
    issubclass(type(stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    attributes["dilations"] = (dilations if (
    issubclass(type(dilations), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    attributes["padding"] = (padding if (
    issubclass(type(padding), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(padding, context=_ods_context))
    attributes["grad_bias_enable"] = (grad_bias_enable if (
    issubclass(type(grad_bias_enable), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(grad_bias_enable, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def gradout(self):
    return self.operation.operands[1]

  @builtins.property
  def gradout_transpose(self):
    return self.operation.operands[2]

  @builtins.property
  def groups(self):
    return self.operation.attributes["groups"]

  @groups.setter
  def groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groups"] = value

  @builtins.property
  def input_shape(self):
    return self.operation.attributes["input_shape"]

  @input_shape.setter
  def input_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_shape"] = value

  @builtins.property
  def grad_out_shape(self):
    return self.operation.attributes["grad_out_shape"]

  @grad_out_shape.setter
  def grad_out_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_out_shape"] = value

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def padding(self):
    return self.operation.attributes["padding"]

  @padding.setter
  def padding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding"] = value

  @builtins.property
  def grad_bias_enable(self):
    return self.operation.attributes["grad_bias_enable"]

  @grad_bias_enable.setter
  def grad_bias_enable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_bias_enable"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ConvbwdOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Convbwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_input, grad_weight, grad_bias, grad_out, input, kernel, buffer, groups, input_shape, grad_out_shape, kernel_shape, stride, dilations, padding, inserts, grad_input_enable, grad_weight_enable, grad_bias_enable, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_out))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(kernel))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["groups"] = (groups if (
    issubclass(type(groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(groups, context=_ods_context))
    attributes["input_shape"] = (input_shape if (
    issubclass(type(input_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_shape, context=_ods_context))
    attributes["grad_out_shape"] = (grad_out_shape if (
    issubclass(type(grad_out_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(grad_out_shape, context=_ods_context))
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["stride"] = (stride if (
    issubclass(type(stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(stride, context=_ods_context))
    attributes["dilations"] = (dilations if (
    issubclass(type(dilations), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    attributes["padding"] = (padding if (
    issubclass(type(padding), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(padding, context=_ods_context))
    attributes["inserts"] = (inserts if (
    issubclass(type(inserts), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(inserts, context=_ods_context))
    attributes["grad_input_enable"] = (grad_input_enable if (
    issubclass(type(grad_input_enable), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(grad_input_enable, context=_ods_context))
    attributes["grad_weight_enable"] = (grad_weight_enable if (
    issubclass(type(grad_weight_enable), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(grad_weight_enable, context=_ods_context))
    attributes["grad_bias_enable"] = (grad_bias_enable if (
    issubclass(type(grad_bias_enable), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(grad_bias_enable, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(grad_input)
    results.append(grad_weight)
    results.append(grad_bias)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def kernel(self):
    return self.operation.operands[2]

  @builtins.property
  def buffer(self):
    return self.operation.operands[3]

  @builtins.property
  def groups(self):
    return self.operation.attributes["groups"]

  @groups.setter
  def groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["groups"] = value

  @builtins.property
  def input_shape(self):
    return self.operation.attributes["input_shape"]

  @input_shape.setter
  def input_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_shape"] = value

  @builtins.property
  def grad_out_shape(self):
    return self.operation.attributes["grad_out_shape"]

  @grad_out_shape.setter
  def grad_out_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_out_shape"] = value

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def stride(self):
    return self.operation.attributes["stride"]

  @stride.setter
  def stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["stride"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def padding(self):
    return self.operation.attributes["padding"]

  @padding.setter
  def padding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding"] = value

  @builtins.property
  def inserts(self):
    return self.operation.attributes["inserts"]

  @inserts.setter
  def inserts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inserts"] = value

  @builtins.property
  def grad_input_enable(self):
    return self.operation.attributes["grad_input_enable"]

  @grad_input_enable.setter
  def grad_input_enable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_input_enable"] = value

  @builtins.property
  def grad_weight_enable(self):
    return self.operation.attributes["grad_weight_enable"]

  @grad_weight_enable.setter
  def grad_weight_enable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_weight_enable"] = value

  @builtins.property
  def grad_bias_enable(self):
    return self.operation.attributes["grad_bias_enable"]

  @grad_bias_enable.setter
  def grad_bias_enable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grad_bias_enable"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def grad_input(self):
    return self.operation.results[0]

  @builtins.property
  def grad_weight(self):
    return self.operation.results[1]

  @builtins.property
  def grad_bias(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CopyOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shape, input_stride, output_stride, *, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["shape"] = (shape if (
    issubclass(type(shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    attributes["input_stride"] = (input_stride if (
    issubclass(type(input_stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_stride, context=_ods_context))
    attributes["output_stride"] = (output_stride if (
    issubclass(type(output_stride), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_stride, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def input_stride(self):
    return self.operation.attributes["input_stride"]

  @input_stride.setter
  def input_stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_stride"] = value

  @builtins.property
  def output_stride(self):
    return self.operation.attributes["output_stride"]

  @output_stride.setter
  def output_stride(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_stride"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CoreBeginOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.CoreBegin"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, pattern, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pattern"] = (pattern if (
    issubclass(type(pattern), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_CorePatternAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_CorePatternAttr')(pattern, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def pattern(self):
    return self.operation.attributes["pattern"]

  @pattern.setter
  def pattern(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pattern"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CoreEndOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.CoreEnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, pattern, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pattern"] = (pattern if (
    issubclass(type(pattern), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_CorePatternAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_CorePatternAttr')(pattern, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def pattern(self):
    return self.operation.attributes["pattern"]

  @pattern.setter
  def pattern(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pattern"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CoreParallelOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.CoreParallel"

  _ODS_REGIONS = (1, True)

  def __init__(self, outputs, inputs, offset, size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(offset, context=_ods_context))
    attributes["size"] = (size if (
    issubclass(type(size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(size, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def size(self):
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CorrelationOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Correlation"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, max_disp=None, num_groups=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if max_disp is not None: attributes["max_disp"] = (max_disp if (
        issubclass(type(max_disp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(max_disp, context=_ods_context))
    if num_groups is not None: attributes["num_groups"] = (num_groups if (
        issubclass(type(num_groups), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(num_groups, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def max_disp(self):
    return self.operation.attributes["max_disp"]

  @max_disp.setter
  def max_disp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_disp"] = value

  @builtins.property
  def num_groups(self):
    return self.operation.attributes["num_groups"]

  @num_groups.setter
  def num_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CscOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Csc"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, pixel_format, *, channel_order=None, aligned=None, pixel_type=None, y_align=None, w_align=None, channel_align=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if channel_order is not None: attributes["channel_order"] = (channel_order if (
        issubclass(type(channel_order), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I32ArrayAttr')(channel_order, context=_ods_context))
    attributes["pixel_format"] = (pixel_format if (
    issubclass(type(pixel_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(pixel_format, context=_ods_context))
    if aligned is not None: attributes["aligned"] = (aligned if (
        issubclass(type(aligned), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(aligned, context=_ods_context))
    if pixel_type is not None: attributes["pixel_type"] = (pixel_type if (
        issubclass(type(pixel_type), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pixel_type, context=_ods_context))
    if y_align is not None: attributes["y_align"] = (y_align if (
        issubclass(type(y_align), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(y_align, context=_ods_context))
    if w_align is not None: attributes["w_align"] = (w_align if (
        issubclass(type(w_align), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(w_align, context=_ods_context))
    if channel_align is not None: attributes["channel_align"] = (channel_align if (
        issubclass(type(channel_align), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(channel_align, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def channel_order(self):
    if "channel_order" not in self.operation.attributes:
      return None
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is not None:
      self.operation.attributes["channel_order"] = value
    elif "channel_order" in self.operation.attributes:
      del self.operation.attributes["channel_order"]

  @channel_order.deleter
  def channel_order(self):
    del self.operation.attributes["channel_order"]

  @builtins.property
  def pixel_format(self):
    return self.operation.attributes["pixel_format"]

  @pixel_format.setter
  def pixel_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pixel_format"] = value

  @builtins.property
  def aligned(self):
    return self.operation.attributes["aligned"]

  @aligned.setter
  def aligned(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["aligned"] = value

  @builtins.property
  def pixel_type(self):
    return self.operation.attributes["pixel_type"]

  @pixel_type.setter
  def pixel_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pixel_type"] = value

  @builtins.property
  def y_align(self):
    return self.operation.attributes["y_align"]

  @y_align.setter
  def y_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_align"] = value

  @builtins.property
  def w_align(self):
    return self.operation.attributes["w_align"]

  @w_align.setter
  def w_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["w_align"] = value

  @builtins.property
  def channel_align(self):
    return self.operation.attributes["channel_align"]

  @channel_align.setter
  def channel_align(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_align"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CumSumOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.CumSum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, dim, axis, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(dim))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def dim(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CustomOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Custom"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, buffer, name, params, *, ginfo=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    issubclass(type(name), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["params"] = (params if (
    issubclass(type(params), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
      _ods_ir.AttrBuilder.get('DictArrayAttr')(params, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def buffer(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def params(self):
    return self.operation.attributes["params"]

  @params.setter
  def params(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["params"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class D2DOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.D2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Deconv3DOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Deconv3D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, kernel_shape, strides, pads, with_bias, *, group=None, dilations=None, output_padding=None, do_relu=None, relu_limit=None, multiplier=None, rshift=None, quant_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if output_padding is not None: attributes["output_padding"] = (output_padding if (
        issubclass(type(output_padding), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_padding, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    attributes["with_bias"] = (with_bias if (
    issubclass(type(with_bias), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(with_bias, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshift, context=_ods_context))
    if quant_mode is not None: attributes["quant_mode"] = (quant_mode if (
        issubclass(type(quant_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def dilations(self):
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def output_padding(self):
    if "output_padding" not in self.operation.attributes:
      return None
    return self.operation.attributes["output_padding"]

  @output_padding.setter
  def output_padding(self, value):
    if value is not None:
      self.operation.attributes["output_padding"] = value
    elif "output_padding" in self.operation.attributes:
      del self.operation.attributes["output_padding"]

  @output_padding.deleter
  def output_padding(self):
    del self.operation.attributes["output_padding"]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def with_bias(self):
    return self.operation.attributes["with_bias"]

  @with_bias.setter
  def with_bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["with_bias"] = value

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DeconvOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Deconv"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, filter, bias, kernel_shape, strides, pads, with_bias, *, group=None, dilations=None, output_padding=None, do_relu=None, relu_limit=None, multiplier=None, rshift=None, quant_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if group is not None: attributes["group"] = (group if (
        issubclass(type(group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if dilations is not None: attributes["dilations"] = (dilations if (
        issubclass(type(dilations), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    if output_padding is not None: attributes["output_padding"] = (output_padding if (
        issubclass(type(output_padding), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(output_padding, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    attributes["with_bias"] = (with_bias if (
    issubclass(type(with_bias), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(with_bias, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshift, context=_ods_context))
    if quant_mode is not None: attributes["quant_mode"] = (quant_mode if (
        issubclass(type(quant_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def dilations(self):
    if "dilations" not in self.operation.attributes:
      return None
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is not None:
      self.operation.attributes["dilations"] = value
    elif "dilations" in self.operation.attributes:
      del self.operation.attributes["dilations"]

  @dilations.deleter
  def dilations(self):
    del self.operation.attributes["dilations"]

  @builtins.property
  def output_padding(self):
    if "output_padding" not in self.operation.attributes:
      return None
    return self.operation.attributes["output_padding"]

  @output_padding.setter
  def output_padding(self, value):
    if value is not None:
      self.operation.attributes["output_padding"] = value
    elif "output_padding" in self.operation.attributes:
      del self.operation.attributes["output_padding"]

  @output_padding.deleter
  def output_padding(self):
    del self.operation.attributes["output_padding"]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def with_bias(self):
    return self.operation.attributes["with_bias"]

  @with_bias.setter
  def with_bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["with_bias"] = value

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DeformGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.DeformGather"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, offset, mask, buffer, kernel_shape, strides, dilations, pads, *, use_mask=None, deform_group=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(offset))
    operands.append(_get_op_result_or_value(mask))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["dilations"] = (dilations if (
    issubclass(type(dilations), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if use_mask is not None: attributes["use_mask"] = (use_mask if (
        issubclass(type(use_mask), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(use_mask, context=_ods_context))
    if deform_group is not None: attributes["deform_group"] = (deform_group if (
        issubclass(type(deform_group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(deform_group, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def offset(self):
    return self.operation.operands[1]

  @builtins.property
  def mask(self):
    return self.operation.operands[2]

  @builtins.property
  def buffer(self):
    return self.operation.operands[3]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def use_mask(self):
    return self.operation.attributes["use_mask"]

  @use_mask.setter
  def use_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_mask"] = value

  @builtins.property
  def deform_group(self):
    return self.operation.attributes["deform_group"]

  @deform_group.setter
  def deform_group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["deform_group"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DepackRawOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.DepackRaw"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, padding_h, padding_w, white_level, black_level, channel_order, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["padding_h"] = (padding_h if (
    issubclass(type(padding_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(padding_h, context=_ods_context))
    attributes["padding_w"] = (padding_w if (
    issubclass(type(padding_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(padding_w, context=_ods_context))
    attributes["white_level"] = (white_level if (
    issubclass(type(white_level), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(white_level, context=_ods_context))
    attributes["black_level"] = (black_level if (
    issubclass(type(black_level), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(black_level, context=_ods_context))
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(channel_order, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def padding_h(self):
    return self.operation.attributes["padding_h"]

  @padding_h.setter
  def padding_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_h"] = value

  @builtins.property
  def padding_w(self):
    return self.operation.attributes["padding_w"]

  @padding_w.setter
  def padding_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_w"] = value

  @builtins.property
  def white_level(self):
    return self.operation.attributes["white_level"]

  @white_level.setter
  def white_level(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["white_level"] = value

  @builtins.property
  def black_level(self):
    return self.operation.attributes["black_level"]

  @black_level.setter
  def black_level(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["black_level"] = value

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Depth2SpaceOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Depth2Space"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, block_h, block_w, is_CRD, is_inversed, *, in_is_NCHW=None, out_is_NCHW=None, swap_cr=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["block_h"] = (block_h if (
    issubclass(type(block_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_h, context=_ods_context))
    attributes["block_w"] = (block_w if (
    issubclass(type(block_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_w, context=_ods_context))
    attributes["is_CRD"] = (is_CRD if (
    issubclass(type(is_CRD), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_CRD, context=_ods_context))
    attributes["is_inversed"] = (is_inversed if (
    issubclass(type(is_inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_inversed, context=_ods_context))
    if in_is_NCHW is not None: attributes["in_is_NCHW"] = (in_is_NCHW if (
        issubclass(type(in_is_NCHW), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(in_is_NCHW, context=_ods_context))
    if out_is_NCHW is not None: attributes["out_is_NCHW"] = (out_is_NCHW if (
        issubclass(type(out_is_NCHW), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(out_is_NCHW, context=_ods_context))
    if swap_cr is not None: attributes["swap_cr"] = (swap_cr if (
        issubclass(type(swap_cr), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(swap_cr, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def block_h(self):
    return self.operation.attributes["block_h"]

  @block_h.setter
  def block_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_h"] = value

  @builtins.property
  def block_w(self):
    return self.operation.attributes["block_w"]

  @block_w.setter
  def block_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_w"] = value

  @builtins.property
  def is_CRD(self):
    return self.operation.attributes["is_CRD"]

  @is_CRD.setter
  def is_CRD(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_CRD"] = value

  @builtins.property
  def is_inversed(self):
    return self.operation.attributes["is_inversed"]

  @is_inversed.setter
  def is_inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_inversed"] = value

  @builtins.property
  def in_is_NCHW(self):
    return self.operation.attributes["in_is_NCHW"]

  @in_is_NCHW.setter
  def in_is_NCHW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["in_is_NCHW"] = value

  @builtins.property
  def out_is_NCHW(self):
    return self.operation.attributes["out_is_NCHW"]

  @out_is_NCHW.setter
  def out_is_NCHW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["out_is_NCHW"] = value

  @builtins.property
  def swap_cr(self):
    return self.operation.attributes["swap_cr"]

  @swap_cr.setter
  def swap_cr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["swap_cr"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DequantIntAxisOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.DequantIntAxis"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, quant, quant_mode, *, lshift=None, round_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(quant))
    _ods_context = _ods_get_default_loc_context(loc)
    if lshift is not None: attributes["lshift"] = (lshift if (
        issubclass(type(lshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(lshift, context=_ods_context))
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_DequantModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_DequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant(self):
    return self.operation.operands[1]

  @builtins.property
  def lshift(self):
    return self.operation.attributes["lshift"]

  @lshift.setter
  def lshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lshift"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DequantIntOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.DequantInt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, multiplier, shift, quant_mode, *, lshift=None, round_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["multiplier"] = (multiplier if (
    issubclass(type(multiplier), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    attributes["shift"] = (shift if (
    issubclass(type(shift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(shift, context=_ods_context))
    if lshift is not None: attributes["lshift"] = (lshift if (
        issubclass(type(lshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(lshift, context=_ods_context))
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_DequantModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_DequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def shift(self):
    return self.operation.attributes["shift"]

  @shift.setter
  def shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shift"] = value

  @builtins.property
  def lshift(self):
    return self.operation.attributes["lshift"]

  @lshift.setter
  def lshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lshift"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DetectionOutputOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.DetectionOutput"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, num_classes, nms_threshold, top_k, code_type, keep_top_k, confidence_threshold, buffer, *, background_label_id=None, share_location=None, variance_encoded_in_target=None, eta=None, onnx_nms=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_classes"] = (num_classes if (
    issubclass(type(num_classes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_classes, context=_ods_context))
    if background_label_id is not None: attributes["background_label_id"] = (background_label_id if (
        issubclass(type(background_label_id), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(background_label_id, context=_ods_context))
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["top_k"] = (top_k if (
    issubclass(type(top_k), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(top_k, context=_ods_context))
    attributes["code_type"] = (code_type if (
    issubclass(type(code_type), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DetectionOutputCodeTypeAttr')) else
      _ods_ir.AttrBuilder.get('DetectionOutputCodeTypeAttr')(code_type, context=_ods_context))
    attributes["keep_top_k"] = (keep_top_k if (
    issubclass(type(keep_top_k), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_top_k, context=_ods_context))
    attributes["confidence_threshold"] = (confidence_threshold if (
    issubclass(type(confidence_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(confidence_threshold, context=_ods_context))
    if share_location is not None: attributes["share_location"] = (share_location if (
        issubclass(type(share_location), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(share_location, context=_ods_context))
    if variance_encoded_in_target is not None: attributes["variance_encoded_in_target"] = (variance_encoded_in_target if (
        issubclass(type(variance_encoded_in_target), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(variance_encoded_in_target, context=_ods_context))
    if eta is not None: attributes["eta"] = (eta if (
        issubclass(type(eta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(eta, context=_ods_context))
    if onnx_nms is not None: attributes["onnx_nms"] = (onnx_nms if (
        issubclass(type(onnx_nms), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(onnx_nms, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def buffer(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def num_classes(self):
    return self.operation.attributes["num_classes"]

  @num_classes.setter
  def num_classes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_classes"] = value

  @builtins.property
  def background_label_id(self):
    return self.operation.attributes["background_label_id"]

  @background_label_id.setter
  def background_label_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["background_label_id"] = value

  @builtins.property
  def nms_threshold(self):
    return self.operation.attributes["nms_threshold"]

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def top_k(self):
    return self.operation.attributes["top_k"]

  @top_k.setter
  def top_k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["top_k"] = value

  @builtins.property
  def code_type(self):
    return self.operation.attributes["code_type"]

  @code_type.setter
  def code_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["code_type"] = value

  @builtins.property
  def keep_top_k(self):
    return self.operation.attributes["keep_top_k"]

  @keep_top_k.setter
  def keep_top_k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_top_k"] = value

  @builtins.property
  def confidence_threshold(self):
    return self.operation.attributes["confidence_threshold"]

  @confidence_threshold.setter
  def confidence_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["confidence_threshold"] = value

  @builtins.property
  def share_location(self):
    return self.operation.attributes["share_location"]

  @share_location.setter
  def share_location(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["share_location"] = value

  @builtins.property
  def variance_encoded_in_target(self):
    return self.operation.attributes["variance_encoded_in_target"]

  @variance_encoded_in_target.setter
  def variance_encoded_in_target(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variance_encoded_in_target"] = value

  @builtins.property
  def eta(self):
    return self.operation.attributes["eta"]

  @eta.setter
  def eta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eta"] = value

  @builtins.property
  def onnx_nms(self):
    return self.operation.attributes["onnx_nms"]

  @onnx_nms.setter
  def onnx_nms(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["onnx_nms"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DevBeginOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.DevBegin"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, pattern, begin_methods, *, num_head=None, done=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pattern"] = (pattern if (
    issubclass(type(pattern), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_DevPatternAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_DevPatternAttr')(pattern, context=_ods_context))
    attributes["begin_methods"] = (begin_methods if (
    issubclass(type(begin_methods), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(begin_methods, context=_ods_context))
    if num_head is not None: attributes["num_head"] = (num_head if (
        issubclass(type(num_head), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(num_head, context=_ods_context))
    if done is not None: attributes["done"] = (done if (
        issubclass(type(done), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(done, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def pattern(self):
    return self.operation.attributes["pattern"]

  @pattern.setter
  def pattern(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pattern"] = value

  @builtins.property
  def begin_methods(self):
    return self.operation.attributes["begin_methods"]

  @begin_methods.setter
  def begin_methods(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["begin_methods"] = value

  @builtins.property
  def num_head(self):
    return self.operation.attributes["num_head"]

  @num_head.setter
  def num_head(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_head"] = value

  @builtins.property
  def done(self):
    return self.operation.attributes["done"]

  @done.setter
  def done(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["done"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DevEndOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.DevEnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, pattern, end_methods, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pattern"] = (pattern if (
    issubclass(type(pattern), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_DevPatternAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_DevPatternAttr')(pattern, context=_ods_context))
    attributes["end_methods"] = (end_methods if (
    issubclass(type(end_methods), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(end_methods, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def pattern(self):
    return self.operation.attributes["pattern"]

  @pattern.setter
  def pattern(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pattern"] = value

  @builtins.property
  def end_methods(self):
    return self.operation.attributes["end_methods"]

  @end_methods.setter
  def end_methods(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end_methods"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Device2HostOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Device2Host"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DivOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Div"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, is_reverse=None, do_relu=None, relu_limit=None, multiplier=None, rshift=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DtypeCastOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.DtypeCast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, extra_input=None, ginfo=None, with_scale=None, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if extra_input is not None: attributes["extra_input"] = (extra_input if (
        issubclass(type(extra_input), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(extra_input, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if with_scale is not None: attributes["with_scale"] = (with_scale if (
        issubclass(type(with_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(with_scale, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def extra_input(self):
    if "extra_input" not in self.operation.attributes:
      return None
    return self.operation.attributes["extra_input"]

  @extra_input.setter
  def extra_input(self, value):
    if value is not None:
      self.operation.attributes["extra_input"] = value
    elif "extra_input" in self.operation.attributes:
      del self.operation.attributes["extra_input"]

  @extra_input.deleter
  def extra_input(self):
    del self.operation.attributes["extra_input"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def with_scale(self):
    return self.operation.attributes["with_scale"]

  @with_scale.setter
  def with_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["with_scale"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class EmbDenseBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.EmbDenseBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, grad_output, indices, num_weights, padding_idx, scale_grad_by_freq, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_output))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_weights"] = (num_weights if (
    issubclass(type(num_weights), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(num_weights, context=_ods_context))
    attributes["padding_idx"] = (padding_idx if (
    issubclass(type(padding_idx), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(padding_idx, context=_ods_context))
    attributes["scale_grad_by_freq"] = (scale_grad_by_freq if (
    issubclass(type(scale_grad_by_freq), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(scale_grad_by_freq, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def num_weights(self):
    return self.operation.attributes["num_weights"]

  @num_weights.setter
  def num_weights(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_weights"] = value

  @builtins.property
  def padding_idx(self):
    return self.operation.attributes["padding_idx"]

  @padding_idx.setter
  def padding_idx(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_idx"] = value

  @builtins.property
  def scale_grad_by_freq(self):
    return self.operation.attributes["scale_grad_by_freq"]

  @scale_grad_by_freq.setter
  def scale_grad_by_freq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_grad_by_freq"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FAttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.FAttention"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, queries, keys, values, mask, buffer, scale, batch, q_head, kv_head, dim, mq, mk, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(queries))
    operands.append(_get_op_result_or_value(keys))
    operands.append(_get_op_result_or_value(values))
    operands.append(_get_op_result_or_value(mask))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    attributes["batch"] = (batch if (
    issubclass(type(batch), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(batch, context=_ods_context))
    attributes["q_head"] = (q_head if (
    issubclass(type(q_head), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(q_head, context=_ods_context))
    attributes["kv_head"] = (kv_head if (
    issubclass(type(kv_head), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(kv_head, context=_ods_context))
    attributes["dim"] = (dim if (
    issubclass(type(dim), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dim, context=_ods_context))
    attributes["mq"] = (mq if (
    issubclass(type(mq), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(mq, context=_ods_context))
    attributes["mk"] = (mk if (
    issubclass(type(mk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(mk, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def queries(self):
    return self.operation.operands[0]

  @builtins.property
  def keys(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def mask(self):
    return self.operation.operands[3]

  @builtins.property
  def buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def batch(self):
    return self.operation.attributes["batch"]

  @batch.setter
  def batch(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch"] = value

  @builtins.property
  def q_head(self):
    return self.operation.attributes["q_head"]

  @q_head.setter
  def q_head(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["q_head"] = value

  @builtins.property
  def kv_head(self):
    return self.operation.attributes["kv_head"]

  @kv_head.setter
  def kv_head(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kv_head"] = value

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def mq(self):
    return self.operation.attributes["mq"]

  @mq.setter
  def mq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mq"] = value

  @builtins.property
  def mk(self):
    return self.operation.attributes["mk"]

  @mk.setter
  def mk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mk"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FusedActiveCastOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.FusedActiveCast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mode, *, coeffs=None, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_ActiveModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_ActiveModeAttr')(mode, context=_ods_context))
    if coeffs is not None: attributes["coeffs"] = (coeffs if (
        issubclass(type(coeffs), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeffs, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def coeffs(self):
    if "coeffs" not in self.operation.attributes:
      return None
    return self.operation.attributes["coeffs"]

  @coeffs.setter
  def coeffs(self, value):
    if value is not None:
      self.operation.attributes["coeffs"] = value
    elif "coeffs" in self.operation.attributes:
      del self.operation.attributes["coeffs"]

  @coeffs.deleter
  def coeffs(self):
    del self.operation.attributes["coeffs"]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GRUOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GRU"

  _ODS_REGIONS = (0, True)

  def __init__(self, Y, Y_h, input, filter, recurrence, bias, initial_h, buffer, sigmoid_table, sigmoid_slope_table, tanh_table, tanh_slope_table, hidden_size, bidirectional, *, linear_before_reset=None, batch_first=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(recurrence))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(initial_h))
    operands.append(_get_op_result_or_value(buffer))
    operands.append(_get_op_result_or_value(sigmoid_table))
    operands.append(_get_op_result_or_value(sigmoid_slope_table))
    operands.append(_get_op_result_or_value(tanh_table))
    operands.append(_get_op_result_or_value(tanh_slope_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["hidden_size"] = (hidden_size if (
    issubclass(type(hidden_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(hidden_size, context=_ods_context))
    attributes["bidirectional"] = (bidirectional if (
    issubclass(type(bidirectional), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(bidirectional, context=_ods_context))
    if linear_before_reset is not None: attributes["linear_before_reset"] = (linear_before_reset if (
        issubclass(type(linear_before_reset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(linear_before_reset, context=_ods_context))
    if batch_first is not None: attributes["batch_first"] = (batch_first if (
        issubclass(type(batch_first), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(batch_first, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(Y)
    results.append(Y_h)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def recurrence(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def initial_h(self):
    return self.operation.operands[4]

  @builtins.property
  def buffer(self):
    return self.operation.operands[5]

  @builtins.property
  def sigmoid_table(self):
    return self.operation.operands[6]

  @builtins.property
  def sigmoid_slope_table(self):
    return self.operation.operands[7]

  @builtins.property
  def tanh_table(self):
    return self.operation.operands[8]

  @builtins.property
  def tanh_slope_table(self):
    return self.operation.operands[9]

  @builtins.property
  def hidden_size(self):
    return self.operation.attributes["hidden_size"]

  @hidden_size.setter
  def hidden_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hidden_size"] = value

  @builtins.property
  def bidirectional(self):
    return self.operation.attributes["bidirectional"]

  @bidirectional.setter
  def bidirectional(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bidirectional"] = value

  @builtins.property
  def linear_before_reset(self):
    return self.operation.attributes["linear_before_reset"]

  @linear_before_reset.setter
  def linear_before_reset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["linear_before_reset"] = value

  @builtins.property
  def batch_first(self):
    return self.operation.attributes["batch_first"]

  @batch_first.setter
  def batch_first(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_first"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def Y(self):
    return self.operation.results[0]

  @builtins.property
  def Y_h(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GatherElements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, indices_coeff, buffer, *, axis=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(indices_coeff))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def indices_coeff(self):
    return self.operation.operands[2]

  @builtins.property
  def buffer(self):
    return self.operation.operands[3]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherNDOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GatherND"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input_data, indices, *, indice_dims=None, batch_dims=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input_data))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    if indice_dims is not None: attributes["indice_dims"] = (indice_dims if (
        issubclass(type(indice_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(indice_dims, context=_ods_context))
    if batch_dims is not None: attributes["batch_dims"] = (batch_dims if (
        issubclass(type(batch_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(batch_dims, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input_data(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def indice_dims(self):
    if "indice_dims" not in self.operation.attributes:
      return None
    return self.operation.attributes["indice_dims"]

  @indice_dims.setter
  def indice_dims(self, value):
    if value is not None:
      self.operation.attributes["indice_dims"] = value
    elif "indice_dims" in self.operation.attributes:
      del self.operation.attributes["indice_dims"]

  @indice_dims.deleter
  def indice_dims(self):
    del self.operation.attributes["indice_dims"]

  @builtins.property
  def batch_dims(self):
    return self.operation.attributes["batch_dims"]

  @batch_dims.setter
  def batch_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_dims"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GatherOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, buffer, *, axis=None, if_neg_index=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if axis is not None: attributes["axis"] = (axis if (
        issubclass(type(axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if if_neg_index is not None: attributes["if_neg_index"] = (if_neg_index if (
        issubclass(type(if_neg_index), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(if_neg_index, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def buffer(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def if_neg_index(self):
    return self.operation.attributes["if_neg_index"]

  @if_neg_index.setter
  def if_neg_index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["if_neg_index"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GenericCpuOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GenericCpu"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, cpu_op_name, *, param=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cpu_op_name"] = (cpu_op_name if (
    issubclass(type(cpu_op_name), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(cpu_op_name, context=_ods_context))
    if param is not None: attributes["param"] = (param if (
        issubclass(type(param), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(param, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def cpu_op_name(self):
    return self.operation.attributes["cpu_op_name"]

  @cpu_op_name.setter
  def cpu_op_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cpu_op_name"] = value

  @builtins.property
  def param(self):
    if "param" not in self.operation.attributes:
      return None
    return self.operation.attributes["param"]

  @param.setter
  def param(self, value):
    if value is not None:
      self.operation.attributes["param"] = value
    elif "param" in self.operation.attributes:
      del self.operation.attributes["param"]

  @param.deleter
  def param(self):
    del self.operation.attributes["param"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GridSampleInDeformableAttnOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GridSampleInDeformableAttn"

  _ODS_REGIONS = (0, True)

  def __init__(self, output_global_addr, input_global_addr, grid_global_addr, attn_global_addr, num_grid_samples, input_dims, input_n, input_c, input_d, input_h, input_w, grid_dout, grid_hout, grid_wout, interp_mode, padding_mode, align_corners, buffer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(input_global_addr))
    operands.extend(_get_op_results_or_values(grid_global_addr))
    operands.extend(_get_op_results_or_values(attn_global_addr))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_grid_samples"] = (num_grid_samples if (
    issubclass(type(num_grid_samples), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_grid_samples, context=_ods_context))
    attributes["input_dims"] = (input_dims if (
    issubclass(type(input_dims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(input_dims, context=_ods_context))
    attributes["input_n"] = (input_n if (
    issubclass(type(input_n), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_n, context=_ods_context))
    attributes["input_c"] = (input_c if (
    issubclass(type(input_c), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_c, context=_ods_context))
    attributes["input_d"] = (input_d if (
    issubclass(type(input_d), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_d, context=_ods_context))
    attributes["input_h"] = (input_h if (
    issubclass(type(input_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_h, context=_ods_context))
    attributes["input_w"] = (input_w if (
    issubclass(type(input_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_w, context=_ods_context))
    attributes["grid_dout"] = (grid_dout if (
    issubclass(type(grid_dout), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(grid_dout, context=_ods_context))
    attributes["grid_hout"] = (grid_hout if (
    issubclass(type(grid_hout), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(grid_hout, context=_ods_context))
    attributes["grid_wout"] = (grid_wout if (
    issubclass(type(grid_wout), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(grid_wout, context=_ods_context))
    attributes["interp_mode"] = (interp_mode if (
    issubclass(type(interp_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(interp_mode, context=_ods_context))
    attributes["padding_mode"] = (padding_mode if (
    issubclass(type(padding_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(padding_mode, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    results.append(output_global_addr)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input_global_addr(self):
    start, pg = _ods_equally_sized_accessor(operation.operands, 3, 0, 0)
    return self.operation.operands[start:start + pg]

  @builtins.property
  def grid_global_addr(self):
    start, pg = _ods_equally_sized_accessor(operation.operands, 3, 0, 1)
    return self.operation.operands[start:start + pg]

  @builtins.property
  def attn_global_addr(self):
    start, pg = _ods_equally_sized_accessor(operation.operands, 3, 0, 2)
    return self.operation.operands[start:start + pg]

  @builtins.property
  def buffer(self):
    start, pg = _ods_equally_sized_accessor(operation.operands, 3, 0, 3)
    return self.operation.operands[start]

  @builtins.property
  def num_grid_samples(self):
    return self.operation.attributes["num_grid_samples"]

  @num_grid_samples.setter
  def num_grid_samples(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_grid_samples"] = value

  @builtins.property
  def input_dims(self):
    return self.operation.attributes["input_dims"]

  @input_dims.setter
  def input_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_dims"] = value

  @builtins.property
  def input_n(self):
    return self.operation.attributes["input_n"]

  @input_n.setter
  def input_n(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_n"] = value

  @builtins.property
  def input_c(self):
    return self.operation.attributes["input_c"]

  @input_c.setter
  def input_c(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_c"] = value

  @builtins.property
  def input_d(self):
    return self.operation.attributes["input_d"]

  @input_d.setter
  def input_d(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_d"] = value

  @builtins.property
  def input_h(self):
    return self.operation.attributes["input_h"]

  @input_h.setter
  def input_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_h"] = value

  @builtins.property
  def input_w(self):
    return self.operation.attributes["input_w"]

  @input_w.setter
  def input_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_w"] = value

  @builtins.property
  def grid_dout(self):
    return self.operation.attributes["grid_dout"]

  @grid_dout.setter
  def grid_dout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grid_dout"] = value

  @builtins.property
  def grid_hout(self):
    return self.operation.attributes["grid_hout"]

  @grid_hout.setter
  def grid_hout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grid_hout"] = value

  @builtins.property
  def grid_wout(self):
    return self.operation.attributes["grid_wout"]

  @grid_wout.setter
  def grid_wout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["grid_wout"] = value

  @builtins.property
  def interp_mode(self):
    return self.operation.attributes["interp_mode"]

  @interp_mode.setter
  def interp_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["interp_mode"] = value

  @builtins.property
  def padding_mode(self):
    return self.operation.attributes["padding_mode"]

  @padding_mode.setter
  def padding_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_mode"] = value

  @builtins.property
  def align_corners(self):
    return self.operation.attributes["align_corners"]

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def output_global_addr(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GridSamplerOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GridSampler"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, grid, buffer, mode, padding_mode, align_corners, *, mean=None, scale=None, need_permute=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(grid))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(mode, context=_ods_context))
    attributes["padding_mode"] = (padding_mode if (
    issubclass(type(padding_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(padding_mode, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    if mean is not None: attributes["mean"] = (mean if (
        issubclass(type(mean), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(mean, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    if need_permute is not None: attributes["need_permute"] = (need_permute if (
        issubclass(type(need_permute), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(need_permute, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def grid(self):
    return self.operation.operands[1]

  @builtins.property
  def buffer(self):
    return self.operation.operands[2]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def padding_mode(self):
    return self.operation.attributes["padding_mode"]

  @padding_mode.setter
  def padding_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["padding_mode"] = value

  @builtins.property
  def align_corners(self):
    return self.operation.attributes["align_corners"]

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def mean(self):
    return self.operation.attributes["mean"]

  @mean.setter
  def mean(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mean"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def need_permute(self):
    return self.operation.attributes["need_permute"]

  @need_permute.setter
  def need_permute(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["need_permute"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GroupNormOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GroupNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, table, mantissa_table, num_groups, eps, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(mantissa_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_groups"] = (num_groups if (
    issubclass(type(num_groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_groups, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def table(self):
    return self.operation.operands[3]

  @builtins.property
  def mantissa_table(self):
    return self.operation.operands[4]

  @builtins.property
  def num_groups(self):
    return self.operation.attributes["num_groups"]

  @num_groups.setter
  def num_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GroupNormTrainOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GroupNormTrain"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mean, rstd, input, weight, bias, num_groups, eps, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["num_groups"] = (num_groups if (
    issubclass(type(num_groups), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_groups, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    results.append(mean)
    results.append(rstd)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def num_groups(self):
    return self.operation.attributes["num_groups"]

  @num_groups.setter
  def num_groups(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_groups"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mean(self):
    return self.operation.results[1]

  @builtins.property
  def rstd(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GroupOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Group"

  _ODS_REGIONS = (1, True)

  def __init__(self, outputs, inputs, nsecs, hsecs, dsecs, wsecs, csecs, swpipl_stage_num, group_type, *, flow=None, self_up_overlap_op=None, self_down_overlap_op=None, other_up_overlap_op=None, other_down_overlap_op=None, support_compress=None, run_core_id=None, core_slice_ncdhw=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["nsecs"] = (nsecs if (
    issubclass(type(nsecs), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(nsecs, context=_ods_context))
    attributes["hsecs"] = (hsecs if (
    issubclass(type(hsecs), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(hsecs, context=_ods_context))
    attributes["dsecs"] = (dsecs if (
    issubclass(type(dsecs), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dsecs, context=_ods_context))
    attributes["wsecs"] = (wsecs if (
    issubclass(type(wsecs), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(wsecs, context=_ods_context))
    attributes["csecs"] = (csecs if (
    issubclass(type(csecs), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(csecs, context=_ods_context))
    attributes["swpipl_stage_num"] = (swpipl_stage_num if (
    issubclass(type(swpipl_stage_num), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(swpipl_stage_num, context=_ods_context))
    attributes["group_type"] = (group_type if (
    issubclass(type(group_type), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(group_type, context=_ods_context))
    if flow is not None: attributes["flow"] = (flow if (
        issubclass(type(flow), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(flow, context=_ods_context))
    if self_up_overlap_op is not None: attributes["self_up_overlap_op"] = (self_up_overlap_op if (
        issubclass(type(self_up_overlap_op), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(self_up_overlap_op, context=_ods_context))
    if self_down_overlap_op is not None: attributes["self_down_overlap_op"] = (self_down_overlap_op if (
        issubclass(type(self_down_overlap_op), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(self_down_overlap_op, context=_ods_context))
    if other_up_overlap_op is not None: attributes["other_up_overlap_op"] = (other_up_overlap_op if (
        issubclass(type(other_up_overlap_op), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(other_up_overlap_op, context=_ods_context))
    if other_down_overlap_op is not None: attributes["other_down_overlap_op"] = (other_down_overlap_op if (
        issubclass(type(other_down_overlap_op), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(other_down_overlap_op, context=_ods_context))
    if support_compress is not None: attributes["support_compress"] = (support_compress if (
        issubclass(type(support_compress), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(support_compress, context=_ods_context))
    if run_core_id is not None: attributes["run_core_id"] = (run_core_id if (
        issubclass(type(run_core_id), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(run_core_id, context=_ods_context))
    if core_slice_ncdhw is not None: attributes["core_slice_ncdhw"] = (core_slice_ncdhw if (
        issubclass(type(core_slice_ncdhw), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(core_slice_ncdhw, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def nsecs(self):
    return self.operation.attributes["nsecs"]

  @nsecs.setter
  def nsecs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nsecs"] = value

  @builtins.property
  def hsecs(self):
    return self.operation.attributes["hsecs"]

  @hsecs.setter
  def hsecs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hsecs"] = value

  @builtins.property
  def dsecs(self):
    return self.operation.attributes["dsecs"]

  @dsecs.setter
  def dsecs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dsecs"] = value

  @builtins.property
  def wsecs(self):
    return self.operation.attributes["wsecs"]

  @wsecs.setter
  def wsecs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wsecs"] = value

  @builtins.property
  def csecs(self):
    return self.operation.attributes["csecs"]

  @csecs.setter
  def csecs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["csecs"] = value

  @builtins.property
  def swpipl_stage_num(self):
    return self.operation.attributes["swpipl_stage_num"]

  @swpipl_stage_num.setter
  def swpipl_stage_num(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["swpipl_stage_num"] = value

  @builtins.property
  def group_type(self):
    return self.operation.attributes["group_type"]

  @group_type.setter
  def group_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_type"] = value

  @builtins.property
  def flow(self):
    return self.operation.attributes["flow"]

  @flow.setter
  def flow(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flow"] = value

  @builtins.property
  def self_up_overlap_op(self):
    return self.operation.attributes["self_up_overlap_op"]

  @self_up_overlap_op.setter
  def self_up_overlap_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["self_up_overlap_op"] = value

  @builtins.property
  def self_down_overlap_op(self):
    return self.operation.attributes["self_down_overlap_op"]

  @self_down_overlap_op.setter
  def self_down_overlap_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["self_down_overlap_op"] = value

  @builtins.property
  def other_up_overlap_op(self):
    return self.operation.attributes["other_up_overlap_op"]

  @other_up_overlap_op.setter
  def other_up_overlap_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["other_up_overlap_op"] = value

  @builtins.property
  def other_down_overlap_op(self):
    return self.operation.attributes["other_down_overlap_op"]

  @other_down_overlap_op.setter
  def other_down_overlap_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["other_down_overlap_op"] = value

  @builtins.property
  def support_compress(self):
    return self.operation.attributes["support_compress"]

  @support_compress.setter
  def support_compress(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["support_compress"] = value

  @builtins.property
  def run_core_id(self):
    return self.operation.attributes["run_core_id"]

  @run_core_id.setter
  def run_core_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["run_core_id"] = value

  @builtins.property
  def core_slice_ncdhw(self):
    return self.operation.attributes["core_slice_ncdhw"]

  @core_slice_ncdhw.setter
  def core_slice_ncdhw(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["core_slice_ncdhw"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GroupParallelOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.GroupParallel"

  _ODS_REGIONS = (0, False)

  def __init__(self, outputs, inputs, num_parallel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(outputs)
    _ods_successors = None
    regions = 0 + num_parallel
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def parallel(self):
    return self.regions[0:]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Host2DeviceOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Host2Device"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class IdentityOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Identity"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class IfOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.If"

  _ODS_REGIONS = (2, True)

  def __init__(self, output, cond, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def then_branch(self):
    return self.regions[0]

  @builtins.property
  def else_branch(self):
    return self.regions[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class IndexPutOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.IndexPut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, values, buffer, *, accumulate=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(values))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if accumulate is not None: attributes["accumulate"] = (accumulate if (
        issubclass(type(accumulate), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(accumulate, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    return self.operation.operands[2]

  @builtins.property
  def buffer(self):
    return self.operation.operands[3]

  @builtins.property
  def accumulate(self):
    return self.operation.attributes["accumulate"]

  @accumulate.setter
  def accumulate(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["accumulate"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InstanceNormOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.InstanceNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, table, mantissa_table, eps, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(mantissa_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def table(self):
    return self.operation.operands[3]

  @builtins.property
  def mantissa_table(self):
    return self.operation.operands[4]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InterpOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Interp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shapeT, buffer, scale_h, scale_w, mode, coord_mode, *, ppl_flag=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(shapeT))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale_h"] = (scale_h if (
    issubclass(type(scale_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(scale_h, context=_ods_context))
    attributes["scale_w"] = (scale_w if (
    issubclass(type(scale_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(scale_w, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_ResizeModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_ResizeModeAttr')(mode, context=_ods_context))
    attributes["coord_mode"] = (coord_mode if (
    issubclass(type(coord_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_ResizeCoordModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_ResizeCoordModeAttr')(coord_mode, context=_ods_context))
    if ppl_flag is not None: attributes["ppl_flag"] = (ppl_flag if (
        issubclass(type(ppl_flag), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ppl_flag, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shapeT(self):
    return self.operation.operands[1]

  @builtins.property
  def buffer(self):
    return self.operation.operands[2]

  @builtins.property
  def scale_h(self):
    return self.operation.attributes["scale_h"]

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return self.operation.attributes["scale_w"]

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def coord_mode(self):
    return self.operation.attributes["coord_mode"]

  @coord_mode.setter
  def coord_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["coord_mode"] = value

  @builtins.property
  def ppl_flag(self):
    return self.operation.attributes["ppl_flag"]

  @ppl_flag.setter
  def ppl_flag(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ppl_flag"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class JoinOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Join"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LRNOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LRN"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, mantissa, size, *, alpha=None, beta=None, bias=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(mantissa))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["size"] = (size if (
    issubclass(type(size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(size, context=_ods_context))
    if alpha is not None: attributes["alpha"] = (alpha if (
        issubclass(type(alpha), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    if beta is not None: attributes["beta"] = (beta if (
        issubclass(type(beta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    if bias is not None: attributes["bias"] = (bias if (
        issubclass(type(bias), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(bias, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def mantissa(self):
    return self.operation.operands[2]

  @builtins.property
  def size(self):
    return self.operation.attributes["size"]

  @size.setter
  def size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["size"] = value

  @builtins.property
  def alpha(self):
    return self.operation.attributes["alpha"]

  @alpha.setter
  def alpha(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["alpha"] = value

  @builtins.property
  def beta(self):
    return self.operation.attributes["beta"]

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def bias(self):
    return self.operation.attributes["bias"]

  @bias.setter
  def bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bias"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LSTMOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LSTM"

  _ODS_REGIONS = (0, True)

  def __init__(self, Y, Y_h, Y_c, input, filter, recurrence, bias, initial_h, initial_c, cont, buffer, sigmoid_table, sigmoid_slope_table, tanh_table, tanh_slope_table, hidden_size, bidirectional, *, batch_first=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(filter))
    operands.append(_get_op_result_or_value(recurrence))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(initial_h))
    operands.append(_get_op_result_or_value(initial_c))
    operands.append(_get_op_result_or_value(cont))
    operands.append(_get_op_result_or_value(buffer))
    operands.append(_get_op_result_or_value(sigmoid_table))
    operands.append(_get_op_result_or_value(sigmoid_slope_table))
    operands.append(_get_op_result_or_value(tanh_table))
    operands.append(_get_op_result_or_value(tanh_slope_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["hidden_size"] = (hidden_size if (
    issubclass(type(hidden_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(hidden_size, context=_ods_context))
    attributes["bidirectional"] = (bidirectional if (
    issubclass(type(bidirectional), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(bidirectional, context=_ods_context))
    if batch_first is not None: attributes["batch_first"] = (batch_first if (
        issubclass(type(batch_first), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(batch_first, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(Y)
    results.append(Y_h)
    results.append(Y_c)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def filter(self):
    return self.operation.operands[1]

  @builtins.property
  def recurrence(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def initial_h(self):
    return self.operation.operands[4]

  @builtins.property
  def initial_c(self):
    return self.operation.operands[5]

  @builtins.property
  def cont(self):
    return self.operation.operands[6]

  @builtins.property
  def buffer(self):
    return self.operation.operands[7]

  @builtins.property
  def sigmoid_table(self):
    return self.operation.operands[8]

  @builtins.property
  def sigmoid_slope_table(self):
    return self.operation.operands[9]

  @builtins.property
  def tanh_table(self):
    return self.operation.operands[10]

  @builtins.property
  def tanh_slope_table(self):
    return self.operation.operands[11]

  @builtins.property
  def hidden_size(self):
    return self.operation.attributes["hidden_size"]

  @hidden_size.setter
  def hidden_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hidden_size"] = value

  @builtins.property
  def bidirectional(self):
    return self.operation.attributes["bidirectional"]

  @bidirectional.setter
  def bidirectional(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bidirectional"] = value

  @builtins.property
  def batch_first(self):
    return self.operation.attributes["batch_first"]

  @batch_first.setter
  def batch_first(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["batch_first"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def Y(self):
    return self.operation.results[0]

  @builtins.property
  def Y_h(self):
    return self.operation.results[1]

  @builtins.property
  def Y_c(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LayerNormBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LayerNormBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_input, grad_weight, grad_bias, grad_out, input, mean, variance, weight, bias, normalized_shape, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_out))
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mean))
    operands.append(_get_op_result_or_value(variance))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["normalized_shape"] = (normalized_shape if (
    issubclass(type(normalized_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(normalized_shape, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(grad_input)
    results.append(grad_weight)
    results.append(grad_bias)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_out(self):
    return self.operation.operands[0]

  @builtins.property
  def input(self):
    return self.operation.operands[1]

  @builtins.property
  def mean(self):
    return self.operation.operands[2]

  @builtins.property
  def variance(self):
    return self.operation.operands[3]

  @builtins.property
  def weight(self):
    return self.operation.operands[4]

  @builtins.property
  def bias(self):
    return self.operation.operands[5]

  @builtins.property
  def normalized_shape(self):
    return self.operation.attributes["normalized_shape"]

  @normalized_shape.setter
  def normalized_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["normalized_shape"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def grad_input(self):
    return self.operation.results[0]

  @builtins.property
  def grad_weight(self):
    return self.operation.results[1]

  @builtins.property
  def grad_bias(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LayerNormCastOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LayerNormCast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, axis, eps, *, round_mode=None, isCastAtEnd=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if isCastAtEnd is not None: attributes["isCastAtEnd"] = (isCastAtEnd if (
        issubclass(type(isCastAtEnd), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(isCastAtEnd, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def isCastAtEnd(self):
    return self.operation.attributes["isCastAtEnd"]

  @isCastAtEnd.setter
  def isCastAtEnd(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["isCastAtEnd"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LayerNormOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LayerNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, table, mantissa_table, normalized_shape, axis, eps, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(mantissa_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["normalized_shape"] = (normalized_shape if (
    issubclass(type(normalized_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(normalized_shape, context=_ods_context))
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def table(self):
    return self.operation.operands[3]

  @builtins.property
  def mantissa_table(self):
    return self.operation.operands[4]

  @builtins.property
  def normalized_shape(self):
    return self.operation.attributes["normalized_shape"]

  @normalized_shape.setter
  def normalized_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["normalized_shape"] = value

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LayerNormTrainOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LayerNormTrain"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mean, variance, input, weight, bias, normalized_shape, axis, eps, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["normalized_shape"] = (normalized_shape if (
    issubclass(type(normalized_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(normalized_shape, context=_ods_context))
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    results.append(mean)
    results.append(variance)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def normalized_shape(self):
    return self.operation.attributes["normalized_shape"]

  @normalized_shape.setter
  def normalized_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["normalized_shape"] = value

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mean(self):
    return self.operation.results[1]

  @builtins.property
  def variance(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LeakyReluOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LeakyRelu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, alpha=None, multiplier=None, multiplier_neg=None, rshift=None, rshift_neg=None, round_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if alpha is not None: attributes["alpha"] = (alpha if (
        issubclass(type(alpha), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(alpha, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if multiplier_neg is not None: attributes["multiplier_neg"] = (multiplier_neg if (
        issubclass(type(multiplier_neg), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier_neg, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if rshift_neg is not None: attributes["rshift_neg"] = (rshift_neg if (
        issubclass(type(rshift_neg), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift_neg, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def alpha(self):
    if "alpha" not in self.operation.attributes:
      return None
    return self.operation.attributes["alpha"]

  @alpha.setter
  def alpha(self, value):
    if value is not None:
      self.operation.attributes["alpha"] = value
    elif "alpha" in self.operation.attributes:
      del self.operation.attributes["alpha"]

  @alpha.deleter
  def alpha(self):
    del self.operation.attributes["alpha"]

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def multiplier_neg(self):
    if "multiplier_neg" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier_neg"]

  @multiplier_neg.setter
  def multiplier_neg(self, value):
    if value is not None:
      self.operation.attributes["multiplier_neg"] = value
    elif "multiplier_neg" in self.operation.attributes:
      del self.operation.attributes["multiplier_neg"]

  @multiplier_neg.deleter
  def multiplier_neg(self):
    del self.operation.attributes["multiplier_neg"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def rshift_neg(self):
    if "rshift_neg" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift_neg"]

  @rshift_neg.setter
  def rshift_neg(self, value):
    if value is not None:
      self.operation.attributes["rshift_neg"] = value
    elif "rshift_neg" in self.operation.attributes:
      del self.operation.attributes["rshift_neg"]

  @rshift_neg.deleter
  def rshift_neg(self):
    del self.operation.attributes["rshift_neg"]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoadOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Load"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, do_bcast=None, use_3ic_optimize=None, lmem_type=None, ginfo=None, support_compress=None, is_idx_weight=None, compress_info=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_bcast is not None: attributes["do_bcast"] = (do_bcast if (
        issubclass(type(do_bcast), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_bcast, context=_ods_context))
    if use_3ic_optimize is not None: attributes["use_3ic_optimize"] = (use_3ic_optimize if (
        issubclass(type(use_3ic_optimize), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(use_3ic_optimize, context=_ods_context))
    if lmem_type is not None: attributes["lmem_type"] = (lmem_type if (
        issubclass(type(lmem_type), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(lmem_type, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if support_compress is not None: attributes["support_compress"] = (support_compress if (
        issubclass(type(support_compress), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(support_compress, context=_ods_context))
    if is_idx_weight is not None: attributes["is_idx_weight"] = (is_idx_weight if (
        issubclass(type(is_idx_weight), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_idx_weight, context=_ods_context))
    if compress_info is not None: attributes["compress_info"] = (compress_info if (
        issubclass(type(compress_info), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_CompressAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_CompressAttr')(compress_info, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def do_bcast(self):
    return self.operation.attributes["do_bcast"]

  @do_bcast.setter
  def do_bcast(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_bcast"] = value

  @builtins.property
  def use_3ic_optimize(self):
    return self.operation.attributes["use_3ic_optimize"]

  @use_3ic_optimize.setter
  def use_3ic_optimize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_3ic_optimize"] = value

  @builtins.property
  def lmem_type(self):
    return self.operation.attributes["lmem_type"]

  @lmem_type.setter
  def lmem_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lmem_type"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def support_compress(self):
    return self.operation.attributes["support_compress"]

  @support_compress.setter
  def support_compress(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["support_compress"] = value

  @builtins.property
  def is_idx_weight(self):
    return self.operation.attributes["is_idx_weight"]

  @is_idx_weight.setter
  def is_idx_weight(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_idx_weight"] = value

  @builtins.property
  def compress_info(self):
    if "compress_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["compress_info"]

  @compress_info.setter
  def compress_info(self, value):
    if value is not None:
      self.operation.attributes["compress_info"] = value
    elif "compress_info" in self.operation.attributes:
      del self.operation.attributes["compress_info"]

  @compress_info.deleter
  def compress_info(self):
    del self.operation.attributes["compress_info"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoadToL2MOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LoadToL2M"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, buffer, id, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["id"] = (id if (
    issubclass(type(id), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(id, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def id(self):
    return self.operation.attributes["id"]

  @id.setter
  def id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["id"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LogicalAndOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LogicalAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LoopOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Loop"

  _ODS_REGIONS = (1, True)

  def __init__(self, v_final_and_scan_outputs, M, cond, v_initial, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(M))
    operands.append(_get_op_result_or_value(cond))
    operands.extend(_get_op_results_or_values(v_initial))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(v_final_and_scan_outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def M(self):
    return self.operation.operands[0]

  @builtins.property
  def cond(self):
    return self.operation.operands[1]

  @builtins.property
  def v_initial(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def v_final_and_scan_outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LutBF16Op(_ods_ir.OpView):
  OPERATION_NAME = "tpu.LutBF16"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, mantissa, *, max_range=None, min_range=None, lut_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(mantissa))
    _ods_context = _ods_get_default_loc_context(loc)
    if max_range is not None: attributes["max_range"] = (max_range if (
        issubclass(type(max_range), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(max_range, context=_ods_context))
    if min_range is not None: attributes["min_range"] = (min_range if (
        issubclass(type(min_range), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(min_range, context=_ods_context))
    if lut_mode is not None: attributes["lut_mode"] = (lut_mode if (
        issubclass(type(lut_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LutBF16ModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LutBF16ModeAttr')(lut_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def mantissa(self):
    return self.operation.operands[2]

  @builtins.property
  def max_range(self):
    return self.operation.attributes["max_range"]

  @max_range.setter
  def max_range(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_range"] = value

  @builtins.property
  def min_range(self):
    return self.operation.attributes["min_range"]

  @min_range.setter
  def min_range(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min_range"] = value

  @builtins.property
  def lut_mode(self):
    return self.operation.attributes["lut_mode"]

  @lut_mode.setter
  def lut_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lut_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LutOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Lut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, *, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    _ods_context = _ods_get_default_loc_context(loc)
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskRCNNBboxPoolerOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaskRCNN_BboxPooler"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_res, result_rois, ptr_feat0, ptr_feat1, ptr_feat2, ptr_feat3, rois_multi_batch, ptr_tmp_res, ptr_rois_tmp, ROI_NUM_LEVELS, ROI_H, ROI_W, CHANNEL_ROI, ROI_SLICE, ROI_PH, ROI_PW, ROI_LEN, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr_feat0))
    operands.append(_get_op_result_or_value(ptr_feat1))
    operands.append(_get_op_result_or_value(ptr_feat2))
    operands.append(_get_op_result_or_value(ptr_feat3))
    operands.append(_get_op_result_or_value(rois_multi_batch))
    operands.append(_get_op_result_or_value(ptr_tmp_res))
    operands.append(_get_op_result_or_value(ptr_rois_tmp))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ROI_NUM_LEVELS"] = (ROI_NUM_LEVELS if (
    issubclass(type(ROI_NUM_LEVELS), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_NUM_LEVELS, context=_ods_context))
    attributes["ROI_H"] = (ROI_H if (
    issubclass(type(ROI_H), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_H, context=_ods_context))
    attributes["ROI_W"] = (ROI_W if (
    issubclass(type(ROI_W), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_W, context=_ods_context))
    attributes["CHANNEL_ROI"] = (CHANNEL_ROI if (
    issubclass(type(CHANNEL_ROI), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(CHANNEL_ROI, context=_ods_context))
    attributes["ROI_SLICE"] = (ROI_SLICE if (
    issubclass(type(ROI_SLICE), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_SLICE, context=_ods_context))
    attributes["ROI_PH"] = (ROI_PH if (
    issubclass(type(ROI_PH), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_PH, context=_ods_context))
    attributes["ROI_PW"] = (ROI_PW if (
    issubclass(type(ROI_PW), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_PW, context=_ods_context))
    attributes["ROI_LEN"] = (ROI_LEN if (
    issubclass(type(ROI_LEN), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_LEN, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(result_res)
    results.append(result_rois)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr_feat0(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr_feat1(self):
    return self.operation.operands[1]

  @builtins.property
  def ptr_feat2(self):
    return self.operation.operands[2]

  @builtins.property
  def ptr_feat3(self):
    return self.operation.operands[3]

  @builtins.property
  def rois_multi_batch(self):
    return self.operation.operands[4]

  @builtins.property
  def ptr_tmp_res(self):
    return self.operation.operands[5]

  @builtins.property
  def ptr_rois_tmp(self):
    return self.operation.operands[6]

  @builtins.property
  def ROI_NUM_LEVELS(self):
    return self.operation.attributes["ROI_NUM_LEVELS"]

  @ROI_NUM_LEVELS.setter
  def ROI_NUM_LEVELS(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_NUM_LEVELS"] = value

  @builtins.property
  def ROI_H(self):
    return self.operation.attributes["ROI_H"]

  @ROI_H.setter
  def ROI_H(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_H"] = value

  @builtins.property
  def ROI_W(self):
    return self.operation.attributes["ROI_W"]

  @ROI_W.setter
  def ROI_W(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_W"] = value

  @builtins.property
  def CHANNEL_ROI(self):
    return self.operation.attributes["CHANNEL_ROI"]

  @CHANNEL_ROI.setter
  def CHANNEL_ROI(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["CHANNEL_ROI"] = value

  @builtins.property
  def ROI_SLICE(self):
    return self.operation.attributes["ROI_SLICE"]

  @ROI_SLICE.setter
  def ROI_SLICE(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_SLICE"] = value

  @builtins.property
  def ROI_PH(self):
    return self.operation.attributes["ROI_PH"]

  @ROI_PH.setter
  def ROI_PH(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_PH"] = value

  @builtins.property
  def ROI_PW(self):
    return self.operation.attributes["ROI_PW"]

  @ROI_PW.setter
  def ROI_PW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_PW"] = value

  @builtins.property
  def ROI_LEN(self):
    return self.operation.attributes["ROI_LEN"]

  @ROI_LEN.setter
  def ROI_LEN(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_LEN"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def result_res(self):
    return self.operation.results[0]

  @builtins.property
  def result_rois(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskRCNNGetBboxBOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaskRCNN_GetBboxB"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_det_bboxes, result_det_labels, ptr_rois, ptr_bbox, ptr_score, max_val, scale_factor, means, stds, res_bbox, res_bbox1, res_bbox0, res_score0, res_score1, res_score2, res_score3, res_label2, result_list, keep_3nch, keep_u32_1h, glb_buffer_boxes, glb_buffer_scores, glb_buffer_nms, glb_buffer_nonzero, result_valid_ind, glb_lables, glb_lables_expand, threshold_score_eq, wh_ratio_log, nms_iou_thr, delta2bbox_means, delta2bbox_stds_0, delta2bbox_stds_1, NUM_INDEXES, NUM_CLASSES, TOPK_ONNX_NMS, NUM_CLASSES_getBboxB, MAX_NMS_LENGTH_GetBboxB, MAX_PER_IMG, MAX_PER_IMG_GetBboxB, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(ptr_rois))
    operands.append(_get_op_result_or_value(ptr_bbox))
    operands.append(_get_op_result_or_value(ptr_score))
    operands.append(_get_op_result_or_value(max_val))
    operands.append(_get_op_result_or_value(scale_factor))
    operands.append(_get_op_result_or_value(means))
    operands.append(_get_op_result_or_value(stds))
    operands.append(_get_op_result_or_value(res_bbox))
    operands.append(_get_op_result_or_value(res_bbox1))
    operands.append(_get_op_result_or_value(res_bbox0))
    operands.append(_get_op_result_or_value(res_score0))
    operands.append(_get_op_result_or_value(res_score1))
    operands.append(_get_op_result_or_value(res_score2))
    operands.append(_get_op_result_or_value(res_score3))
    operands.append(_get_op_result_or_value(res_label2))
    operands.append(_get_op_result_or_value(result_list))
    operands.append(_get_op_result_or_value(keep_3nch))
    operands.append(_get_op_result_or_value(keep_u32_1h))
    operands.append(_get_op_result_or_value(glb_buffer_boxes))
    operands.append(_get_op_result_or_value(glb_buffer_scores))
    operands.append(_get_op_result_or_value(glb_buffer_nms))
    operands.append(_get_op_result_or_value(glb_buffer_nonzero))
    operands.append(_get_op_result_or_value(result_valid_ind))
    operands.append(_get_op_result_or_value(glb_lables))
    operands.append(_get_op_result_or_value(glb_lables_expand))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["threshold_score_eq"] = (threshold_score_eq if (
    issubclass(type(threshold_score_eq), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(threshold_score_eq, context=_ods_context))
    attributes["wh_ratio_log"] = (wh_ratio_log if (
    issubclass(type(wh_ratio_log), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(wh_ratio_log, context=_ods_context))
    attributes["nms_iou_thr"] = (nms_iou_thr if (
    issubclass(type(nms_iou_thr), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_iou_thr, context=_ods_context))
    attributes["delta2bbox_means"] = (delta2bbox_means if (
    issubclass(type(delta2bbox_means), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_means, context=_ods_context))
    attributes["delta2bbox_stds_0"] = (delta2bbox_stds_0 if (
    issubclass(type(delta2bbox_stds_0), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_stds_0, context=_ods_context))
    attributes["delta2bbox_stds_1"] = (delta2bbox_stds_1 if (
    issubclass(type(delta2bbox_stds_1), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_stds_1, context=_ods_context))
    attributes["NUM_INDEXES"] = (NUM_INDEXES if (
    issubclass(type(NUM_INDEXES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_INDEXES, context=_ods_context))
    attributes["NUM_CLASSES"] = (NUM_CLASSES if (
    issubclass(type(NUM_CLASSES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_CLASSES, context=_ods_context))
    attributes["TOPK_ONNX_NMS"] = (TOPK_ONNX_NMS if (
    issubclass(type(TOPK_ONNX_NMS), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(TOPK_ONNX_NMS, context=_ods_context))
    attributes["NUM_CLASSES_getBboxB"] = (NUM_CLASSES_getBboxB if (
    issubclass(type(NUM_CLASSES_getBboxB), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_CLASSES_getBboxB, context=_ods_context))
    attributes["MAX_NMS_LENGTH_GetBboxB"] = (MAX_NMS_LENGTH_GetBboxB if (
    issubclass(type(MAX_NMS_LENGTH_GetBboxB), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_NMS_LENGTH_GetBboxB, context=_ods_context))
    attributes["MAX_PER_IMG"] = (MAX_PER_IMG if (
    issubclass(type(MAX_PER_IMG), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_PER_IMG, context=_ods_context))
    attributes["MAX_PER_IMG_GetBboxB"] = (MAX_PER_IMG_GetBboxB if (
    issubclass(type(MAX_PER_IMG_GetBboxB), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_PER_IMG_GetBboxB, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(result_det_bboxes)
    results.append(result_det_labels)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def ptr_rois(self):
    return self.operation.operands[0]

  @builtins.property
  def ptr_bbox(self):
    return self.operation.operands[1]

  @builtins.property
  def ptr_score(self):
    return self.operation.operands[2]

  @builtins.property
  def max_val(self):
    return self.operation.operands[3]

  @builtins.property
  def scale_factor(self):
    return self.operation.operands[4]

  @builtins.property
  def means(self):
    return self.operation.operands[5]

  @builtins.property
  def stds(self):
    return self.operation.operands[6]

  @builtins.property
  def res_bbox(self):
    return self.operation.operands[7]

  @builtins.property
  def res_bbox1(self):
    return self.operation.operands[8]

  @builtins.property
  def res_bbox0(self):
    return self.operation.operands[9]

  @builtins.property
  def res_score0(self):
    return self.operation.operands[10]

  @builtins.property
  def res_score1(self):
    return self.operation.operands[11]

  @builtins.property
  def res_score2(self):
    return self.operation.operands[12]

  @builtins.property
  def res_score3(self):
    return self.operation.operands[13]

  @builtins.property
  def res_label2(self):
    return self.operation.operands[14]

  @builtins.property
  def result_list(self):
    return self.operation.operands[15]

  @builtins.property
  def keep_3nch(self):
    return self.operation.operands[16]

  @builtins.property
  def keep_u32_1h(self):
    return self.operation.operands[17]

  @builtins.property
  def glb_buffer_boxes(self):
    return self.operation.operands[18]

  @builtins.property
  def glb_buffer_scores(self):
    return self.operation.operands[19]

  @builtins.property
  def glb_buffer_nms(self):
    return self.operation.operands[20]

  @builtins.property
  def glb_buffer_nonzero(self):
    return self.operation.operands[21]

  @builtins.property
  def result_valid_ind(self):
    return self.operation.operands[22]

  @builtins.property
  def glb_lables(self):
    return self.operation.operands[23]

  @builtins.property
  def glb_lables_expand(self):
    return self.operation.operands[24]

  @builtins.property
  def threshold_score_eq(self):
    return self.operation.attributes["threshold_score_eq"]

  @threshold_score_eq.setter
  def threshold_score_eq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["threshold_score_eq"] = value

  @builtins.property
  def wh_ratio_log(self):
    return self.operation.attributes["wh_ratio_log"]

  @wh_ratio_log.setter
  def wh_ratio_log(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["wh_ratio_log"] = value

  @builtins.property
  def nms_iou_thr(self):
    return self.operation.attributes["nms_iou_thr"]

  @nms_iou_thr.setter
  def nms_iou_thr(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_iou_thr"] = value

  @builtins.property
  def delta2bbox_means(self):
    return self.operation.attributes["delta2bbox_means"]

  @delta2bbox_means.setter
  def delta2bbox_means(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_means"] = value

  @builtins.property
  def delta2bbox_stds_0(self):
    return self.operation.attributes["delta2bbox_stds_0"]

  @delta2bbox_stds_0.setter
  def delta2bbox_stds_0(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_stds_0"] = value

  @builtins.property
  def delta2bbox_stds_1(self):
    return self.operation.attributes["delta2bbox_stds_1"]

  @delta2bbox_stds_1.setter
  def delta2bbox_stds_1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_stds_1"] = value

  @builtins.property
  def NUM_INDEXES(self):
    return self.operation.attributes["NUM_INDEXES"]

  @NUM_INDEXES.setter
  def NUM_INDEXES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_INDEXES"] = value

  @builtins.property
  def NUM_CLASSES(self):
    return self.operation.attributes["NUM_CLASSES"]

  @NUM_CLASSES.setter
  def NUM_CLASSES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_CLASSES"] = value

  @builtins.property
  def TOPK_ONNX_NMS(self):
    return self.operation.attributes["TOPK_ONNX_NMS"]

  @TOPK_ONNX_NMS.setter
  def TOPK_ONNX_NMS(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["TOPK_ONNX_NMS"] = value

  @builtins.property
  def NUM_CLASSES_getBboxB(self):
    return self.operation.attributes["NUM_CLASSES_getBboxB"]

  @NUM_CLASSES_getBboxB.setter
  def NUM_CLASSES_getBboxB(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_CLASSES_getBboxB"] = value

  @builtins.property
  def MAX_NMS_LENGTH_GetBboxB(self):
    return self.operation.attributes["MAX_NMS_LENGTH_GetBboxB"]

  @MAX_NMS_LENGTH_GetBboxB.setter
  def MAX_NMS_LENGTH_GetBboxB(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_NMS_LENGTH_GetBboxB"] = value

  @builtins.property
  def MAX_PER_IMG(self):
    return self.operation.attributes["MAX_PER_IMG"]

  @MAX_PER_IMG.setter
  def MAX_PER_IMG(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_PER_IMG"] = value

  @builtins.property
  def MAX_PER_IMG_GetBboxB(self):
    return self.operation.attributes["MAX_PER_IMG_GetBboxB"]

  @MAX_PER_IMG_GetBboxB.setter
  def MAX_PER_IMG_GetBboxB(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_PER_IMG_GetBboxB"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def result_det_bboxes(self):
    return self.operation.results[0]

  @builtins.property
  def result_det_labels(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskRCNNMaskPoolerOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaskRCNN_MaskPooler"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_res, x_0, x_1, x_2, x_3, det_bboxes_multi_batch, det_labels_multi_batch, scale_factor, ptr_rois_buff, result_filled_det_bboxes, result_filled_det_labels, ptr_tmp_res, ptr_rois_tmp, ROI_NUM_LEVELS, ROI_H, ROI_W, CHANNEL_ROI, ROI_SLICE, ROI_PH, ROI_PW, ROI_LEN, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(x_0))
    operands.append(_get_op_result_or_value(x_1))
    operands.append(_get_op_result_or_value(x_2))
    operands.append(_get_op_result_or_value(x_3))
    operands.append(_get_op_result_or_value(det_bboxes_multi_batch))
    operands.append(_get_op_result_or_value(det_labels_multi_batch))
    operands.append(_get_op_result_or_value(scale_factor))
    operands.append(_get_op_result_or_value(ptr_rois_buff))
    operands.append(_get_op_result_or_value(result_filled_det_bboxes))
    operands.append(_get_op_result_or_value(result_filled_det_labels))
    operands.append(_get_op_result_or_value(ptr_tmp_res))
    operands.append(_get_op_result_or_value(ptr_rois_tmp))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ROI_NUM_LEVELS"] = (ROI_NUM_LEVELS if (
    issubclass(type(ROI_NUM_LEVELS), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_NUM_LEVELS, context=_ods_context))
    attributes["ROI_H"] = (ROI_H if (
    issubclass(type(ROI_H), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_H, context=_ods_context))
    attributes["ROI_W"] = (ROI_W if (
    issubclass(type(ROI_W), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_W, context=_ods_context))
    attributes["CHANNEL_ROI"] = (CHANNEL_ROI if (
    issubclass(type(CHANNEL_ROI), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(CHANNEL_ROI, context=_ods_context))
    attributes["ROI_SLICE"] = (ROI_SLICE if (
    issubclass(type(ROI_SLICE), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_SLICE, context=_ods_context))
    attributes["ROI_PH"] = (ROI_PH if (
    issubclass(type(ROI_PH), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_PH, context=_ods_context))
    attributes["ROI_PW"] = (ROI_PW if (
    issubclass(type(ROI_PW), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_PW, context=_ods_context))
    attributes["ROI_LEN"] = (ROI_LEN if (
    issubclass(type(ROI_LEN), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ROI_LEN, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(result_res)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def x_0(self):
    return self.operation.operands[0]

  @builtins.property
  def x_1(self):
    return self.operation.operands[1]

  @builtins.property
  def x_2(self):
    return self.operation.operands[2]

  @builtins.property
  def x_3(self):
    return self.operation.operands[3]

  @builtins.property
  def det_bboxes_multi_batch(self):
    return self.operation.operands[4]

  @builtins.property
  def det_labels_multi_batch(self):
    return self.operation.operands[5]

  @builtins.property
  def scale_factor(self):
    return self.operation.operands[6]

  @builtins.property
  def ptr_rois_buff(self):
    return self.operation.operands[7]

  @builtins.property
  def result_filled_det_bboxes(self):
    return self.operation.operands[8]

  @builtins.property
  def result_filled_det_labels(self):
    return self.operation.operands[9]

  @builtins.property
  def ptr_tmp_res(self):
    return self.operation.operands[10]

  @builtins.property
  def ptr_rois_tmp(self):
    return self.operation.operands[11]

  @builtins.property
  def ROI_NUM_LEVELS(self):
    return self.operation.attributes["ROI_NUM_LEVELS"]

  @ROI_NUM_LEVELS.setter
  def ROI_NUM_LEVELS(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_NUM_LEVELS"] = value

  @builtins.property
  def ROI_H(self):
    return self.operation.attributes["ROI_H"]

  @ROI_H.setter
  def ROI_H(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_H"] = value

  @builtins.property
  def ROI_W(self):
    return self.operation.attributes["ROI_W"]

  @ROI_W.setter
  def ROI_W(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_W"] = value

  @builtins.property
  def CHANNEL_ROI(self):
    return self.operation.attributes["CHANNEL_ROI"]

  @CHANNEL_ROI.setter
  def CHANNEL_ROI(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["CHANNEL_ROI"] = value

  @builtins.property
  def ROI_SLICE(self):
    return self.operation.attributes["ROI_SLICE"]

  @ROI_SLICE.setter
  def ROI_SLICE(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_SLICE"] = value

  @builtins.property
  def ROI_PH(self):
    return self.operation.attributes["ROI_PH"]

  @ROI_PH.setter
  def ROI_PH(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_PH"] = value

  @builtins.property
  def ROI_PW(self):
    return self.operation.attributes["ROI_PW"]

  @ROI_PW.setter
  def ROI_PW(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_PW"] = value

  @builtins.property
  def ROI_LEN(self):
    return self.operation.attributes["ROI_LEN"]

  @ROI_LEN.setter
  def ROI_LEN(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ROI_LEN"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def result_res(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskRCNNRPNGetBboxesOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaskRCNN_RPNGetBboxes"

  _ODS_REGIONS = (0, True)

  def __init__(self, result_list, cls_scores_0, cls_scores_1, cls_scores_2, cls_scores_3, cls_scores_4, bbox_preds_0, bbox_preds_1, bbox_preds_2, bbox_preds_3, bbox_preds_4, max_shape, mlvl_anchors_0, mlvl_anchors_1, mlvl_anchors_2, mlvl_anchors_3, mlvl_anchors_4, batch_mlvl_scores, batch_mlvl_anchors, batch_mlvl_rpn_bbox_pred, batch_mlvl_proposals, batch_mlvl_ids, glb_buffer_tmp_scores_stretched, glb_buffer_ranked_scores, glb_buffer_rank_inds_int32, glb_buffer_rank_inds_u32, glb_topk_inds, glb_buffer_gather_1, glb_buffer_gather_2, glb_buffer_rpn_bbox_permuted, glb_buffer_nonzero, result_valid_ind, glb_buffer_gather_boxes, glb_buffer_gather_scores, keep_3nch, keep_u32_1h, glb_buffer_boxes, glb_buffer_scores, glb_buffer_nms, gather_mlvl_proposals, gather_mlvl_scores, gather_mlvl_ids, glb_buffer_result_list, delta2bbox_mean_0, delta2bbox_mean_1, delta2bbox_mean_2, delta2bbox_mean_3, delta2bbox_std_0, delta2bbox_std_1, delta2bbox_std_2, delta2bbox_std_3, delta2bbox_max_scalar_c, iou_threshold, conf_threshold, MAX_LENGTH_STATIC_STRECHED, NUM_INDEXES, NUM_CLASSES, CHANNEL_RPN_BBOXES, CHANNEL_RPN_SCORES, NMS_PRE, HARDWARE_FACTOR_TOPK, NMS_MAX_LENGTH, TOPK_ONNX_NMS, H_RPN_DYN_MAX, W_RPN_DYN_MAX, MAX_PER_IMG, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cls_scores_0))
    operands.append(_get_op_result_or_value(cls_scores_1))
    operands.append(_get_op_result_or_value(cls_scores_2))
    operands.append(_get_op_result_or_value(cls_scores_3))
    operands.append(_get_op_result_or_value(cls_scores_4))
    operands.append(_get_op_result_or_value(bbox_preds_0))
    operands.append(_get_op_result_or_value(bbox_preds_1))
    operands.append(_get_op_result_or_value(bbox_preds_2))
    operands.append(_get_op_result_or_value(bbox_preds_3))
    operands.append(_get_op_result_or_value(bbox_preds_4))
    operands.append(_get_op_result_or_value(max_shape))
    operands.append(_get_op_result_or_value(mlvl_anchors_0))
    operands.append(_get_op_result_or_value(mlvl_anchors_1))
    operands.append(_get_op_result_or_value(mlvl_anchors_2))
    operands.append(_get_op_result_or_value(mlvl_anchors_3))
    operands.append(_get_op_result_or_value(mlvl_anchors_4))
    operands.append(_get_op_result_or_value(batch_mlvl_scores))
    operands.append(_get_op_result_or_value(batch_mlvl_anchors))
    operands.append(_get_op_result_or_value(batch_mlvl_rpn_bbox_pred))
    operands.append(_get_op_result_or_value(batch_mlvl_proposals))
    operands.append(_get_op_result_or_value(batch_mlvl_ids))
    operands.append(_get_op_result_or_value(glb_buffer_tmp_scores_stretched))
    operands.append(_get_op_result_or_value(glb_buffer_ranked_scores))
    operands.append(_get_op_result_or_value(glb_buffer_rank_inds_int32))
    operands.append(_get_op_result_or_value(glb_buffer_rank_inds_u32))
    operands.append(_get_op_result_or_value(glb_topk_inds))
    operands.append(_get_op_result_or_value(glb_buffer_gather_1))
    operands.append(_get_op_result_or_value(glb_buffer_gather_2))
    operands.append(_get_op_result_or_value(glb_buffer_rpn_bbox_permuted))
    operands.append(_get_op_result_or_value(glb_buffer_nonzero))
    operands.append(_get_op_result_or_value(result_valid_ind))
    operands.append(_get_op_result_or_value(glb_buffer_gather_boxes))
    operands.append(_get_op_result_or_value(glb_buffer_gather_scores))
    operands.append(_get_op_result_or_value(keep_3nch))
    operands.append(_get_op_result_or_value(keep_u32_1h))
    operands.append(_get_op_result_or_value(glb_buffer_boxes))
    operands.append(_get_op_result_or_value(glb_buffer_scores))
    operands.append(_get_op_result_or_value(glb_buffer_nms))
    operands.append(_get_op_result_or_value(gather_mlvl_proposals))
    operands.append(_get_op_result_or_value(gather_mlvl_scores))
    operands.append(_get_op_result_or_value(gather_mlvl_ids))
    operands.append(_get_op_result_or_value(glb_buffer_result_list))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["delta2bbox_mean_0"] = (delta2bbox_mean_0 if (
    issubclass(type(delta2bbox_mean_0), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_mean_0, context=_ods_context))
    attributes["delta2bbox_mean_1"] = (delta2bbox_mean_1 if (
    issubclass(type(delta2bbox_mean_1), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_mean_1, context=_ods_context))
    attributes["delta2bbox_mean_2"] = (delta2bbox_mean_2 if (
    issubclass(type(delta2bbox_mean_2), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_mean_2, context=_ods_context))
    attributes["delta2bbox_mean_3"] = (delta2bbox_mean_3 if (
    issubclass(type(delta2bbox_mean_3), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_mean_3, context=_ods_context))
    attributes["delta2bbox_std_0"] = (delta2bbox_std_0 if (
    issubclass(type(delta2bbox_std_0), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_std_0, context=_ods_context))
    attributes["delta2bbox_std_1"] = (delta2bbox_std_1 if (
    issubclass(type(delta2bbox_std_1), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_std_1, context=_ods_context))
    attributes["delta2bbox_std_2"] = (delta2bbox_std_2 if (
    issubclass(type(delta2bbox_std_2), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_std_2, context=_ods_context))
    attributes["delta2bbox_std_3"] = (delta2bbox_std_3 if (
    issubclass(type(delta2bbox_std_3), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_std_3, context=_ods_context))
    attributes["delta2bbox_max_scalar_c"] = (delta2bbox_max_scalar_c if (
    issubclass(type(delta2bbox_max_scalar_c), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(delta2bbox_max_scalar_c, context=_ods_context))
    attributes["iou_threshold"] = (iou_threshold if (
    issubclass(type(iou_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(iou_threshold, context=_ods_context))
    attributes["conf_threshold"] = (conf_threshold if (
    issubclass(type(conf_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(conf_threshold, context=_ods_context))
    attributes["MAX_LENGTH_STATIC_STRECHED"] = (MAX_LENGTH_STATIC_STRECHED if (
    issubclass(type(MAX_LENGTH_STATIC_STRECHED), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_LENGTH_STATIC_STRECHED, context=_ods_context))
    attributes["NUM_INDEXES"] = (NUM_INDEXES if (
    issubclass(type(NUM_INDEXES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_INDEXES, context=_ods_context))
    attributes["NUM_CLASSES"] = (NUM_CLASSES if (
    issubclass(type(NUM_CLASSES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NUM_CLASSES, context=_ods_context))
    attributes["CHANNEL_RPN_BBOXES"] = (CHANNEL_RPN_BBOXES if (
    issubclass(type(CHANNEL_RPN_BBOXES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(CHANNEL_RPN_BBOXES, context=_ods_context))
    attributes["CHANNEL_RPN_SCORES"] = (CHANNEL_RPN_SCORES if (
    issubclass(type(CHANNEL_RPN_SCORES), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(CHANNEL_RPN_SCORES, context=_ods_context))
    attributes["NMS_PRE"] = (NMS_PRE if (
    issubclass(type(NMS_PRE), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NMS_PRE, context=_ods_context))
    attributes["HARDWARE_FACTOR_TOPK"] = (HARDWARE_FACTOR_TOPK if (
    issubclass(type(HARDWARE_FACTOR_TOPK), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(HARDWARE_FACTOR_TOPK, context=_ods_context))
    attributes["NMS_MAX_LENGTH"] = (NMS_MAX_LENGTH if (
    issubclass(type(NMS_MAX_LENGTH), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(NMS_MAX_LENGTH, context=_ods_context))
    attributes["TOPK_ONNX_NMS"] = (TOPK_ONNX_NMS if (
    issubclass(type(TOPK_ONNX_NMS), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(TOPK_ONNX_NMS, context=_ods_context))
    attributes["H_RPN_DYN_MAX"] = (H_RPN_DYN_MAX if (
    issubclass(type(H_RPN_DYN_MAX), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(H_RPN_DYN_MAX, context=_ods_context))
    attributes["W_RPN_DYN_MAX"] = (W_RPN_DYN_MAX if (
    issubclass(type(W_RPN_DYN_MAX), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(W_RPN_DYN_MAX, context=_ods_context))
    attributes["MAX_PER_IMG"] = (MAX_PER_IMG if (
    issubclass(type(MAX_PER_IMG), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(MAX_PER_IMG, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(result_list)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cls_scores_0(self):
    return self.operation.operands[0]

  @builtins.property
  def cls_scores_1(self):
    return self.operation.operands[1]

  @builtins.property
  def cls_scores_2(self):
    return self.operation.operands[2]

  @builtins.property
  def cls_scores_3(self):
    return self.operation.operands[3]

  @builtins.property
  def cls_scores_4(self):
    return self.operation.operands[4]

  @builtins.property
  def bbox_preds_0(self):
    return self.operation.operands[5]

  @builtins.property
  def bbox_preds_1(self):
    return self.operation.operands[6]

  @builtins.property
  def bbox_preds_2(self):
    return self.operation.operands[7]

  @builtins.property
  def bbox_preds_3(self):
    return self.operation.operands[8]

  @builtins.property
  def bbox_preds_4(self):
    return self.operation.operands[9]

  @builtins.property
  def max_shape(self):
    return self.operation.operands[10]

  @builtins.property
  def mlvl_anchors_0(self):
    return self.operation.operands[11]

  @builtins.property
  def mlvl_anchors_1(self):
    return self.operation.operands[12]

  @builtins.property
  def mlvl_anchors_2(self):
    return self.operation.operands[13]

  @builtins.property
  def mlvl_anchors_3(self):
    return self.operation.operands[14]

  @builtins.property
  def mlvl_anchors_4(self):
    return self.operation.operands[15]

  @builtins.property
  def batch_mlvl_scores(self):
    return self.operation.operands[16]

  @builtins.property
  def batch_mlvl_anchors(self):
    return self.operation.operands[17]

  @builtins.property
  def batch_mlvl_rpn_bbox_pred(self):
    return self.operation.operands[18]

  @builtins.property
  def batch_mlvl_proposals(self):
    return self.operation.operands[19]

  @builtins.property
  def batch_mlvl_ids(self):
    return self.operation.operands[20]

  @builtins.property
  def glb_buffer_tmp_scores_stretched(self):
    return self.operation.operands[21]

  @builtins.property
  def glb_buffer_ranked_scores(self):
    return self.operation.operands[22]

  @builtins.property
  def glb_buffer_rank_inds_int32(self):
    return self.operation.operands[23]

  @builtins.property
  def glb_buffer_rank_inds_u32(self):
    return self.operation.operands[24]

  @builtins.property
  def glb_topk_inds(self):
    return self.operation.operands[25]

  @builtins.property
  def glb_buffer_gather_1(self):
    return self.operation.operands[26]

  @builtins.property
  def glb_buffer_gather_2(self):
    return self.operation.operands[27]

  @builtins.property
  def glb_buffer_rpn_bbox_permuted(self):
    return self.operation.operands[28]

  @builtins.property
  def glb_buffer_nonzero(self):
    return self.operation.operands[29]

  @builtins.property
  def result_valid_ind(self):
    return self.operation.operands[30]

  @builtins.property
  def glb_buffer_gather_boxes(self):
    return self.operation.operands[31]

  @builtins.property
  def glb_buffer_gather_scores(self):
    return self.operation.operands[32]

  @builtins.property
  def keep_3nch(self):
    return self.operation.operands[33]

  @builtins.property
  def keep_u32_1h(self):
    return self.operation.operands[34]

  @builtins.property
  def glb_buffer_boxes(self):
    return self.operation.operands[35]

  @builtins.property
  def glb_buffer_scores(self):
    return self.operation.operands[36]

  @builtins.property
  def glb_buffer_nms(self):
    return self.operation.operands[37]

  @builtins.property
  def gather_mlvl_proposals(self):
    return self.operation.operands[38]

  @builtins.property
  def gather_mlvl_scores(self):
    return self.operation.operands[39]

  @builtins.property
  def gather_mlvl_ids(self):
    return self.operation.operands[40]

  @builtins.property
  def glb_buffer_result_list(self):
    return self.operation.operands[41]

  @builtins.property
  def delta2bbox_mean_0(self):
    return self.operation.attributes["delta2bbox_mean_0"]

  @delta2bbox_mean_0.setter
  def delta2bbox_mean_0(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_mean_0"] = value

  @builtins.property
  def delta2bbox_mean_1(self):
    return self.operation.attributes["delta2bbox_mean_1"]

  @delta2bbox_mean_1.setter
  def delta2bbox_mean_1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_mean_1"] = value

  @builtins.property
  def delta2bbox_mean_2(self):
    return self.operation.attributes["delta2bbox_mean_2"]

  @delta2bbox_mean_2.setter
  def delta2bbox_mean_2(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_mean_2"] = value

  @builtins.property
  def delta2bbox_mean_3(self):
    return self.operation.attributes["delta2bbox_mean_3"]

  @delta2bbox_mean_3.setter
  def delta2bbox_mean_3(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_mean_3"] = value

  @builtins.property
  def delta2bbox_std_0(self):
    return self.operation.attributes["delta2bbox_std_0"]

  @delta2bbox_std_0.setter
  def delta2bbox_std_0(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_std_0"] = value

  @builtins.property
  def delta2bbox_std_1(self):
    return self.operation.attributes["delta2bbox_std_1"]

  @delta2bbox_std_1.setter
  def delta2bbox_std_1(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_std_1"] = value

  @builtins.property
  def delta2bbox_std_2(self):
    return self.operation.attributes["delta2bbox_std_2"]

  @delta2bbox_std_2.setter
  def delta2bbox_std_2(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_std_2"] = value

  @builtins.property
  def delta2bbox_std_3(self):
    return self.operation.attributes["delta2bbox_std_3"]

  @delta2bbox_std_3.setter
  def delta2bbox_std_3(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_std_3"] = value

  @builtins.property
  def delta2bbox_max_scalar_c(self):
    return self.operation.attributes["delta2bbox_max_scalar_c"]

  @delta2bbox_max_scalar_c.setter
  def delta2bbox_max_scalar_c(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["delta2bbox_max_scalar_c"] = value

  @builtins.property
  def iou_threshold(self):
    return self.operation.attributes["iou_threshold"]

  @iou_threshold.setter
  def iou_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iou_threshold"] = value

  @builtins.property
  def conf_threshold(self):
    return self.operation.attributes["conf_threshold"]

  @conf_threshold.setter
  def conf_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["conf_threshold"] = value

  @builtins.property
  def MAX_LENGTH_STATIC_STRECHED(self):
    return self.operation.attributes["MAX_LENGTH_STATIC_STRECHED"]

  @MAX_LENGTH_STATIC_STRECHED.setter
  def MAX_LENGTH_STATIC_STRECHED(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_LENGTH_STATIC_STRECHED"] = value

  @builtins.property
  def NUM_INDEXES(self):
    return self.operation.attributes["NUM_INDEXES"]

  @NUM_INDEXES.setter
  def NUM_INDEXES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_INDEXES"] = value

  @builtins.property
  def NUM_CLASSES(self):
    return self.operation.attributes["NUM_CLASSES"]

  @NUM_CLASSES.setter
  def NUM_CLASSES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NUM_CLASSES"] = value

  @builtins.property
  def CHANNEL_RPN_BBOXES(self):
    return self.operation.attributes["CHANNEL_RPN_BBOXES"]

  @CHANNEL_RPN_BBOXES.setter
  def CHANNEL_RPN_BBOXES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["CHANNEL_RPN_BBOXES"] = value

  @builtins.property
  def CHANNEL_RPN_SCORES(self):
    return self.operation.attributes["CHANNEL_RPN_SCORES"]

  @CHANNEL_RPN_SCORES.setter
  def CHANNEL_RPN_SCORES(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["CHANNEL_RPN_SCORES"] = value

  @builtins.property
  def NMS_PRE(self):
    return self.operation.attributes["NMS_PRE"]

  @NMS_PRE.setter
  def NMS_PRE(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NMS_PRE"] = value

  @builtins.property
  def HARDWARE_FACTOR_TOPK(self):
    return self.operation.attributes["HARDWARE_FACTOR_TOPK"]

  @HARDWARE_FACTOR_TOPK.setter
  def HARDWARE_FACTOR_TOPK(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["HARDWARE_FACTOR_TOPK"] = value

  @builtins.property
  def NMS_MAX_LENGTH(self):
    return self.operation.attributes["NMS_MAX_LENGTH"]

  @NMS_MAX_LENGTH.setter
  def NMS_MAX_LENGTH(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["NMS_MAX_LENGTH"] = value

  @builtins.property
  def TOPK_ONNX_NMS(self):
    return self.operation.attributes["TOPK_ONNX_NMS"]

  @TOPK_ONNX_NMS.setter
  def TOPK_ONNX_NMS(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["TOPK_ONNX_NMS"] = value

  @builtins.property
  def H_RPN_DYN_MAX(self):
    return self.operation.attributes["H_RPN_DYN_MAX"]

  @H_RPN_DYN_MAX.setter
  def H_RPN_DYN_MAX(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["H_RPN_DYN_MAX"] = value

  @builtins.property
  def W_RPN_DYN_MAX(self):
    return self.operation.attributes["W_RPN_DYN_MAX"]

  @W_RPN_DYN_MAX.setter
  def W_RPN_DYN_MAX(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["W_RPN_DYN_MAX"] = value

  @builtins.property
  def MAX_PER_IMG(self):
    return self.operation.attributes["MAX_PER_IMG"]

  @MAX_PER_IMG.setter
  def MAX_PER_IMG(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["MAX_PER_IMG"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def result_list(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaskedFillOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaskedFill"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, cond, brn, inversed, const_val, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    operands.append(_get_op_result_or_value(brn))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["inversed"] = (inversed if (
    issubclass(type(inversed), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inversed, context=_ods_context))
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def brn(self):
    return self.operation.operands[1]

  @builtins.property
  def inversed(self):
    return self.operation.attributes["inversed"]

  @inversed.setter
  def inversed(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inversed"] = value

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MatMulLutOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MatMulLut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, right, bias, multi, buffer, *, left_transpose=None, right_transpose=None, output_transpose=None, hdim_is_batch=None, keep_dims=None, do_relu=None, relu_limit=None, multipliers=None, rshifts=None, right_zp=None, input_zp=None, quant_mode=None, left_reuse=None, out_f8_scales=None, ginfo=None, multi_core=None, fuse_rq=None, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(right))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(multi))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if left_transpose is not None: attributes["left_transpose"] = (left_transpose if (
        issubclass(type(left_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(left_transpose, context=_ods_context))
    if right_transpose is not None: attributes["right_transpose"] = (right_transpose if (
        issubclass(type(right_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(right_transpose, context=_ods_context))
    if output_transpose is not None: attributes["output_transpose"] = (output_transpose if (
        issubclass(type(output_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(output_transpose, context=_ods_context))
    if hdim_is_batch is not None: attributes["hdim_is_batch"] = (hdim_is_batch if (
        issubclass(type(hdim_is_batch), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(hdim_is_batch, context=_ods_context))
    if keep_dims is not None: attributes["keep_dims"] = (keep_dims if (
        issubclass(type(keep_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keep_dims, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multipliers is not None: attributes["multipliers"] = (multipliers if (
        issubclass(type(multipliers), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multipliers, context=_ods_context))
    if rshifts is not None: attributes["rshifts"] = (rshifts if (
        issubclass(type(rshifts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshifts, context=_ods_context))
    if right_zp is not None: attributes["right_zp"] = (right_zp if (
        issubclass(type(right_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(right_zp, context=_ods_context))
    if input_zp is not None: attributes["input_zp"] = (input_zp if (
        issubclass(type(input_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(input_zp, context=_ods_context))
    if quant_mode is not None: attributes["quant_mode"] = (quant_mode if (
        issubclass(type(quant_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if left_reuse is not None: attributes["left_reuse"] = (left_reuse if (
        issubclass(type(left_reuse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(left_reuse, context=_ods_context))
    if out_f8_scales is not None: attributes["out_f8_scales"] = (out_f8_scales if (
        issubclass(type(out_f8_scales), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(out_f8_scales, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multi_core is not None: attributes["multi_core"] = (multi_core if (
        issubclass(type(multi_core), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multi_core, context=_ods_context))
    if fuse_rq is not None: attributes["fuse_rq"] = (fuse_rq if (
        issubclass(type(fuse_rq), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(fuse_rq, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def right(self):
    return self.operation.operands[2]

  @builtins.property
  def bias(self):
    return self.operation.operands[3]

  @builtins.property
  def multi(self):
    return self.operation.operands[4]

  @builtins.property
  def buffer(self):
    return self.operation.operands[5]

  @builtins.property
  def left_transpose(self):
    return self.operation.attributes["left_transpose"]

  @left_transpose.setter
  def left_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["left_transpose"] = value

  @builtins.property
  def right_transpose(self):
    return self.operation.attributes["right_transpose"]

  @right_transpose.setter
  def right_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["right_transpose"] = value

  @builtins.property
  def output_transpose(self):
    return self.operation.attributes["output_transpose"]

  @output_transpose.setter
  def output_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_transpose"] = value

  @builtins.property
  def hdim_is_batch(self):
    return self.operation.attributes["hdim_is_batch"]

  @hdim_is_batch.setter
  def hdim_is_batch(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hdim_is_batch"] = value

  @builtins.property
  def keep_dims(self):
    return self.operation.attributes["keep_dims"]

  @keep_dims.setter
  def keep_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_dims"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multipliers(self):
    return self.operation.attributes["multipliers"]

  @multipliers.setter
  def multipliers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multipliers"] = value

  @builtins.property
  def rshifts(self):
    return self.operation.attributes["rshifts"]

  @rshifts.setter
  def rshifts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshifts"] = value

  @builtins.property
  def right_zp(self):
    return self.operation.attributes["right_zp"]

  @right_zp.setter
  def right_zp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["right_zp"] = value

  @builtins.property
  def input_zp(self):
    return self.operation.attributes["input_zp"]

  @input_zp.setter
  def input_zp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_zp"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def left_reuse(self):
    return self.operation.attributes["left_reuse"]

  @left_reuse.setter
  def left_reuse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["left_reuse"] = value

  @builtins.property
  def out_f8_scales(self):
    if "out_f8_scales" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_f8_scales"]

  @out_f8_scales.setter
  def out_f8_scales(self, value):
    if value is not None:
      self.operation.attributes["out_f8_scales"] = value
    elif "out_f8_scales" in self.operation.attributes:
      del self.operation.attributes["out_f8_scales"]

  @out_f8_scales.deleter
  def out_f8_scales(self):
    del self.operation.attributes["out_f8_scales"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multi_core(self):
    if "multi_core" not in self.operation.attributes:
      return None
    return self.operation.attributes["multi_core"]

  @multi_core.setter
  def multi_core(self, value):
    if value is not None:
      self.operation.attributes["multi_core"] = value
    elif "multi_core" in self.operation.attributes:
      del self.operation.attributes["multi_core"]

  @multi_core.deleter
  def multi_core(self):
    del self.operation.attributes["multi_core"]

  @builtins.property
  def fuse_rq(self):
    return self.operation.attributes["fuse_rq"]

  @fuse_rq.setter
  def fuse_rq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fuse_rq"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MatMulOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MatMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, right, bias, multi, buffer, *, left_transpose=None, right_transpose=None, output_transpose=None, hdim_is_batch=None, keep_dims=None, do_relu=None, relu_limit=None, multipliers=None, rshifts=None, right_zp=None, input_zp=None, quant_mode=None, left_reuse=None, out_f8_scales=None, ginfo=None, multi_core=None, fuse_rq=None, weight_bits=None, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(right))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(multi))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if left_transpose is not None: attributes["left_transpose"] = (left_transpose if (
        issubclass(type(left_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(left_transpose, context=_ods_context))
    if right_transpose is not None: attributes["right_transpose"] = (right_transpose if (
        issubclass(type(right_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(right_transpose, context=_ods_context))
    if output_transpose is not None: attributes["output_transpose"] = (output_transpose if (
        issubclass(type(output_transpose), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(output_transpose, context=_ods_context))
    if hdim_is_batch is not None: attributes["hdim_is_batch"] = (hdim_is_batch if (
        issubclass(type(hdim_is_batch), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(hdim_is_batch, context=_ods_context))
    if keep_dims is not None: attributes["keep_dims"] = (keep_dims if (
        issubclass(type(keep_dims), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(keep_dims, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multipliers is not None: attributes["multipliers"] = (multipliers if (
        issubclass(type(multipliers), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multipliers, context=_ods_context))
    if rshifts is not None: attributes["rshifts"] = (rshifts if (
        issubclass(type(rshifts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshifts, context=_ods_context))
    if right_zp is not None: attributes["right_zp"] = (right_zp if (
        issubclass(type(right_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(right_zp, context=_ods_context))
    if input_zp is not None: attributes["input_zp"] = (input_zp if (
        issubclass(type(input_zp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(input_zp, context=_ods_context))
    if quant_mode is not None: attributes["quant_mode"] = (quant_mode if (
        issubclass(type(quant_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if left_reuse is not None: attributes["left_reuse"] = (left_reuse if (
        issubclass(type(left_reuse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(left_reuse, context=_ods_context))
    if out_f8_scales is not None: attributes["out_f8_scales"] = (out_f8_scales if (
        issubclass(type(out_f8_scales), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(out_f8_scales, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multi_core is not None: attributes["multi_core"] = (multi_core if (
        issubclass(type(multi_core), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multi_core, context=_ods_context))
    if fuse_rq is not None: attributes["fuse_rq"] = (fuse_rq if (
        issubclass(type(fuse_rq), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(fuse_rq, context=_ods_context))
    if weight_bits is not None: attributes["weight_bits"] = (weight_bits if (
        issubclass(type(weight_bits), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(weight_bits, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def right(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def multi(self):
    return self.operation.operands[3]

  @builtins.property
  def buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def left_transpose(self):
    return self.operation.attributes["left_transpose"]

  @left_transpose.setter
  def left_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["left_transpose"] = value

  @builtins.property
  def right_transpose(self):
    return self.operation.attributes["right_transpose"]

  @right_transpose.setter
  def right_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["right_transpose"] = value

  @builtins.property
  def output_transpose(self):
    return self.operation.attributes["output_transpose"]

  @output_transpose.setter
  def output_transpose(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_transpose"] = value

  @builtins.property
  def hdim_is_batch(self):
    return self.operation.attributes["hdim_is_batch"]

  @hdim_is_batch.setter
  def hdim_is_batch(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hdim_is_batch"] = value

  @builtins.property
  def keep_dims(self):
    return self.operation.attributes["keep_dims"]

  @keep_dims.setter
  def keep_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_dims"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multipliers(self):
    return self.operation.attributes["multipliers"]

  @multipliers.setter
  def multipliers(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multipliers"] = value

  @builtins.property
  def rshifts(self):
    return self.operation.attributes["rshifts"]

  @rshifts.setter
  def rshifts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshifts"] = value

  @builtins.property
  def right_zp(self):
    return self.operation.attributes["right_zp"]

  @right_zp.setter
  def right_zp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["right_zp"] = value

  @builtins.property
  def input_zp(self):
    return self.operation.attributes["input_zp"]

  @input_zp.setter
  def input_zp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_zp"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def left_reuse(self):
    return self.operation.attributes["left_reuse"]

  @left_reuse.setter
  def left_reuse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["left_reuse"] = value

  @builtins.property
  def out_f8_scales(self):
    if "out_f8_scales" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_f8_scales"]

  @out_f8_scales.setter
  def out_f8_scales(self, value):
    if value is not None:
      self.operation.attributes["out_f8_scales"] = value
    elif "out_f8_scales" in self.operation.attributes:
      del self.operation.attributes["out_f8_scales"]

  @out_f8_scales.deleter
  def out_f8_scales(self):
    del self.operation.attributes["out_f8_scales"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multi_core(self):
    if "multi_core" not in self.operation.attributes:
      return None
    return self.operation.attributes["multi_core"]

  @multi_core.setter
  def multi_core(self, value):
    if value is not None:
      self.operation.attributes["multi_core"] = value
    elif "multi_core" in self.operation.attributes:
      del self.operation.attributes["multi_core"]

  @multi_core.deleter
  def multi_core(self):
    del self.operation.attributes["multi_core"]

  @builtins.property
  def fuse_rq(self):
    return self.operation.attributes["fuse_rq"]

  @fuse_rq.setter
  def fuse_rq(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fuse_rq"] = value

  @builtins.property
  def weight_bits(self):
    if "weight_bits" not in self.operation.attributes:
      return None
    return self.operation.attributes["weight_bits"]

  @weight_bits.setter
  def weight_bits(self, value):
    if value is not None:
      self.operation.attributes["weight_bits"] = value
    elif "weight_bits" in self.operation.attributes:
      del self.operation.attributes["weight_bits"]

  @weight_bits.deleter
  def weight_bits(self):
    del self.operation.attributes["weight_bits"]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MatchTemplateOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MatchTemplate"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, match, table, mantissa_table, mode, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(match))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(mantissa_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('MatchTemplateModeAttr')) else
      _ods_ir.AttrBuilder.get('MatchTemplateModeAttr')(mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def match(self):
    return self.operation.operands[1]

  @builtins.property
  def table(self):
    return self.operation.operands[2]

  @builtins.property
  def mantissa_table(self):
    return self.operation.operands[3]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxConstOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaxConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, do_relu=None, relu_limit=None, multiplier=None, rshift=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Max"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, coeff=None, multipliers=None, rshifts=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if coeff is not None: attributes["coeff"] = (coeff if (
        issubclass(type(coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeff, context=_ods_context))
    if multipliers is not None: attributes["multipliers"] = (multipliers if (
        issubclass(type(multipliers), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multipliers, context=_ods_context))
    if rshifts is not None: attributes["rshifts"] = (rshifts if (
        issubclass(type(rshifts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshifts, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def coeff(self):
    if "coeff" not in self.operation.attributes:
      return None
    return self.operation.attributes["coeff"]

  @coeff.setter
  def coeff(self, value):
    if value is not None:
      self.operation.attributes["coeff"] = value
    elif "coeff" in self.operation.attributes:
      del self.operation.attributes["coeff"]

  @coeff.deleter
  def coeff(self):
    del self.operation.attributes["coeff"]

  @builtins.property
  def multipliers(self):
    if "multipliers" not in self.operation.attributes:
      return None
    return self.operation.attributes["multipliers"]

  @multipliers.setter
  def multipliers(self, value):
    if value is not None:
      self.operation.attributes["multipliers"] = value
    elif "multipliers" in self.operation.attributes:
      del self.operation.attributes["multipliers"]

  @multipliers.deleter
  def multipliers(self):
    del self.operation.attributes["multipliers"]

  @builtins.property
  def rshifts(self):
    if "rshifts" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshifts"]

  @rshifts.setter
  def rshifts(self, value):
    if value is not None:
      self.operation.attributes["rshifts"] = value
    elif "rshifts" in self.operation.attributes:
      del self.operation.attributes["rshifts"]

  @rshifts.deleter
  def rshifts(self):
    del self.operation.attributes["rshifts"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxPoolWithMaskOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaxPoolWithMask"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mask, input, kernel_shape, strides, pads, *, do_relu=None, relu_limit=None, layer_group=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if layer_group is not None: attributes["layer_group"] = (layer_group if (
        issubclass(type(layer_group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(layer_group, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    results.append(mask)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def layer_group(self):
    if "layer_group" not in self.operation.attributes:
      return None
    return self.operation.attributes["layer_group"]

  @layer_group.setter
  def layer_group(self, value):
    if value is not None:
      self.operation.attributes["layer_group"] = value
    elif "layer_group" in self.operation.attributes:
      del self.operation.attributes["layer_group"]

  @layer_group.deleter
  def layer_group(self):
    del self.operation.attributes["layer_group"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

  @builtins.property
  def mask(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxUnpoolOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaxUnpool"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, mask, scale_h, scale_w, *, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(mask))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale_h"] = (scale_h if (
    issubclass(type(scale_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_h, context=_ods_context))
    attributes["scale_w"] = (scale_w if (
    issubclass(type(scale_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_w, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def mask(self):
    return self.operation.operands[1]

  @builtins.property
  def scale_h(self):
    return self.operation.attributes["scale_h"]

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return self.operation.attributes["scale_w"]

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MeanRstdOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MeanRstd"

  _ODS_REGIONS = (0, True)

  def __init__(self, mean, rstd, running_mean_update, running_var_update, scale, bias_new, input, running_mean, running_var, weight, bias, eps, momentum, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(running_mean))
    operands.append(_get_op_result_or_value(running_var))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    attributes["momentum"] = (momentum if (
    issubclass(type(momentum), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(momentum, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(mean)
    results.append(rstd)
    results.append(running_mean_update)
    results.append(running_var_update)
    results.append(scale)
    results.append(bias_new)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def running_mean(self):
    return self.operation.operands[1]

  @builtins.property
  def running_var(self):
    return self.operation.operands[2]

  @builtins.property
  def weight(self):
    return self.operation.operands[3]

  @builtins.property
  def bias(self):
    return self.operation.operands[4]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def momentum(self):
    return self.operation.attributes["momentum"]

  @momentum.setter
  def momentum(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["momentum"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def mean(self):
    return self.operation.results[0]

  @builtins.property
  def rstd(self):
    return self.operation.results[1]

  @builtins.property
  def running_mean_update(self):
    return self.operation.results[2]

  @builtins.property
  def running_var_update(self):
    return self.operation.results[3]

  @builtins.property
  def scale(self):
    return self.operation.results[4]

  @builtins.property
  def bias_new(self):
    return self.operation.results[5]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MeanStdScaleOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MeanStdScale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, f32_param, quant_mode, customization_format, channel_order, scale, std, mean, zero_points, resize_dims, multi, rshift, offset, rounding_mode, *, sign=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(f32_param))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(quant_mode, context=_ods_context))
    attributes["customization_format"] = (customization_format if (
    issubclass(type(customization_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(customization_format, context=_ods_context))
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(channel_order, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["std"] = (std if (
    issubclass(type(std), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(std, context=_ods_context))
    attributes["mean"] = (mean if (
    issubclass(type(mean), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(mean, context=_ods_context))
    attributes["zero_points"] = (zero_points if (
    issubclass(type(zero_points), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(zero_points, context=_ods_context))
    attributes["resize_dims"] = (resize_dims if (
    issubclass(type(resize_dims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(resize_dims, context=_ods_context))
    attributes["multi"] = (multi if (
    issubclass(type(multi), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(multi, context=_ods_context))
    attributes["rshift"] = (rshift if (
    issubclass(type(rshift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(rshift, context=_ods_context))
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(offset, context=_ods_context))
    attributes["rounding_mode"] = (rounding_mode if (
    issubclass(type(rounding_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(rounding_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def f32_param(self):
    return self.operation.operands[1]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def customization_format(self):
    return self.operation.attributes["customization_format"]

  @customization_format.setter
  def customization_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["customization_format"] = value

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def sign(self):
    return self.operation.attributes["sign"]

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def std(self):
    return self.operation.attributes["std"]

  @std.setter
  def std(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["std"] = value

  @builtins.property
  def mean(self):
    return self.operation.attributes["mean"]

  @mean.setter
  def mean(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mean"] = value

  @builtins.property
  def zero_points(self):
    return self.operation.attributes["zero_points"]

  @zero_points.setter
  def zero_points(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["zero_points"] = value

  @builtins.property
  def resize_dims(self):
    return self.operation.attributes["resize_dims"]

  @resize_dims.setter
  def resize_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resize_dims"] = value

  @builtins.property
  def multi(self):
    return self.operation.attributes["multi"]

  @multi.setter
  def multi(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multi"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def rounding_mode(self):
    return self.operation.attributes["rounding_mode"]

  @rounding_mode.setter
  def rounding_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rounding_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MinConstOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MinConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, do_relu=None, relu_limit=None, multiplier=None, rshift=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MinOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Min"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, coeff=None, multipliers=None, rshifts=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if coeff is not None: attributes["coeff"] = (coeff if (
        issubclass(type(coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeff, context=_ods_context))
    if multipliers is not None: attributes["multipliers"] = (multipliers if (
        issubclass(type(multipliers), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multipliers, context=_ods_context))
    if rshifts is not None: attributes["rshifts"] = (rshifts if (
        issubclass(type(rshifts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshifts, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def coeff(self):
    if "coeff" not in self.operation.attributes:
      return None
    return self.operation.attributes["coeff"]

  @coeff.setter
  def coeff(self, value):
    if value is not None:
      self.operation.attributes["coeff"] = value
    elif "coeff" in self.operation.attributes:
      del self.operation.attributes["coeff"]

  @coeff.deleter
  def coeff(self):
    del self.operation.attributes["coeff"]

  @builtins.property
  def multipliers(self):
    if "multipliers" not in self.operation.attributes:
      return None
    return self.operation.attributes["multipliers"]

  @multipliers.setter
  def multipliers(self, value):
    if value is not None:
      self.operation.attributes["multipliers"] = value
    elif "multipliers" in self.operation.attributes:
      del self.operation.attributes["multipliers"]

  @multipliers.deleter
  def multipliers(self):
    del self.operation.attributes["multipliers"]

  @builtins.property
  def rshifts(self):
    if "rshifts" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshifts"]

  @rshifts.setter
  def rshifts(self, value):
    if value is not None:
      self.operation.attributes["rshifts"] = value
    elif "rshifts" in self.operation.attributes:
      del self.operation.attributes["rshifts"]

  @rshifts.deleter
  def rshifts(self):
    del self.operation.attributes["rshifts"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Mmap2RgbmapOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Mmap2Rgbmap"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MoveOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Move"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, inputs, name, move_src_add, move_dest_add, move_size, ts_id, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["name"] = (name if (
    issubclass(type(name), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["move_src_add"] = (move_src_add if (
    issubclass(type(move_src_add), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(move_src_add, context=_ods_context))
    attributes["move_dest_add"] = (move_dest_add if (
    issubclass(type(move_dest_add), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(move_dest_add, context=_ods_context))
    attributes["move_size"] = (move_size if (
    issubclass(type(move_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(move_size, context=_ods_context))
    attributes["ts_id"] = (ts_id if (
    issubclass(type(ts_id), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ts_id, context=_ods_context))
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def name(self):
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["name"] = value

  @builtins.property
  def move_src_add(self):
    return self.operation.attributes["move_src_add"]

  @move_src_add.setter
  def move_src_add(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["move_src_add"] = value

  @builtins.property
  def move_dest_add(self):
    return self.operation.attributes["move_dest_add"]

  @move_dest_add.setter
  def move_dest_add(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["move_dest_add"] = value

  @builtins.property
  def move_size(self):
    return self.operation.attributes["move_size"]

  @move_size.setter
  def move_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["move_size"] = value

  @builtins.property
  def ts_id(self):
    return self.operation.attributes["ts_id"]

  @ts_id.setter
  def ts_id(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ts_id"] = value

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MulConstOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MulConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, do_relu=None, relu_limit=None, multiplier=None, rshift=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MulOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, do_relu=None, relu_limit=None, multiplier=None, rshift=None, quant_mode=None, out_f8_scales=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if quant_mode is not None: attributes["quant_mode"] = (quant_mode if (
        issubclass(type(quant_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if out_f8_scales is not None: attributes["out_f8_scales"] = (out_f8_scales if (
        issubclass(type(out_f8_scales), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(out_f8_scales, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def out_f8_scales(self):
    if "out_f8_scales" not in self.operation.attributes:
      return None
    return self.operation.attributes["out_f8_scales"]

  @out_f8_scales.setter
  def out_f8_scales(self, value):
    if value is not None:
      self.operation.attributes["out_f8_scales"] = value
    elif "out_f8_scales" in self.operation.attributes:
      del self.operation.attributes["out_f8_scales"]

  @out_f8_scales.deleter
  def out_f8_scales(self):
    del self.operation.attributes["out_f8_scales"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MulShiftOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MulShift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, multiplier, rshift, *, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["multiplier"] = (multiplier if (
    issubclass(type(multiplier), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    attributes["rshift"] = (rshift if (
    issubclass(type(rshift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NmsOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Nms"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, center_point_box, max_output_size, buffer, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["center_point_box"] = (center_point_box if (
    issubclass(type(center_point_box), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(center_point_box, context=_ods_context))
    attributes["max_output_size"] = (max_output_size if (
    issubclass(type(max_output_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(max_output_size, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def buffer(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def center_point_box(self):
    return self.operation.attributes["center_point_box"]

  @center_point_box.setter
  def center_point_box(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["center_point_box"] = value

  @builtins.property
  def max_output_size(self):
    return self.operation.attributes["max_output_size"]

  @max_output_size.setter
  def max_output_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max_output_size"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class NonZeroOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.NonZero"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, buffer, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    issubclass(type(order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('NonZeroOrderAttr')) else
      _ods_ir.AttrBuilder.get('NonZeroOrderAttr')(order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def order(self):
    return self.operation.attributes["order"]

  @order.setter
  def order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class OutBufferOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.OutBuffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, *, need_dump=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if need_dump is not None: attributes["need_dump"] = (need_dump if (
        issubclass(type(need_dump), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(need_dump, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def need_dump(self):
    return self.operation.attributes["need_dump"]

  @need_dump.setter
  def need_dump(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["need_dump"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PReluOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.PReluOp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, slope, *, rshift=None, rshift_pos=None, multiplier_pos=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(slope))
    _ods_context = _ods_get_default_loc_context(loc)
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if rshift_pos is not None: attributes["rshift_pos"] = (rshift_pos if (
        issubclass(type(rshift_pos), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift_pos, context=_ods_context))
    if multiplier_pos is not None: attributes["multiplier_pos"] = (multiplier_pos if (
        issubclass(type(multiplier_pos), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier_pos, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def slope(self):
    return self.operation.operands[1]

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def rshift_pos(self):
    if "rshift_pos" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift_pos"]

  @rshift_pos.setter
  def rshift_pos(self, value):
    if value is not None:
      self.operation.attributes["rshift_pos"] = value
    elif "rshift_pos" in self.operation.attributes:
      del self.operation.attributes["rshift_pos"]

  @rshift_pos.deleter
  def rshift_pos(self):
    del self.operation.attributes["rshift_pos"]

  @builtins.property
  def multiplier_pos(self):
    if "multiplier_pos" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier_pos"]

  @multiplier_pos.setter
  def multiplier_pos(self, value):
    if value is not None:
      self.operation.attributes["multiplier_pos"] = value
    elif "multiplier_pos" in self.operation.attributes:
      del self.operation.attributes["multiplier_pos"]

  @multiplier_pos.deleter
  def multiplier_pos(self):
    del self.operation.attributes["multiplier_pos"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PackRawOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.PackRaw"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, high_table, low_table, white_level, black_level, threshold, channel_order, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(high_table))
    operands.append(_get_op_result_or_value(low_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["white_level"] = (white_level if (
    issubclass(type(white_level), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(white_level, context=_ods_context))
    attributes["black_level"] = (black_level if (
    issubclass(type(black_level), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(black_level, context=_ods_context))
    attributes["threshold"] = (threshold if (
    issubclass(type(threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(threshold, context=_ods_context))
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(channel_order, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def high_table(self):
    return self.operation.operands[1]

  @builtins.property
  def low_table(self):
    return self.operation.operands[2]

  @builtins.property
  def white_level(self):
    return self.operation.attributes["white_level"]

  @white_level.setter
  def white_level(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["white_level"] = value

  @builtins.property
  def black_level(self):
    return self.operation.attributes["black_level"]

  @black_level.setter
  def black_level(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["black_level"] = value

  @builtins.property
  def threshold(self):
    return self.operation.attributes["threshold"]

  @threshold.setter
  def threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["threshold"] = value

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, left_select, right_select, buffer, paddings, *, paddingsT=None, val=None, mode=None, with_insert_zero=None, insert_zeros=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if paddingsT is not None: operands.append(_get_op_result_or_value(paddingsT))
    operands.append(_get_op_result_or_value(left_select))
    operands.append(_get_op_result_or_value(right_select))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["paddings"] = (paddings if (
    issubclass(type(paddings), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(paddings, context=_ods_context))
    if val is not None: attributes["val"] = (val if (
        issubclass(type(val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(val, context=_ods_context))
    if mode is not None: attributes["mode"] = (mode if (
        issubclass(type(mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_PaddingModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_PaddingModeAttr')(mode, context=_ods_context))
    if with_insert_zero is not None: attributes["with_insert_zero"] = (with_insert_zero if (
        issubclass(type(with_insert_zero), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(with_insert_zero, context=_ods_context))
    if insert_zeros is not None: attributes["insert_zeros"] = (insert_zeros if (
        issubclass(type(insert_zeros), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(insert_zeros, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def paddingsT(self):
    return None if len(self.operation.operands) < 5 else self.operation.operands[1]

  @builtins.property
  def left_select(self):
    _ods_variadic_group_length = len(self.operation.operands) - 5 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def right_select(self):
    _ods_variadic_group_length = len(self.operation.operands) - 5 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def buffer(self):
    _ods_variadic_group_length = len(self.operation.operands) - 5 + 1
    return self.operation.operands[4 + _ods_variadic_group_length - 1]

  @builtins.property
  def paddings(self):
    return self.operation.attributes["paddings"]

  @paddings.setter
  def paddings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["paddings"] = value

  @builtins.property
  def val(self):
    return self.operation.attributes["val"]

  @val.setter
  def val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["val"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def with_insert_zero(self):
    return self.operation.attributes["with_insert_zero"]

  @with_insert_zero.setter
  def with_insert_zero(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["with_insert_zero"] = value

  @builtins.property
  def insert_zeros(self):
    if "insert_zeros" not in self.operation.attributes:
      return None
    return self.operation.attributes["insert_zeros"]

  @insert_zeros.setter
  def insert_zeros(self, value):
    if value is not None:
      self.operation.attributes["insert_zeros"] = value
    elif "insert_zeros" in self.operation.attributes:
      del self.operation.attributes["insert_zeros"]

  @insert_zeros.deleter
  def insert_zeros(self):
    del self.operation.attributes["insert_zeros"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PermuteOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Permute"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, order, buffer, *, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    issubclass(type(order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(order, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def order(self):
    return self.operation.attributes["order"]

  @order.setter
  def order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PixelNormOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.PixelNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, weight, bias, table, mantissa_table, eps, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(weight))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(mantissa_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def weight(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def table(self):
    return self.operation.operands[3]

  @builtins.property
  def mantissa_table(self):
    return self.operation.operands[4]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Pool1DOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Pool1D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel_shape, strides, pads, pool_mode, *, pad_value=None, is_adaptive=None, count_include_pad=None, do_relu=None, relu_limit=None, ceil_mode=None, multiplier=None, rshift=None, scale=None, offset=None, round_mode=None, first_round_mode=None, layer_group=None, fp8_out_scale=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    attributes["pool_mode"] = (pool_mode if (
    issubclass(type(pool_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_PoolModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_PoolModeAttr')(pool_mode, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if is_adaptive is not None: attributes["is_adaptive"] = (is_adaptive if (
        issubclass(type(is_adaptive), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_adaptive, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if ceil_mode is not None: attributes["ceil_mode"] = (ceil_mode if (
        issubclass(type(ceil_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    if offset is not None: attributes["offset"] = (offset if (
        issubclass(type(offset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(offset, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(first_round_mode, context=_ods_context))
    if layer_group is not None: attributes["layer_group"] = (layer_group if (
        issubclass(type(layer_group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(layer_group, context=_ods_context))
    if fp8_out_scale is not None: attributes["fp8_out_scale"] = (fp8_out_scale if (
        issubclass(type(fp8_out_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(fp8_out_scale, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def pool_mode(self):
    return self.operation.attributes["pool_mode"]

  @pool_mode.setter
  def pool_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pool_mode"] = value

  @builtins.property
  def pad_value(self):
    return self.operation.attributes["pad_value"]

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def is_adaptive(self):
    return self.operation.attributes["is_adaptive"]

  @is_adaptive.setter
  def is_adaptive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_adaptive"] = value

  @builtins.property
  def count_include_pad(self):
    return self.operation.attributes["count_include_pad"]

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def ceil_mode(self):
    if "ceil_mode" not in self.operation.attributes:
      return None
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is not None:
      self.operation.attributes["ceil_mode"] = value
    elif "ceil_mode" in self.operation.attributes:
      del self.operation.attributes["ceil_mode"]

  @ceil_mode.deleter
  def ceil_mode(self):
    del self.operation.attributes["ceil_mode"]

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def scale(self):
    if "scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is not None:
      self.operation.attributes["scale"] = value
    elif "scale" in self.operation.attributes:
      del self.operation.attributes["scale"]

  @scale.deleter
  def scale(self):
    del self.operation.attributes["scale"]

  @builtins.property
  def offset(self):
    if "offset" not in self.operation.attributes:
      return None
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is not None:
      self.operation.attributes["offset"] = value
    elif "offset" in self.operation.attributes:
      del self.operation.attributes["offset"]

  @offset.deleter
  def offset(self):
    del self.operation.attributes["offset"]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def layer_group(self):
    if "layer_group" not in self.operation.attributes:
      return None
    return self.operation.attributes["layer_group"]

  @layer_group.setter
  def layer_group(self, value):
    if value is not None:
      self.operation.attributes["layer_group"] = value
    elif "layer_group" in self.operation.attributes:
      del self.operation.attributes["layer_group"]

  @layer_group.deleter
  def layer_group(self):
    del self.operation.attributes["layer_group"]

  @builtins.property
  def fp8_out_scale(self):
    if "fp8_out_scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["fp8_out_scale"]

  @fp8_out_scale.setter
  def fp8_out_scale(self, value):
    if value is not None:
      self.operation.attributes["fp8_out_scale"] = value
    elif "fp8_out_scale" in self.operation.attributes:
      del self.operation.attributes["fp8_out_scale"]

  @fp8_out_scale.deleter
  def fp8_out_scale(self):
    del self.operation.attributes["fp8_out_scale"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Pool2DOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Pool2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, kernel_shape, strides, pads, pool_mode, *, pad_value=None, is_adaptive=None, count_include_pad=None, do_relu=None, relu_limit=None, ceil_mode=None, multiplier=None, rshift=None, scale=None, offset=None, round_mode=None, first_round_mode=None, layer_group=None, fp8_out_scale=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    attributes["pool_mode"] = (pool_mode if (
    issubclass(type(pool_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_PoolModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_PoolModeAttr')(pool_mode, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if is_adaptive is not None: attributes["is_adaptive"] = (is_adaptive if (
        issubclass(type(is_adaptive), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_adaptive, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if ceil_mode is not None: attributes["ceil_mode"] = (ceil_mode if (
        issubclass(type(ceil_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(ceil_mode, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    if offset is not None: attributes["offset"] = (offset if (
        issubclass(type(offset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(offset, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(first_round_mode, context=_ods_context))
    if layer_group is not None: attributes["layer_group"] = (layer_group if (
        issubclass(type(layer_group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(layer_group, context=_ods_context))
    if fp8_out_scale is not None: attributes["fp8_out_scale"] = (fp8_out_scale if (
        issubclass(type(fp8_out_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(fp8_out_scale, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def pool_mode(self):
    return self.operation.attributes["pool_mode"]

  @pool_mode.setter
  def pool_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pool_mode"] = value

  @builtins.property
  def pad_value(self):
    return self.operation.attributes["pad_value"]

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def is_adaptive(self):
    return self.operation.attributes["is_adaptive"]

  @is_adaptive.setter
  def is_adaptive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_adaptive"] = value

  @builtins.property
  def count_include_pad(self):
    return self.operation.attributes["count_include_pad"]

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def ceil_mode(self):
    if "ceil_mode" not in self.operation.attributes:
      return None
    return self.operation.attributes["ceil_mode"]

  @ceil_mode.setter
  def ceil_mode(self, value):
    if value is not None:
      self.operation.attributes["ceil_mode"] = value
    elif "ceil_mode" in self.operation.attributes:
      del self.operation.attributes["ceil_mode"]

  @ceil_mode.deleter
  def ceil_mode(self):
    del self.operation.attributes["ceil_mode"]

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def scale(self):
    if "scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is not None:
      self.operation.attributes["scale"] = value
    elif "scale" in self.operation.attributes:
      del self.operation.attributes["scale"]

  @scale.deleter
  def scale(self):
    del self.operation.attributes["scale"]

  @builtins.property
  def offset(self):
    if "offset" not in self.operation.attributes:
      return None
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is not None:
      self.operation.attributes["offset"] = value
    elif "offset" in self.operation.attributes:
      del self.operation.attributes["offset"]

  @offset.deleter
  def offset(self):
    del self.operation.attributes["offset"]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def layer_group(self):
    if "layer_group" not in self.operation.attributes:
      return None
    return self.operation.attributes["layer_group"]

  @layer_group.setter
  def layer_group(self, value):
    if value is not None:
      self.operation.attributes["layer_group"] = value
    elif "layer_group" in self.operation.attributes:
      del self.operation.attributes["layer_group"]

  @layer_group.deleter
  def layer_group(self):
    del self.operation.attributes["layer_group"]

  @builtins.property
  def fp8_out_scale(self):
    if "fp8_out_scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["fp8_out_scale"]

  @fp8_out_scale.setter
  def fp8_out_scale(self, value):
    if value is not None:
      self.operation.attributes["fp8_out_scale"] = value
    elif "fp8_out_scale" in self.operation.attributes:
      del self.operation.attributes["fp8_out_scale"]

  @fp8_out_scale.deleter
  def fp8_out_scale(self):
    del self.operation.attributes["fp8_out_scale"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Pool3DOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Pool3D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, buffer, kernel_shape, strides, pads, pool_mode, *, pad_value=None, count_include_pad=None, do_relu=None, relu_limit=None, multiplier=None, rshift=None, scale=None, offset=None, round_mode=None, first_round_mode=None, layer_group=None, fp8_out_scale=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    attributes["pool_mode"] = (pool_mode if (
    issubclass(type(pool_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_PoolModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_PoolModeAttr')(pool_mode, context=_ods_context))
    if pad_value is not None: attributes["pad_value"] = (pad_value if (
        issubclass(type(pad_value), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(pad_value, context=_ods_context))
    if count_include_pad is not None: attributes["count_include_pad"] = (count_include_pad if (
        issubclass(type(count_include_pad), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(count_include_pad, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    if offset is not None: attributes["offset"] = (offset if (
        issubclass(type(offset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(offset, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(first_round_mode, context=_ods_context))
    if layer_group is not None: attributes["layer_group"] = (layer_group if (
        issubclass(type(layer_group), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(layer_group, context=_ods_context))
    if fp8_out_scale is not None: attributes["fp8_out_scale"] = (fp8_out_scale if (
        issubclass(type(fp8_out_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(fp8_out_scale, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def pool_mode(self):
    return self.operation.attributes["pool_mode"]

  @pool_mode.setter
  def pool_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pool_mode"] = value

  @builtins.property
  def pad_value(self):
    return self.operation.attributes["pad_value"]

  @pad_value.setter
  def pad_value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pad_value"] = value

  @builtins.property
  def count_include_pad(self):
    return self.operation.attributes["count_include_pad"]

  @count_include_pad.setter
  def count_include_pad(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count_include_pad"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def scale(self):
    if "scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is not None:
      self.operation.attributes["scale"] = value
    elif "scale" in self.operation.attributes:
      del self.operation.attributes["scale"]

  @scale.deleter
  def scale(self):
    del self.operation.attributes["scale"]

  @builtins.property
  def offset(self):
    if "offset" not in self.operation.attributes:
      return None
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is not None:
      self.operation.attributes["offset"] = value
    elif "offset" in self.operation.attributes:
      del self.operation.attributes["offset"]

  @offset.deleter
  def offset(self):
    del self.operation.attributes["offset"]

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def layer_group(self):
    if "layer_group" not in self.operation.attributes:
      return None
    return self.operation.attributes["layer_group"]

  @layer_group.setter
  def layer_group(self, value):
    if value is not None:
      self.operation.attributes["layer_group"] = value
    elif "layer_group" in self.operation.attributes:
      del self.operation.attributes["layer_group"]

  @layer_group.deleter
  def layer_group(self):
    del self.operation.attributes["layer_group"]

  @builtins.property
  def fp8_out_scale(self):
    if "fp8_out_scale" not in self.operation.attributes:
      return None
    return self.operation.attributes["fp8_out_scale"]

  @fp8_out_scale.setter
  def fp8_out_scale(self, value):
    if value is not None:
      self.operation.attributes["fp8_out_scale"] = value
    elif "fp8_out_scale" in self.operation.attributes:
      del self.operation.attributes["fp8_out_scale"]

  @fp8_out_scale.deleter
  def fp8_out_scale(self):
    del self.operation.attributes["fp8_out_scale"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PoolMaskOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.PoolMask"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PreprocessOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Preprocess"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, quant_mode, customization_format, channel_order, resize_dims, scale, mean, *, sign=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(quant_mode, context=_ods_context))
    attributes["customization_format"] = (customization_format if (
    issubclass(type(customization_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(customization_format, context=_ods_context))
    attributes["channel_order"] = (channel_order if (
    issubclass(type(channel_order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(channel_order, context=_ods_context))
    attributes["resize_dims"] = (resize_dims if (
    issubclass(type(resize_dims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(resize_dims, context=_ods_context))
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["mean"] = (mean if (
    issubclass(type(mean), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(mean, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def customization_format(self):
    return self.operation.attributes["customization_format"]

  @customization_format.setter
  def customization_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["customization_format"] = value

  @builtins.property
  def channel_order(self):
    return self.operation.attributes["channel_order"]

  @channel_order.setter
  def channel_order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["channel_order"] = value

  @builtins.property
  def resize_dims(self):
    return self.operation.attributes["resize_dims"]

  @resize_dims.setter
  def resize_dims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resize_dims"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def mean(self):
    return self.operation.attributes["mean"]

  @mean.setter
  def mean(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mean"] = value

  @builtins.property
  def sign(self):
    return self.operation.attributes["sign"]

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RMSNormOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.RMSNorm"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, gamma, eps, *, weight_keep_f32=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(gamma))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["eps"] = (eps if (
    issubclass(type(eps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(eps, context=_ods_context))
    if weight_keep_f32 is not None: attributes["weight_keep_f32"] = (weight_keep_f32 if (
        issubclass(type(weight_keep_f32), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(weight_keep_f32, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def gamma(self):
    return self.operation.operands[1]

  @builtins.property
  def eps(self):
    return self.operation.attributes["eps"]

  @eps.setter
  def eps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["eps"] = value

  @builtins.property
  def weight_keep_f32(self):
    return self.operation.attributes["weight_keep_f32"]

  @weight_keep_f32.setter
  def weight_keep_f32(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["weight_keep_f32"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RandnLikeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.RandnLike"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, randn_data, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(randn_data))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def randn_data(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RangeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Range"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, start, limit, delta, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(start))
    operands.append(_get_op_result_or_value(limit))
    operands.append(_get_op_result_or_value(delta))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def start(self):
    return self.operation.operands[0]

  @builtins.property
  def limit(self):
    return self.operation.operands[1]

  @builtins.property
  def delta(self):
    return self.operation.operands[2]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReciprocalOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Reciprocal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, const_val=None, do_relu=None, relu_limit=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if const_val is not None: attributes["const_val"] = (const_val if (
        issubclass(type(const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Reduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, buffer, reciprocal_mantissa_table, axes, keepdims, mode, *, multiplier=None, rshift=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    operands.append(_get_op_result_or_value(reciprocal_mantissa_table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    attributes["keepdims"] = (keepdims if (
    issubclass(type(keepdims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ReduceModeAttr')) else
      _ods_ir.AttrBuilder.get('ReduceModeAttr')(mode, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshift, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def reciprocal_mantissa_table(self):
    return self.operation.operands[2]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def multiplier(self):
    if "multiplier" not in self.operation.attributes:
      return None
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is not None:
      self.operation.attributes["multiplier"] = value
    elif "multiplier" in self.operation.attributes:
      del self.operation.attributes["multiplier"]

  @multiplier.deleter
  def multiplier(self):
    del self.operation.attributes["multiplier"]

  @builtins.property
  def rshift(self):
    if "rshift" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is not None:
      self.operation.attributes["rshift"] = value
    elif "rshift" in self.operation.attributes:
      del self.operation.attributes["rshift"]

  @rshift.deleter
  def rshift(self):
    del self.operation.attributes["rshift"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReluOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Relu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, ginfo=None, relu_limit=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RequantFpAxisOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.RequantFpAxis"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, quant, quant_mode, *, round_mode=None, first_round_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(quant))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(first_round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant(self):
    return self.operation.operands[1]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RequantFpOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.RequantFp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, quant_mode, *, offset=None, round_mode=None, first_round_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    if offset is not None: attributes["offset"] = (offset if (
        issubclass(type(offset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(offset, context=_ods_context))
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if first_round_mode is not None: attributes["first_round_mode"] = (first_round_mode if (
        issubclass(type(first_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(first_round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def first_round_mode(self):
    return self.operation.attributes["first_round_mode"]

  @first_round_mode.setter
  def first_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["first_round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RequantIntAxisOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.RequantIntAxis"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, quant, quant_mode, *, round_mode=None, ginfo=None, rq_axis=None, fuse_rq_axis=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(quant))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if rq_axis is not None: attributes["rq_axis"] = (rq_axis if (
        issubclass(type(rq_axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rq_axis, context=_ods_context))
    if fuse_rq_axis is not None: attributes["fuse_rq_axis"] = (fuse_rq_axis if (
        issubclass(type(fuse_rq_axis), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(fuse_rq_axis, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def quant(self):
    return self.operation.operands[1]

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def rq_axis(self):
    return self.operation.attributes["rq_axis"]

  @rq_axis.setter
  def rq_axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rq_axis"] = value

  @builtins.property
  def fuse_rq_axis(self):
    return self.operation.attributes["fuse_rq_axis"]

  @fuse_rq_axis.setter
  def fuse_rq_axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fuse_rq_axis"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RequantIntOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.RequantInt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, multiplier, rshift, quant_mode, *, round_mode=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["multiplier"] = (multiplier if (
    issubclass(type(multiplier), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    attributes["rshift"] = (rshift if (
    issubclass(type(rshift), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    attributes["quant_mode"] = (quant_mode if (
    issubclass(type(quant_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_RequantModeAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_RequantModeAttr')(quant_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def quant_mode(self):
    return self.operation.attributes["quant_mode"]

  @quant_mode.setter
  def quant_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["quant_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, shape=None, buffer=None, flatten_start_dim=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if buffer is not None: operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if shape is not None: attributes["shape"] = (shape if (
        issubclass(type(shape), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    if flatten_start_dim is not None: attributes["flatten_start_dim"] = (flatten_start_dim if (
        issubclass(type(flatten_start_dim), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(flatten_start_dim, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def flatten_start_dim(self):
    return self.operation.attributes["flatten_start_dim"]

  @flatten_start_dim.setter
  def flatten_start_dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flatten_start_dim"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ReverseOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Reverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RoiAlignOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.RoiAlign"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, rois, mode, output_height, output_width, sampling_ratio, spatial_scale, align_corners, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(rois))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RoiAlignModeAttr')) else
      _ods_ir.AttrBuilder.get('RoiAlignModeAttr')(mode, context=_ods_context))
    attributes["output_height"] = (output_height if (
    issubclass(type(output_height), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_height, context=_ods_context))
    attributes["output_width"] = (output_width if (
    issubclass(type(output_width), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_width, context=_ods_context))
    attributes["sampling_ratio"] = (sampling_ratio if (
    issubclass(type(sampling_ratio), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(sampling_ratio, context=_ods_context))
    attributes["spatial_scale"] = (spatial_scale if (
    issubclass(type(spatial_scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(spatial_scale, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def rois(self):
    return self.operation.operands[1]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def output_height(self):
    return self.operation.attributes["output_height"]

  @output_height.setter
  def output_height(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_height"] = value

  @builtins.property
  def output_width(self):
    return self.operation.attributes["output_width"]

  @output_width.setter
  def output_width(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_width"] = value

  @builtins.property
  def sampling_ratio(self):
    return self.operation.attributes["sampling_ratio"]

  @sampling_ratio.setter
  def sampling_ratio(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sampling_ratio"] = value

  @builtins.property
  def spatial_scale(self):
    return self.operation.attributes["spatial_scale"]

  @spatial_scale.setter
  def spatial_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spatial_scale"] = value

  @builtins.property
  def align_corners(self):
    return self.operation.attributes["align_corners"]

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RoiExtractorOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.RoiExtractor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, rois, target_lvls, inputs, mode, num_levels, output_height, output_width, sampling_ratio, spatial_scales, align_corners, is_static, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(rois))
    operands.append(_get_op_result_or_value(target_lvls))
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('RoiAlignModeAttr')) else
      _ods_ir.AttrBuilder.get('RoiAlignModeAttr')(mode, context=_ods_context))
    attributes["num_levels"] = (num_levels if (
    issubclass(type(num_levels), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(num_levels, context=_ods_context))
    attributes["output_height"] = (output_height if (
    issubclass(type(output_height), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_height, context=_ods_context))
    attributes["output_width"] = (output_width if (
    issubclass(type(output_width), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_width, context=_ods_context))
    attributes["sampling_ratio"] = (sampling_ratio if (
    issubclass(type(sampling_ratio), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(sampling_ratio, context=_ods_context))
    attributes["spatial_scales"] = (spatial_scales if (
    issubclass(type(spatial_scales), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(spatial_scales, context=_ods_context))
    attributes["align_corners"] = (align_corners if (
    issubclass(type(align_corners), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(align_corners, context=_ods_context))
    attributes["is_static"] = (is_static if (
    issubclass(type(is_static), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(is_static, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def rois(self):
    return self.operation.operands[0]

  @builtins.property
  def target_lvls(self):
    return self.operation.operands[1]

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def num_levels(self):
    return self.operation.attributes["num_levels"]

  @num_levels.setter
  def num_levels(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_levels"] = value

  @builtins.property
  def output_height(self):
    return self.operation.attributes["output_height"]

  @output_height.setter
  def output_height(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_height"] = value

  @builtins.property
  def output_width(self):
    return self.operation.attributes["output_width"]

  @output_width.setter
  def output_width(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_width"] = value

  @builtins.property
  def sampling_ratio(self):
    return self.operation.attributes["sampling_ratio"]

  @sampling_ratio.setter
  def sampling_ratio(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sampling_ratio"] = value

  @builtins.property
  def spatial_scales(self):
    return self.operation.attributes["spatial_scales"]

  @spatial_scales.setter
  def spatial_scales(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spatial_scales"] = value

  @builtins.property
  def align_corners(self):
    return self.operation.attributes["align_corners"]

  @align_corners.setter
  def align_corners(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["align_corners"] = value

  @builtins.property
  def is_static(self):
    return self.operation.attributes["is_static"]

  @is_static.setter
  def is_static(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_static"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RopeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Rope"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, input3, *, is_permute_optimize=None, mul1_round_mode=None, mul2_round_mode=None, add_round_mode=None, mul1_shift=None, mul2_shift=None, add_shift=None, mul1_saturation=None, mul2_saturation=None, add_saturation=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input1))
    operands.append(_get_op_result_or_value(input2))
    operands.append(_get_op_result_or_value(input3))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_permute_optimize is not None: attributes["is_permute_optimize"] = (is_permute_optimize if (
        issubclass(type(is_permute_optimize), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_permute_optimize, context=_ods_context))
    if mul1_round_mode is not None: attributes["mul1_round_mode"] = (mul1_round_mode if (
        issubclass(type(mul1_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(mul1_round_mode, context=_ods_context))
    if mul2_round_mode is not None: attributes["mul2_round_mode"] = (mul2_round_mode if (
        issubclass(type(mul2_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(mul2_round_mode, context=_ods_context))
    if add_round_mode is not None: attributes["add_round_mode"] = (add_round_mode if (
        issubclass(type(add_round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(add_round_mode, context=_ods_context))
    if mul1_shift is not None: attributes["mul1_shift"] = (mul1_shift if (
        issubclass(type(mul1_shift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(mul1_shift, context=_ods_context))
    if mul2_shift is not None: attributes["mul2_shift"] = (mul2_shift if (
        issubclass(type(mul2_shift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(mul2_shift, context=_ods_context))
    if add_shift is not None: attributes["add_shift"] = (add_shift if (
        issubclass(type(add_shift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(add_shift, context=_ods_context))
    if mul1_saturation is not None: attributes["mul1_saturation"] = (mul1_saturation if (
        issubclass(type(mul1_saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(mul1_saturation, context=_ods_context))
    if mul2_saturation is not None: attributes["mul2_saturation"] = (mul2_saturation if (
        issubclass(type(mul2_saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(mul2_saturation, context=_ods_context))
    if add_saturation is not None: attributes["add_saturation"] = (add_saturation if (
        issubclass(type(add_saturation), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(add_saturation, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input1(self):
    return self.operation.operands[0]

  @builtins.property
  def input2(self):
    return self.operation.operands[1]

  @builtins.property
  def input3(self):
    return self.operation.operands[2]

  @builtins.property
  def is_permute_optimize(self):
    return self.operation.attributes["is_permute_optimize"]

  @is_permute_optimize.setter
  def is_permute_optimize(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_permute_optimize"] = value

  @builtins.property
  def mul1_round_mode(self):
    return self.operation.attributes["mul1_round_mode"]

  @mul1_round_mode.setter
  def mul1_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul1_round_mode"] = value

  @builtins.property
  def mul2_round_mode(self):
    return self.operation.attributes["mul2_round_mode"]

  @mul2_round_mode.setter
  def mul2_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul2_round_mode"] = value

  @builtins.property
  def add_round_mode(self):
    return self.operation.attributes["add_round_mode"]

  @add_round_mode.setter
  def add_round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["add_round_mode"] = value

  @builtins.property
  def mul1_shift(self):
    return self.operation.attributes["mul1_shift"]

  @mul1_shift.setter
  def mul1_shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul1_shift"] = value

  @builtins.property
  def mul2_shift(self):
    return self.operation.attributes["mul2_shift"]

  @mul2_shift.setter
  def mul2_shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul2_shift"] = value

  @builtins.property
  def add_shift(self):
    return self.operation.attributes["add_shift"]

  @add_shift.setter
  def add_shift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["add_shift"] = value

  @builtins.property
  def mul1_saturation(self):
    return self.operation.attributes["mul1_saturation"]

  @mul1_saturation.setter
  def mul1_saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul1_saturation"] = value

  @builtins.property
  def mul2_saturation(self):
    return self.operation.attributes["mul2_saturation"]

  @mul2_saturation.setter
  def mul2_saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mul2_saturation"] = value

  @builtins.property
  def add_saturation(self):
    return self.operation.attributes["add_saturation"]

  @add_saturation.setter
  def add_saturation(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["add_saturation"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScaleLutOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ScaleLut"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, scale, bias, *, sign=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale"] = (scale if (
    issubclass(type(scale), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(scale, context=_ods_context))
    attributes["bias"] = (bias if (
    issubclass(type(bias), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(bias, context=_ods_context))
    if sign is not None: attributes["sign"] = (sign if (
        issubclass(type(sign), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sign, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def bias(self):
    return self.operation.attributes["bias"]

  @bias.setter
  def bias(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bias"] = value

  @builtins.property
  def sign(self):
    return self.operation.attributes["sign"]

  @sign.setter
  def sign(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sign"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScaleOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Scale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, scale, bias, lshift, *, do_relu=None, relu_limit=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(scale))
    operands.append(_get_op_result_or_value(bias))
    operands.append(_get_op_result_or_value(lshift))
    _ods_context = _ods_get_default_loc_context(loc)
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def scale(self):
    return self.operation.operands[1]

  @builtins.property
  def bias(self):
    return self.operation.operands[2]

  @builtins.property
  def lshift(self):
    return self.operation.operands[3]

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScatterElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ScatterElements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, updates, indices_coeff, buffer, axis, *, reduction=None, nc_can_split=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    operands.append(_get_op_result_or_value(indices_coeff))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if reduction is not None: attributes["reduction"] = (reduction if (
        issubclass(type(reduction), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(reduction, context=_ods_context))
    if nc_can_split is not None: attributes["nc_can_split"] = (nc_can_split if (
        issubclass(type(nc_can_split), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(nc_can_split, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def indices_coeff(self):
    return self.operation.operands[3]

  @builtins.property
  def buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def reduction(self):
    return self.operation.attributes["reduction"]

  @reduction.setter
  def reduction(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction"] = value

  @builtins.property
  def nc_can_split(self):
    return self.operation.attributes["nc_can_split"]

  @nc_can_split.setter
  def nc_can_split(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nc_can_split"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScatterNDOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ScatterND"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input_data, indices, updates, buffer, *, reduction=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input_data))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if reduction is not None: attributes["reduction"] = (reduction if (
        issubclass(type(reduction), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(reduction, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input_data(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def buffer(self):
    return self.operation.operands[3]

  @builtins.property
  def reduction(self):
    return self.operation.attributes["reduction"]

  @reduction.setter
  def reduction(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SelectiveScanOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.SelectiveScan"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, Cs, deltaA, deltaB_u, us, Ds, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(Cs))
    operands.append(_get_op_result_or_value(deltaA))
    operands.append(_get_op_result_or_value(deltaB_u))
    operands.append(_get_op_result_or_value(us))
    operands.append(_get_op_result_or_value(Ds))
    _ods_context = _ods_get_default_loc_context(loc)
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def Cs(self):
    return self.operation.operands[0]

  @builtins.property
  def deltaA(self):
    return self.operation.operands[1]

  @builtins.property
  def deltaB_u(self):
    return self.operation.operands[2]

  @builtins.property
  def us(self):
    return self.operation.operands[3]

  @builtins.property
  def Ds(self):
    return self.operation.operands[4]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeArithOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeArith"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, type_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    issubclass(type(type_), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(type_, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeAssignOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeAssign"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.operands[1]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeCastOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeCast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeClipOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeClip"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, min, max, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["min"] = (min if (
    issubclass(type(min), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F32Attr')) else
      _ods_ir.AttrBuilder.get('F32Attr')(min, context=_ods_context))
    attributes["max"] = (max if (
    issubclass(type(max), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F32Attr')) else
      _ods_ir.AttrBuilder.get('F32Attr')(max, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def min(self):
    return self.operation.attributes["min"]

  @min.setter
  def min(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["min"] = value

  @builtins.property
  def max(self):
    return self.operation.attributes["max"]

  @max.setter
  def max(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["max"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapePackOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapePack"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapePowOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapePow"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, exponent, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["exponent"] = (exponent if (
    issubclass(type(exponent), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F32Attr')) else
      _ods_ir.AttrBuilder.get('F32Attr')(exponent, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def exponent(self):
    return self.operation.attributes["exponent"]

  @exponent.setter
  def exponent(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["exponent"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeReduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, keepdims, mode, *, scale=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    attributes["keepdims"] = (keepdims if (
    issubclass(type(keepdims), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(keepdims, context=_ods_context))
    attributes["mode"] = (mode if (
    issubclass(type(mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ReduceModeAttr')) else
      _ods_ir.AttrBuilder.get('ReduceModeAttr')(mode, context=_ods_context))
    if scale is not None: attributes["scale"] = (scale if (
        issubclass(type(scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(scale, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def keepdims(self):
    return self.operation.attributes["keepdims"]

  @keepdims.setter
  def keepdims(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keepdims"] = value

  @builtins.property
  def mode(self):
    return self.operation.attributes["mode"]

  @mode.setter
  def mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["mode"] = value

  @builtins.property
  def scale(self):
    return self.operation.attributes["scale"]

  @scale.setter
  def scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeReshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, shape=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if shape is not None: attributes["shape"] = (shape if (
        issubclass(type(shape), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(shape, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def shape(self):
    return self.operation.attributes["shape"]

  @shape.setter
  def shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shape"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeReverseOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeReverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axis, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeScatterElementsOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeScatterElements"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, updates, axis, *, reduction=None, nc_can_split=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    operands.append(_get_op_result_or_value(updates))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if reduction is not None: attributes["reduction"] = (reduction if (
        issubclass(type(reduction), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(reduction, context=_ods_context))
    if nc_can_split is not None: attributes["nc_can_split"] = (nc_can_split if (
        issubclass(type(nc_can_split), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(nc_can_split, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def updates(self):
    return self.operation.operands[2]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def reduction(self):
    return self.operation.attributes["reduction"]

  @reduction.setter
  def reduction(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction"] = value

  @builtins.property
  def nc_can_split(self):
    return self.operation.attributes["nc_can_split"]

  @nc_can_split.setter
  def nc_can_split(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nc_can_split"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeSlice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, offsetT, endsT, stepsT, offset, steps, ends, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(offsetT))
    operands.append(_get_op_result_or_value(endsT))
    operands.append(_get_op_result_or_value(stepsT))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(offset, context=_ods_context))
    attributes["steps"] = (steps if (
    issubclass(type(steps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(steps, context=_ods_context))
    attributes["ends"] = (ends if (
    issubclass(type(ends), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(ends, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def offsetT(self):
    return self.operation.operands[1]

  @builtins.property
  def endsT(self):
    return self.operation.operands[2]

  @builtins.property
  def stepsT(self):
    return self.operation.operands[3]

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def steps(self):
    return self.operation.attributes["steps"]

  @steps.setter
  def steps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["steps"] = value

  @builtins.property
  def ends(self):
    return self.operation.attributes["ends"]

  @ends.setter
  def ends(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ends"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeSqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeSqueeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeTileOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeTile"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, tileT=None, tile=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if tileT is not None: operands.append(_get_op_result_or_value(tileT))
    _ods_context = _ods_get_default_loc_context(loc)
    if tile is not None: attributes["tile"] = (tile if (
        issubclass(type(tile), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(tile, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tileT(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def tile(self):
    return self.operation.attributes["tile"]

  @tile.setter
  def tile(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tile"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeTransposeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeTranspose"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, order, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["order"] = (order if (
    issubclass(type(order), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(order, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def order(self):
    return self.operation.attributes["order"]

  @order.setter
  def order(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["order"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShapeUnsqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShapeUnsqueeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ShuffleChannelOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.ShuffleChannel"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, group, *, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["group"] = (group if (
    issubclass(type(group), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(group, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def group(self):
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SliceMergeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.SliceMerge"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SliceOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, offsetT, endsT, stepsT, buffer, offset, steps, ends, *, axes=None, hasparamConvert_axes=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(offsetT))
    operands.append(_get_op_result_or_value(endsT))
    operands.append(_get_op_result_or_value(stepsT))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["offset"] = (offset if (
    issubclass(type(offset), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(offset, context=_ods_context))
    attributes["steps"] = (steps if (
    issubclass(type(steps), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(steps, context=_ods_context))
    attributes["ends"] = (ends if (
    issubclass(type(ends), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(ends, context=_ods_context))
    if axes is not None: attributes["axes"] = (axes if (
        issubclass(type(axes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    if hasparamConvert_axes is not None: attributes["hasparamConvert_axes"] = (hasparamConvert_axes if (
        issubclass(type(hasparamConvert_axes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(hasparamConvert_axes, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def offsetT(self):
    return self.operation.operands[1]

  @builtins.property
  def endsT(self):
    return self.operation.operands[2]

  @builtins.property
  def stepsT(self):
    return self.operation.operands[3]

  @builtins.property
  def buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def offset(self):
    return self.operation.attributes["offset"]

  @offset.setter
  def offset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["offset"] = value

  @builtins.property
  def steps(self):
    return self.operation.attributes["steps"]

  @steps.setter
  def steps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["steps"] = value

  @builtins.property
  def ends(self):
    return self.operation.attributes["ends"]

  @ends.setter
  def ends(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ends"] = value

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def hasparamConvert_axes(self):
    return self.operation.attributes["hasparamConvert_axes"]

  @hasparamConvert_axes.setter
  def hasparamConvert_axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["hasparamConvert_axes"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftmaxBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.SoftmaxBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_input, grad_output, output, dim, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_output))
    operands.append(_get_op_result_or_value(output))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dim"] = (dim if (
    issubclass(type(dim), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(dim, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(grad_input)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.operands[1]

  @builtins.property
  def dim(self):
    return self.operation.attributes["dim"]

  @dim.setter
  def dim(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dim"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def grad_input(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftmaxCastOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.SoftmaxCast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, slope_table, reciprocal_table, reciprocal_mantissa_table, buffer, axis, *, log=None, beta=None, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(slope_table))
    operands.append(_get_op_result_or_value(reciprocal_table))
    operands.append(_get_op_result_or_value(reciprocal_mantissa_table))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if log is not None: attributes["log"] = (log if (
        issubclass(type(log), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(log, context=_ods_context))
    if beta is not None: attributes["beta"] = (beta if (
        issubclass(type(beta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def slope_table(self):
    return self.operation.operands[2]

  @builtins.property
  def reciprocal_table(self):
    return self.operation.operands[3]

  @builtins.property
  def reciprocal_mantissa_table(self):
    return self.operation.operands[4]

  @builtins.property
  def buffer(self):
    return self.operation.operands[5]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def log(self):
    return self.operation.attributes["log"]

  @log.setter
  def log(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["log"] = value

  @builtins.property
  def beta(self):
    return self.operation.attributes["beta"]

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SoftmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Softmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, table, slope_table, reciprocal_table, reciprocal_mantissa_table, buffer, axis, *, log=None, beta=None, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(table))
    operands.append(_get_op_result_or_value(slope_table))
    operands.append(_get_op_result_or_value(reciprocal_table))
    operands.append(_get_op_result_or_value(reciprocal_mantissa_table))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(axis, context=_ods_context))
    if log is not None: attributes["log"] = (log if (
        issubclass(type(log), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(log, context=_ods_context))
    if beta is not None: attributes["beta"] = (beta if (
        issubclass(type(beta), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(beta, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def table(self):
    return self.operation.operands[1]

  @builtins.property
  def slope_table(self):
    return self.operation.operands[2]

  @builtins.property
  def reciprocal_table(self):
    return self.operation.operands[3]

  @builtins.property
  def reciprocal_mantissa_table(self):
    return self.operation.operands[4]

  @builtins.property
  def buffer(self):
    return self.operation.operands[5]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def log(self):
    return self.operation.attributes["log"]

  @log.setter
  def log(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["log"] = value

  @builtins.property
  def beta(self):
    return self.operation.attributes["beta"]

  @beta.setter
  def beta(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["beta"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SortOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Sort"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, buffer, axis, *, descending=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    if descending is not None: attributes["descending"] = (descending if (
        issubclass(type(descending), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(descending, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def descending(self):
    return self.operation.attributes["descending"]

  @descending.setter
  def descending(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["descending"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Space2BatchOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Space2Batch"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, buffer, block_h, block_w, pads, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["block_h"] = (block_h if (
    issubclass(type(block_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_h, context=_ods_context))
    attributes["block_w"] = (block_w if (
    issubclass(type(block_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(block_w, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def block_h(self):
    return self.operation.attributes["block_h"]

  @block_h.setter
  def block_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_h"] = value

  @builtins.property
  def block_w(self):
    return self.operation.attributes["block_w"]

  @block_w.setter
  def block_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["block_w"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Split"

  _ODS_REGIONS = (0, True)

  def __init__(self, outputs, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(outputs)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def outputs(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Squeeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class StoreOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Store"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, buffer, *, ginfo=None, support_compress=None, compress_info=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if support_compress is not None: attributes["support_compress"] = (support_compress if (
        issubclass(type(support_compress), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(support_compress, context=_ods_context))
    if compress_info is not None: attributes["compress_info"] = (compress_info if (
        issubclass(type(compress_info), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_CompressAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_CompressAttr')(compress_info, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def support_compress(self):
    return self.operation.attributes["support_compress"]

  @support_compress.setter
  def support_compress(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["support_compress"] = value

  @builtins.property
  def compress_info(self):
    if "compress_info" not in self.operation.attributes:
      return None
    return self.operation.attributes["compress_info"]

  @compress_info.setter
  def compress_info(self, value):
    if value is not None:
      self.operation.attributes["compress_info"] = value
    elif "compress_info" in self.operation.attributes:
      del self.operation.attributes["compress_info"]

  @compress_info.deleter
  def compress_info(self):
    del self.operation.attributes["compress_info"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class StridedSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.StridedSlice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, starts, ends, strides, begin_mask, end_mask, ellipsis_mask, new_axis_mask, shrink_axis_mask, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(starts))
    operands.append(_get_op_result_or_value(ends))
    operands.append(_get_op_result_or_value(strides))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["begin_mask"] = (begin_mask if (
    issubclass(type(begin_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(begin_mask, context=_ods_context))
    attributes["end_mask"] = (end_mask if (
    issubclass(type(end_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(end_mask, context=_ods_context))
    attributes["ellipsis_mask"] = (ellipsis_mask if (
    issubclass(type(ellipsis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(ellipsis_mask, context=_ods_context))
    attributes["new_axis_mask"] = (new_axis_mask if (
    issubclass(type(new_axis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(new_axis_mask, context=_ods_context))
    attributes["shrink_axis_mask"] = (shrink_axis_mask if (
    issubclass(type(shrink_axis_mask), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(shrink_axis_mask, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def starts(self):
    return self.operation.operands[1]

  @builtins.property
  def ends(self):
    return self.operation.operands[2]

  @builtins.property
  def strides(self):
    return self.operation.operands[3]

  @builtins.property
  def begin_mask(self):
    return self.operation.attributes["begin_mask"]

  @begin_mask.setter
  def begin_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["begin_mask"] = value

  @builtins.property
  def end_mask(self):
    return self.operation.attributes["end_mask"]

  @end_mask.setter
  def end_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["end_mask"] = value

  @builtins.property
  def ellipsis_mask(self):
    return self.operation.attributes["ellipsis_mask"]

  @ellipsis_mask.setter
  def ellipsis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ellipsis_mask"] = value

  @builtins.property
  def new_axis_mask(self):
    return self.operation.attributes["new_axis_mask"]

  @new_axis_mask.setter
  def new_axis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["new_axis_mask"] = value

  @builtins.property
  def shrink_axis_mask(self):
    return self.operation.attributes["shrink_axis_mask"]

  @shrink_axis_mask.setter
  def shrink_axis_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["shrink_axis_mask"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SubConstOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.SubConst"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, const_val, *, is_reverse=None, do_relu=None, relu_limit=None, multiplier=None, rshift=None, f8_scale=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["const_val"] = (const_val if (
    issubclass(type(const_val), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(const_val, context=_ods_context))
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if multiplier is not None: attributes["multiplier"] = (multiplier if (
        issubclass(type(multiplier), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(multiplier, context=_ods_context))
    if rshift is not None: attributes["rshift"] = (rshift if (
        issubclass(type(rshift), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SI32Attr')) else
          _ods_ir.AttrBuilder.get('SI32Attr')(rshift, context=_ods_context))
    if f8_scale is not None: attributes["f8_scale"] = (f8_scale if (
        issubclass(type(f8_scale), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(f8_scale, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def const_val(self):
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["const_val"] = value

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def multiplier(self):
    return self.operation.attributes["multiplier"]

  @multiplier.setter
  def multiplier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["multiplier"] = value

  @builtins.property
  def rshift(self):
    return self.operation.attributes["rshift"]

  @rshift.setter
  def rshift(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["rshift"] = value

  @builtins.property
  def f8_scale(self):
    return self.operation.attributes["f8_scale"]

  @f8_scale.setter
  def f8_scale(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["f8_scale"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SubOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, *, is_reverse=None, do_relu=None, relu_limit=None, coeff=None, multipliers=None, rshifts=None, f8_scales=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    if is_reverse is not None: attributes["is_reverse"] = (is_reverse if (
        issubclass(type(is_reverse), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(is_reverse, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if coeff is not None: attributes["coeff"] = (coeff if (
        issubclass(type(coeff), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(coeff, context=_ods_context))
    if multipliers is not None: attributes["multipliers"] = (multipliers if (
        issubclass(type(multipliers), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(multipliers, context=_ods_context))
    if rshifts is not None: attributes["rshifts"] = (rshifts if (
        issubclass(type(rshifts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(rshifts, context=_ods_context))
    if f8_scales is not None: attributes["f8_scales"] = (f8_scales if (
        issubclass(type(f8_scales), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('F64ArrayAttr')(f8_scales, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def is_reverse(self):
    return self.operation.attributes["is_reverse"]

  @is_reverse.setter
  def is_reverse(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["is_reverse"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def coeff(self):
    if "coeff" not in self.operation.attributes:
      return None
    return self.operation.attributes["coeff"]

  @coeff.setter
  def coeff(self, value):
    if value is not None:
      self.operation.attributes["coeff"] = value
    elif "coeff" in self.operation.attributes:
      del self.operation.attributes["coeff"]

  @coeff.deleter
  def coeff(self):
    del self.operation.attributes["coeff"]

  @builtins.property
  def multipliers(self):
    if "multipliers" not in self.operation.attributes:
      return None
    return self.operation.attributes["multipliers"]

  @multipliers.setter
  def multipliers(self, value):
    if value is not None:
      self.operation.attributes["multipliers"] = value
    elif "multipliers" in self.operation.attributes:
      del self.operation.attributes["multipliers"]

  @multipliers.deleter
  def multipliers(self):
    del self.operation.attributes["multipliers"]

  @builtins.property
  def rshifts(self):
    if "rshifts" not in self.operation.attributes:
      return None
    return self.operation.attributes["rshifts"]

  @rshifts.setter
  def rshifts(self, value):
    if value is not None:
      self.operation.attributes["rshifts"] = value
    elif "rshifts" in self.operation.attributes:
      del self.operation.attributes["rshifts"]

  @rshifts.deleter
  def rshifts(self):
    del self.operation.attributes["rshifts"]

  @builtins.property
  def f8_scales(self):
    if "f8_scales" not in self.operation.attributes:
      return None
    return self.operation.attributes["f8_scales"]

  @f8_scales.setter
  def f8_scales(self, value):
    if value is not None:
      self.operation.attributes["f8_scales"] = value
    elif "f8_scales" in self.operation.attributes:
      del self.operation.attributes["f8_scales"]

  @f8_scales.deleter
  def f8_scales(self):
    del self.operation.attributes["f8_scales"]

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, buffer, *, tileT=None, tile=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if tileT is not None: operands.append(_get_op_result_or_value(tileT))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if tile is not None: attributes["tile"] = (tile if (
        issubclass(type(tile), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(tile, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def tileT(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[1]

  @builtins.property
  def buffer(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def tile(self):
    return self.operation.attributes["tile"]

  @tile.setter
  def tile(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tile"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TopKOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.TopK"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, indices, input, axis, K, buffer_val, buffer_idx, *, kT=None, largest=None, sorted=None, values_used_only=None, replace_topk_indices=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    if kT is not None: operands.append(_get_op_result_or_value(kT))
    operands.append(_get_op_result_or_value(buffer_val))
    operands.append(_get_op_result_or_value(buffer_idx))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axis"] = (axis if (
    issubclass(type(axis), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(axis, context=_ods_context))
    attributes["K"] = (K if (
    issubclass(type(K), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(K, context=_ods_context))
    if largest is not None: attributes["largest"] = (largest if (
        issubclass(type(largest), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(largest, context=_ods_context))
    if sorted is not None: attributes["sorted"] = (sorted if (
        issubclass(type(sorted), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(sorted, context=_ods_context))
    if values_used_only is not None: attributes["values_used_only"] = (values_used_only if (
        issubclass(type(values_used_only), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(values_used_only, context=_ods_context))
    if replace_topk_indices is not None: attributes["replace_topk_indices"] = (replace_topk_indices if (
        issubclass(type(replace_topk_indices), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(replace_topk_indices, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(values)
    results.append(indices)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def kT(self):
    return None if len(self.operation.operands) < 4 else self.operation.operands[1]

  @builtins.property
  def buffer_val(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def buffer_idx(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def axis(self):
    return self.operation.attributes["axis"]

  @axis.setter
  def axis(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axis"] = value

  @builtins.property
  def K(self):
    return self.operation.attributes["K"]

  @K.setter
  def K(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["K"] = value

  @builtins.property
  def largest(self):
    return self.operation.attributes["largest"]

  @largest.setter
  def largest(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["largest"] = value

  @builtins.property
  def sorted(self):
    return self.operation.attributes["sorted"]

  @sorted.setter
  def sorted(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sorted"] = value

  @builtins.property
  def values_used_only(self):
    return self.operation.attributes["values_used_only"]

  @values_used_only.setter
  def values_used_only(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values_used_only"] = value

  @builtins.property
  def replace_topk_indices(self):
    return self.operation.attributes["replace_topk_indices"]

  @replace_topk_indices.setter
  def replace_topk_indices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["replace_topk_indices"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def values(self):
    return self.operation.results[0]

  @builtins.property
  def indices(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TriluOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Trilu"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, upper, diagonal, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["upper"] = (upper if (
    issubclass(type(upper), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(upper, context=_ods_context))
    attributes["diagonal"] = (diagonal if (
    issubclass(type(diagonal), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SI32Attr')) else
      _ods_ir.AttrBuilder.get('SI32Attr')(diagonal, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def upper(self):
    return self.operation.attributes["upper"]

  @upper.setter
  def upper(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["upper"] = value

  @builtins.property
  def diagonal(self):
    return self.operation.attributes["diagonal"]

  @diagonal.setter
  def diagonal(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["diagonal"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UnsqueezeOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Unsqueeze"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, axes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["axes"] = (axes if (
    issubclass(type(axes), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(axes, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def axes(self):
    return self.operation.attributes["axes"]

  @axes.setter
  def axes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["axes"] = value

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class UpsampleOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Upsample"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, indices, scale_h, scale_w, *, do_relu=None, relu_limit=None, ginfo=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["scale_h"] = (scale_h if (
    issubclass(type(scale_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_h, context=_ods_context))
    attributes["scale_w"] = (scale_w if (
    issubclass(type(scale_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(scale_w, context=_ods_context))
    if do_relu is not None: attributes["do_relu"] = (do_relu if (
        issubclass(type(do_relu), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_relu, context=_ods_context))
    if relu_limit is not None: attributes["relu_limit"] = (relu_limit if (
        issubclass(type(relu_limit), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(relu_limit, context=_ods_context))
    if ginfo is not None: attributes["ginfo"] = (ginfo if (
        issubclass(type(ginfo), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_LayerGroupAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_LayerGroupAttr')(ginfo, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def scale_h(self):
    return self.operation.attributes["scale_h"]

  @scale_h.setter
  def scale_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_h"] = value

  @builtins.property
  def scale_w(self):
    return self.operation.attributes["scale_w"]

  @scale_w.setter
  def scale_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["scale_w"] = value

  @builtins.property
  def do_relu(self):
    return self.operation.attributes["do_relu"]

  @do_relu.setter
  def do_relu(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_relu"] = value

  @builtins.property
  def relu_limit(self):
    return self.operation.attributes["relu_limit"]

  @relu_limit.setter
  def relu_limit(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["relu_limit"] = value

  @builtins.property
  def ginfo(self):
    if "ginfo" not in self.operation.attributes:
      return None
    return self.operation.attributes["ginfo"]

  @ginfo.setter
  def ginfo(self, value):
    if value is not None:
      self.operation.attributes["ginfo"] = value
    elif "ginfo" in self.operation.attributes:
      del self.operation.attributes["ginfo"]

  @ginfo.deleter
  def ginfo(self):
    del self.operation.attributes["ginfo"]

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Weight2ActivationOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Weight2Activation"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WeightReorderOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.WeightReorder"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, reorder_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(input))
    _ods_context = _ods_get_default_loc_context(loc)
    if reorder_mode is not None: attributes["reorder_mode"] = (reorder_mode if (
        issubclass(type(reorder_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(reorder_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def reorder_mode(self):
    return self.operation.attributes["reorder_mode"]

  @reorder_mode.setter
  def reorder_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reorder_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WhereBnbwdOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.WhereBnbwdOp"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_in, weight_grad, bias_grad, where_output, where_grad_out, bnbwd_input, bnbwd_weight, bnbwd_bias, bnbwd_saved_mean, bnbwd_saved_invstd, buffer, *, epsilon=None, do_recompute=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(where_output))
    operands.append(_get_op_result_or_value(where_grad_out))
    operands.append(_get_op_result_or_value(bnbwd_input))
    operands.append(_get_op_result_or_value(bnbwd_weight))
    operands.append(_get_op_result_or_value(bnbwd_bias))
    operands.append(_get_op_result_or_value(bnbwd_saved_mean))
    operands.append(_get_op_result_or_value(bnbwd_saved_invstd))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if epsilon is not None: attributes["epsilon"] = (epsilon if (
        issubclass(type(epsilon), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(epsilon, context=_ods_context))
    if do_recompute is not None: attributes["do_recompute"] = (do_recompute if (
        issubclass(type(do_recompute), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(do_recompute, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(grad_in)
    results.append(weight_grad)
    results.append(bias_grad)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def where_output(self):
    return self.operation.operands[0]

  @builtins.property
  def where_grad_out(self):
    return self.operation.operands[1]

  @builtins.property
  def bnbwd_input(self):
    return self.operation.operands[2]

  @builtins.property
  def bnbwd_weight(self):
    return self.operation.operands[3]

  @builtins.property
  def bnbwd_bias(self):
    return self.operation.operands[4]

  @builtins.property
  def bnbwd_saved_mean(self):
    return self.operation.operands[5]

  @builtins.property
  def bnbwd_saved_invstd(self):
    return self.operation.operands[6]

  @builtins.property
  def buffer(self):
    return self.operation.operands[7]

  @builtins.property
  def epsilon(self):
    return self.operation.attributes["epsilon"]

  @epsilon.setter
  def epsilon(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["epsilon"] = value

  @builtins.property
  def do_recompute(self):
    return self.operation.attributes["do_recompute"]

  @do_recompute.setter
  def do_recompute(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["do_recompute"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def grad_in(self):
    return self.operation.results[0]

  @builtins.property
  def weight_grad(self):
    return self.operation.results[1]

  @builtins.property
  def bias_grad(self):
    return self.operation.results[2]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WhereOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Where"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, cond, tbrn, fbrn, buffer, *, x_is_const=None, y_is_const=None, x_const_val=None, y_const_val=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(cond))
    operands.append(_get_op_result_or_value(tbrn))
    operands.append(_get_op_result_or_value(fbrn))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    if x_is_const is not None: attributes["x_is_const"] = (x_is_const if (
        issubclass(type(x_is_const), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(x_is_const, context=_ods_context))
    if y_is_const is not None: attributes["y_is_const"] = (y_is_const if (
        issubclass(type(y_is_const), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(y_is_const, context=_ods_context))
    if x_const_val is not None: attributes["x_const_val"] = (x_const_val if (
        issubclass(type(x_const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(x_const_val, context=_ods_context))
    if y_const_val is not None: attributes["y_const_val"] = (y_const_val if (
        issubclass(type(y_const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('F64Attr')) else
          _ods_ir.AttrBuilder.get('F64Attr')(y_const_val, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def cond(self):
    return self.operation.operands[0]

  @builtins.property
  def tbrn(self):
    return self.operation.operands[1]

  @builtins.property
  def fbrn(self):
    return self.operation.operands[2]

  @builtins.property
  def buffer(self):
    return self.operation.operands[3]

  @builtins.property
  def x_is_const(self):
    return self.operation.attributes["x_is_const"]

  @x_is_const.setter
  def x_is_const(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["x_is_const"] = value

  @builtins.property
  def y_is_const(self):
    return self.operation.attributes["y_is_const"]

  @y_is_const.setter
  def y_is_const(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_is_const"] = value

  @builtins.property
  def x_const_val(self):
    return self.operation.attributes["x_const_val"]

  @x_const_val.setter
  def x_const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["x_const_val"] = value

  @builtins.property
  def y_const_val(self):
    return self.operation.attributes["y_const_val"]

  @y_const_val.setter
  def y_const_val(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["y_const_val"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class YoloDetectionOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.YoloDetection"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inputs, net_input_h, net_input_w, nms_threshold, obj_threshold, keep_topk, anchors, version, buffer, *, class_num=None, num_boxes=None, agnostic_nms=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    operands.append(_get_op_result_or_value(buffer))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["net_input_h"] = (net_input_h if (
    issubclass(type(net_input_h), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_h, context=_ods_context))
    attributes["net_input_w"] = (net_input_w if (
    issubclass(type(net_input_w), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(net_input_w, context=_ods_context))
    attributes["nms_threshold"] = (nms_threshold if (
    issubclass(type(nms_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(nms_threshold, context=_ods_context))
    attributes["obj_threshold"] = (obj_threshold if (
    issubclass(type(obj_threshold), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64Attr')) else
      _ods_ir.AttrBuilder.get('F64Attr')(obj_threshold, context=_ods_context))
    attributes["keep_topk"] = (keep_topk if (
    issubclass(type(keep_topk), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(keep_topk, context=_ods_context))
    attributes["anchors"] = (anchors if (
    issubclass(type(anchors), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('F64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('F64ArrayAttr')(anchors, context=_ods_context))
    attributes["version"] = (version if (
    issubclass(type(version), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('YoloVersionAttr')) else
      _ods_ir.AttrBuilder.get('YoloVersionAttr')(version, context=_ods_context))
    if class_num is not None: attributes["class_num"] = (class_num if (
        issubclass(type(class_num), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(class_num, context=_ods_context))
    if num_boxes is not None: attributes["num_boxes"] = (num_boxes if (
        issubclass(type(num_boxes), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(num_boxes, context=_ods_context))
    if agnostic_nms is not None: attributes["agnostic_nms"] = (agnostic_nms if (
        issubclass(type(agnostic_nms), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(agnostic_nms, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def buffer(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def net_input_h(self):
    return self.operation.attributes["net_input_h"]

  @net_input_h.setter
  def net_input_h(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_h"] = value

  @builtins.property
  def net_input_w(self):
    return self.operation.attributes["net_input_w"]

  @net_input_w.setter
  def net_input_w(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["net_input_w"] = value

  @builtins.property
  def nms_threshold(self):
    return self.operation.attributes["nms_threshold"]

  @nms_threshold.setter
  def nms_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["nms_threshold"] = value

  @builtins.property
  def obj_threshold(self):
    return self.operation.attributes["obj_threshold"]

  @obj_threshold.setter
  def obj_threshold(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["obj_threshold"] = value

  @builtins.property
  def keep_topk(self):
    return self.operation.attributes["keep_topk"]

  @keep_topk.setter
  def keep_topk(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keep_topk"] = value

  @builtins.property
  def anchors(self):
    return self.operation.attributes["anchors"]

  @anchors.setter
  def anchors(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["anchors"] = value

  @builtins.property
  def version(self):
    return self.operation.attributes["version"]

  @version.setter
  def version(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["version"] = value

  @builtins.property
  def class_num(self):
    return self.operation.attributes["class_num"]

  @class_num.setter
  def class_num(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["class_num"] = value

  @builtins.property
  def num_boxes(self):
    return self.operation.attributes["num_boxes"]

  @num_boxes.setter
  def num_boxes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["num_boxes"] = value

  @builtins.property
  def agnostic_nms(self):
    return self.operation.attributes["agnostic_nms"]

  @agnostic_nms.setter
  def agnostic_nms(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["agnostic_nms"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class Yuv2rgbFormulaOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.Yuv2rgbFormula"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, YUV, src_format, dst_format, image_format, formula_mode, *, round_mode=None, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(YUV))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["src_format"] = (src_format if (
    issubclass(type(src_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('UI32Attr')) else
      _ods_ir.AttrBuilder.get('UI32Attr')(src_format, context=_ods_context))
    attributes["dst_format"] = (dst_format if (
    issubclass(type(dst_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('UI32Attr')) else
      _ods_ir.AttrBuilder.get('UI32Attr')(dst_format, context=_ods_context))
    attributes["image_format"] = (image_format if (
    issubclass(type(image_format), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_ImageOutFormatAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_ImageOutFormatAttr')(image_format, context=_ods_context))
    attributes["formula_mode"] = (formula_mode if (
    issubclass(type(formula_mode), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Tpu_Yuv2rgbFormulaAttr')) else
      _ods_ir.AttrBuilder.get('Tpu_Yuv2rgbFormulaAttr')(formula_mode, context=_ods_context))
    if round_mode is not None: attributes["round_mode"] = (round_mode if (
        issubclass(type(round_mode), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Tpu_RoundModeAttr')) else
          _ods_ir.AttrBuilder.get('Tpu_RoundModeAttr')(round_mode, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(output)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def YUV(self):
    return self.operation.operands[0]

  @builtins.property
  def src_format(self):
    return self.operation.attributes["src_format"]

  @src_format.setter
  def src_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["src_format"] = value

  @builtins.property
  def dst_format(self):
    return self.operation.attributes["dst_format"]

  @dst_format.setter
  def dst_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dst_format"] = value

  @builtins.property
  def image_format(self):
    return self.operation.attributes["image_format"]

  @image_format.setter
  def image_format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["image_format"] = value

  @builtins.property
  def formula_mode(self):
    return self.operation.attributes["formula_mode"]

  @formula_mode.setter
  def formula_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["formula_mode"] = value

  @builtins.property
  def round_mode(self):
    return self.operation.attributes["round_mode"]

  @round_mode.setter
  def round_mode(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["round_mode"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def output(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MaxPoolingIndicesBwdOp(_ods_ir.OpView):
  OPERATION_NAME = "tpu.MaxPoolingIndicesBwd"

  _ODS_REGIONS = (0, True)

  def __init__(self, grad_input, grad_output, indices, kernel_shape, strides, pads, dilations, input_shape, *, multicore=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(grad_output))
    operands.append(_get_op_result_or_value(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["kernel_shape"] = (kernel_shape if (
    issubclass(type(kernel_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(kernel_shape, context=_ods_context))
    attributes["strides"] = (strides if (
    issubclass(type(strides), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(strides, context=_ods_context))
    attributes["pads"] = (pads if (
    issubclass(type(pads), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(pads, context=_ods_context))
    attributes["dilations"] = (dilations if (
    issubclass(type(dilations), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(dilations, context=_ods_context))
    attributes["input_shape"] = (input_shape if (
    issubclass(type(input_shape), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I64ArrayAttr')(input_shape, context=_ods_context))
    if multicore is not None: attributes["multicore"] = (multicore if (
        issubclass(type(multicore), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(multicore, context=_ods_context))
    results.append(grad_input)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def grad_output(self):
    return self.operation.operands[0]

  @builtins.property
  def indices(self):
    return self.operation.operands[1]

  @builtins.property
  def kernel_shape(self):
    return self.operation.attributes["kernel_shape"]

  @kernel_shape.setter
  def kernel_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_shape"] = value

  @builtins.property
  def strides(self):
    return self.operation.attributes["strides"]

  @strides.setter
  def strides(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strides"] = value

  @builtins.property
  def pads(self):
    return self.operation.attributes["pads"]

  @pads.setter
  def pads(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pads"] = value

  @builtins.property
  def dilations(self):
    return self.operation.attributes["dilations"]

  @dilations.setter
  def dilations(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dilations"] = value

  @builtins.property
  def input_shape(self):
    return self.operation.attributes["input_shape"]

  @input_shape.setter
  def input_shape(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["input_shape"] = value

  @builtins.property
  def multicore(self):
    if "multicore" not in self.operation.attributes:
      return None
    return self.operation.attributes["multicore"]

  @multicore.setter
  def multicore(self, value):
    if value is not None:
      self.operation.attributes["multicore"] = value
    elif "multicore" in self.operation.attributes:
      del self.operation.attributes["multicore"]

  @multicore.deleter
  def multicore(self):
    del self.operation.attributes["multicore"]

  @builtins.property
  def grad_input(self):
    return self.operation.results[0]
