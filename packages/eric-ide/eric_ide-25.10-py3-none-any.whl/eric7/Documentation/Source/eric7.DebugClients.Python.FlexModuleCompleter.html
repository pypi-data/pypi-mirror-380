<!DOCTYPE html>
<html><head>
<title>eric7.DebugClients.Python.FlexModuleCompleter</title>
<meta charset="UTF-8">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<a NAME="top" ID="top"></a>
<h1>eric7.DebugClients.Python.FlexModuleCompleter</h1>
<p>
Module word completion for the eric-ide shell.
</p>
<p>
<h4>NOTE for eric-ide variant</h4>
</p>
<p>
    This version is a re-implementation of _module_completer as found in the Python3
    library. It is modified to work with the eric-ide debug client.
</p>

<h3>Global Attributes</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Classes</h3>
<table>
<tr>
<td><a href="#ImportParser">ImportParser</a></td>
<td>Class to Parse incomplete import statements that are suitable for autocomplete suggestions.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter">ModuleCompleter</a></td>
<td>Class implementing a completer for Python import statements.</td>
</tr>
<tr>
<td><a href="#ParseError">ParseError</a></td>
<td>Class representing a parsing issue.</td>
</tr>
<tr>
<td><a href="#Result">Result</a></td>
<td>Class implementing the result data structure.</td>
</tr>
<tr>
<td><a href="#TokenQueue">TokenQueue</a></td>
<td>Class implementing helper functions for working with a sequence of tokens.</td>
</tr>
</table>

<h3>Functions</h3>
<table>
<tr><td>None</td></tr>
</table>

<hr />
<hr />
<a NAME="ImportParser" ID="ImportParser"></a>
<h2>ImportParser</h2>
<p>
    Class to Parse incomplete import statements that are suitable for autocomplete
    suggestions.
</p>
<p>
    Examples:
        - import foo          -> Result(from_name=None, name='foo')
        - import foo.         -> Result(from_name=None, name='foo.')
        - from foo            -> Result(from_name='foo', name=None)
        - from foo import bar -> Result(from_name='foo', name='bar')
        - from .foo import (  -> Result(from_name='.foo', name='')
</p>
<p>
    Note that the parser works in reverse order, starting from the
    last token in the input string. This makes the parser more robust
    when parsing multiple statements.
</p>

<h3>Derived from</h3>
None
<h3>Class Attributes</h3>
<table>
<tr><td>_ignored_tokens</td></tr>
<tr><td>_keywords</td></tr>
</table>

<h3>Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Methods</h3>
<table>
<tr>
<td><a href="#ImportParser.__init__">ImportParser</a></td>
<td>Constructor</td>
</tr>
<tr>
<td><a href="#ImportParser._parse">_parse</a></td>
<td>Protected method parse the supported import variants.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse">parse</a></td>
<td>Public method to parse the code line.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse_as_name">parse_as_name</a></td>
<td>Public method to parse the as part.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse_as_names">parse_as_names</a></td>
<td>Public method to parse the as parts.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse_dotted_as_name">parse_dotted_as_name</a></td>
<td>Public method to parse a dotted as name.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse_dotted_name">parse_dotted_name</a></td>
<td>Public method to parse a dotted name.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse_empty_from_import">parse_empty_from_import</a></td>
<td>Public method to parse an empty from...import statement.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse_from">parse_from</a></td>
<td>Public method to parse the from part.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse_from_import">parse_from_import</a></td>
<td>Public method to parse a from...import statement.</td>
</tr>
<tr>
<td><a href="#ImportParser.parse_import">parse_import</a></td>
<td>Public method to parse a simple import statement.</td>
</tr>
</table>

<h3>Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>


<a NAME="ImportParser.__init__" ID="ImportParser.__init__"></a>
<h4>ImportParser (Constructor)</h4>
<b>ImportParser</b>(<i>code_line</i>)
<p>
        Constructor
</p>

<dl>

<dt><i>code_line</i> (str)</dt>
<dd>
line of code to be parsed
</dd>
</dl>
<a NAME="ImportParser._parse" ID="ImportParser._parse"></a>
<h4>ImportParser._parse</h4>
<b>_parse</b>(<i></i>)
<p>
        Protected method parse the supported import variants.
</p>

<dl>
<dt>Return:</dt>
<dd>
result of the parse operation
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
Result
</dd>
</dl>
<a NAME="ImportParser.parse" ID="ImportParser.parse"></a>
<h4>ImportParser.parse</h4>
<b>parse</b>(<i></i>)
<p>
        Public method to parse the code line.
</p>

<dl>
<dt>Return:</dt>
<dd>
tuple containing the package name and the module name
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (str, str)
</dd>
</dl>
<a NAME="ImportParser.parse_as_name" ID="ImportParser.parse_as_name"></a>
<h4>ImportParser.parse_as_name</h4>
<b>parse_as_name</b>(<i></i>)
<p>
        Public method to parse the as part.
</p>

<a NAME="ImportParser.parse_as_names" ID="ImportParser.parse_as_names"></a>
<h4>ImportParser.parse_as_names</h4>
<b>parse_as_names</b>(<i></i>)
<p>
        Public method to parse the as parts.
</p>

<a NAME="ImportParser.parse_dotted_as_name" ID="ImportParser.parse_dotted_as_name"></a>
<h4>ImportParser.parse_dotted_as_name</h4>
<b>parse_dotted_as_name</b>(<i></i>)
<p>
        Public method to parse a dotted as name.
</p>

<dl>
<dt>Return:</dt>
<dd>
module name
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<a NAME="ImportParser.parse_dotted_name" ID="ImportParser.parse_dotted_name"></a>
<h4>ImportParser.parse_dotted_name</h4>
<b>parse_dotted_name</b>(<i></i>)
<p>
        Public method to parse a dotted name.
</p>

<dl>
<dt>Return:</dt>
<dd>
dotted module name
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<dl>

<dt>Raises <b>ParseError</b>:</dt>
<dd>
DESCRIPTION
</dd>
</dl>
<a NAME="ImportParser.parse_empty_from_import" ID="ImportParser.parse_empty_from_import"></a>
<h4>ImportParser.parse_empty_from_import</h4>
<b>parse_empty_from_import</b>(<i></i>)
<p>
        Public method to parse an empty from...import statement.
</p>

<dl>
<dt>Return:</dt>
<dd>
package name
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<a NAME="ImportParser.parse_from" ID="ImportParser.parse_from"></a>
<h4>ImportParser.parse_from</h4>
<b>parse_from</b>(<i></i>)
<p>
        Public method to parse the from part.
</p>

<dl>
<dt>Return:</dt>
<dd>
package name
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<a NAME="ImportParser.parse_from_import" ID="ImportParser.parse_from_import"></a>
<h4>ImportParser.parse_from_import</h4>
<b>parse_from_import</b>(<i></i>)
<p>
        Public method to parse a from...import statement.
</p>

<dl>
<dt>Return:</dt>
<dd>
result of the parse operation
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
Result
</dd>
</dl>
<dl>

<dt>Raises <b>ParseError</b>:</dt>
<dd>
DESCRIPTION
</dd>
</dl>
<a NAME="ImportParser.parse_import" ID="ImportParser.parse_import"></a>
<h4>ImportParser.parse_import</h4>
<b>parse_import</b>(<i></i>)
<p>
        Public method to parse a simple import statement.
</p>

<dl>
<dt>Return:</dt>
<dd>
result of the parse operation
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
Result
</dd>
</dl>
<dl>

<dt>Raises <b>ParseError</b>:</dt>
<dd>
DESCRIPTION
</dd>
</dl>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="ModuleCompleter" ID="ModuleCompleter"></a>
<h2>ModuleCompleter</h2>
<p>
    Class implementing a completer for Python import statements.
</p>
<p>
    Examples:
        - import <tab>
        - import foo<tab>
        - import foo.<tab>
        - import foo as bar, baz<tab>
</p>
<p>
        - from <tab>
        - from foo<tab>
        - from foo import <tab>
        - from foo import bar<tab>
        - from foo import (bar as baz, qux<tab>
</p>

<h3>Derived from</h3>
None
<h3>Class Attributes</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Methods</h3>
<table>
<tr>
<td><a href="#ModuleCompleter.__init__">ModuleCompleter</a></td>
<td>Constructor</td>
</tr>
<tr>
<td><a href="#ModuleCompleter._find_modules">_find_modules</a></td>
<td>Protected method to find all modules under 'path' that start with 'prefix' (even invalid module names).</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.complete">complete</a></td>
<td>Public method to complete module or submodule names.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.find_modules">find_modules</a></td>
<td>Public method to find all modules under 'path' that start with 'prefix'.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.format_completion">format_completion</a></td>
<td>Public method to format a valid module path.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.get_completions">get_completions</a></td>
<td>Public method to get the next possible import completions for 'line'.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.get_path_and_prefix">get_path_and_prefix</a></td>
<td>Public method to split a dotted name into an import path and a final prefix that is to be completed.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.global_cache">global_cache</a></td>
<td>Public method implementing the global module cache.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.is_suggestion_match">is_suggestion_match</a></td>
<td>Public method to ckeck, if 'module_name' is a valid suggestion.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.iter_submodules">iter_submodules</a></td>
<td>Public method to iterate over all submodules of the given parent modules.</td>
</tr>
<tr>
<td><a href="#ModuleCompleter.resolve_relative_name">resolve_relative_name</a></td>
<td>Public method to resolve a relative module name to an absolute name.</td>
</tr>
</table>

<h3>Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>


<a NAME="ModuleCompleter.__init__" ID="ModuleCompleter.__init__"></a>
<h4>ModuleCompleter (Constructor)</h4>
<b>ModuleCompleter</b>(<i>namespace=None</i>)
<p>
        Constructor
</p>

<dl>

<dt><i>namespace</i> (dict or FrameLocalsProxy (optional))</dt>
<dd>
namespace for the completer (defaults to None)
</dd>
</dl>
<a NAME="ModuleCompleter._find_modules" ID="ModuleCompleter._find_modules"></a>
<h4>ModuleCompleter._find_modules</h4>
<b>_find_modules</b>(<i>path, prefix</i>)
<p>
        Protected method to find all modules under 'path' that start with 'prefix'
        (even invalid module names).
</p>

<dl>

<dt><i>path</i> (str)</dt>
<dd>
path to find modules in
</dd>
<dt><i>prefix</i> (str)</dt>
<dd>
module prefix to look for
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
list of modules
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of str
</dd>
</dl>
<a NAME="ModuleCompleter.complete" ID="ModuleCompleter.complete"></a>
<h4>ModuleCompleter.complete</h4>
<b>complete</b>(<i>from_name, name</i>)
<p>
        Public method to complete module or submodule names.
</p>

<dl>

<dt><i>from_name</i> (str)</dt>
<dd>
name of modules to import from
</dd>
<dt><i>name</i> (str)</dt>
<dd>
name part to be completed
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
list of completions
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of str
</dd>
</dl>
<a NAME="ModuleCompleter.find_modules" ID="ModuleCompleter.find_modules"></a>
<h4>ModuleCompleter.find_modules</h4>
<b>find_modules</b>(<i>path, prefix</i>)
<p>
        Public method to find all modules under 'path' that start with 'prefix'.
</p>

<dl>

<dt><i>path</i> (str)</dt>
<dd>
path to find modules in
</dd>
<dt><i>prefix</i> (str)</dt>
<dd>
module prefix to look for
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
list of modules
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of str
</dd>
</dl>
<a NAME="ModuleCompleter.format_completion" ID="ModuleCompleter.format_completion"></a>
<h4>ModuleCompleter.format_completion</h4>
<b>format_completion</b>(<i>path, module</i>)
<p>
        Public method to format a valid module path.
</p>

<dl>

<dt><i>path</i> (str)</dt>
<dd>
path component
</dd>
<dt><i>module</i> (str)</dt>
<dd>
module name
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
formatted module name
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<a NAME="ModuleCompleter.get_completions" ID="ModuleCompleter.get_completions"></a>
<h4>ModuleCompleter.get_completions</h4>
<b>get_completions</b>(<i>line</i>)
<p>
        Public method to get the next possible import completions for 'line'.
</p>

<dl>

<dt><i>line</i> (str)</dt>
<dd>
line of code to get completions for
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
list of potential completions
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of str
</dd>
</dl>
<a NAME="ModuleCompleter.get_path_and_prefix" ID="ModuleCompleter.get_path_and_prefix"></a>
<h4>ModuleCompleter.get_path_and_prefix</h4>
<b>get_path_and_prefix</b>(<i>dotted_name</i>)
<p>
        Public method to split a dotted name into an import path and a
        final prefix that is to be completed.
</p>
<p>
        Examples:
            'foo.bar' -> 'foo', 'bar'
            'foo.' -> 'foo', ''
            '.foo' -> '.', 'foo'
</p>

<dl>

<dt><i>dotted_name</i> (str)</dt>
<dd>
dotted modules name to be split
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
tuple containing the import path and the final prefix
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
tuple of (str, str)
</dd>
</dl>
<a NAME="ModuleCompleter.global_cache" ID="ModuleCompleter.global_cache"></a>
<h4>ModuleCompleter.global_cache</h4>
<b>global_cache</b>(<i></i>)
<p>
        Public method implementing the global module cache.
</p>

<dl>
<dt>Return:</dt>
<dd>
reference to the global cache object
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
list of pkgutil.ModuleInfo
</dd>
</dl>
<a NAME="ModuleCompleter.is_suggestion_match" ID="ModuleCompleter.is_suggestion_match"></a>
<h4>ModuleCompleter.is_suggestion_match</h4>
<b>is_suggestion_match</b>(<i>module_name, prefix</i>)
<p>
        Public method to ckeck, if 'module_name' is a valid suggestion.
</p>

<dl>

<dt><i>module_name</i> (str)</dt>
<dd>
module name to be checked
</dd>
<dt><i>prefix</i> (str)</dt>
<dd>
module name prefix to check against
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
flag indicating a valid suggestion
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="ModuleCompleter.iter_submodules" ID="ModuleCompleter.iter_submodules"></a>
<h4>ModuleCompleter.iter_submodules</h4>
<b>iter_submodules</b>(<i>parent_modules</i>)
<p>
        Public method to iterate over all submodules of the given parent modules.
</p>

<dl>

<dt><i>parent_modules</i> (list of pkgutil.ModuleInfo)</dt>
<dd>
list of module info objects to be processed
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
iterator of all submodules
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
iterator of pkgutil.ModuleInfo
</dd>
</dl>
<a NAME="ModuleCompleter.resolve_relative_name" ID="ModuleCompleter.resolve_relative_name"></a>
<h4>ModuleCompleter.resolve_relative_name</h4>
<b>resolve_relative_name</b>(<i>name, package</i>)
<p>
        Public method to resolve a relative module name to an absolute name.
</p>
<p>
        Example: resolve_relative_name('.foo', 'bar') -> 'bar.foo'
</p>

<dl>

<dt><i>name</i> (str)</dt>
<dd>
relative module name
</dd>
<dt><i>package</i> (str)</dt>
<dd>
package name
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
absolute module name
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str or None
</dd>
</dl>
<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="ParseError" ID="ParseError"></a>
<h2>ParseError</h2>
<p>
    Class representing a parsing issue.
</p>

<h3>Derived from</h3>
Exception
<h3>Class Attributes</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>


<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="Result" ID="Result"></a>
<h2>Result</h2>
<p>
    Class implementing the result data structure.
</p>

<h3>Derived from</h3>
None
<h3>Class Attributes</h3>
<table>
<tr><td>from_name</td></tr>
<tr><td>name</td></tr>
</table>

<h3>Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>


<div align="right"><a href="#top">Up</a></div>
<hr />
<hr />
<a NAME="TokenQueue" ID="TokenQueue"></a>
<h2>TokenQueue</h2>
<p>
    Class implementing helper functions for working with a sequence of tokens.
</p>

<h3>Derived from</h3>
None
<h3>Class Attributes</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<h3>Methods</h3>
<table>
<tr>
<td><a href="#TokenQueue.__init__">TokenQueue</a></td>
<td>Constructor</td>
</tr>
<tr>
<td><a href="#TokenQueue.__bool__">__bool__</a></td>
<td>Special method implementing the 'bool' logic.</td>
</tr>
<tr>
<td><a href="#TokenQueue.peek">peek</a></td>
<td>Public method to get the next token without popping it.</td>
</tr>
<tr>
<td><a href="#TokenQueue.peek_name">peek_name</a></td>
<td>Public method to check, if the next token is a name token without popping it.</td>
</tr>
<tr>
<td><a href="#TokenQueue.peek_string">peek_string</a></td>
<td>Public method check, if the next token has a specific value.</td>
</tr>
<tr>
<td><a href="#TokenQueue.pop">pop</a></td>
<td>Public method to pop the next token off the stack.</td>
</tr>
<tr>
<td><a href="#TokenQueue.pop_name">pop_name</a></td>
<td>Public method to pop a name token off the token stack.</td>
</tr>
<tr>
<td><a href="#TokenQueue.pop_string">pop_string</a></td>
<td>Public method to pop the next token and return its value, if it is of a specific name.</td>
</tr>
<tr>
<td><a href="#TokenQueue.save_state">save_state</a></td>
<td>Public method implementing a context manager to save the current state.</td>
</tr>
</table>

<h3>Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>


<a NAME="TokenQueue.__init__" ID="TokenQueue.__init__"></a>
<h4>TokenQueue (Constructor)</h4>
<b>TokenQueue</b>(<i>tokens</i>)
<p>
        Constructor
</p>

<dl>

<dt><i>tokens</i> (list of TokenInfo)</dt>
<dd>
list of token info objects
</dd>
</dl>
<a NAME="TokenQueue.__bool__" ID="TokenQueue.__bool__"></a>
<h4>TokenQueue.__bool__</h4>
<b>__bool__</b>(<i></i>)
<p>
        Special method implementing the 'bool' logic.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating the boolean state
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="TokenQueue.peek" ID="TokenQueue.peek"></a>
<h4>TokenQueue.peek</h4>
<b>peek</b>(<i></i>)
<p>
        Public method to get the next token without popping it.
</p>

<dl>
<dt>Return:</dt>
<dd>
next token
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
TokenInfo
</dd>
</dl>
<a NAME="TokenQueue.peek_name" ID="TokenQueue.peek_name"></a>
<h4>TokenQueue.peek_name</h4>
<b>peek_name</b>(<i></i>)
<p>
        Public method to check, if the next token is a name token without popping it.
</p>

<dl>
<dt>Return:</dt>
<dd>
flag indicating that the next token is a name token
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
TokenInfo
</dd>
</dl>
<a NAME="TokenQueue.peek_string" ID="TokenQueue.peek_string"></a>
<h4>TokenQueue.peek_string</h4>
<b>peek_string</b>(<i>token_string</i>)
<p>
        Public method check, if the next token has a specific value.
</p>

<dl>

<dt><i>token_string</i> (str)</dt>
<dd>
string to test against
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
flag indicating that the next token has the specified value
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
bool
</dd>
</dl>
<a NAME="TokenQueue.pop" ID="TokenQueue.pop"></a>
<h4>TokenQueue.pop</h4>
<b>pop</b>(<i></i>)
<p>
        Public method to pop the next token off the stack.
</p>

<dl>
<dt>Return:</dt>
<dd>
next token
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
TokenInfo
</dd>
</dl>
<dl>

<dt>Raises <b>ParseError</b>:</dt>
<dd>
raised to indicate an empty token queue.
</dd>
</dl>
<a NAME="TokenQueue.pop_name" ID="TokenQueue.pop_name"></a>
<h4>TokenQueue.pop_name</h4>
<b>pop_name</b>(<i></i>)
<p>
        Public method to pop a name token off the token stack.
</p>

<dl>
<dt>Return:</dt>
<dd>
value of the name token
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<dl>

<dt>Raises <b>ParseError</b>:</dt>
<dd>
raised to indicate that the popped token is not a
            name token
</dd>
</dl>
<a NAME="TokenQueue.pop_string" ID="TokenQueue.pop_string"></a>
<h4>TokenQueue.pop_string</h4>
<b>pop_string</b>(<i>token_string</i>)
<p>
        Public method to pop the next token and return its value, if it is of a
        specific name.
</p>

<dl>

<dt><i>token_string</i> (str)</dt>
<dd>
string to test against
</dd>
</dl>
<dl>
<dt>Return:</dt>
<dd>
token value
</dd>
</dl>
<dl>
<dt>Return Type:</dt>
<dd>
str
</dd>
</dl>
<dl>

<dt>Raises <b>ParseError</b>:</dt>
<dd>
raised to indicate an invalid or unexpected token
</dd>
</dl>
<a NAME="TokenQueue.save_state" ID="TokenQueue.save_state"></a>
<h4>TokenQueue.save_state</h4>
<b>save_state</b>(<i></i>)
<p>
        Public method implementing a context manager to save the current state.
</p>

<div align="right"><a href="#top">Up</a></div>
<hr />
</body></html>
