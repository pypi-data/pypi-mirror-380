"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Copyright 2020 Alibaba Group Holding Limited.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import algebra_pb2
import builtins
import collections.abc
import cypher_ddl_pb2
import cypher_dml_pb2
import cypher_write_pb2
import expr_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import stored_procedure_pb2
import sys
import type_pb2
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Project(google.protobuf.message.Message):
    """To project a relation on certain attributes or further their properties"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ExprAlias(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        EXPR_FIELD_NUMBER: builtins.int
        ALIAS_FIELD_NUMBER: builtins.int
        @property
        def expr(self) -> expr_pb2.Expression:
            """The expression to be aliased"""

        @property
        def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
            """The alias that is either given by the query or by the system"""

        def __init__(
            self,
            *,
            expr: expr_pb2.Expression | None = ...,
            alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["alias", b"alias", "expr", b"expr"]
        ) -> builtins.bool: ...
        def ClearField(
            self, field_name: typing.Literal["alias", b"alias", "expr", b"expr"]
        ) -> None: ...

    MAPPINGS_FIELD_NUMBER: builtins.int
    IS_APPEND_FIELD_NUMBER: builtins.int
    is_append: builtins.bool
    """An indicator to tell the runtime whether the projected value is appending to or replacing
    existing relation.
    """
    @property
    def mappings(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Project.ExprAlias
    ]:
        """A list of [expression -> alias] to be projected from the graph relation.
        e.g., project_{a.birthday / 100 % 100 as birth_month }
        """

    def __init__(
        self,
        *,
        mappings: collections.abc.Iterable[global___Project.ExprAlias] | None = ...,
        is_append: builtins.bool = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal["is_append", b"is_append", "mappings", b"mappings"],
    ) -> None: ...

global___Project = Project

@typing.final
class GroupBy(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class AggFunc(google.protobuf.message.Message):
        """To define the function to be applied on each group after performing grouping. For example,
        GROUPBY({a, b}, COUNT_DISTINCT(c, d) as e), one shall count distinct present of the pairs
        (c, d), and alias the count as e.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _Aggregate:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _AggregateEnumTypeWrapper(
            google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
                GroupBy.AggFunc._Aggregate.ValueType
            ],
            builtins.type,
        ):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            SUM: GroupBy.AggFunc._Aggregate.ValueType  # 0
            MIN: GroupBy.AggFunc._Aggregate.ValueType  # 1
            MAX: GroupBy.AggFunc._Aggregate.ValueType  # 2
            COUNT: GroupBy.AggFunc._Aggregate.ValueType  # 3
            COUNT_DISTINCT: GroupBy.AggFunc._Aggregate.ValueType  # 4
            TO_LIST: GroupBy.AggFunc._Aggregate.ValueType  # 5
            TO_SET: GroupBy.AggFunc._Aggregate.ValueType  # 6
            AVG: GroupBy.AggFunc._Aggregate.ValueType  # 7
            FIRST: GroupBy.AggFunc._Aggregate.ValueType  # 8

        class Aggregate(_Aggregate, metaclass=_AggregateEnumTypeWrapper): ...
        SUM: GroupBy.AggFunc.Aggregate.ValueType  # 0
        MIN: GroupBy.AggFunc.Aggregate.ValueType  # 1
        MAX: GroupBy.AggFunc.Aggregate.ValueType  # 2
        COUNT: GroupBy.AggFunc.Aggregate.ValueType  # 3
        COUNT_DISTINCT: GroupBy.AggFunc.Aggregate.ValueType  # 4
        TO_LIST: GroupBy.AggFunc.Aggregate.ValueType  # 5
        TO_SET: GroupBy.AggFunc.Aggregate.ValueType  # 6
        AVG: GroupBy.AggFunc.Aggregate.ValueType  # 7
        FIRST: GroupBy.AggFunc.Aggregate.ValueType  # 8

        VARS_FIELD_NUMBER: builtins.int
        AGGREGATE_FIELD_NUMBER: builtins.int
        ALIAS_FIELD_NUMBER: builtins.int
        aggregate: global___GroupBy.AggFunc.Aggregate.ValueType
        """The aggregate function"""
        @property
        def vars(
            self,
        ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
            expr_pb2.Variable
        ]:
            """The variables to apply this aggregation"""

        @property
        def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
            """The alias for the aggregated value"""

        def __init__(
            self,
            *,
            vars: collections.abc.Iterable[expr_pb2.Variable] | None = ...,
            aggregate: global___GroupBy.AggFunc.Aggregate.ValueType = ...,
            alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["alias", b"alias"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "aggregate", b"aggregate", "alias", b"alias", "vars", b"vars"
            ],
        ) -> None: ...

    @typing.final
    class KeyAlias(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        ALIAS_FIELD_NUMBER: builtins.int
        @property
        def key(self) -> expr_pb2.Variable:
            """The key to perform grouping"""

        @property
        def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
            """The alias for the key"""

        def __init__(
            self,
            *,
            key: expr_pb2.Variable | None = ...,
            alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["alias", b"alias", "key", b"key"]
        ) -> builtins.bool: ...
        def ClearField(
            self, field_name: typing.Literal["alias", b"alias", "key", b"key"]
        ) -> None: ...

    MAPPINGS_FIELD_NUMBER: builtins.int
    FUNCTIONS_FIELD_NUMBER: builtins.int
    @property
    def mappings(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___GroupBy.KeyAlias
    ]:
        """A collection of key-alias mappings"""

    @property
    def functions(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___GroupBy.AggFunc
    ]:
        """The grouping functions"""

    def __init__(
        self,
        *,
        mappings: collections.abc.Iterable[global___GroupBy.KeyAlias] | None = ...,
        functions: collections.abc.Iterable[global___GroupBy.AggFunc] | None = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal["functions", b"functions", "mappings", b"mappings"],
    ) -> None: ...

global___GroupBy = GroupBy

@typing.final
class Unfold(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAG_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    @property
    def tag(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The tag of a graph relation that **must** refer to a data of collection type"""

    @property
    def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The alias tag for the elements that are unfolded from the collection"""

    def __init__(
        self,
        *,
        tag: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["alias", b"alias", "tag", b"tag"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["alias", b"alias", "tag", b"tag"]
    ) -> None: ...

global___Unfold = Unfold

@typing.final
class Union(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUB_PLANS_FIELD_NUMBER: builtins.int
    @property
    def sub_plans(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___PhysicalPlan
    ]: ...
    def __init__(
        self,
        *,
        sub_plans: collections.abc.Iterable[global___PhysicalPlan] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["sub_plans", b"sub_plans"]
    ) -> None: ...

global___Union = Union

@typing.final
class Intersect(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUB_PLANS_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    key: builtins.int
    @property
    def sub_plans(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___PhysicalPlan
    ]: ...
    def __init__(
        self,
        *,
        sub_plans: collections.abc.Iterable[global___PhysicalPlan] | None = ...,
        key: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["key", b"key", "sub_plans", b"sub_plans"]
    ) -> None: ...

global___Intersect = Intersect

@typing.final
class Join(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _JoinKind:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _JoinKindEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            Join._JoinKind.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        INNER: Join._JoinKind.ValueType  # 0
        """Inner join"""
        LEFT_OUTER: Join._JoinKind.ValueType  # 1
        """Left outer join"""
        RIGHT_OUTER: Join._JoinKind.ValueType  # 2
        """Right outer join"""
        FULL_OUTER: Join._JoinKind.ValueType  # 3
        """Full outer join"""
        SEMI: Join._JoinKind.ValueType  # 4
        """Left semi-join, right alternative can be naturally adapted"""
        ANTI: Join._JoinKind.ValueType  # 5
        """Left anti-join, right alternative can be naturally adapted"""
        TIMES: Join._JoinKind.ValueType  # 6
        """aka. Cartesian product"""

    class JoinKind(_JoinKind, metaclass=_JoinKindEnumTypeWrapper): ...
    INNER: Join.JoinKind.ValueType  # 0
    """Inner join"""
    LEFT_OUTER: Join.JoinKind.ValueType  # 1
    """Left outer join"""
    RIGHT_OUTER: Join.JoinKind.ValueType  # 2
    """Right outer join"""
    FULL_OUTER: Join.JoinKind.ValueType  # 3
    """Full outer join"""
    SEMI: Join.JoinKind.ValueType  # 4
    """Left semi-join, right alternative can be naturally adapted"""
    ANTI: Join.JoinKind.ValueType  # 5
    """Left anti-join, right alternative can be naturally adapted"""
    TIMES: Join.JoinKind.ValueType  # 6
    """aka. Cartesian product"""

    LEFT_KEYS_FIELD_NUMBER: builtins.int
    RIGHT_KEYS_FIELD_NUMBER: builtins.int
    JOIN_KIND_FIELD_NUMBER: builtins.int
    LEFT_PLAN_FIELD_NUMBER: builtins.int
    RIGHT_PLAN_FIELD_NUMBER: builtins.int
    join_kind: global___Join.JoinKind.ValueType
    @property
    def left_keys(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        expr_pb2.Variable
    ]:
        """The key to perform Join (on results output by left_plan)"""

    @property
    def right_keys(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        expr_pb2.Variable
    ]:
        """The key to perform Join (on results output by right_plan)"""

    @property
    def left_plan(self) -> global___PhysicalPlan: ...
    @property
    def right_plan(self) -> global___PhysicalPlan: ...
    def __init__(
        self,
        *,
        left_keys: collections.abc.Iterable[expr_pb2.Variable] | None = ...,
        right_keys: collections.abc.Iterable[expr_pb2.Variable] | None = ...,
        join_kind: global___Join.JoinKind.ValueType = ...,
        left_plan: global___PhysicalPlan | None = ...,
        right_plan: global___PhysicalPlan | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "left_plan", b"left_plan", "right_plan", b"right_plan"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "join_kind",
            b"join_kind",
            "left_keys",
            b"left_keys",
            "left_plan",
            b"left_plan",
            "right_keys",
            b"right_keys",
            "right_plan",
            b"right_plan",
        ],
    ) -> None: ...

global___Join = Join

@typing.final
class Apply(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    JOIN_KIND_FIELD_NUMBER: builtins.int
    KEYS_FIELD_NUMBER: builtins.int
    SUB_PLAN_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    join_kind: global___Join.JoinKind.ValueType
    """Define how to join the result of the subtask back to the original relation"""
    @property
    def keys(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        expr_pb2.Variable
    ]:
        """The variables to perform grouping, or segmenting.
        If not specified, it is an Apply; otherwise, it is a SegmentApply
        """

    @property
    def sub_plan(self) -> global___PhysicalPlan:
        """The subtask will be perform on certain tags as keys of the input relation"""

    @property
    def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """Define the alias of output from `Apply`. Optional Field."""

    def __init__(
        self,
        *,
        join_kind: global___Join.JoinKind.ValueType = ...,
        keys: collections.abc.Iterable[expr_pb2.Variable] | None = ...,
        sub_plan: global___PhysicalPlan | None = ...,
        alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["alias", b"alias", "sub_plan", b"sub_plan"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "join_kind",
            b"join_kind",
            "keys",
            b"keys",
            "sub_plan",
            b"sub_plan",
        ],
    ) -> None: ...

global___Apply = Apply

@typing.final
class Scan(google.protobuf.message.Message):
    """Scan is an operator that transforms the source data format (defined by the database)
    into internal data format (defined/used by runtime)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ScanOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ScanOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            Scan._ScanOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERTEX: Scan._ScanOpt.ValueType  # 0
        """Scanning the vertices"""
        EDGE: Scan._ScanOpt.ValueType  # 1
        """Scanning the edges"""
        TABLE: Scan._ScanOpt.ValueType  # 2
        """Scanning a relational table"""

    class ScanOpt(_ScanOpt, metaclass=_ScanOptEnumTypeWrapper): ...
    VERTEX: Scan.ScanOpt.ValueType  # 0
    """Scanning the vertices"""
    EDGE: Scan.ScanOpt.ValueType  # 1
    """Scanning the edges"""
    TABLE: Scan.ScanOpt.ValueType  # 2
    """Scanning a relational table"""

    SCAN_OPT_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    IDX_PREDICATE_FIELD_NUMBER: builtins.int
    IS_COUNT_ONLY_FIELD_NUMBER: builtins.int
    scan_opt: global___Scan.ScanOpt.ValueType
    is_count_only: builtins.bool
    """The flag that indicates to SCAN + COUNT"""
    @property
    def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The alias of the item if it is a vertex or edge"""

    @property
    def params(self) -> algebra_pb2.QueryParams:
        """The required parameters for the scan"""

    @property
    def idx_predicate(self) -> algebra_pb2.IndexPredicate:
        """The optional filtering predicate for the field that have been indexed"""

    def __init__(
        self,
        *,
        scan_opt: global___Scan.ScanOpt.ValueType = ...,
        alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        params: algebra_pb2.QueryParams | None = ...,
        idx_predicate: algebra_pb2.IndexPredicate | None = ...,
        is_count_only: builtins.bool = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias", b"alias", "idx_predicate", b"idx_predicate", "params", b"params"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "idx_predicate",
            b"idx_predicate",
            "is_count_only",
            b"is_count_only",
            "params",
            b"params",
            "scan_opt",
            b"scan_opt",
        ],
    ) -> None: ...

global___Scan = Scan

@typing.final
class GetV(google.protobuf.message.Message):
    """It is typical to use the operator when:
    1. The input entry is an edge entry, and to obtain some properties (or filter) on the adjacent vertex of the input edge
    2. The input entry is a vertex entry, and directly obtain some properties (or filter) on the input vertex
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _VOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _VOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            GetV._VOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        START: GetV._VOpt.ValueType  # 0
        """The case when getting the start vertex of the edge"""
        END: GetV._VOpt.ValueType  # 1
        """The case when getting the end vertex of the edge/path"""
        OTHER: GetV._VOpt.ValueType  # 2
        """The case when getting the other vertex of the edge. We are calibrating to Gremlin's bothE.otherV semantics"""
        BOTH: GetV._VOpt.ValueType  # 3
        """The case when getting both vertices of the edge"""
        ITSELF: GetV._VOpt.ValueType  # 4
        """The case when tag refers to vertices"""

    class VOpt(_VOpt, metaclass=_VOptEnumTypeWrapper): ...
    START: GetV.VOpt.ValueType  # 0
    """The case when getting the start vertex of the edge"""
    END: GetV.VOpt.ValueType  # 1
    """The case when getting the end vertex of the edge/path"""
    OTHER: GetV.VOpt.ValueType  # 2
    """The case when getting the other vertex of the edge. We are calibrating to Gremlin's bothE.otherV semantics"""
    BOTH: GetV.VOpt.ValueType  # 3
    """The case when getting both vertices of the edge"""
    ITSELF: GetV.VOpt.ValueType  # 4
    """The case when tag refers to vertices"""

    TAG_FIELD_NUMBER: builtins.int
    OPT_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    opt: global___GetV.VOpt.ValueType
    """Determine what vertex to get from the tagged object"""
    @property
    def tag(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The tag that refers to the edge/path where the end vertex will be retrieved"""

    @property
    def params(self) -> algebra_pb2.QueryParams:
        """The query parameters of getting vertices"""

    @property
    def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The alias of this vertex"""

    def __init__(
        self,
        *,
        tag: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        opt: global___GetV.VOpt.ValueType = ...,
        params: algebra_pb2.QueryParams | None = ...,
        alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias", b"alias", "params", b"params", "tag", b"tag"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias", b"alias", "opt", b"opt", "params", b"params", "tag", b"tag"
        ],
    ) -> None: ...

global___GetV = GetV

@typing.final
class EdgeExpand(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Direction:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DirectionEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            EdgeExpand._Direction.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        OUT: EdgeExpand._Direction.ValueType  # 0
        IN: EdgeExpand._Direction.ValueType  # 1
        BOTH: EdgeExpand._Direction.ValueType  # 2

    class Direction(_Direction, metaclass=_DirectionEnumTypeWrapper): ...
    OUT: EdgeExpand.Direction.ValueType  # 0
    IN: EdgeExpand.Direction.ValueType  # 1
    BOTH: EdgeExpand.Direction.ValueType  # 2

    class _ExpandOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ExpandOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            EdgeExpand._ExpandOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERTEX: EdgeExpand._ExpandOpt.ValueType  # 0
        EDGE: EdgeExpand._ExpandOpt.ValueType  # 1
        DEGREE: EdgeExpand._ExpandOpt.ValueType  # 2

    class ExpandOpt(_ExpandOpt, metaclass=_ExpandOptEnumTypeWrapper): ...
    VERTEX: EdgeExpand.ExpandOpt.ValueType  # 0
    EDGE: EdgeExpand.ExpandOpt.ValueType  # 1
    DEGREE: EdgeExpand.ExpandOpt.ValueType  # 2

    V_TAG_FIELD_NUMBER: builtins.int
    DIRECTION_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    EXPAND_OPT_FIELD_NUMBER: builtins.int
    IS_OPTIONAL_FIELD_NUMBER: builtins.int
    direction: global___EdgeExpand.Direction.ValueType
    """The direction of the expanded edge"""
    expand_opt: global___EdgeExpand.ExpandOpt.ValueType
    """Expand option, i.e., expand vertices/edges/degree."""
    is_optional: builtins.bool
    """Whether the expand is optional, if true, the expand will return a `None` if the edge does not exist"""
    @property
    def v_tag(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The tag that refers to the starting vertex"""

    @property
    def params(self) -> algebra_pb2.QueryParams:
        """The query parameters define the condition that the edge/end vertex must satisfy.
        Note that whether the query parameters apply to the edge or end vertex depends on
        the `is_edge` indicator, with one exception that the `tables` parameter in `EdgeExpand`
        **always** applies to the edge for now (may be fixed later) .
        """

    @property
    def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """An optional alias for the object of the expansion"""

    def __init__(
        self,
        *,
        v_tag: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        direction: global___EdgeExpand.Direction.ValueType = ...,
        params: algebra_pb2.QueryParams | None = ...,
        alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        expand_opt: global___EdgeExpand.ExpandOpt.ValueType = ...,
        is_optional: builtins.bool = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias", b"alias", "params", b"params", "v_tag", b"v_tag"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "direction",
            b"direction",
            "expand_opt",
            b"expand_opt",
            "is_optional",
            b"is_optional",
            "params",
            b"params",
            "v_tag",
            b"v_tag",
        ],
    ) -> None: ...

global___EdgeExpand = EdgeExpand

@typing.final
class PathExpand(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _PathOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _PathOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            PathExpand._PathOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        ARBITRARY: PathExpand._PathOpt.ValueType  # 0
        """an arbitrary path, in which both vertex/edge may duplicate"""
        SIMPLE: PathExpand._PathOpt.ValueType  # 1
        """a path without vertex duplications"""
        TRAIL: PathExpand._PathOpt.ValueType  # 2
        """a path without edge duplications"""
        ANY_SHORTEST: PathExpand._PathOpt.ValueType  # 3
        """Define the shortest option according to the GQL standard:
        Selects one path with shortest length, Non-deterministic.
        """
        ALL_SHORTEST: PathExpand._PathOpt.ValueType  # 4
        """Selects all paths that have the minimal length. Deterministic."""

    class PathOpt(_PathOpt, metaclass=_PathOptEnumTypeWrapper): ...
    ARBITRARY: PathExpand.PathOpt.ValueType  # 0
    """an arbitrary path, in which both vertex/edge may duplicate"""
    SIMPLE: PathExpand.PathOpt.ValueType  # 1
    """a path without vertex duplications"""
    TRAIL: PathExpand.PathOpt.ValueType  # 2
    """a path without edge duplications"""
    ANY_SHORTEST: PathExpand.PathOpt.ValueType  # 3
    """Define the shortest option according to the GQL standard:
    Selects one path with shortest length, Non-deterministic.
    """
    ALL_SHORTEST: PathExpand.PathOpt.ValueType  # 4
    """Selects all paths that have the minimal length. Deterministic."""

    class _ResultOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ResultOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            PathExpand._ResultOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        END_V: PathExpand._ResultOpt.ValueType  # 0
        """only end vertex is required for this expansion"""
        ALL_V: PathExpand._ResultOpt.ValueType  # 1
        """all vertices of this path are required for this expansion."""
        ALL_V_E: PathExpand._ResultOpt.ValueType  # 2
        """all vertices and edges of this path are required for this expansion."""

    class ResultOpt(_ResultOpt, metaclass=_ResultOptEnumTypeWrapper):
        """Define what result is required for this path. We currently support `EndV` and `AllV`, while an option to
        include all edges and vertices may be needed in the future.
        """

    END_V: PathExpand.ResultOpt.ValueType  # 0
    """only end vertex is required for this expansion"""
    ALL_V: PathExpand.ResultOpt.ValueType  # 1
    """all vertices of this path are required for this expansion."""
    ALL_V_E: PathExpand.ResultOpt.ValueType  # 2
    """all vertices and edges of this path are required for this expansion."""

    @typing.final
    class ExpandBase(google.protobuf.message.Message):
        """The expand base of PathExpand"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        EDGE_EXPAND_FIELD_NUMBER: builtins.int
        GET_V_FIELD_NUMBER: builtins.int
        @property
        def edge_expand(self) -> global___EdgeExpand:
            """Can either be a single EdgeExpand (with ExpandOpt = Vertex), or EdgeExpand (with ExpandOpt = Edge) + GetV"""

        @property
        def get_V(self) -> global___GetV: ...
        def __init__(
            self,
            *,
            edge_expand: global___EdgeExpand | None = ...,
            get_V: global___GetV | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "edge_expand", b"edge_expand", "get_V", b"get_V"
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "edge_expand", b"edge_expand", "get_V", b"get_V"
            ],
        ) -> None: ...

    BASE_FIELD_NUMBER: builtins.int
    START_TAG_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    HOP_RANGE_FIELD_NUMBER: builtins.int
    PATH_OPT_FIELD_NUMBER: builtins.int
    RESULT_OPT_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    IS_OPTIONAL_FIELD_NUMBER: builtins.int
    path_opt: global___PathExpand.PathOpt.ValueType
    """Path option, including to expand an arbitrary path or a simple path"""
    result_opt: global___PathExpand.ResultOpt.ValueType
    """Result option, including to take end vertex (EndV), or whole path (AllV), for this expansion"""
    is_optional: builtins.bool
    """Whether the path expand is optional, if true, the path expand will return a `None` if the path does not exist"""
    @property
    def base(self) -> global___PathExpand.ExpandBase:
        """A path expansion has a base of edge expansion"""

    @property
    def start_tag(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The tag that refers to the starting vertex"""

    @property
    def alias(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """An optional alias for the object of the expansion"""

    @property
    def hop_range(self) -> algebra_pb2.Range:
        """The range that defines the minimum and maximum number of hops of the path expansion.
        This is optional, if not set, the minimum number is 1, and the maximum is INT_MAX
        """

    @property
    def condition(self) -> expr_pb2.Expression:
        """A condition formulated as an expression predicate"""

    def __init__(
        self,
        *,
        base: global___PathExpand.ExpandBase | None = ...,
        start_tag: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        alias: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        hop_range: algebra_pb2.Range | None = ...,
        path_opt: global___PathExpand.PathOpt.ValueType = ...,
        result_opt: global___PathExpand.ResultOpt.ValueType = ...,
        condition: expr_pb2.Expression | None = ...,
        is_optional: builtins.bool = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "base",
            b"base",
            "condition",
            b"condition",
            "hop_range",
            b"hop_range",
            "start_tag",
            b"start_tag",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "base",
            b"base",
            "condition",
            b"condition",
            "hop_range",
            b"hop_range",
            "is_optional",
            b"is_optional",
            "path_opt",
            b"path_opt",
            "result_opt",
            b"result_opt",
            "start_tag",
            b"start_tag",
        ],
    ) -> None: ...

global___PathExpand = PathExpand

@typing.final
class Sink(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class OptTag(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TAG_FIELD_NUMBER: builtins.int
        @property
        def tag(self) -> google.protobuf.wrappers_pb2.Int32Value: ...
        def __init__(
            self,
            *,
            tag: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["tag", b"tag"]
        ) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["tag", b"tag"]) -> None: ...

    TAGS_FIELD_NUMBER: builtins.int
    SINK_TARGET_FIELD_NUMBER: builtins.int
    @property
    def tags(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Sink.OptTag
    ]:
        """Define the tags of columns to sink. If no tags given, sink all **tagged** columns by default."""

    @property
    def sink_target(self) -> algebra_pb2.Sink.SinkTarget:
        """Define the target of sink, e.g., to Client as default, to Graph such as Vineyard etc."""

    def __init__(
        self,
        *,
        tags: collections.abc.Iterable[global___Sink.OptTag] | None = ...,
        sink_target: algebra_pb2.Sink.SinkTarget | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["sink_target", b"sink_target"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["sink_target", b"sink_target", "tags", b"tags"]
    ) -> None: ...

global___Sink = Sink

@typing.final
class Repartition(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Shuffle(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        SHUFFLE_KEY_FIELD_NUMBER: builtins.int
        @property
        def shuffle_key(self) -> google.protobuf.wrappers_pb2.Int32Value: ...
        def __init__(
            self,
            *,
            shuffle_key: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["shuffle_key", b"shuffle_key"]
        ) -> builtins.bool: ...
        def ClearField(
            self, field_name: typing.Literal["shuffle_key", b"shuffle_key"]
        ) -> None: ...

    @typing.final
    class Broadcast(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        def __init__(
            self,
        ) -> None: ...

    TO_ANOTHER_FIELD_NUMBER: builtins.int
    TO_OTHERS_FIELD_NUMBER: builtins.int
    @property
    def to_another(self) -> global___Repartition.Shuffle: ...
    @property
    def to_others(self) -> global___Repartition.Broadcast: ...
    def __init__(
        self,
        *,
        to_another: global___Repartition.Shuffle | None = ...,
        to_others: global___Repartition.Broadcast | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "Strategy",
            b"Strategy",
            "to_another",
            b"to_another",
            "to_others",
            b"to_others",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "Strategy",
            b"Strategy",
            "to_another",
            b"to_another",
            "to_others",
            b"to_others",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["Strategy", b"Strategy"]
    ) -> typing.Literal["to_another", "to_others"] | None: ...

global___Repartition = Repartition

@typing.final
class Root(google.protobuf.message.Message):
    """A dummy node to delegate a source opr for multiple scan cases."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___Root = Root

@typing.final
class ProcedureCall(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    QUERY_FIELD_NUMBER: builtins.int
    @property
    def query(self) -> stored_procedure_pb2.Query: ...
    def __init__(
        self,
        *,
        query: stored_procedure_pb2.Query | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["query", b"query"]
    ) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["query", b"query"]) -> None: ...

global___ProcedureCall = ProcedureCall

@typing.final
class PhysicalOpr(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Operator(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        PROJECT_FIELD_NUMBER: builtins.int
        SELECT_FIELD_NUMBER: builtins.int
        GROUP_BY_FIELD_NUMBER: builtins.int
        ORDER_BY_FIELD_NUMBER: builtins.int
        DEDUP_FIELD_NUMBER: builtins.int
        UNFOLD_FIELD_NUMBER: builtins.int
        LIMIT_FIELD_NUMBER: builtins.int
        SCAN_FIELD_NUMBER: builtins.int
        SINK_FIELD_NUMBER: builtins.int
        APPLY_FIELD_NUMBER: builtins.int
        JOIN_FIELD_NUMBER: builtins.int
        UNION_FIELD_NUMBER: builtins.int
        INTERSECT_FIELD_NUMBER: builtins.int
        REPARTITION_FIELD_NUMBER: builtins.int
        ROOT_FIELD_NUMBER: builtins.int
        SAMPLE_FIELD_NUMBER: builtins.int
        VERTEX_FIELD_NUMBER: builtins.int
        EDGE_FIELD_NUMBER: builtins.int
        PATH_FIELD_NUMBER: builtins.int
        PROCEDURE_CALL_FIELD_NUMBER: builtins.int
        SET_FIELD_NUMBER: builtins.int
        LOAD_FIELD_NUMBER: builtins.int
        DELETE_FIELD_NUMBER: builtins.int
        SOURCE_FIELD_NUMBER: builtins.int
        LOAD_VERTEX_FIELD_NUMBER: builtins.int
        LOAD_EDGE_FIELD_NUMBER: builtins.int
        CREATE_VERTEX_FIELD_NUMBER: builtins.int
        CREATE_EDGE_FIELD_NUMBER: builtins.int
        SET_VERTEX_FIELD_NUMBER: builtins.int
        SET_EDGE_FIELD_NUMBER: builtins.int
        DELETE_VERTEX_FIELD_NUMBER: builtins.int
        DELETE_EDGE_FIELD_NUMBER: builtins.int
        @property
        def project(self) -> global___Project: ...
        @property
        def select(self) -> algebra_pb2.Select: ...
        @property
        def group_by(self) -> global___GroupBy: ...
        @property
        def order_by(self) -> algebra_pb2.OrderBy: ...
        @property
        def dedup(self) -> algebra_pb2.Dedup: ...
        @property
        def unfold(self) -> global___Unfold: ...
        @property
        def limit(self) -> algebra_pb2.Limit: ...
        @property
        def scan(self) -> global___Scan: ...
        @property
        def sink(self) -> global___Sink: ...
        @property
        def apply(self) -> global___Apply: ...
        @property
        def join(self) -> global___Join: ...
        @property
        def union(self) -> global___Union: ...
        @property
        def intersect(self) -> global___Intersect: ...
        @property
        def repartition(self) -> global___Repartition: ...
        @property
        def root(self) -> global___Root: ...
        @property
        def sample(self) -> algebra_pb2.Sample: ...
        @property
        def vertex(self) -> global___GetV:
            """Saving the room for relational operators"""

        @property
        def edge(self) -> global___EdgeExpand: ...
        @property
        def path(self) -> global___PathExpand: ...
        @property
        def procedure_call(self) -> global___ProcedureCall: ...
        @property
        def set(self) -> cypher_write_pb2.Set:
            """write operators"""

        @property
        def load(self) -> cypher_write_pb2.Load: ...
        @property
        def delete(self) -> cypher_write_pb2.Delete: ...
        @property
        def source(self) -> cypher_dml_pb2.DataSource:
            """DML operators
            tag, 0(id),1(name),2(age)
            """

        @property
        def load_vertex(self) -> cypher_dml_pb2.BatchInsertVertex:
            """0->id, 1->name, 2->age"""

        @property
        def load_edge(self) -> cypher_dml_pb2.BatchInsertEdge: ...
        @property
        def create_vertex(self) -> cypher_dml_pb2.InsertVertex: ...
        @property
        def create_edge(self) -> cypher_dml_pb2.InsertEdge: ...
        @property
        def set_vertex(self) -> cypher_dml_pb2.SetVertexProperty: ...
        @property
        def set_edge(self) -> cypher_dml_pb2.SetEdgeProperty: ...
        @property
        def delete_vertex(self) -> cypher_dml_pb2.DeleteVertex: ...
        @property
        def delete_edge(self) -> cypher_dml_pb2.DeleteEdge: ...
        def __init__(
            self,
            *,
            project: global___Project | None = ...,
            select: algebra_pb2.Select | None = ...,
            group_by: global___GroupBy | None = ...,
            order_by: algebra_pb2.OrderBy | None = ...,
            dedup: algebra_pb2.Dedup | None = ...,
            unfold: global___Unfold | None = ...,
            limit: algebra_pb2.Limit | None = ...,
            scan: global___Scan | None = ...,
            sink: global___Sink | None = ...,
            apply: global___Apply | None = ...,
            join: global___Join | None = ...,
            union: global___Union | None = ...,
            intersect: global___Intersect | None = ...,
            repartition: global___Repartition | None = ...,
            root: global___Root | None = ...,
            sample: algebra_pb2.Sample | None = ...,
            vertex: global___GetV | None = ...,
            edge: global___EdgeExpand | None = ...,
            path: global___PathExpand | None = ...,
            procedure_call: global___ProcedureCall | None = ...,
            set: cypher_write_pb2.Set | None = ...,
            load: cypher_write_pb2.Load | None = ...,
            delete: cypher_write_pb2.Delete | None = ...,
            source: cypher_dml_pb2.DataSource | None = ...,
            load_vertex: cypher_dml_pb2.BatchInsertVertex | None = ...,
            load_edge: cypher_dml_pb2.BatchInsertEdge | None = ...,
            create_vertex: cypher_dml_pb2.InsertVertex | None = ...,
            create_edge: cypher_dml_pb2.InsertEdge | None = ...,
            set_vertex: cypher_dml_pb2.SetVertexProperty | None = ...,
            set_edge: cypher_dml_pb2.SetEdgeProperty | None = ...,
            delete_vertex: cypher_dml_pb2.DeleteVertex | None = ...,
            delete_edge: cypher_dml_pb2.DeleteEdge | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "apply",
                b"apply",
                "create_edge",
                b"create_edge",
                "create_vertex",
                b"create_vertex",
                "dedup",
                b"dedup",
                "delete",
                b"delete",
                "delete_edge",
                b"delete_edge",
                "delete_vertex",
                b"delete_vertex",
                "edge",
                b"edge",
                "group_by",
                b"group_by",
                "intersect",
                b"intersect",
                "join",
                b"join",
                "limit",
                b"limit",
                "load",
                b"load",
                "load_edge",
                b"load_edge",
                "load_vertex",
                b"load_vertex",
                "op_kind",
                b"op_kind",
                "order_by",
                b"order_by",
                "path",
                b"path",
                "procedure_call",
                b"procedure_call",
                "project",
                b"project",
                "repartition",
                b"repartition",
                "root",
                b"root",
                "sample",
                b"sample",
                "scan",
                b"scan",
                "select",
                b"select",
                "set",
                b"set",
                "set_edge",
                b"set_edge",
                "set_vertex",
                b"set_vertex",
                "sink",
                b"sink",
                "source",
                b"source",
                "unfold",
                b"unfold",
                "union",
                b"union",
                "vertex",
                b"vertex",
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "apply",
                b"apply",
                "create_edge",
                b"create_edge",
                "create_vertex",
                b"create_vertex",
                "dedup",
                b"dedup",
                "delete",
                b"delete",
                "delete_edge",
                b"delete_edge",
                "delete_vertex",
                b"delete_vertex",
                "edge",
                b"edge",
                "group_by",
                b"group_by",
                "intersect",
                b"intersect",
                "join",
                b"join",
                "limit",
                b"limit",
                "load",
                b"load",
                "load_edge",
                b"load_edge",
                "load_vertex",
                b"load_vertex",
                "op_kind",
                b"op_kind",
                "order_by",
                b"order_by",
                "path",
                b"path",
                "procedure_call",
                b"procedure_call",
                "project",
                b"project",
                "repartition",
                b"repartition",
                "root",
                b"root",
                "sample",
                b"sample",
                "scan",
                b"scan",
                "select",
                b"select",
                "set",
                b"set",
                "set_edge",
                b"set_edge",
                "set_vertex",
                b"set_vertex",
                "sink",
                b"sink",
                "source",
                b"source",
                "unfold",
                b"unfold",
                "union",
                b"union",
                "vertex",
                b"vertex",
            ],
        ) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["op_kind", b"op_kind"]) -> (
            typing.Literal[
                "project",
                "select",
                "group_by",
                "order_by",
                "dedup",
                "unfold",
                "limit",
                "scan",
                "sink",
                "apply",
                "join",
                "union",
                "intersect",
                "repartition",
                "root",
                "sample",
                "vertex",
                "edge",
                "path",
                "procedure_call",
                "set",
                "load",
                "delete",
                "source",
                "load_vertex",
                "load_edge",
                "create_vertex",
                "create_edge",
                "set_vertex",
                "set_edge",
                "delete_vertex",
                "delete_edge",
            ]
            | None
        ): ...

    @typing.final
    class MetaData(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TYPE_FIELD_NUMBER: builtins.int
        ALIAS_FIELD_NUMBER: builtins.int
        alias: builtins.int
        @property
        def type(self) -> type_pb2.IrDataType: ...
        def __init__(
            self,
            *,
            type: type_pb2.IrDataType | None = ...,
            alias: builtins.int = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["type", b"type"]
        ) -> builtins.bool: ...
        def ClearField(
            self, field_name: typing.Literal["alias", b"alias", "type", b"type"]
        ) -> None: ...

    OPR_FIELD_NUMBER: builtins.int
    META_DATA_FIELD_NUMBER: builtins.int
    @property
    def opr(self) -> global___PhysicalOpr.Operator:
        """The node's operator"""

    @property
    def meta_data(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___PhysicalOpr.MetaData
    ]:
        """The meta data of outputs of operator"""

    def __init__(
        self,
        *,
        opr: global___PhysicalOpr.Operator | None = ...,
        meta_data: collections.abc.Iterable[global___PhysicalOpr.MetaData] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["opr", b"opr"]) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["meta_data", b"meta_data", "opr", b"opr"]
    ) -> None: ...

global___PhysicalOpr = PhysicalOpr

@typing.final
class QueryPlan(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Mode:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ModeEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            QueryPlan._Mode.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        READ_ONLY: QueryPlan._Mode.ValueType  # 0
        WRITE_ONLY: QueryPlan._Mode.ValueType  # 1
        READ_WRITE: QueryPlan._Mode.ValueType  # 2

    class Mode(_Mode, metaclass=_ModeEnumTypeWrapper): ...
    READ_ONLY: QueryPlan.Mode.ValueType  # 0
    WRITE_ONLY: QueryPlan.Mode.ValueType  # 1
    READ_WRITE: QueryPlan.Mode.ValueType  # 2

    MODE_FIELD_NUMBER: builtins.int
    PLAN_FIELD_NUMBER: builtins.int
    mode: global___QueryPlan.Mode.ValueType
    @property
    def plan(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___PhysicalOpr
    ]: ...
    def __init__(
        self,
        *,
        mode: global___QueryPlan.Mode.ValueType = ...,
        plan: collections.abc.Iterable[global___PhysicalOpr] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["mode", b"mode", "plan", b"plan"]
    ) -> None: ...

global___QueryPlan = QueryPlan

@typing.final
class PhysicalPlan(google.protobuf.message.Message):
    """A single Cypher query ending with a semicolon (;)"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PLAN_ID_FIELD_NUMBER: builtins.int
    DDL_PLAN_FIELD_NUMBER: builtins.int
    QUERY_PLAN_FIELD_NUMBER: builtins.int
    plan_id: builtins.int
    @property
    def ddl_plan(self) -> cypher_ddl_pb2.DDLPlan: ...
    @property
    def query_plan(self) -> global___QueryPlan: ...
    def __init__(
        self,
        *,
        plan_id: builtins.int = ...,
        ddl_plan: cypher_ddl_pb2.DDLPlan | None = ...,
        query_plan: global___QueryPlan | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "ddl_plan", b"ddl_plan", "plan", b"plan", "query_plan", b"query_plan"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "ddl_plan",
            b"ddl_plan",
            "plan",
            b"plan",
            "plan_id",
            b"plan_id",
            "query_plan",
            b"query_plan",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["plan", b"plan"]
    ) -> typing.Literal["ddl_plan", "query_plan"] | None: ...

global___PhysicalPlan = PhysicalPlan

@typing.final
class PhysicalPlans(google.protobuf.message.Message):
    """Multiple queries in a single `execute` function"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PLANS_FIELD_NUMBER: builtins.int
    @property
    def plans(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___PhysicalPlan
    ]: ...
    def __init__(
        self,
        *,
        plans: collections.abc.Iterable[global___PhysicalPlan] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["plans", b"plans"]) -> None: ...

global___PhysicalPlans = PhysicalPlans
