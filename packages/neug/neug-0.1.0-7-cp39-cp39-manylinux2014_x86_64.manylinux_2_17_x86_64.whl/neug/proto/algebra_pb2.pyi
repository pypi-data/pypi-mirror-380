"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Copyright 2020 Alibaba Group Holding Limited.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import builtins
import collections.abc
import common_pb2
import expr_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import schema_pb2
import sys
import type_pb2
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class MetaData(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    alias: builtins.int
    @property
    def type(self) -> type_pb2.IrDataType: ...
    def __init__(
        self,
        *,
        type: type_pb2.IrDataType | None = ...,
        alias: builtins.int = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["type", b"type"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["alias", b"alias", "type", b"type"]
    ) -> None: ...

global___MetaData = MetaData

@typing.final
class Project(google.protobuf.message.Message):
    """We have several logical operators that are similar to physical operators (e.g., Project, GroupBy etc.),
    except for the type of operator's tags(or alias) is Option<i32> in physical, while Option<NameOrId> in logical.
    TODO: We preserve both for compatibility temporarily, but these operators would be identical with tag's (alias') type as Option<i32> soon.

    To project a relation on certain attributes or further their properties
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ExprAlias(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        EXPR_FIELD_NUMBER: builtins.int
        ALIAS_FIELD_NUMBER: builtins.int
        @property
        def expr(self) -> expr_pb2.Expression:
            """The expression to be aliased"""

        @property
        def alias(self) -> common_pb2.NameOrId:
            """The alias that is either given by the query or by the system"""

        def __init__(
            self,
            *,
            expr: expr_pb2.Expression | None = ...,
            alias: common_pb2.NameOrId | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["alias", b"alias", "expr", b"expr"]
        ) -> builtins.bool: ...
        def ClearField(
            self, field_name: typing.Literal["alias", b"alias", "expr", b"expr"]
        ) -> None: ...

    MAPPINGS_FIELD_NUMBER: builtins.int
    IS_APPEND_FIELD_NUMBER: builtins.int
    META_DATA_FIELD_NUMBER: builtins.int
    is_append: builtins.bool
    """An indicator to tell the runtime whether the projected value is appending to or replacing
    existing relation.
    """
    @property
    def mappings(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Project.ExprAlias
    ]:
        """A list of [expression -> alias] to be projected from the graph relation.
        e.g., project_{a.birthday / 100 % 100 as birth_month }
        """

    @property
    def meta_data(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___MetaData
    ]:
        """The datatype of output results"""

    def __init__(
        self,
        *,
        mappings: collections.abc.Iterable[global___Project.ExprAlias] | None = ...,
        is_append: builtins.bool = ...,
        meta_data: collections.abc.Iterable[global___MetaData] | None = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "is_append",
            b"is_append",
            "mappings",
            b"mappings",
            "meta_data",
            b"meta_data",
        ],
    ) -> None: ...

global___Project = Project

@typing.final
class Select(google.protobuf.message.Message):
    """To filter a relation based on a given predicate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PREDICATE_FIELD_NUMBER: builtins.int
    @property
    def predicate(self) -> expr_pb2.Expression:
        """A predicate formulated as an expression tree"""

    def __init__(
        self,
        *,
        predicate: expr_pb2.Expression | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["predicate", b"predicate"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["predicate", b"predicate"]
    ) -> None: ...

global___Select = Select

@typing.final
class Join(google.protobuf.message.Message):
    """Join two relations based on certain predicate."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _JoinKind:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _JoinKindEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            Join._JoinKind.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        INNER: Join._JoinKind.ValueType  # 0
        """Inner join"""
        LEFT_OUTER: Join._JoinKind.ValueType  # 1
        """Left outer join"""
        RIGHT_OUTER: Join._JoinKind.ValueType  # 2
        """Right outer join"""
        FULL_OUTER: Join._JoinKind.ValueType  # 3
        """Full outer join"""
        SEMI: Join._JoinKind.ValueType  # 4
        """Left semi-join, right alternative can be naturally adapted"""
        ANTI: Join._JoinKind.ValueType  # 5
        """Left anti-join, right alternative can be naturally adapted"""
        TIMES: Join._JoinKind.ValueType  # 6
        """aka. Cartesian product"""

    class JoinKind(_JoinKind, metaclass=_JoinKindEnumTypeWrapper): ...
    INNER: Join.JoinKind.ValueType  # 0
    """Inner join"""
    LEFT_OUTER: Join.JoinKind.ValueType  # 1
    """Left outer join"""
    RIGHT_OUTER: Join.JoinKind.ValueType  # 2
    """Right outer join"""
    FULL_OUTER: Join.JoinKind.ValueType  # 3
    """Full outer join"""
    SEMI: Join.JoinKind.ValueType  # 4
    """Left semi-join, right alternative can be naturally adapted"""
    ANTI: Join.JoinKind.ValueType  # 5
    """Left anti-join, right alternative can be naturally adapted"""
    TIMES: Join.JoinKind.ValueType  # 6
    """aka. Cartesian product"""

    LEFT_KEYS_FIELD_NUMBER: builtins.int
    RIGHT_KEYS_FIELD_NUMBER: builtins.int
    KIND_FIELD_NUMBER: builtins.int
    kind: global___Join.JoinKind.ValueType
    @property
    def left_keys(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        expr_pb2.Variable
    ]:
        """TODO(longbin) An expression-ish predicate here is a more general form:
        We currently only support the predicate of the equality of the given keys of both relations are equal.
        In general, a join operator can join on any arbitrary predicate regarding certain attributes of left and right
        participants.
        """

    @property
    def right_keys(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        expr_pb2.Variable
    ]: ...
    def __init__(
        self,
        *,
        left_keys: collections.abc.Iterable[expr_pb2.Variable] | None = ...,
        right_keys: collections.abc.Iterable[expr_pb2.Variable] | None = ...,
        kind: global___Join.JoinKind.ValueType = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "kind", b"kind", "left_keys", b"left_keys", "right_keys", b"right_keys"
        ],
    ) -> None: ...

global___Join = Join

@typing.final
class Union(google.protobuf.message.Message):
    """Union multiple relations"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARENTS_FIELD_NUMBER: builtins.int
    @property
    def parents(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[
        builtins.int
    ]: ...
    def __init__(
        self,
        *,
        parents: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["parents", b"parents"]) -> None: ...

global___Union = Union

@typing.final
class Intersect(google.protobuf.message.Message):
    """Intersect multiple relations regarding a given key. In order to do so, the relations must satisfy:
    * They have exactly the same schema,
    * The data of every two relations is the same tuple-wise except for the data field referred by the given key,
    * The key must refer to an array of objects.
    The results of the intersection,
    taking intersecting two relations R1[a, b, c, ..., array] and R2[a, b, c, ..., array] as an example,
    is R[a, b, c, ..., array], where for each tuple r of R,  r.array = r1.array <intersect> r2.array
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARENTS_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    @property
    def parents(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[
        builtins.int
    ]: ...
    @property
    def key(self) -> common_pb2.NameOrId: ...
    def __init__(
        self,
        *,
        parents: collections.abc.Iterable[builtins.int] | None = ...,
        key: common_pb2.NameOrId | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["key", b"key", "parents", b"parents"]
    ) -> None: ...

global___Intersect = Intersect

@typing.final
class GroupBy(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class AggFunc(google.protobuf.message.Message):
        """To define the function to be applied on each group after performing grouping. For example,
        GROUPBY({a, b}, COUNT_DISTINCT(c, d) as e), one shall count distinct present of the pairs
        (c, d), and alias the count as e.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _Aggregate:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _AggregateEnumTypeWrapper(
            google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
                GroupBy.AggFunc._Aggregate.ValueType
            ],
            builtins.type,
        ):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            SUM: GroupBy.AggFunc._Aggregate.ValueType  # 0
            MIN: GroupBy.AggFunc._Aggregate.ValueType  # 1
            MAX: GroupBy.AggFunc._Aggregate.ValueType  # 2
            COUNT: GroupBy.AggFunc._Aggregate.ValueType  # 3
            COUNT_DISTINCT: GroupBy.AggFunc._Aggregate.ValueType  # 4
            TO_LIST: GroupBy.AggFunc._Aggregate.ValueType  # 5
            TO_SET: GroupBy.AggFunc._Aggregate.ValueType  # 6
            AVG: GroupBy.AggFunc._Aggregate.ValueType  # 7
            FIRST: GroupBy.AggFunc._Aggregate.ValueType  # 8

        class Aggregate(_Aggregate, metaclass=_AggregateEnumTypeWrapper): ...
        SUM: GroupBy.AggFunc.Aggregate.ValueType  # 0
        MIN: GroupBy.AggFunc.Aggregate.ValueType  # 1
        MAX: GroupBy.AggFunc.Aggregate.ValueType  # 2
        COUNT: GroupBy.AggFunc.Aggregate.ValueType  # 3
        COUNT_DISTINCT: GroupBy.AggFunc.Aggregate.ValueType  # 4
        TO_LIST: GroupBy.AggFunc.Aggregate.ValueType  # 5
        TO_SET: GroupBy.AggFunc.Aggregate.ValueType  # 6
        AVG: GroupBy.AggFunc.Aggregate.ValueType  # 7
        FIRST: GroupBy.AggFunc.Aggregate.ValueType  # 8

        VARS_FIELD_NUMBER: builtins.int
        AGGREGATE_FIELD_NUMBER: builtins.int
        ALIAS_FIELD_NUMBER: builtins.int
        aggregate: global___GroupBy.AggFunc.Aggregate.ValueType
        """The aggregate function"""
        @property
        def vars(
            self,
        ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
            expr_pb2.Variable
        ]:
            """The variables to apply this aggregation
            TODO(longbin) An expression here is a more general form
            """

        @property
        def alias(self) -> common_pb2.NameOrId:
            """The alias for the aggregated value"""

        def __init__(
            self,
            *,
            vars: collections.abc.Iterable[expr_pb2.Variable] | None = ...,
            aggregate: global___GroupBy.AggFunc.Aggregate.ValueType = ...,
            alias: common_pb2.NameOrId | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["alias", b"alias"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "aggregate", b"aggregate", "alias", b"alias", "vars", b"vars"
            ],
        ) -> None: ...

    @typing.final
    class KeyAlias(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        ALIAS_FIELD_NUMBER: builtins.int
        @property
        def key(self) -> expr_pb2.Variable:
            """The key to perform grouping
            TODO(longbin) An expression here is a more general form
            """

        @property
        def alias(self) -> common_pb2.NameOrId:
            """The alias for the key"""

        def __init__(
            self,
            *,
            key: expr_pb2.Variable | None = ...,
            alias: common_pb2.NameOrId | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["alias", b"alias", "key", b"key"]
        ) -> builtins.bool: ...
        def ClearField(
            self, field_name: typing.Literal["alias", b"alias", "key", b"key"]
        ) -> None: ...

    MAPPINGS_FIELD_NUMBER: builtins.int
    FUNCTIONS_FIELD_NUMBER: builtins.int
    META_DATA_FIELD_NUMBER: builtins.int
    @property
    def mappings(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___GroupBy.KeyAlias
    ]:
        """A collection of key-alias mappings"""

    @property
    def functions(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___GroupBy.AggFunc
    ]:
        """The grouping functions"""

    @property
    def meta_data(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___MetaData
    ]:
        """The datatype of output results"""

    def __init__(
        self,
        *,
        mappings: collections.abc.Iterable[global___GroupBy.KeyAlias] | None = ...,
        functions: collections.abc.Iterable[global___GroupBy.AggFunc] | None = ...,
        meta_data: collections.abc.Iterable[global___MetaData] | None = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "functions",
            b"functions",
            "mappings",
            b"mappings",
            "meta_data",
            b"meta_data",
        ],
    ) -> None: ...

global___GroupBy = GroupBy

@typing.final
class OrderBy(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class OrderingPair(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _Order:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _OrderEnumTypeWrapper(
            google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
                OrderBy.OrderingPair._Order.ValueType
            ],
            builtins.type,
        ):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            SHUFFLE: OrderBy.OrderingPair._Order.ValueType  # 0
            """random"""
            ASC: OrderBy.OrderingPair._Order.ValueType  # 1
            """ascending"""
            DESC: OrderBy.OrderingPair._Order.ValueType  # 2
            """descending"""

        class Order(_Order, metaclass=_OrderEnumTypeWrapper): ...
        SHUFFLE: OrderBy.OrderingPair.Order.ValueType  # 0
        """random"""
        ASC: OrderBy.OrderingPair.Order.ValueType  # 1
        """ascending"""
        DESC: OrderBy.OrderingPair.Order.ValueType  # 2
        """descending"""

        KEY_FIELD_NUMBER: builtins.int
        ORDER_FIELD_NUMBER: builtins.int
        order: global___OrderBy.OrderingPair.Order.ValueType
        @property
        def key(self) -> expr_pb2.Variable:
            """TODO(longbin) An expression here is a more general form"""

        def __init__(
            self,
            *,
            key: expr_pb2.Variable | None = ...,
            order: global___OrderBy.OrderingPair.Order.ValueType = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["key", b"key"]
        ) -> builtins.bool: ...
        def ClearField(
            self, field_name: typing.Literal["key", b"key", "order", b"order"]
        ) -> None: ...

    PAIRS_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    @property
    def pairs(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___OrderBy.OrderingPair
    ]: ...
    @property
    def limit(self) -> global___Range:
        """A size limit. `OrderBy.Limit` is equivalent to the `Topk` operation"""

    def __init__(
        self,
        *,
        pairs: collections.abc.Iterable[global___OrderBy.OrderingPair] | None = ...,
        limit: global___Range | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["limit", b"limit"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["limit", b"limit", "pairs", b"pairs"]
    ) -> None: ...

global___OrderBy = OrderBy

@typing.final
class Dedup(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        expr_pb2.Variable
    ]:
        """TODO(longbin) An expression here is a more general form"""

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[expr_pb2.Variable] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

global___Dedup = Dedup

@typing.final
class Unfold(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAG_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    META_DATA_FIELD_NUMBER: builtins.int
    @property
    def tag(self) -> common_pb2.NameOrId:
        """The tag of a graph relation that **must** refer to a data of collection type"""

    @property
    def alias(self) -> common_pb2.NameOrId:
        """The alias tag for the elements that are unfolded from the collection"""

    @property
    def meta_data(self) -> global___MetaData:
        """The type for the unfold value"""

    def __init__(
        self,
        *,
        tag: common_pb2.NameOrId | None = ...,
        alias: common_pb2.NameOrId | None = ...,
        meta_data: global___MetaData | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias", b"alias", "meta_data", b"meta_data", "tag", b"tag"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias", b"alias", "meta_data", b"meta_data", "tag", b"tag"
        ],
    ) -> None: ...

global___Unfold = Unfold

@typing.final
class Range(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOWER_FIELD_NUMBER: builtins.int
    UPPER_FIELD_NUMBER: builtins.int
    lower: builtins.int
    """The lower bound of the range, included"""
    upper: builtins.int
    """The upper bound of the range, **excluded**"""
    def __init__(
        self,
        *,
        lower: builtins.int = ...,
        upper: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["lower", b"lower", "upper", b"upper"]
    ) -> None: ...

global___Range = Range

@typing.final
class Limit(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RANGE_FIELD_NUMBER: builtins.int
    @property
    def range(self) -> global___Range:
        """The limit range, e.g., limit(10) will be represented by Range {lower = 0, upper = 10}"""

    def __init__(
        self,
        *,
        range: global___Range | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["range", b"range"]
    ) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["range", b"range"]) -> None: ...

global___Limit = Limit

@typing.final
class IndexPredicate(google.protobuf.message.Message):
    """To define a predicate of {{k1, cmp, v1} and {k2, cmp, v2}} or ...,
    where the values referred by k1, k2, ... are indexed and hence the
    predicate can be efficiently verified by leveraging the index.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Triplet(google.protobuf.message.Message):
        """A triplet defines that a key must be **equal** to a given value.
        The value can be a constant value, or a dynamic parameter.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        CONST_FIELD_NUMBER: builtins.int
        PARAM_FIELD_NUMBER: builtins.int
        CMP_FIELD_NUMBER: builtins.int
        cmp: expr_pb2.Logical.ValueType
        """TODO(longbin) More comparators (gt, ge, lt, le, ne) other than equivalence (eq or within) may be required"""
        @property
        def key(self) -> expr_pb2.Property: ...
        @property
        def const(self) -> common_pb2.Value: ...
        @property
        def param(self) -> expr_pb2.DynamicParam: ...
        def __init__(
            self,
            *,
            key: expr_pb2.Property | None = ...,
            const: common_pb2.Value | None = ...,
            param: expr_pb2.DynamicParam | None = ...,
            cmp: expr_pb2.Logical.ValueType = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "const", b"const", "key", b"key", "param", b"param", "value", b"value"
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "cmp",
                b"cmp",
                "const",
                b"const",
                "key",
                b"key",
                "param",
                b"param",
                "value",
                b"value",
            ],
        ) -> None: ...
        def WhichOneof(
            self, oneof_group: typing.Literal["value", b"value"]
        ) -> typing.Literal["const", "param"] | None: ...

    @typing.final
    class AndPredicate(google.protobuf.message.Message):
        """A collection of `Triplet` that forms a logical **AND** of all `Predicate`s."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        PREDICATES_FIELD_NUMBER: builtins.int
        @property
        def predicates(
            self,
        ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
            global___IndexPredicate.Triplet
        ]: ...
        def __init__(
            self,
            *,
            predicates: (
                collections.abc.Iterable[global___IndexPredicate.Triplet] | None
            ) = ...,
        ) -> None: ...
        def ClearField(
            self, field_name: typing.Literal["predicates", b"predicates"]
        ) -> None: ...

    OR_PREDICATES_FIELD_NUMBER: builtins.int
    @property
    def or_predicates(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___IndexPredicate.AndPredicate
    ]:
        """A collection of `AndPredicate` that forms a logical **OR** of all `AndPredicate`s"""

    def __init__(
        self,
        *,
        or_predicates: (
            collections.abc.Iterable[global___IndexPredicate.AndPredicate] | None
        ) = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["or_predicates", b"or_predicates"]
    ) -> None: ...

global___IndexPredicate = IndexPredicate

@typing.final
class QueryParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ExtraEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(
            self, field_name: typing.Literal["key", b"key", "value", b"value"]
        ) -> None: ...

    TABLES_FIELD_NUMBER: builtins.int
    COLUMNS_FIELD_NUMBER: builtins.int
    IS_ALL_COLUMNS_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    PREDICATE_FIELD_NUMBER: builtins.int
    SAMPLE_RATIO_FIELD_NUMBER: builtins.int
    EXTRA_FIELD_NUMBER: builtins.int
    is_all_columns: builtins.bool
    """Can specify to get all columns of the table"""
    sample_ratio: builtins.float
    """Define the sampling ratio, while querying vertex/edge.
    1.0 by default for deterministic case.
    """
    @property
    def tables(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        common_pb2.NameOrId
    ]:
        """The tables to fetch data from. While this may sound arbitrary, but in graph db, we often use
        label instead of table to refer to an entity (vertex/edge). They are semantically the same.
        """

    @property
    def columns(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        common_pb2.NameOrId
    ]:
        """The required columns of the table."""

    @property
    def limit(self) -> global___Range:
        """The size limit"""

    @property
    def predicate(self) -> expr_pb2.Expression:
        """The optional predicate for the data tuple, which may be pushed down to the storage service"""

    @property
    def extra(
        self,
    ) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Extra parameters for general-purpose usage"""

    def __init__(
        self,
        *,
        tables: collections.abc.Iterable[common_pb2.NameOrId] | None = ...,
        columns: collections.abc.Iterable[common_pb2.NameOrId] | None = ...,
        is_all_columns: builtins.bool = ...,
        limit: global___Range | None = ...,
        predicate: expr_pb2.Expression | None = ...,
        sample_ratio: builtins.float = ...,
        extra: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["limit", b"limit", "predicate", b"predicate"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "columns",
            b"columns",
            "extra",
            b"extra",
            "is_all_columns",
            b"is_all_columns",
            "limit",
            b"limit",
            "predicate",
            b"predicate",
            "sample_ratio",
            b"sample_ratio",
            "tables",
            b"tables",
        ],
    ) -> None: ...

global___QueryParams = QueryParams

@typing.final
class Scan(google.protobuf.message.Message):
    """Scan is an operator that transforms the source data format (defined by the database)
    into internal data format (defined/used by runtime)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ScanOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ScanOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            Scan._ScanOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERTEX: Scan._ScanOpt.ValueType  # 0
        """Scanning the vertices"""
        EDGE: Scan._ScanOpt.ValueType  # 1
        """Scanning the edges"""
        TABLE: Scan._ScanOpt.ValueType  # 2
        """Scanning a relational table"""

    class ScanOpt(_ScanOpt, metaclass=_ScanOptEnumTypeWrapper): ...
    VERTEX: Scan.ScanOpt.ValueType  # 0
    """Scanning the vertices"""
    EDGE: Scan.ScanOpt.ValueType  # 1
    """Scanning the edges"""
    TABLE: Scan.ScanOpt.ValueType  # 2
    """Scanning a relational table"""

    SCAN_OPT_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    IDX_PREDICATE_FIELD_NUMBER: builtins.int
    IS_COUNT_ONLY_FIELD_NUMBER: builtins.int
    META_DATA_FIELD_NUMBER: builtins.int
    scan_opt: global___Scan.ScanOpt.ValueType
    is_count_only: builtins.bool
    """The flag that indicates SCAN + COUNT"""
    @property
    def alias(self) -> common_pb2.NameOrId:
        """The alias of the item if it is a vertex or edge"""

    @property
    def params(self) -> global___QueryParams:
        """The required parameters for the scan"""

    @property
    def idx_predicate(self) -> global___IndexPredicate:
        """The optional filtering predicate for the field that have been indexed"""

    @property
    def meta_data(self) -> global___MetaData: ...
    def __init__(
        self,
        *,
        scan_opt: global___Scan.ScanOpt.ValueType = ...,
        alias: common_pb2.NameOrId | None = ...,
        params: global___QueryParams | None = ...,
        idx_predicate: global___IndexPredicate | None = ...,
        is_count_only: builtins.bool = ...,
        meta_data: global___MetaData | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "idx_predicate",
            b"idx_predicate",
            "meta_data",
            b"meta_data",
            "params",
            b"params",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "idx_predicate",
            b"idx_predicate",
            "is_count_only",
            b"is_count_only",
            "meta_data",
            b"meta_data",
            "params",
            b"params",
            "scan_opt",
            b"scan_opt",
        ],
    ) -> None: ...

global___Scan = Scan

@typing.final
class GetV(google.protobuf.message.Message):
    """It is typical to use the operator together with EdgeExpand or PathExpand, with the functionality of
    obtaining some properties of the end vertex after the expansion.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _VOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _VOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            GetV._VOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        START: GetV._VOpt.ValueType  # 0
        """Getting the start vertex of the edge/path"""
        END: GetV._VOpt.ValueType  # 1
        """Getting the end vertex of the edge/path"""
        OTHER: GetV._VOpt.ValueType  # 2
        """Getting the other vertex of the edge/path. We are calibrating to Gremlin's bothE.otherV semantics"""
        BOTH: GetV._VOpt.ValueType  # 3
        """Getting both vertices of the edge/path"""

    class VOpt(_VOpt, metaclass=_VOptEnumTypeWrapper): ...
    START: GetV.VOpt.ValueType  # 0
    """Getting the start vertex of the edge/path"""
    END: GetV.VOpt.ValueType  # 1
    """Getting the end vertex of the edge/path"""
    OTHER: GetV.VOpt.ValueType  # 2
    """Getting the other vertex of the edge/path. We are calibrating to Gremlin's bothE.otherV semantics"""
    BOTH: GetV.VOpt.ValueType  # 3
    """Getting both vertices of the edge/path"""

    TAG_FIELD_NUMBER: builtins.int
    OPT_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    META_DATA_FIELD_NUMBER: builtins.int
    opt: global___GetV.VOpt.ValueType
    """Determine what vertex to get from the tagged object"""
    @property
    def tag(self) -> common_pb2.NameOrId:
        """The tag that refers to the edge/path where the end vertex will be retrieved"""

    @property
    def params(self) -> global___QueryParams:
        """The query parameters of getting vertices"""

    @property
    def alias(self) -> common_pb2.NameOrId:
        """The alias of this vertex"""

    @property
    def meta_data(self) -> global___MetaData: ...
    def __init__(
        self,
        *,
        tag: common_pb2.NameOrId | None = ...,
        opt: global___GetV.VOpt.ValueType = ...,
        params: global___QueryParams | None = ...,
        alias: common_pb2.NameOrId | None = ...,
        meta_data: global___MetaData | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "meta_data",
            b"meta_data",
            "params",
            b"params",
            "tag",
            b"tag",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "meta_data",
            b"meta_data",
            "opt",
            b"opt",
            "params",
            b"params",
            "tag",
            b"tag",
        ],
    ) -> None: ...

global___GetV = GetV

@typing.final
class As(google.protobuf.message.Message):
    """To tag the current data with an alias"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ALIAS_FIELD_NUMBER: builtins.int
    @property
    def alias(self) -> common_pb2.NameOrId:
        """The alias to give if any, this is especially helpful when the entity now refers to the head of the record"""

    def __init__(
        self,
        *,
        alias: common_pb2.NameOrId | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["alias", b"alias"]
    ) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["alias", b"alias"]) -> None: ...

global___As = As

@typing.final
class EdgeExpand(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Direction:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DirectionEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            EdgeExpand._Direction.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        OUT: EdgeExpand._Direction.ValueType  # 0
        IN: EdgeExpand._Direction.ValueType  # 1
        BOTH: EdgeExpand._Direction.ValueType  # 2

    class Direction(_Direction, metaclass=_DirectionEnumTypeWrapper): ...
    OUT: EdgeExpand.Direction.ValueType  # 0
    IN: EdgeExpand.Direction.ValueType  # 1
    BOTH: EdgeExpand.Direction.ValueType  # 2

    class _ExpandOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ExpandOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            EdgeExpand._ExpandOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERTEX: EdgeExpand._ExpandOpt.ValueType  # 0
        EDGE: EdgeExpand._ExpandOpt.ValueType  # 1
        DEGREE: EdgeExpand._ExpandOpt.ValueType  # 2

    class ExpandOpt(_ExpandOpt, metaclass=_ExpandOptEnumTypeWrapper): ...
    VERTEX: EdgeExpand.ExpandOpt.ValueType  # 0
    EDGE: EdgeExpand.ExpandOpt.ValueType  # 1
    DEGREE: EdgeExpand.ExpandOpt.ValueType  # 2

    V_TAG_FIELD_NUMBER: builtins.int
    DIRECTION_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    EXPAND_OPT_FIELD_NUMBER: builtins.int
    META_DATA_FIELD_NUMBER: builtins.int
    IS_OPTIONAL_FIELD_NUMBER: builtins.int
    direction: global___EdgeExpand.Direction.ValueType
    """The direction of the expanded edge"""
    expand_opt: global___EdgeExpand.ExpandOpt.ValueType
    """Expand option, i.e., expand vertices/edges/degree."""
    is_optional: builtins.bool
    """Whether the expand is optional, if true, the expand will return a `None` if the edge does not exist"""
    @property
    def v_tag(self) -> common_pb2.NameOrId:
        """The tag that refers to the starting vertex"""

    @property
    def params(self) -> global___QueryParams:
        """The query parameters define the condition that the edge/end vertex must satisfy.
        Note that whether the query parameters apply to the edge or end vertex depends on
        the `is_edge` indicator, with one exception that the `tables` parameter in `EdgeExpand`
        **always** applies to the edge for now (may be fixed later) .
        """

    @property
    def alias(self) -> common_pb2.NameOrId:
        """An optional alias for the object of the expansion"""

    @property
    def meta_data(self) -> global___MetaData: ...
    def __init__(
        self,
        *,
        v_tag: common_pb2.NameOrId | None = ...,
        direction: global___EdgeExpand.Direction.ValueType = ...,
        params: global___QueryParams | None = ...,
        alias: common_pb2.NameOrId | None = ...,
        expand_opt: global___EdgeExpand.ExpandOpt.ValueType = ...,
        meta_data: global___MetaData | None = ...,
        is_optional: builtins.bool = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "meta_data",
            b"meta_data",
            "params",
            b"params",
            "v_tag",
            b"v_tag",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "direction",
            b"direction",
            "expand_opt",
            b"expand_opt",
            "is_optional",
            b"is_optional",
            "meta_data",
            b"meta_data",
            "params",
            b"params",
            "v_tag",
            b"v_tag",
        ],
    ) -> None: ...

global___EdgeExpand = EdgeExpand

@typing.final
class PathExpand(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _PathOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _PathOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            PathExpand._PathOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        ARBITRARY: PathExpand._PathOpt.ValueType  # 0
        """an arbitrary path, in which both vertex/edge may duplicate"""
        SIMPLE: PathExpand._PathOpt.ValueType  # 1
        """a path without vertex duplications"""
        TRAIL: PathExpand._PathOpt.ValueType  # 2
        """a path without edge duplications"""

    class PathOpt(_PathOpt, metaclass=_PathOptEnumTypeWrapper): ...
    ARBITRARY: PathExpand.PathOpt.ValueType  # 0
    """an arbitrary path, in which both vertex/edge may duplicate"""
    SIMPLE: PathExpand.PathOpt.ValueType  # 1
    """a path without vertex duplications"""
    TRAIL: PathExpand.PathOpt.ValueType  # 2
    """a path without edge duplications"""

    class _ResultOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ResultOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            PathExpand._ResultOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        END_V: PathExpand._ResultOpt.ValueType  # 0
        """only end vertex is required for this expansion"""
        ALL_V: PathExpand._ResultOpt.ValueType  # 1
        """all vertices of this path are required for this expansion."""
        ALL_V_E: PathExpand._ResultOpt.ValueType  # 2
        """all vertices and edges of this path are required for this expansion."""

    class ResultOpt(_ResultOpt, metaclass=_ResultOptEnumTypeWrapper):
        """Define what result is required for this path. We currently support `EndV` and `AllV`, while an option to
        include all edges and vertices may be needed in the future.
        """

    END_V: PathExpand.ResultOpt.ValueType  # 0
    """only end vertex is required for this expansion"""
    ALL_V: PathExpand.ResultOpt.ValueType  # 1
    """all vertices of this path are required for this expansion."""
    ALL_V_E: PathExpand.ResultOpt.ValueType  # 2
    """all vertices and edges of this path are required for this expansion."""

    @typing.final
    class ExpandBase(google.protobuf.message.Message):
        """The expand base of PathExpand"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        EDGE_EXPAND_FIELD_NUMBER: builtins.int
        GET_V_FIELD_NUMBER: builtins.int
        @property
        def edge_expand(self) -> global___EdgeExpand:
            """Can either be a single EdgeExpand (with ExpandOpt = Vertex), or EdgeExpand (with ExpandOpt = Edge) + GetV"""

        @property
        def get_V(self) -> global___GetV: ...
        def __init__(
            self,
            *,
            edge_expand: global___EdgeExpand | None = ...,
            get_V: global___GetV | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "edge_expand", b"edge_expand", "get_V", b"get_V"
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "edge_expand", b"edge_expand", "get_V", b"get_V"
            ],
        ) -> None: ...

    BASE_FIELD_NUMBER: builtins.int
    START_TAG_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    HOP_RANGE_FIELD_NUMBER: builtins.int
    PATH_OPT_FIELD_NUMBER: builtins.int
    RESULT_OPT_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    IS_OPTIONAL_FIELD_NUMBER: builtins.int
    path_opt: global___PathExpand.PathOpt.ValueType
    """Path option, including to expand an arbitrary path or a simple path"""
    result_opt: global___PathExpand.ResultOpt.ValueType
    """Result option, including to take end vertex (EndV), or whole path (AllV), for this expansion"""
    is_optional: builtins.bool
    """Whether the expand is optional, if true, the expand will return a `None` if the path does not exist"""
    @property
    def base(self) -> global___PathExpand.ExpandBase:
        """A path expansion has a base expansion"""

    @property
    def start_tag(self) -> common_pb2.NameOrId:
        """The tag that refers to the starting vertex"""

    @property
    def alias(self) -> common_pb2.NameOrId:
        """An optional alias for the object of the expansion"""

    @property
    def hop_range(self) -> global___Range:
        """The range that defines the minimum and maximum number of hops of the path expansion.
        This is optional, if not set, the minimum number is 1, and the maximum is INT_MAX
        """

    @property
    def condition(self) -> expr_pb2.Expression:
        """A condition formulated as an expression predicate"""

    def __init__(
        self,
        *,
        base: global___PathExpand.ExpandBase | None = ...,
        start_tag: common_pb2.NameOrId | None = ...,
        alias: common_pb2.NameOrId | None = ...,
        hop_range: global___Range | None = ...,
        path_opt: global___PathExpand.PathOpt.ValueType = ...,
        result_opt: global___PathExpand.ResultOpt.ValueType = ...,
        condition: expr_pb2.Expression | None = ...,
        is_optional: builtins.bool = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "base",
            b"base",
            "condition",
            b"condition",
            "hop_range",
            b"hop_range",
            "start_tag",
            b"start_tag",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "base",
            b"base",
            "condition",
            b"condition",
            "hop_range",
            b"hop_range",
            "is_optional",
            b"is_optional",
            "path_opt",
            b"path_opt",
            "result_opt",
            b"result_opt",
            "start_tag",
            b"start_tag",
        ],
    ) -> None: ...

global___PathExpand = PathExpand

@typing.final
class Apply(google.protobuf.message.Message):
    """
    message ShortestPathExpand {
    message WeightCal {
    enum Aggregate {
    SUM = 0;
    MAX = 1;
    MIN = 2;
    AVG = 3;
    MUL = 4;
    }
    // This optional expression defines how to calculate the weight on each edge. In the expression,
    // one can directly write start, end to indicate the start/edge vertices of the edge.
    // e.g. the expression: "start.value + end.value * weight" defines that the weight of each edge
    // is calculated by multiplying the edge vertex's value with the edge's weight and then summing
    // it with the start vertex's value.
    common.Expression weight_each = 1;
    // Define how to aggregate the calculated weight of each edge as the path weight
    Aggregate aggregate = 2;
    }
    // A shortest path expansion has a base of path expansion
    PathExpand path_expand = 1;
    // An optional weight calculation function for shortest path. If not specified, the weight is
    // by default the length of the path.
    WeightCal weight_cal = 2;
    }

    Apply is a relational operation where it first performs a inner correlated subtask for each tuple
    of input relations, and then the result of the subtask will be joined back to each input tuple.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    JOIN_KIND_FIELD_NUMBER: builtins.int
    TAGS_FIELD_NUMBER: builtins.int
    SUBTASK_FIELD_NUMBER: builtins.int
    ALIAS_FIELD_NUMBER: builtins.int
    join_kind: global___Join.JoinKind.ValueType
    """Define how to join the result of the subtask back to the original relation"""
    subtask: builtins.int
    """The subtask will be perform on certain tags as keys of the input relation"""
    @property
    def tags(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        common_pb2.NameOrId
    ]:
        """To project on certain tags of the input relation to execute the subtask"""

    @property
    def alias(self) -> common_pb2.NameOrId:
        """Define the alias of output from `Apply`"""

    def __init__(
        self,
        *,
        join_kind: global___Join.JoinKind.ValueType = ...,
        tags: collections.abc.Iterable[common_pb2.NameOrId] | None = ...,
        subtask: builtins.int = ...,
        alias: common_pb2.NameOrId | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["alias", b"alias"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "alias",
            b"alias",
            "join_kind",
            b"join_kind",
            "subtask",
            b"subtask",
            "tags",
            b"tags",
        ],
    ) -> None: ...

global___Apply = Apply

@typing.final
class SegmentApply(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    APPLY_SUBTASK_FIELD_NUMBER: builtins.int
    @property
    def keys(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        common_pb2.NameOrId
    ]:
        """The keys to perform grouping, or segmenting. For simplicity, we only allows grouping by the
        existed tags of the graph relation, which is unlike GroupBy that we further allows digging
        into the properties of a vertex/edge that the tag refers to.
        """

    @property
    def apply_subtask(self) -> global___Apply:
        """A base of apply operation that is conducted on each group of the relations instead of tuple"""

    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[common_pb2.NameOrId] | None = ...,
        apply_subtask: global___Apply | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["apply_subtask", b"apply_subtask"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal["apply_subtask", b"apply_subtask", "keys", b"keys"],
    ) -> None: ...

global___SegmentApply = SegmentApply

@typing.final
class Pattern(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Binder(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        EDGE_FIELD_NUMBER: builtins.int
        PATH_FIELD_NUMBER: builtins.int
        VERTEX_FIELD_NUMBER: builtins.int
        SELECT_FIELD_NUMBER: builtins.int
        @property
        def edge(self) -> global___EdgeExpand: ...
        @property
        def path(self) -> global___PathExpand: ...
        @property
        def vertex(self) -> global___GetV: ...
        @property
        def select(self) -> global___Select: ...
        def __init__(
            self,
            *,
            edge: global___EdgeExpand | None = ...,
            path: global___PathExpand | None = ...,
            vertex: global___GetV | None = ...,
            select: global___Select | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "edge",
                b"edge",
                "item",
                b"item",
                "path",
                b"path",
                "select",
                b"select",
                "vertex",
                b"vertex",
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "edge",
                b"edge",
                "item",
                b"item",
                "path",
                b"path",
                "select",
                b"select",
                "vertex",
                b"vertex",
            ],
        ) -> None: ...
        def WhichOneof(
            self, oneof_group: typing.Literal["item", b"item"]
        ) -> typing.Literal["edge", "path", "vertex", "select"] | None: ...

    @typing.final
    class Sentence(google.protobuf.message.Message):
        """A sentence defines a match"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        START_FIELD_NUMBER: builtins.int
        BINDERS_FIELD_NUMBER: builtins.int
        END_FIELD_NUMBER: builtins.int
        JOIN_KIND_FIELD_NUMBER: builtins.int
        join_kind: global___Join.JoinKind.ValueType
        """/ Define how to attach this sentence to the other one"""
        @property
        def start(self) -> common_pb2.NameOrId: ...
        @property
        def binders(
            self,
        ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
            global___Pattern.Binder
        ]: ...
        @property
        def end(self) -> common_pb2.NameOrId: ...
        def __init__(
            self,
            *,
            start: common_pb2.NameOrId | None = ...,
            binders: collections.abc.Iterable[global___Pattern.Binder] | None = ...,
            end: common_pb2.NameOrId | None = ...,
            join_kind: global___Join.JoinKind.ValueType = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["end", b"end", "start", b"start"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "binders",
                b"binders",
                "end",
                b"end",
                "join_kind",
                b"join_kind",
                "start",
                b"start",
            ],
        ) -> None: ...

    SENTENCES_FIELD_NUMBER: builtins.int
    META_DATA_FIELD_NUMBER: builtins.int
    @property
    def sentences(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Pattern.Sentence
    ]: ...
    @property
    def meta_data(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___MetaData
    ]: ...
    def __init__(
        self,
        *,
        sentences: collections.abc.Iterable[global___Pattern.Sentence] | None = ...,
        meta_data: collections.abc.Iterable[global___MetaData] | None = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "meta_data", b"meta_data", "sentences", b"sentences"
        ],
    ) -> None: ...

global___Pattern = Pattern

@typing.final
class Sample(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class SampleByRatio(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RATIO_FIELD_NUMBER: builtins.int
        ratio: builtins.float
        """The sample ratio"""
        def __init__(
            self,
            *,
            ratio: builtins.float = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["ratio", b"ratio"]) -> None: ...

    @typing.final
    class SampleByNum(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NUM_FIELD_NUMBER: builtins.int
        num: builtins.int
        """The sample number"""
        def __init__(
            self,
            *,
            num: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["num", b"num"]) -> None: ...

    @typing.final
    class SampleType(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        SAMPLE_BY_RATIO_FIELD_NUMBER: builtins.int
        SAMPLE_BY_NUM_FIELD_NUMBER: builtins.int
        @property
        def sample_by_ratio(self) -> global___Sample.SampleByRatio: ...
        @property
        def sample_by_num(self) -> global___Sample.SampleByNum: ...
        def __init__(
            self,
            *,
            sample_by_ratio: global___Sample.SampleByRatio | None = ...,
            sample_by_num: global___Sample.SampleByNum | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "inner",
                b"inner",
                "sample_by_num",
                b"sample_by_num",
                "sample_by_ratio",
                b"sample_by_ratio",
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "inner",
                b"inner",
                "sample_by_num",
                b"sample_by_num",
                "sample_by_ratio",
                b"sample_by_ratio",
            ],
        ) -> None: ...
        def WhichOneof(
            self, oneof_group: typing.Literal["inner", b"inner"]
        ) -> typing.Literal["sample_by_ratio", "sample_by_num"] | None: ...

    SAMPLE_TYPE_FIELD_NUMBER: builtins.int
    SEED_FIELD_NUMBER: builtins.int
    SAMPLE_WEIGHT_FIELD_NUMBER: builtins.int
    @property
    def sample_type(self) -> global___Sample.SampleType:
        """The type of sampling"""

    @property
    def seed(self) -> google.protobuf.wrappers_pb2.Int32Value:
        """The seed for random number generator, which is optional"""

    @property
    def sample_weight(self) -> expr_pb2.Variable:
        """The variable refer to the sample weight, which is optional"""

    def __init__(
        self,
        *,
        sample_type: global___Sample.SampleType | None = ...,
        seed: google.protobuf.wrappers_pb2.Int32Value | None = ...,
        sample_weight: expr_pb2.Variable | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "sample_type",
            b"sample_type",
            "sample_weight",
            b"sample_weight",
            "seed",
            b"seed",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "sample_type",
            b"sample_type",
            "sample_weight",
            b"sample_weight",
            "seed",
            b"seed",
        ],
    ) -> None: ...

global___Sample = Sample

@typing.final
class Sink(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class SinkTarget(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        SINK_DEFAULT_FIELD_NUMBER: builtins.int
        SINK_VINEYARD_FIELD_NUMBER: builtins.int
        @property
        def sink_default(self) -> global___SinkDefault: ...
        @property
        def sink_vineyard(self) -> global___SinkVineyard: ...
        def __init__(
            self,
            *,
            sink_default: global___SinkDefault | None = ...,
            sink_vineyard: global___SinkVineyard | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "inner",
                b"inner",
                "sink_default",
                b"sink_default",
                "sink_vineyard",
                b"sink_vineyard",
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "inner",
                b"inner",
                "sink_default",
                b"sink_default",
                "sink_vineyard",
                b"sink_vineyard",
            ],
        ) -> None: ...
        def WhichOneof(
            self, oneof_group: typing.Literal["inner", b"inner"]
        ) -> typing.Literal["sink_default", "sink_vineyard"] | None: ...

    TAGS_FIELD_NUMBER: builtins.int
    SINK_TARGET_FIELD_NUMBER: builtins.int
    @property
    def tags(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        expr_pb2.NameOrIdKey
    ]:
        """Define the tags of columns to sink. If no tags given, sink all **tagged** columns by default."""

    @property
    def sink_target(self) -> global___Sink.SinkTarget:
        """Define the target of sink, e.g., to Client as default, to Graph such as Vineyard etc."""

    def __init__(
        self,
        *,
        tags: collections.abc.Iterable[expr_pb2.NameOrIdKey] | None = ...,
        sink_target: global___Sink.SinkTarget | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["sink_target", b"sink_target"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["sink_target", b"sink_target", "tags", b"tags"]
    ) -> None: ...

global___Sink = Sink

@typing.final
class SinkDefault(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _MetaType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _MetaTypeEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            SinkDefault._MetaType.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        ENTITY: SinkDefault._MetaType.ValueType  # 0
        RELATION: SinkDefault._MetaType.ValueType  # 1
        COLUMN: SinkDefault._MetaType.ValueType  # 2
        TAG: SinkDefault._MetaType.ValueType  # 3

    class MetaType(_MetaType, metaclass=_MetaTypeEnumTypeWrapper): ...
    ENTITY: SinkDefault.MetaType.ValueType  # 0
    RELATION: SinkDefault.MetaType.ValueType  # 1
    COLUMN: SinkDefault.MetaType.ValueType  # 2
    TAG: SinkDefault.MetaType.ValueType  # 3

    @typing.final
    class IdNameMapping(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        NAME_FIELD_NUMBER: builtins.int
        META_TYPE_FIELD_NUMBER: builtins.int
        id: builtins.int
        name: builtins.str
        meta_type: global___SinkDefault.MetaType.ValueType
        def __init__(
            self,
            *,
            id: builtins.int = ...,
            name: builtins.str = ...,
            meta_type: global___SinkDefault.MetaType.ValueType = ...,
        ) -> None: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "id", b"id", "meta_type", b"meta_type", "name", b"name"
            ],
        ) -> None: ...

    ID_NAME_MAPPINGS_FIELD_NUMBER: builtins.int
    @property
    def id_name_mappings(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___SinkDefault.IdNameMapping
    ]:
        """The mapping of id to name given certain `MetaType`"""

    def __init__(
        self,
        *,
        id_name_mappings: (
            collections.abc.Iterable[global___SinkDefault.IdNameMapping] | None
        ) = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["id_name_mappings", b"id_name_mappings"]
    ) -> None: ...

global___SinkDefault = SinkDefault

@typing.final
class SinkVineyard(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GRAPH_NAME_FIELD_NUMBER: builtins.int
    GRAPH_SCHEMA_FIELD_NUMBER: builtins.int
    graph_name: builtins.str
    @property
    def graph_schema(self) -> schema_pb2.Schema: ...
    def __init__(
        self,
        *,
        graph_name: builtins.str = ...,
        graph_schema: schema_pb2.Schema | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["graph_schema", b"graph_schema"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "graph_name", b"graph_name", "graph_schema", b"graph_schema"
        ],
    ) -> None: ...

global___SinkVineyard = SinkVineyard

@typing.final
class Root(google.protobuf.message.Message):
    """A dummy node to delegate a source opr for multiple scan cases."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___Root = Root

@typing.final
class Branch(google.protobuf.message.Message):
    """A node for auxiliary suggesting branches when dealing with logical plan with nested branches"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___Branch = Branch

@typing.final
class LogicalPlan(google.protobuf.message.Message):
    """A logical plan of graph relation algebra forms a DAG, where each node is an operator and the
    edge indicates the execution flow.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class Operator(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        PROJECT_FIELD_NUMBER: builtins.int
        SELECT_FIELD_NUMBER: builtins.int
        JOIN_FIELD_NUMBER: builtins.int
        UNION_FIELD_NUMBER: builtins.int
        GROUP_BY_FIELD_NUMBER: builtins.int
        ORDER_BY_FIELD_NUMBER: builtins.int
        DEDUP_FIELD_NUMBER: builtins.int
        UNFOLD_FIELD_NUMBER: builtins.int
        APPLY_FIELD_NUMBER: builtins.int
        SEG_APPLY_FIELD_NUMBER: builtins.int
        SCAN_FIELD_NUMBER: builtins.int
        LIMIT_FIELD_NUMBER: builtins.int
        AS_FIELD_NUMBER: builtins.int
        INTERSECT_FIELD_NUMBER: builtins.int
        SINK_FIELD_NUMBER: builtins.int
        ROOT_FIELD_NUMBER: builtins.int
        SAMPLE_FIELD_NUMBER: builtins.int
        BRANCH_FIELD_NUMBER: builtins.int
        VERTEX_FIELD_NUMBER: builtins.int
        EDGE_FIELD_NUMBER: builtins.int
        PATH_FIELD_NUMBER: builtins.int
        PATTERN_FIELD_NUMBER: builtins.int
        @property
        def project(self) -> global___Project: ...
        @property
        def select(self) -> global___Select: ...
        @property
        def join(self) -> global___Join: ...
        @property
        def union(self) -> global___Union: ...
        @property
        def group_by(self) -> global___GroupBy: ...
        @property
        def order_by(self) -> global___OrderBy: ...
        @property
        def dedup(self) -> global___Dedup: ...
        @property
        def unfold(self) -> global___Unfold: ...
        @property
        def apply(self) -> global___Apply: ...
        @property
        def seg_apply(self) -> global___SegmentApply: ...
        @property
        def scan(self) -> global___Scan: ...
        @property
        def limit(self) -> global___Limit: ...
        @property
        def intersect(self) -> global___Intersect: ...
        @property
        def sink(self) -> global___Sink: ...
        @property
        def root(self) -> global___Root: ...
        @property
        def sample(self) -> global___Sample: ...
        @property
        def branch(self) -> global___Branch: ...
        @property
        def vertex(self) -> global___GetV:
            """Saving the room for relational operators"""

        @property
        def edge(self) -> global___EdgeExpand: ...
        @property
        def path(self) -> global___PathExpand: ...
        @property
        def pattern(self) -> global___Pattern: ...
        def __init__(
            self,
            *,
            project: global___Project | None = ...,
            select: global___Select | None = ...,
            join: global___Join | None = ...,
            union: global___Union | None = ...,
            group_by: global___GroupBy | None = ...,
            order_by: global___OrderBy | None = ...,
            dedup: global___Dedup | None = ...,
            unfold: global___Unfold | None = ...,
            apply: global___Apply | None = ...,
            seg_apply: global___SegmentApply | None = ...,
            scan: global___Scan | None = ...,
            limit: global___Limit | None = ...,
            intersect: global___Intersect | None = ...,
            sink: global___Sink | None = ...,
            root: global___Root | None = ...,
            sample: global___Sample | None = ...,
            branch: global___Branch | None = ...,
            vertex: global___GetV | None = ...,
            edge: global___EdgeExpand | None = ...,
            path: global___PathExpand | None = ...,
            pattern: global___Pattern | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "apply",
                b"apply",
                "as",
                b"as",
                "branch",
                b"branch",
                "dedup",
                b"dedup",
                "edge",
                b"edge",
                "group_by",
                b"group_by",
                "intersect",
                b"intersect",
                "join",
                b"join",
                "limit",
                b"limit",
                "opr",
                b"opr",
                "order_by",
                b"order_by",
                "path",
                b"path",
                "pattern",
                b"pattern",
                "project",
                b"project",
                "root",
                b"root",
                "sample",
                b"sample",
                "scan",
                b"scan",
                "seg_apply",
                b"seg_apply",
                "select",
                b"select",
                "sink",
                b"sink",
                "unfold",
                b"unfold",
                "union",
                b"union",
                "vertex",
                b"vertex",
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "apply",
                b"apply",
                "as",
                b"as",
                "branch",
                b"branch",
                "dedup",
                b"dedup",
                "edge",
                b"edge",
                "group_by",
                b"group_by",
                "intersect",
                b"intersect",
                "join",
                b"join",
                "limit",
                b"limit",
                "opr",
                b"opr",
                "order_by",
                b"order_by",
                "path",
                b"path",
                "pattern",
                b"pattern",
                "project",
                b"project",
                "root",
                b"root",
                "sample",
                b"sample",
                "scan",
                b"scan",
                "seg_apply",
                b"seg_apply",
                "select",
                b"select",
                "sink",
                b"sink",
                "unfold",
                b"unfold",
                "union",
                b"union",
                "vertex",
                b"vertex",
            ],
        ) -> None: ...
        def WhichOneof(self, oneof_group: typing.Literal["opr", b"opr"]) -> (
            typing.Literal[
                "project",
                "select",
                "join",
                "union",
                "group_by",
                "order_by",
                "dedup",
                "unfold",
                "apply",
                "seg_apply",
                "scan",
                "limit",
                "as",
                "intersect",
                "sink",
                "root",
                "sample",
                "branch",
                "vertex",
                "edge",
                "path",
                "pattern",
            ]
            | None
        ): ...

    @typing.final
    class Node(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        OPR_FIELD_NUMBER: builtins.int
        CHILDREN_FIELD_NUMBER: builtins.int
        @property
        def opr(self) -> global___LogicalPlan.Operator:
            """The node's operator"""

        @property
        def children(
            self,
        ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[
            builtins.int
        ]:
            """The children operators' identifiers, where the id refers to its array index in the plan"""

        def __init__(
            self,
            *,
            opr: global___LogicalPlan.Operator | None = ...,
            children: collections.abc.Iterable[builtins.int] | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["opr", b"opr"]
        ) -> builtins.bool: ...
        def ClearField(
            self, field_name: typing.Literal["children", b"children", "opr", b"opr"]
        ) -> None: ...

    NODES_FIELD_NUMBER: builtins.int
    ROOTS_FIELD_NUMBER: builtins.int
    @property
    def nodes(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___LogicalPlan.Node
    ]:
        """A array of nodes"""

    @property
    def roots(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """/ The root nodes' array indices"""

    def __init__(
        self,
        *,
        nodes: collections.abc.Iterable[global___LogicalPlan.Node] | None = ...,
        roots: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["nodes", b"nodes", "roots", b"roots"]
    ) -> None: ...

global___LogicalPlan = LogicalPlan
