"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
*
Copyright 2020 Alibaba Group Holding Limited.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import builtins
import collections.abc
import common_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import type_pb2
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _Logical:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _LogicalEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Logical.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EQ: _Logical.ValueType  # 0
    """A binary equality operator"""
    NE: _Logical.ValueType  # 1
    """A binary inequality operator"""
    LT: _Logical.ValueType  # 2
    """A binary less-than operator"""
    LE: _Logical.ValueType  # 3
    """A binary less-than-equal operator"""
    GT: _Logical.ValueType  # 4
    """A binary greater-than operator"""
    GE: _Logical.ValueType  # 5
    """A binary greater-than-equal operator"""
    WITHIN: _Logical.ValueType  # 6
    """A binary containment check operator, e.g 1 WITHIN [1, 2, 3, 4]"""
    WITHOUT: _Logical.ValueType  # 7
    """A binary not-containment check operator, e.g 5 WITHOUT [1, 2, 3, 4]"""
    STARTSWITH: _Logical.ValueType  # 8
    """A binary operator to verify whether a string is a prefix of another string"""
    ENDSWITH: _Logical.ValueType  # 9
    """A binary operator to verify whether a string is a suffix of another string"""
    AND: _Logical.ValueType  # 10
    """A binary logical and operator."""
    OR: _Logical.ValueType  # 11
    """A binary logical or operator."""
    NOT: _Logical.ValueType  # 12
    """A unary logical not operator."""
    ISNULL: _Logical.ValueType  # 13
    """A unary logical isnull operator"""
    REGEX: _Logical.ValueType  # 14
    """A binary operator to verify whether a string matches a regular expression"""

class Logical(_Logical, metaclass=_LogicalEnumTypeWrapper): ...

EQ: Logical.ValueType  # 0
"""A binary equality operator"""
NE: Logical.ValueType  # 1
"""A binary inequality operator"""
LT: Logical.ValueType  # 2
"""A binary less-than operator"""
LE: Logical.ValueType  # 3
"""A binary less-than-equal operator"""
GT: Logical.ValueType  # 4
"""A binary greater-than operator"""
GE: Logical.ValueType  # 5
"""A binary greater-than-equal operator"""
WITHIN: Logical.ValueType  # 6
"""A binary containment check operator, e.g 1 WITHIN [1, 2, 3, 4]"""
WITHOUT: Logical.ValueType  # 7
"""A binary not-containment check operator, e.g 5 WITHOUT [1, 2, 3, 4]"""
STARTSWITH: Logical.ValueType  # 8
"""A binary operator to verify whether a string is a prefix of another string"""
ENDSWITH: Logical.ValueType  # 9
"""A binary operator to verify whether a string is a suffix of another string"""
AND: Logical.ValueType  # 10
"""A binary logical and operator."""
OR: Logical.ValueType  # 11
"""A binary logical or operator."""
NOT: Logical.ValueType  # 12
"""A unary logical not operator."""
ISNULL: Logical.ValueType  # 13
"""A unary logical isnull operator"""
REGEX: Logical.ValueType  # 14
"""A binary operator to verify whether a string matches a regular expression"""
global___Logical = Logical

class _Arithmetic:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ArithmeticEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Arithmetic.ValueType],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ADD: _Arithmetic.ValueType  # 0
    """A binary addition operator"""
    SUB: _Arithmetic.ValueType  # 1
    """A binary subtraction operator"""
    MUL: _Arithmetic.ValueType  # 2
    """A binary multiplication operator"""
    DIV: _Arithmetic.ValueType  # 3
    """A binary division operator"""
    MOD: _Arithmetic.ValueType  # 4
    """A binary modulo operator"""
    EXP: _Arithmetic.ValueType  # 5
    """A binary exponentiation operator"""
    BITAND: _Arithmetic.ValueType  # 6
    """A binary bitwise and operator"""
    BITOR: _Arithmetic.ValueType  # 7
    """A binary bitwise or operator"""
    BITXOR: _Arithmetic.ValueType  # 8
    """A binary bitwise or operator"""
    BITLSHIFT: _Arithmetic.ValueType  # 9
    """A binary bitwise left-shift operator"""
    BITRSHIFT: _Arithmetic.ValueType  # 10
    """A binary bitwise right-shift operator"""

class Arithmetic(_Arithmetic, metaclass=_ArithmeticEnumTypeWrapper): ...

ADD: Arithmetic.ValueType  # 0
"""A binary addition operator"""
SUB: Arithmetic.ValueType  # 1
"""A binary subtraction operator"""
MUL: Arithmetic.ValueType  # 2
"""A binary multiplication operator"""
DIV: Arithmetic.ValueType  # 3
"""A binary division operator"""
MOD: Arithmetic.ValueType  # 4
"""A binary modulo operator"""
EXP: Arithmetic.ValueType  # 5
"""A binary exponentiation operator"""
BITAND: Arithmetic.ValueType  # 6
"""A binary bitwise and operator"""
BITOR: Arithmetic.ValueType  # 7
"""A binary bitwise or operator"""
BITXOR: Arithmetic.ValueType  # 8
"""A binary bitwise or operator"""
BITLSHIFT: Arithmetic.ValueType  # 9
"""A binary bitwise left-shift operator"""
BITRSHIFT: Arithmetic.ValueType  # 10
"""A binary bitwise right-shift operator"""
global___Arithmetic = Arithmetic

@typing.final
class IdKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___IdKey = IdKey

@typing.final
class LabelKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___LabelKey = LabelKey

@typing.final
class LengthKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___LengthKey = LengthKey

@typing.final
class AllKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___AllKey = AllKey

@typing.final
class NameOrIdKey(google.protobuf.message.Message):
    """Use `NameOrId` as key item, which is the same as `Option<NameOrId>`"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> common_pb2.NameOrId: ...
    def __init__(
        self,
        *,
        key: common_pb2.NameOrId | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key"]) -> None: ...

global___NameOrIdKey = NameOrIdKey

@typing.final
class Property(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    LEN_FIELD_NUMBER: builtins.int
    ALL_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> global___IdKey:
        """Get id from the entity"""

    @property
    def label(self) -> global___LabelKey:
        """Get label from the entity"""

    @property
    def len(self) -> global___LengthKey:
        """Get length from the entity"""

    @property
    def all(self) -> global___AllKey:
        """Get all properties"""

    @property
    def key(self) -> common_pb2.NameOrId:
        """Get property of key from the entity"""

    def __init__(
        self,
        *,
        id: global___IdKey | None = ...,
        label: global___LabelKey | None = ...,
        len: global___LengthKey | None = ...,
        all: global___AllKey | None = ...,
        key: common_pb2.NameOrId | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "all",
            b"all",
            "id",
            b"id",
            "item",
            b"item",
            "key",
            b"key",
            "label",
            b"label",
            "len",
            b"len",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "all",
            b"all",
            "id",
            b"id",
            "item",
            b"item",
            "key",
            b"key",
            "label",
            b"label",
            "len",
            b"len",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["item", b"item"]
    ) -> typing.Literal["id", "label", "len", "all", "key"] | None: ...

global___Property = Property

@typing.final
class Variable(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAG_FIELD_NUMBER: builtins.int
    PROPERTY_FIELD_NUMBER: builtins.int
    NODE_TYPE_FIELD_NUMBER: builtins.int
    @property
    def tag(self) -> common_pb2.NameOrId:
        """The alias of a graph relation, which is required for a variable"""

    @property
    def property(self) -> global___Property:
        """The property of a nested attribute (vertex/edge) of a graph relation, r.a.key, optional"""

    @property
    def node_type(self) -> type_pb2.IrDataType:
        """The data of type of Property"""

    def __init__(
        self,
        *,
        tag: common_pb2.NameOrId | None = ...,
        property: global___Property | None = ...,
        node_type: type_pb2.IrDataType | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "node_type", b"node_type", "property", b"property", "tag", b"tag"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "node_type", b"node_type", "property", b"property", "tag", b"tag"
        ],
    ) -> None: ...

global___Variable = Variable

@typing.final
class PathFunction(google.protobuf.message.Message):
    """Path function to rechieve properties of each vertex or edge (or both) in a path.
    e.g., project `a.name`, `a.[name, age]`, or `a.{name, age}`, where `a` refers to a path
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _FuncOpt:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _FuncOptEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            PathFunction._FuncOpt.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERTEX: PathFunction._FuncOpt.ValueType  # 0
        EDGE: PathFunction._FuncOpt.ValueType  # 1
        VERTEX_EDGE: PathFunction._FuncOpt.ValueType  # 2

    class FuncOpt(_FuncOpt, metaclass=_FuncOptEnumTypeWrapper):
        """the option of PathFunction, e.g., rechieve the properties of each vertex, edge, or both, in a path"""

    VERTEX: PathFunction.FuncOpt.ValueType  # 0
    EDGE: PathFunction.FuncOpt.ValueType  # 1
    VERTEX_EDGE: PathFunction.FuncOpt.ValueType  # 2

    @typing.final
    class PathElementKeys(google.protobuf.message.Message):
        """rechieve properties from a path to a list"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEYS_FIELD_NUMBER: builtins.int
        @property
        def keys(
            self,
        ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
            global___Property
        ]: ...
        def __init__(
            self,
            *,
            keys: collections.abc.Iterable[global___Property] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

    @typing.final
    class PathElementKeyValues(google.protobuf.message.Message):
        """rechieve properties from a path to a map"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing.final
        class PathElementKeyValue(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            KEY_FIELD_NUMBER: builtins.int
            VAL_FIELD_NUMBER: builtins.int
            @property
            def key(self) -> common_pb2.Value: ...
            @property
            def val(self) -> global___Property: ...
            def __init__(
                self,
                *,
                key: common_pb2.Value | None = ...,
                val: global___Property | None = ...,
            ) -> None: ...
            def HasField(
                self, field_name: typing.Literal["key", b"key", "val", b"val"]
            ) -> builtins.bool: ...
            def ClearField(
                self, field_name: typing.Literal["key", b"key", "val", b"val"]
            ) -> None: ...

        KEY_VALS_FIELD_NUMBER: builtins.int
        @property
        def key_vals(
            self,
        ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
            global___PathFunction.PathElementKeyValues.PathElementKeyValue
        ]: ...
        def __init__(
            self,
            *,
            key_vals: (
                collections.abc.Iterable[
                    global___PathFunction.PathElementKeyValues.PathElementKeyValue
                ]
                | None
            ) = ...,
        ) -> None: ...
        def ClearField(
            self, field_name: typing.Literal["key_vals", b"key_vals"]
        ) -> None: ...

    TAG_FIELD_NUMBER: builtins.int
    PROPERTY_FIELD_NUMBER: builtins.int
    VARS_FIELD_NUMBER: builtins.int
    MAP_FIELD_NUMBER: builtins.int
    OPT_FIELD_NUMBER: builtins.int
    NODE_TYPE_FIELD_NUMBER: builtins.int
    opt: global___PathFunction.FuncOpt.ValueType
    @property
    def tag(self) -> common_pb2.NameOrId:
        """The alias of a graph path"""

    @property
    def property(self) -> global___Property:
        """e.g., project name, and return the property of each entry in the path,
        and return [marko, josh]
        """

    @property
    def vars(self) -> global___PathFunction.PathElementKeys:
        """e.g., project [name, age] to a list of properties of each entry in the path,
        and [[marko, 29], [josh, 27]]
        """

    @property
    def map(self) -> global___PathFunction.PathElementKeyValues:
        """e.g., project {name, age} to a map of properties of each entry in the path,
        and return [{name: marko, age: 29}, {name: josh, age: 27}]
        """

    @property
    def node_type(self) -> type_pb2.IrDataType: ...
    def __init__(
        self,
        *,
        tag: common_pb2.NameOrId | None = ...,
        property: global___Property | None = ...,
        vars: global___PathFunction.PathElementKeys | None = ...,
        map: global___PathFunction.PathElementKeyValues | None = ...,
        opt: global___PathFunction.FuncOpt.ValueType = ...,
        node_type: type_pb2.IrDataType | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "map",
            b"map",
            "node_type",
            b"node_type",
            "path_key",
            b"path_key",
            "property",
            b"property",
            "tag",
            b"tag",
            "vars",
            b"vars",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "map",
            b"map",
            "node_type",
            b"node_type",
            "opt",
            b"opt",
            "path_key",
            b"path_key",
            "property",
            b"property",
            "tag",
            b"tag",
            "vars",
            b"vars",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["path_key", b"path_key"]
    ) -> typing.Literal["property", "vars", "map"] | None: ...

global___PathFunction = PathFunction

@typing.final
class VariableKeys(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEYS_FIELD_NUMBER: builtins.int
    @property
    def keys(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Variable
    ]: ...
    def __init__(
        self,
        *,
        keys: collections.abc.Iterable[global___Variable] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["keys", b"keys"]) -> None: ...

global___VariableKeys = VariableKeys

@typing.final
class VariableKeyValue(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    VAL_FIELD_NUMBER: builtins.int
    PATH_FUNC_FIELD_NUMBER: builtins.int
    NESTED_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> common_pb2.Value: ...
    @property
    def val(self) -> global___Variable: ...
    @property
    def path_func(self) -> global___PathFunction: ...
    @property
    def nested(self) -> global___VariableKeyValues: ...
    def __init__(
        self,
        *,
        key: common_pb2.Value | None = ...,
        val: global___Variable | None = ...,
        path_func: global___PathFunction | None = ...,
        nested: global___VariableKeyValues | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "key",
            b"key",
            "nested",
            b"nested",
            "path_func",
            b"path_func",
            "val",
            b"val",
            "value",
            b"value",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "key",
            b"key",
            "nested",
            b"nested",
            "path_func",
            b"path_func",
            "val",
            b"val",
            "value",
            b"value",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["value", b"value"]
    ) -> typing.Literal["val", "path_func", "nested"] | None: ...

global___VariableKeyValue = VariableKeyValue

@typing.final
class VariableKeyValues(google.protobuf.message.Message):
    """A nested kv projection, which is used to project a nested structure of key-value pairs
    e.g., for a single kv projection,
    to project [VariableKeyValue('name', a.name), VariableKeyValue('age', a.age)], where `a` refers to a vertex,
    it outputs a map of {'name': 'marko', 'age': 27};
    or to project [VariableKeyValue('tagP', PathFunction{tag: a, path_key: PathElementKeys{keys: [name, age]}})], where `a` refers to a path (with two vertices in it),
    it outputs a map of {'tagP': [{'name': 'marko', 'age': 27}, {'name': 'josh', 'age', 29}]}.
    For a more complex nested projection,
    to project [VariableKeyValue('tagA', nested{[VariableKeyValue('name', a.name), VariableKeyValue('age', a.age)]}),
                VariableKeyValue('tagP', nested{[VariableKeyValue('name', p.name), VariableKeyValue('age', p.age)]})],
    where `a` refers to a vertex, and `p` refers to a path (with two vertices in it),
    it outputs a map of {'tagA': {'name': 'marko', 'age': 27}, 'tagP': [{'name': 'marko', 'age': 27}, {'name': 'josh', 'age', 29}]}.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_VALS_FIELD_NUMBER: builtins.int
    @property
    def key_vals(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___VariableKeyValue
    ]: ...
    def __init__(
        self,
        *,
        key_vals: collections.abc.Iterable[global___VariableKeyValue] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["key_vals", b"key_vals"]
    ) -> None: ...

global___VariableKeyValues = VariableKeyValues

@typing.final
class DynamicParam(google.protobuf.message.Message):
    """dynamic param"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    DATA_TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    index: builtins.int
    @property
    def data_type(self) -> type_pb2.IrDataType: ...
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        index: builtins.int = ...,
        data_type: type_pb2.IrDataType | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["data_type", b"data_type"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "data_type", b"data_type", "index", b"index", "name", b"name"
        ],
    ) -> None: ...

global___DynamicParam = DynamicParam

@typing.final
class Case(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class WhenThen(google.protobuf.message.Message):
        """Pair of when <expr> then <expr>"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        WHEN_EXPRESSION_FIELD_NUMBER: builtins.int
        THEN_RESULT_EXPRESSION_FIELD_NUMBER: builtins.int
        @property
        def when_expression(self) -> global___Expression: ...
        @property
        def then_result_expression(self) -> global___Expression: ...
        def __init__(
            self,
            *,
            when_expression: global___Expression | None = ...,
            then_result_expression: global___Expression | None = ...,
        ) -> None: ...
        def HasField(
            self,
            field_name: typing.Literal[
                "then_result_expression",
                b"then_result_expression",
                "when_expression",
                b"when_expression",
            ],
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "then_result_expression",
                b"then_result_expression",
                "when_expression",
                b"when_expression",
            ],
        ) -> None: ...

    WHEN_THEN_EXPRESSIONS_FIELD_NUMBER: builtins.int
    ELSE_RESULT_EXPRESSION_FIELD_NUMBER: builtins.int
    @property
    def when_then_expressions(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Case.WhenThen
    ]:
        """A case operator always follows with a sequence of when_then pairs, e.g.
        CASE WHEN a.name == 'Marko' THEN 1
             WHEN a.name == 'John' THEN 2
        """

    @property
    def else_result_expression(self) -> global___Expression:
        """The trailed else expression:  ELSE 3"""

    def __init__(
        self,
        *,
        when_then_expressions: (
            collections.abc.Iterable[global___Case.WhenThen] | None
        ) = ...,
        else_result_expression: global___Expression | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal["else_result_expression", b"else_result_expression"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "else_result_expression",
            b"else_result_expression",
            "when_then_expressions",
            b"when_then_expressions",
        ],
    ) -> None: ...

global___Case = Case

@typing.final
class Extract(google.protobuf.message.Message):
    """extract interval from a given expression which should be of temporal type"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Interval:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _IntervalEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            Extract._Interval.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        YEAR: Extract._Interval.ValueType  # 0
        MONTH: Extract._Interval.ValueType  # 1
        DAY: Extract._Interval.ValueType  # 2
        HOUR: Extract._Interval.ValueType  # 3
        MINUTE: Extract._Interval.ValueType  # 4
        SECOND: Extract._Interval.ValueType  # 5
        MILLISECOND: Extract._Interval.ValueType  # 6

    class Interval(_Interval, metaclass=_IntervalEnumTypeWrapper): ...
    YEAR: Extract.Interval.ValueType  # 0
    MONTH: Extract.Interval.ValueType  # 1
    DAY: Extract.Interval.ValueType  # 2
    HOUR: Extract.Interval.ValueType  # 3
    MINUTE: Extract.Interval.ValueType  # 4
    SECOND: Extract.Interval.ValueType  # 5
    MILLISECOND: Extract.Interval.ValueType  # 6

    INTERVAL_FIELD_NUMBER: builtins.int
    interval: global___Extract.Interval.ValueType
    def __init__(
        self,
        *,
        interval: global___Extract.Interval.ValueType = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["interval", b"interval"]
    ) -> None: ...

global___Extract = Extract

@typing.final
class TimeInterval(google.protobuf.message.Message):
    """denote time interval, i.e. 3 DAYS, 4 HOURS, 5 MINUTES"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INTERVAL_FIELD_NUMBER: builtins.int
    CONST_FIELD_NUMBER: builtins.int
    PARAM_FIELD_NUMBER: builtins.int
    interval: global___Extract.Interval.ValueType
    @property
    def const(self) -> common_pb2.Value: ...
    @property
    def param(self) -> global___DynamicParam: ...
    def __init__(
        self,
        *,
        interval: global___Extract.Interval.ValueType = ...,
        const: common_pb2.Value | None = ...,
        param: global___DynamicParam | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "const", b"const", "param", b"param", "value", b"value"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "const",
            b"const",
            "interval",
            b"interval",
            "param",
            b"param",
            "value",
            b"value",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["value", b"value"]
    ) -> typing.Literal["const", "param"] | None: ...

global___TimeInterval = TimeInterval

@typing.final
class DateTimeMinus(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INTERVAL_FIELD_NUMBER: builtins.int
    interval: global___Extract.Interval.ValueType
    def __init__(
        self,
        *,
        interval: global___Extract.Interval.ValueType = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["interval", b"interval"]
    ) -> None: ...

global___DateTimeMinus = DateTimeMinus

@typing.final
class PathConcat(google.protobuf.message.Message):
    """e.g., supposing p1 refers to path[v1->v2->v3], p2 refers to path[v5->v4->v3],
    then PathCONCAT((p1, END), (p2, END))) outputs [v1->v2->v3->v4->v5]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Endpoint:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _EndpointEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            PathConcat._Endpoint.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        START: PathConcat._Endpoint.ValueType  # 0
        END: PathConcat._Endpoint.ValueType  # 1

    class Endpoint(_Endpoint, metaclass=_EndpointEnumTypeWrapper):
        """Enum that defines the endpoint of a path where the concatenation will occur."""

    START: PathConcat.Endpoint.ValueType  # 0
    END: PathConcat.Endpoint.ValueType  # 1

    @typing.final
    class ConcatPathInfo(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        PATH_TAG_FIELD_NUMBER: builtins.int
        ENDPOINT_FIELD_NUMBER: builtins.int
        endpoint: global___PathConcat.Endpoint.ValueType
        @property
        def path_tag(self) -> global___Variable: ...
        def __init__(
            self,
            *,
            path_tag: global___Variable | None = ...,
            endpoint: global___PathConcat.Endpoint.ValueType = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing.Literal["path_tag", b"path_tag"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing.Literal[
                "endpoint", b"endpoint", "path_tag", b"path_tag"
            ],
        ) -> None: ...

    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    @property
    def left(self) -> global___PathConcat.ConcatPathInfo: ...
    @property
    def right(self) -> global___PathConcat.ConcatPathInfo: ...
    def __init__(
        self,
        *,
        left: global___PathConcat.ConcatPathInfo | None = ...,
        right: global___PathConcat.ConcatPathInfo | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["left", b"left", "right", b"right"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["left", b"left", "right", b"right"]
    ) -> None: ...

global___PathConcat = PathConcat

@typing.final
class UserDefinedFunction(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    name: builtins.str
    @property
    def parameters(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___Expression
    ]: ...
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        parameters: collections.abc.Iterable[global___Expression] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["name", b"name", "parameters", b"parameters"]
    ) -> None: ...

global___UserDefinedFunction = UserDefinedFunction

@typing.final
class ToDate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATE_STR_FIELD_NUMBER: builtins.int
    date_str: builtins.str
    def __init__(
        self,
        *,
        date_str: builtins.str = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["date_str", b"date_str"]
    ) -> None: ...

global___ToDate = ToDate

@typing.final
class ToDatetime(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATETIME_STR_FIELD_NUMBER: builtins.int
    datetime_str: builtins.str
    def __init__(
        self,
        *,
        datetime_str: builtins.str = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["datetime_str", b"datetime_str"]
    ) -> None: ...

global___ToDatetime = ToDatetime

@typing.final
class ToInterval(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INTERVAL_STR_FIELD_NUMBER: builtins.int
    interval_str: builtins.str
    def __init__(
        self,
        *,
        interval_str: builtins.str = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["interval_str", b"interval_str"]
    ) -> None: ...

global___ToInterval = ToInterval

@typing.final
class ExprOpr(google.protobuf.message.Message):
    """An operator of expression is one of Logical, Arithmetic, Const and Variable."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Brace:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _BraceEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
            ExprOpr._Brace.ValueType
        ],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        LEFT_BRACE: ExprOpr._Brace.ValueType  # 0
        """("""
        RIGHT_BRACE: ExprOpr._Brace.ValueType  # 1
        """)"""

    class Brace(_Brace, metaclass=_BraceEnumTypeWrapper): ...
    LEFT_BRACE: ExprOpr.Brace.ValueType  # 0
    """("""
    RIGHT_BRACE: ExprOpr.Brace.ValueType  # 1
    """)"""

    LOGICAL_FIELD_NUMBER: builtins.int
    ARITH_FIELD_NUMBER: builtins.int
    CONST_FIELD_NUMBER: builtins.int
    VAR_FIELD_NUMBER: builtins.int
    BRACE_FIELD_NUMBER: builtins.int
    VARS_FIELD_NUMBER: builtins.int
    VAR_MAP_FIELD_NUMBER: builtins.int
    PARAM_FIELD_NUMBER: builtins.int
    CASE_FIELD_NUMBER: builtins.int
    EXTRACT_FIELD_NUMBER: builtins.int
    MAP_FIELD_NUMBER: builtins.int
    TIME_INTERVAL_FIELD_NUMBER: builtins.int
    DATE_TIME_MINUS_FIELD_NUMBER: builtins.int
    PATH_CONCAT_FIELD_NUMBER: builtins.int
    PATH_FUNC_FIELD_NUMBER: builtins.int
    UDF_FUNC_FIELD_NUMBER: builtins.int
    TO_DATE_FIELD_NUMBER: builtins.int
    TO_DATETIME_FIELD_NUMBER: builtins.int
    TO_INTERVAL_FIELD_NUMBER: builtins.int
    NODE_TYPE_FIELD_NUMBER: builtins.int
    logical: global___Logical.ValueType
    arith: global___Arithmetic.ValueType
    brace: global___ExprOpr.Brace.ValueType
    @property
    def const(self) -> common_pb2.Value: ...
    @property
    def var(self) -> global___Variable: ...
    @property
    def vars(self) -> global___VariableKeys: ...
    @property
    def var_map(self) -> global___VariableKeys: ...
    @property
    def param(self) -> global___DynamicParam:
        """dynamic param in expression"""

    @property
    def case(self) -> global___Case: ...
    @property
    def extract(self) -> global___Extract: ...
    @property
    def map(self) -> global___VariableKeyValues:
        """TODO: the new definition for var_map, that allows user-given key name, and nested maps. Will remove the old var_map finally."""

    @property
    def time_interval(self) -> global___TimeInterval: ...
    @property
    def date_time_minus(self) -> global___DateTimeMinus: ...
    @property
    def path_concat(self) -> global___PathConcat: ...
    @property
    def path_func(self) -> global___PathFunction: ...
    @property
    def udf_func(self) -> global___UserDefinedFunction: ...
    @property
    def to_date(self) -> global___ToDate: ...
    @property
    def to_datetime(self) -> global___ToDatetime: ...
    @property
    def to_interval(self) -> global___ToInterval: ...
    @property
    def node_type(self) -> type_pb2.IrDataType:
        """The data of type of ExprOpr"""

    def __init__(
        self,
        *,
        logical: global___Logical.ValueType = ...,
        arith: global___Arithmetic.ValueType = ...,
        const: common_pb2.Value | None = ...,
        var: global___Variable | None = ...,
        brace: global___ExprOpr.Brace.ValueType = ...,
        vars: global___VariableKeys | None = ...,
        var_map: global___VariableKeys | None = ...,
        param: global___DynamicParam | None = ...,
        case: global___Case | None = ...,
        extract: global___Extract | None = ...,
        map: global___VariableKeyValues | None = ...,
        time_interval: global___TimeInterval | None = ...,
        date_time_minus: global___DateTimeMinus | None = ...,
        path_concat: global___PathConcat | None = ...,
        path_func: global___PathFunction | None = ...,
        udf_func: global___UserDefinedFunction | None = ...,
        to_date: global___ToDate | None = ...,
        to_datetime: global___ToDatetime | None = ...,
        to_interval: global___ToInterval | None = ...,
        node_type: type_pb2.IrDataType | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "arith",
            b"arith",
            "brace",
            b"brace",
            "case",
            b"case",
            "const",
            b"const",
            "date_time_minus",
            b"date_time_minus",
            "extract",
            b"extract",
            "item",
            b"item",
            "logical",
            b"logical",
            "map",
            b"map",
            "node_type",
            b"node_type",
            "param",
            b"param",
            "path_concat",
            b"path_concat",
            "path_func",
            b"path_func",
            "time_interval",
            b"time_interval",
            "to_date",
            b"to_date",
            "to_datetime",
            b"to_datetime",
            "to_interval",
            b"to_interval",
            "udf_func",
            b"udf_func",
            "var",
            b"var",
            "var_map",
            b"var_map",
            "vars",
            b"vars",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "arith",
            b"arith",
            "brace",
            b"brace",
            "case",
            b"case",
            "const",
            b"const",
            "date_time_minus",
            b"date_time_minus",
            "extract",
            b"extract",
            "item",
            b"item",
            "logical",
            b"logical",
            "map",
            b"map",
            "node_type",
            b"node_type",
            "param",
            b"param",
            "path_concat",
            b"path_concat",
            "path_func",
            b"path_func",
            "time_interval",
            b"time_interval",
            "to_date",
            b"to_date",
            "to_datetime",
            b"to_datetime",
            "to_interval",
            b"to_interval",
            "udf_func",
            b"udf_func",
            "var",
            b"var",
            "var_map",
            b"var_map",
            "vars",
            b"vars",
        ],
    ) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["item", b"item"]) -> (
        typing.Literal[
            "logical",
            "arith",
            "const",
            "var",
            "brace",
            "vars",
            "var_map",
            "param",
            "case",
            "extract",
            "map",
            "time_interval",
            "date_time_minus",
            "path_concat",
            "path_func",
            "udf_func",
            "to_date",
            "to_datetime",
            "to_interval",
        ]
        | None
    ): ...

global___ExprOpr = ExprOpr

@typing.final
class Expression(google.protobuf.message.Message):
    """An inner representation of an expression"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OPERATORS_FIELD_NUMBER: builtins.int
    @property
    def operators(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___ExprOpr
    ]: ...
    def __init__(
        self,
        *,
        operators: collections.abc.Iterable[global___ExprOpr] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["operators", b"operators"]
    ) -> None: ...

global___Expression = Expression
