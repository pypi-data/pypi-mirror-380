"""
A utility script for managing epymorph.data.* export code.
Packages like epymorph.data.ipm define a set of built-in model implementations.
As a matter of convenience, it's nice to have these classes exported by the __init__
of the package. However it's likely we will forget to update the __init__ files
when adding new models, so this script exists to 1) check that the __init__ contains
all of and only the expected exports, and 2) generate the file in a uniform way.
This will be included in our CI/CD checks.
"""

from argparse import ArgumentParser
from importlib import import_module
from importlib.resources import files
from inspect import isclass
from pathlib import Path
from typing import NamedTuple

from epymorph.compartment_model import CompartmentModel
from epymorph.movement_model import MovementModel


class Package(NamedTuple):
    package: str
    model_type: type
    description: str


_PACKAGES: list[Package] = [
    Package(
        "epymorph.data.ipm",
        CompartmentModel,
        "epymorph's collection of built-in compartment models.",
    ),
    Package(
        "epymorph.data.mm",
        MovementModel,
        "epymorph's collection of built-in movement models.",
    ),
]


def discover_classes(package: str, extends: type) -> list[type]:
    """Find all classes in `package` which are subclasses of the type `extends`."""
    modules = [
        import_module(f"{package}.{f.name.removesuffix('.py')}")
        for f in files(package).iterdir()
        if f.name != "__init__.py" and f.name.endswith(".py")
    ]
    classes = [
        value
        for mod in modules
        for value in mod.__dict__.values()
        if isclass(value)
        and value.__module__ == mod.__name__
        and issubclass(value, extends)
    ]
    return sorted(classes, key=lambda x: x.__name__)


def check_imports(packages: list[Package], quiet: bool) -> int:
    """Check that the __init__ file of the package has the correct exports."""
    p = print if not quiet else lambda _: _
    exit_code = 0

    for package, extends, _ in packages:
        p(f"Checking '{package}'...")
        try:
            classes = discover_classes(package, extends)
            class_names = [c.__name__ for c in classes]

            init = import_module(f"{package}.__init__")
            exports = init.__dict__.get("__all__", [])

            for c in classes:
                if c.__name__ not in exports:
                    exit_code = 1
                    fullname = f"{c.__module__}.{c.__name__}"
                    p(f"- Class '{fullname}' not included in exports.")

            for e in exports:
                if e not in class_names:
                    exit_code = 1
                    p(f"- Unknown entry '{e}' included in exports.")
        except ModuleNotFoundError:
            exit_code = 1
            p(f"- __init__.py not found in package '{package}'.")

    if exit_code == 0:
        p("All good!")
    else:
        p("Detected some issues, see above.")
    return exit_code


def generate_imports(packages: list[Package], quiet: bool) -> int:
    p = print if not quiet else lambda _: _
    exit_code = 0

    for package, extends, description in packages:
        classes = discover_classes(package, extends)

        init_lines = [
            f'"""{description}"""',
            "",
            *(f"from {c.__module__} import {c.__name__}" for c in classes),
            "",
            "### WARNING ##########################################",
            "# This file is generated by the data_exports script. #",
            "# Manual changes to this file will be lost.          #",
            "######################################################",
            "",
            "__all__ = [",
            *(f'    "{c.__name__}",' for c in classes),
            "]",
        ]

        path = Path(*package.split("."), "__init__.py")
        with path.open("w") as f:
            f.write("\n".join(init_lines) + "\n")

        p(f"Generated {path}")

    return exit_code


def _define_argparser() -> ArgumentParser:
    parser = ArgumentParser(description="Manage epymorph.data.* exports code.")
    arg = parser.add_mutually_exclusive_group().add_argument
    arg("-c", "--check", action="store_true", help="check data exports")
    arg("-g", "--generate", action="store_true", help="generate data exports")
    parser.add_argument("-q", "--quiet", action="store_true", help="suppress output")
    return parser


def main() -> None:
    args = _define_argparser().parse_args()
    if args.generate:
        exit_code = generate_imports(_PACKAGES, args.quiet)
    else:
        exit_code = check_imports(_PACKAGES, args.quiet)
    exit(exit_code)


if __name__ == "__main__":
    main()
