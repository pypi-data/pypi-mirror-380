"""Authentication handling for Frank Energie integration."""
# python_frank_energie/authentication.py

import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Optional

import jwt

from .exceptions import AuthException

_LOGGER: logging.Logger = logging.getLogger(__name__)


@dataclass
class Authentication:
    """Authentication data generated by the login or renewToken mutation.

    Attributes:
        authToken: The token to use for authenticated requests.
        refreshToken: The token to use to renew the authToken.
    """

    authToken: str
    refreshToken: str

    @staticmethod
    def from_dict(data: dict[str, str]) -> 'Authentication':
        """Parse the response from the login or renewToken mutation.

        Args:
            data: The response dictionary containing token information.

        Raises:
            AuthException: If the response contains errors or is malformed.

        Returns:
            An Authentication instance with tokens.
        """
        _LOGGER.debug("Authentication response: %s", data)

        if errors := data.get("errors"):
            raise AuthException(errors[0].get("message", "Unknown authentication error"))

        payload = Authentication._extract_payload(data)

        if not payload or "authToken" not in payload or "refreshToken" not in payload:
            raise AuthException("Unexpected response: Missing or incomplete payload")

        return Authentication(
            authToken=payload["authToken"],
            refreshToken=payload["refreshToken"]
        )

    @staticmethod
    def _extract_payload(data: dict) -> Optional[dict]:
        """Extract the login or renewToken payload from the response.

        Args:
            data: The full GraphQL response.

        Returns:
            The payload dict if present.
        """
        return data.get("data", {}).get("login") or data.get("data", {}).get("renewToken")

    def auth_token_valid(self, tz: timezone = timezone.utc) -> bool:
        """Check if authToken is still valid according to the expiration timestamp.

        Args:
            tz: The timezone to compare against. Defaults to UTC.

        Returns:
            True if the token has not expired; otherwise, False.
        """
        try:
            decoded = jwt.decode(
                self.authToken,
                algorithms=["HS256"],
                options={"verify_signature": False}
            )
        except jwt.DecodeError as err:
            _LOGGER.warning("Failed to decode authToken: %s", err)
            return False
        except Exception as err:
            _LOGGER.error("Unexpected error decoding authToken: %s", err)
            return False

        expiry = decoded.get("exp")
        if not expiry:
            _LOGGER.warning("Token does not contain 'exp' field")
            return False

        return datetime.fromtimestamp(expiry, tz=timezone.utc) > datetime.now(tz=tz)

    def __repr__(self) -> str:
        return "Authentication(authToken=***, refreshToken=***)"


@dataclass
class AuthenticationResult:
    """Class to hold authentication result after login or refresh.

    Attributes:
        authToken: The current valid auth token.
        refreshToken: The token used to refresh the auth token.
    """
    authToken: str
    refreshToken: str
