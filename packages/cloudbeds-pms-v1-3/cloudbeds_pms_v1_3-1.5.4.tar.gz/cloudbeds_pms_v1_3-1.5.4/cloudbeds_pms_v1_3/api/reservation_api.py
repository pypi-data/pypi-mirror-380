# coding: utf-8

"""
    Cloudbeds API

    <p>     Welcome to the documentation for <strong>Cloudbeds API Version v1.3</strong>!     If you are looking to learn how to use the Cloudbeds API to access guest information, reservations, or similar data     for your Cloudbeds customers, then you've come to the right place. </p>  <p>     In this document you will find all the API methods we provide along with explanations for parameters and response     examples. </p>  <p>     If you have questions about different implementation steps (e.g. how to implement OAuth 2.0), please refer to our     <a href=\"https://integrations.cloudbeds.com/hc/en-us\">Integrations Portal</a>. </p>  <p>     Be sure to <a href=\"https://go.pardot.com/l/308041/2018-07-24/qb2lg\">subscribe</a> to the monthly     Cloudbeds API announcement mailing list to receive information on new additions and improvements to the     Cloudbeds API and related developer tools. </p>  <p>     <strong>Endpoint:</strong> https://api.cloudbeds.com/api/v1.3/{method} </p>  <p>     <strong>HTTPS:</strong> Our API requires HTTPS. We'll respond with an appropriate error if you're not using it. </p>  <p>     <strong>Request Format:</strong> HTTP GET, POST and PUT (Content-Type: application/x-www-form-urlencoded) </p>  <p>     <strong>Response Format:</strong> JSON </p>  <p>     <strong>Response Header:</strong> X-Request-ID is added to response headers in all calls to help accelerate support     and troubleshooting. </p>  <p>     <strong>         <a href=\"https://integrations.cloudbeds.com/hc/en-us/articles/14104678058267-API-Documentation#postman-collection\">             <img src=\"https://run.pstmn.io/button.svg\" alt=\"Run in Postman\">         </a>     </strong> use this link to access our Public collection in Postman. </p>

    The version of the OpenAPI document: v1.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date, datetime
from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr, field_validator
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated
from cloudbeds_pms_v1_3.models.delete_reservation_note_response import DeleteReservationNoteResponse
from cloudbeds_pms_v1_3.models.get_reservation_assignments_response import GetReservationAssignmentsResponse
from cloudbeds_pms_v1_3.models.get_reservation_notes_response import GetReservationNotesResponse
from cloudbeds_pms_v1_3.models.get_reservation_response import GetReservationResponse
from cloudbeds_pms_v1_3.models.get_reservations_response import GetReservationsResponse
from cloudbeds_pms_v1_3.models.get_reservations_with_rate_details_response import GetReservationsWithRateDetailsResponse
from cloudbeds_pms_v1_3.models.get_sources_response import GetSourcesResponse
from cloudbeds_pms_v1_3.models.post_reservation_document_response import PostReservationDocumentResponse
from cloudbeds_pms_v1_3.models.post_reservation_note_response import PostReservationNoteResponse
from cloudbeds_pms_v1_3.models.post_reservation_request_adults_inner import PostReservationRequestAdultsInner
from cloudbeds_pms_v1_3.models.post_reservation_request_children_inner import PostReservationRequestChildrenInner
from cloudbeds_pms_v1_3.models.post_reservation_request_custom_fields_inner import PostReservationRequestCustomFieldsInner
from cloudbeds_pms_v1_3.models.post_reservation_request_rooms_inner import PostReservationRequestRoomsInner
from cloudbeds_pms_v1_3.models.post_reservation_response import PostReservationResponse
from cloudbeds_pms_v1_3.models.put_reservation_note_response import PutReservationNoteResponse
from cloudbeds_pms_v1_3.models.put_reservation_request_custom_fields_inner import PutReservationRequestCustomFieldsInner
from cloudbeds_pms_v1_3.models.put_reservation_request_rooms_inner import PutReservationRequestRoomsInner
from cloudbeds_pms_v1_3.models.put_reservation_response import PutReservationResponse

from cloudbeds_pms_v1_3.api_client import ApiClient, RequestSerialized
from cloudbeds_pms_v1_3.api_response import ApiResponse
from cloudbeds_pms_v1_3.rest import RESTResponseType


class ReservationApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def delete_reservation_note_delete(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier")],
        reservation_note_id: Annotated[StrictStr, Field(description="Reservation Note ID")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeleteReservationNoteResponse:
        """deleteReservationNote

        Archives an existing reservation note.

        :param reservation_id: Reservation Unique Identifier (required)
        :type reservation_id: str
        :param reservation_note_id: Reservation Note ID (required)
        :type reservation_note_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_reservation_note_delete_serialize(
            reservation_id=reservation_id,
            reservation_note_id=reservation_note_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_reservation_note_delete_with_http_info(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier")],
        reservation_note_id: Annotated[StrictStr, Field(description="Reservation Note ID")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeleteReservationNoteResponse]:
        """deleteReservationNote

        Archives an existing reservation note.

        :param reservation_id: Reservation Unique Identifier (required)
        :type reservation_id: str
        :param reservation_note_id: Reservation Note ID (required)
        :type reservation_note_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_reservation_note_delete_serialize(
            reservation_id=reservation_id,
            reservation_note_id=reservation_note_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_reservation_note_delete_without_preload_content(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier")],
        reservation_note_id: Annotated[StrictStr, Field(description="Reservation Note ID")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """deleteReservationNote

        Archives an existing reservation note.

        :param reservation_id: Reservation Unique Identifier (required)
        :type reservation_id: str
        :param reservation_note_id: Reservation Note ID (required)
        :type reservation_note_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_reservation_note_delete_serialize(
            reservation_id=reservation_id,
            reservation_note_id=reservation_note_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_reservation_note_delete_serialize(
        self,
        reservation_id,
        reservation_note_id,
        property_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if reservation_id is not None:
            
            _query_params.append(('reservationID', reservation_id))
            
        if reservation_note_id is not None:
            
            _query_params.append(('reservationNoteID', reservation_note_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/deleteReservationNote',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_reservation_assignments_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        var_date: Annotated[Optional[date], Field(description="Date selected to get the assignments. If no date is passed, it will return the results for the current day.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetReservationAssignmentsResponse:
        """getReservationAssignments

        Returns a list of rooms/reservations assigned for a selected date.

        :param property_id: Property ID
        :type property_id: str
        :param var_date: Date selected to get the assignments. If no date is passed, it will return the results for the current day.
        :type var_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_assignments_get_serialize(
            property_id=property_id,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationAssignmentsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_reservation_assignments_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        var_date: Annotated[Optional[date], Field(description="Date selected to get the assignments. If no date is passed, it will return the results for the current day.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetReservationAssignmentsResponse]:
        """getReservationAssignments

        Returns a list of rooms/reservations assigned for a selected date.

        :param property_id: Property ID
        :type property_id: str
        :param var_date: Date selected to get the assignments. If no date is passed, it will return the results for the current day.
        :type var_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_assignments_get_serialize(
            property_id=property_id,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationAssignmentsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_reservation_assignments_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        var_date: Annotated[Optional[date], Field(description="Date selected to get the assignments. If no date is passed, it will return the results for the current day.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getReservationAssignments

        Returns a list of rooms/reservations assigned for a selected date.

        :param property_id: Property ID
        :type property_id: str
        :param var_date: Date selected to get the assignments. If no date is passed, it will return the results for the current day.
        :type var_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_assignments_get_serialize(
            property_id=property_id,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationAssignmentsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_reservation_assignments_get_serialize(
        self,
        property_id,
        var_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if var_date is not None:
            if isinstance(var_date, date):
                _query_params.append(
                    (
                        'date',
                        var_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date', var_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getReservationAssignments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_reservation_get(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier. Obtained from one of the \"Reservations\" group methods")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetReservationResponse:
        """getReservation

        Returns information on a booking specified by the reservationID parameter

        :param reservation_id: Reservation Unique Identifier. Obtained from one of the \"Reservations\" group methods (required)
        :type reservation_id: str
        :param property_id: Property ID
        :type property_id: str
        :param include_guest_requirements: Includes guest requirements data in the response.
        :type include_guest_requirements: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_get_serialize(
            reservation_id=reservation_id,
            property_id=property_id,
            include_guest_requirements=include_guest_requirements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_reservation_get_with_http_info(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier. Obtained from one of the \"Reservations\" group methods")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetReservationResponse]:
        """getReservation

        Returns information on a booking specified by the reservationID parameter

        :param reservation_id: Reservation Unique Identifier. Obtained from one of the \"Reservations\" group methods (required)
        :type reservation_id: str
        :param property_id: Property ID
        :type property_id: str
        :param include_guest_requirements: Includes guest requirements data in the response.
        :type include_guest_requirements: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_get_serialize(
            reservation_id=reservation_id,
            property_id=property_id,
            include_guest_requirements=include_guest_requirements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_reservation_get_without_preload_content(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier. Obtained from one of the \"Reservations\" group methods")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getReservation

        Returns information on a booking specified by the reservationID parameter

        :param reservation_id: Reservation Unique Identifier. Obtained from one of the \"Reservations\" group methods (required)
        :type reservation_id: str
        :param property_id: Property ID
        :type property_id: str
        :param include_guest_requirements: Includes guest requirements data in the response.
        :type include_guest_requirements: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_get_serialize(
            reservation_id=reservation_id,
            property_id=property_id,
            include_guest_requirements=include_guest_requirements,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_reservation_get_serialize(
        self,
        reservation_id,
        property_id,
        include_guest_requirements,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if reservation_id is not None:
            
            _query_params.append(('reservationID', reservation_id))
            
        if include_guest_requirements is not None:
            
            _query_params.append(('includeGuestRequirements', include_guest_requirements))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getReservation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_reservation_notes_get(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetReservationNotesResponse:
        """getReservationNotes

        Retrieves reservation notes based on parameters

        :param reservation_id: Reservation Unique Identifier (required)
        :type reservation_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_notes_get_serialize(
            reservation_id=reservation_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationNotesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_reservation_notes_get_with_http_info(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetReservationNotesResponse]:
        """getReservationNotes

        Retrieves reservation notes based on parameters

        :param reservation_id: Reservation Unique Identifier (required)
        :type reservation_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_notes_get_serialize(
            reservation_id=reservation_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationNotesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_reservation_notes_get_without_preload_content(
        self,
        reservation_id: Annotated[StrictStr, Field(description="Reservation Unique Identifier")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getReservationNotes

        Retrieves reservation notes based on parameters

        :param reservation_id: Reservation Unique Identifier (required)
        :type reservation_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservation_notes_get_serialize(
            reservation_id=reservation_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationNotesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_reservation_notes_get_serialize(
        self,
        reservation_id,
        property_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if reservation_id is not None:
            
            _query_params.append(('reservationID', reservation_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getReservationNotes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_reservations_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Filter by current reservation status")] = None,
        results_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking date")] = None,
        results_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking date")] = None,
        modified_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking modification date")] = None,
        modified_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking modification date")] = None,
        check_in_from: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-in date range starting on this date")] = None,
        check_in_to: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-in date range ending on this date")] = None,
        check_out_from: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-out date range starting on this date")] = None,
        check_out_to: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-out date range ending on this date")] = None,
        dates_query_mode: Annotated[Optional[StrictStr], Field(description="If we should consider the booking's check-in/check-out dates or the start and end dates for the associated rooms.")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied room ID. CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned. If roomID supplied, roomName is ignored.")] = None,
        room_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied room name (customizable by each property). CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned.")] = None,
        room_type_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied Room Type ID.")] = None,
        include_guests_details: Annotated[Optional[StrictBool], Field(description="If guests details should be included or not")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.")] = None,
        include_custom_fields: Annotated[Optional[StrictBool], Field(description="If reservation custom fields should be included or not")] = None,
        include_all_rooms: Annotated[Optional[StrictBool], Field(description="When specified, the response will include an additional rooms field that combines both unassigned and assigned rooms.")] = None,
        source_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied source ID.")] = None,
        source_reservation_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied reservation source ID.")] = None,
        rate_plan_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied rate plan ID.")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied primary guest first name.")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied primary guest last name.")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied Guest ID (Including additional guests).")] = None,
        allotment_block_code: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied allotment block code.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied group code.")] = None,
        sort_by_recent: Annotated[Optional[StrictBool], Field(description="Sort response results by most recent action")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetReservationsResponse:
        """getReservations

        Returns a list of reservations that matched the filters criteria.<br /> Please note that some reservations modification may not be reflected in this timestamp. ### Group account support

        :param property_id: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.
        :type property_id: str
        :param status: Filter by current reservation status
        :type status: str
        :param results_from: Inferior limit datetime, used to filter reservations, based on booking date
        :type results_from: datetime
        :param results_to: Superior limit datetime, used to filter reservations, based on booking date
        :type results_to: datetime
        :param modified_from: Inferior limit datetime, used to filter reservations, based on booking modification date
        :type modified_from: datetime
        :param modified_to: Superior limit datetime, used to filter reservations, based on booking modification date
        :type modified_to: datetime
        :param check_in_from: Filters reservations result to return only reservations with check-in date range starting on this date
        :type check_in_from: date
        :param check_in_to: Filters reservations result to return only reservations with check-in date range ending on this date
        :type check_in_to: date
        :param check_out_from: Filters reservations result to return only reservations with check-out date range starting on this date
        :type check_out_from: date
        :param check_out_to: Filters reservations result to return only reservations with check-out date range ending on this date
        :type check_out_to: date
        :param dates_query_mode: If we should consider the booking's check-in/check-out dates or the start and end dates for the associated rooms.
        :type dates_query_mode: str
        :param room_id: Filters reservation with the supplied room ID. CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned. If roomID supplied, roomName is ignored.
        :type room_id: str
        :param room_name: Filters reservation with the supplied room name (customizable by each property). CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned.
        :type room_name: str
        :param room_type_id: Filters reservation with the supplied Room Type ID.
        :type room_type_id: str
        :param include_guests_details: If guests details should be included or not
        :type include_guests_details: bool
        :param include_guest_requirements: Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.
        :type include_guest_requirements: bool
        :param include_custom_fields: If reservation custom fields should be included or not
        :type include_custom_fields: bool
        :param include_all_rooms: When specified, the response will include an additional rooms field that combines both unassigned and assigned rooms.
        :type include_all_rooms: bool
        :param source_id: Filters reservation with the supplied source ID.
        :type source_id: str
        :param source_reservation_id: Filters reservation with the supplied reservation source ID.
        :type source_reservation_id: str
        :param rate_plan_id: Filters reservation with the supplied rate plan ID.
        :type rate_plan_id: str
        :param first_name: Filters reservation with the supplied primary guest first name.
        :type first_name: str
        :param last_name: Filters reservation with the supplied primary guest last name.
        :type last_name: str
        :param guest_id: Filters reservation with the supplied Guest ID (Including additional guests).
        :type guest_id: str
        :param allotment_block_code: Filters reservation with the supplied allotment block code.
        :type allotment_block_code: str
        :param group_code: Filters reservation with the supplied group code.
        :type group_code: str
        :param sort_by_recent: Sort response results by most recent action
        :type sort_by_recent: bool
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservations_get_serialize(
            property_id=property_id,
            status=status,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            check_in_from=check_in_from,
            check_in_to=check_in_to,
            check_out_from=check_out_from,
            check_out_to=check_out_to,
            dates_query_mode=dates_query_mode,
            room_id=room_id,
            room_name=room_name,
            room_type_id=room_type_id,
            include_guests_details=include_guests_details,
            include_guest_requirements=include_guest_requirements,
            include_custom_fields=include_custom_fields,
            include_all_rooms=include_all_rooms,
            source_id=source_id,
            source_reservation_id=source_reservation_id,
            rate_plan_id=rate_plan_id,
            first_name=first_name,
            last_name=last_name,
            guest_id=guest_id,
            allotment_block_code=allotment_block_code,
            group_code=group_code,
            sort_by_recent=sort_by_recent,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_reservations_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Filter by current reservation status")] = None,
        results_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking date")] = None,
        results_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking date")] = None,
        modified_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking modification date")] = None,
        modified_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking modification date")] = None,
        check_in_from: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-in date range starting on this date")] = None,
        check_in_to: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-in date range ending on this date")] = None,
        check_out_from: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-out date range starting on this date")] = None,
        check_out_to: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-out date range ending on this date")] = None,
        dates_query_mode: Annotated[Optional[StrictStr], Field(description="If we should consider the booking's check-in/check-out dates or the start and end dates for the associated rooms.")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied room ID. CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned. If roomID supplied, roomName is ignored.")] = None,
        room_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied room name (customizable by each property). CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned.")] = None,
        room_type_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied Room Type ID.")] = None,
        include_guests_details: Annotated[Optional[StrictBool], Field(description="If guests details should be included or not")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.")] = None,
        include_custom_fields: Annotated[Optional[StrictBool], Field(description="If reservation custom fields should be included or not")] = None,
        include_all_rooms: Annotated[Optional[StrictBool], Field(description="When specified, the response will include an additional rooms field that combines both unassigned and assigned rooms.")] = None,
        source_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied source ID.")] = None,
        source_reservation_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied reservation source ID.")] = None,
        rate_plan_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied rate plan ID.")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied primary guest first name.")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied primary guest last name.")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied Guest ID (Including additional guests).")] = None,
        allotment_block_code: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied allotment block code.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied group code.")] = None,
        sort_by_recent: Annotated[Optional[StrictBool], Field(description="Sort response results by most recent action")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetReservationsResponse]:
        """getReservations

        Returns a list of reservations that matched the filters criteria.<br /> Please note that some reservations modification may not be reflected in this timestamp. ### Group account support

        :param property_id: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.
        :type property_id: str
        :param status: Filter by current reservation status
        :type status: str
        :param results_from: Inferior limit datetime, used to filter reservations, based on booking date
        :type results_from: datetime
        :param results_to: Superior limit datetime, used to filter reservations, based on booking date
        :type results_to: datetime
        :param modified_from: Inferior limit datetime, used to filter reservations, based on booking modification date
        :type modified_from: datetime
        :param modified_to: Superior limit datetime, used to filter reservations, based on booking modification date
        :type modified_to: datetime
        :param check_in_from: Filters reservations result to return only reservations with check-in date range starting on this date
        :type check_in_from: date
        :param check_in_to: Filters reservations result to return only reservations with check-in date range ending on this date
        :type check_in_to: date
        :param check_out_from: Filters reservations result to return only reservations with check-out date range starting on this date
        :type check_out_from: date
        :param check_out_to: Filters reservations result to return only reservations with check-out date range ending on this date
        :type check_out_to: date
        :param dates_query_mode: If we should consider the booking's check-in/check-out dates or the start and end dates for the associated rooms.
        :type dates_query_mode: str
        :param room_id: Filters reservation with the supplied room ID. CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned. If roomID supplied, roomName is ignored.
        :type room_id: str
        :param room_name: Filters reservation with the supplied room name (customizable by each property). CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned.
        :type room_name: str
        :param room_type_id: Filters reservation with the supplied Room Type ID.
        :type room_type_id: str
        :param include_guests_details: If guests details should be included or not
        :type include_guests_details: bool
        :param include_guest_requirements: Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.
        :type include_guest_requirements: bool
        :param include_custom_fields: If reservation custom fields should be included or not
        :type include_custom_fields: bool
        :param include_all_rooms: When specified, the response will include an additional rooms field that combines both unassigned and assigned rooms.
        :type include_all_rooms: bool
        :param source_id: Filters reservation with the supplied source ID.
        :type source_id: str
        :param source_reservation_id: Filters reservation with the supplied reservation source ID.
        :type source_reservation_id: str
        :param rate_plan_id: Filters reservation with the supplied rate plan ID.
        :type rate_plan_id: str
        :param first_name: Filters reservation with the supplied primary guest first name.
        :type first_name: str
        :param last_name: Filters reservation with the supplied primary guest last name.
        :type last_name: str
        :param guest_id: Filters reservation with the supplied Guest ID (Including additional guests).
        :type guest_id: str
        :param allotment_block_code: Filters reservation with the supplied allotment block code.
        :type allotment_block_code: str
        :param group_code: Filters reservation with the supplied group code.
        :type group_code: str
        :param sort_by_recent: Sort response results by most recent action
        :type sort_by_recent: bool
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservations_get_serialize(
            property_id=property_id,
            status=status,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            check_in_from=check_in_from,
            check_in_to=check_in_to,
            check_out_from=check_out_from,
            check_out_to=check_out_to,
            dates_query_mode=dates_query_mode,
            room_id=room_id,
            room_name=room_name,
            room_type_id=room_type_id,
            include_guests_details=include_guests_details,
            include_guest_requirements=include_guest_requirements,
            include_custom_fields=include_custom_fields,
            include_all_rooms=include_all_rooms,
            source_id=source_id,
            source_reservation_id=source_reservation_id,
            rate_plan_id=rate_plan_id,
            first_name=first_name,
            last_name=last_name,
            guest_id=guest_id,
            allotment_block_code=allotment_block_code,
            group_code=group_code,
            sort_by_recent=sort_by_recent,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_reservations_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Filter by current reservation status")] = None,
        results_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking date")] = None,
        results_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking date")] = None,
        modified_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking modification date")] = None,
        modified_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking modification date")] = None,
        check_in_from: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-in date range starting on this date")] = None,
        check_in_to: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-in date range ending on this date")] = None,
        check_out_from: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-out date range starting on this date")] = None,
        check_out_to: Annotated[Optional[date], Field(description="Filters reservations result to return only reservations with check-out date range ending on this date")] = None,
        dates_query_mode: Annotated[Optional[StrictStr], Field(description="If we should consider the booking's check-in/check-out dates or the start and end dates for the associated rooms.")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied room ID. CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned. If roomID supplied, roomName is ignored.")] = None,
        room_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied room name (customizable by each property). CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned.")] = None,
        room_type_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied Room Type ID.")] = None,
        include_guests_details: Annotated[Optional[StrictBool], Field(description="If guests details should be included or not")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.")] = None,
        include_custom_fields: Annotated[Optional[StrictBool], Field(description="If reservation custom fields should be included or not")] = None,
        include_all_rooms: Annotated[Optional[StrictBool], Field(description="When specified, the response will include an additional rooms field that combines both unassigned and assigned rooms.")] = None,
        source_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied source ID.")] = None,
        source_reservation_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied reservation source ID.")] = None,
        rate_plan_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied rate plan ID.")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied primary guest first name.")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied primary guest last name.")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied Guest ID (Including additional guests).")] = None,
        allotment_block_code: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied allotment block code.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Filters reservation with the supplied group code.")] = None,
        sort_by_recent: Annotated[Optional[StrictBool], Field(description="Sort response results by most recent action")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getReservations

        Returns a list of reservations that matched the filters criteria.<br /> Please note that some reservations modification may not be reflected in this timestamp. ### Group account support

        :param property_id: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br /> It can be omitted if the API key is single-property, or to get results from all properties on an association.
        :type property_id: str
        :param status: Filter by current reservation status
        :type status: str
        :param results_from: Inferior limit datetime, used to filter reservations, based on booking date
        :type results_from: datetime
        :param results_to: Superior limit datetime, used to filter reservations, based on booking date
        :type results_to: datetime
        :param modified_from: Inferior limit datetime, used to filter reservations, based on booking modification date
        :type modified_from: datetime
        :param modified_to: Superior limit datetime, used to filter reservations, based on booking modification date
        :type modified_to: datetime
        :param check_in_from: Filters reservations result to return only reservations with check-in date range starting on this date
        :type check_in_from: date
        :param check_in_to: Filters reservations result to return only reservations with check-in date range ending on this date
        :type check_in_to: date
        :param check_out_from: Filters reservations result to return only reservations with check-out date range starting on this date
        :type check_out_from: date
        :param check_out_to: Filters reservations result to return only reservations with check-out date range ending on this date
        :type check_out_to: date
        :param dates_query_mode: If we should consider the booking's check-in/check-out dates or the start and end dates for the associated rooms.
        :type dates_query_mode: str
        :param room_id: Filters reservation with the supplied room ID. CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned. If roomID supplied, roomName is ignored.
        :type room_id: str
        :param room_name: Filters reservation with the supplied room name (customizable by each property). CheckIn/checkOut dates OR status are required. If dates are provided and span more than one day, more than one reservation can be returned.
        :type room_name: str
        :param room_type_id: Filters reservation with the supplied Room Type ID.
        :type room_type_id: str
        :param include_guests_details: If guests details should be included or not
        :type include_guests_details: bool
        :param include_guest_requirements: Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.
        :type include_guest_requirements: bool
        :param include_custom_fields: If reservation custom fields should be included or not
        :type include_custom_fields: bool
        :param include_all_rooms: When specified, the response will include an additional rooms field that combines both unassigned and assigned rooms.
        :type include_all_rooms: bool
        :param source_id: Filters reservation with the supplied source ID.
        :type source_id: str
        :param source_reservation_id: Filters reservation with the supplied reservation source ID.
        :type source_reservation_id: str
        :param rate_plan_id: Filters reservation with the supplied rate plan ID.
        :type rate_plan_id: str
        :param first_name: Filters reservation with the supplied primary guest first name.
        :type first_name: str
        :param last_name: Filters reservation with the supplied primary guest last name.
        :type last_name: str
        :param guest_id: Filters reservation with the supplied Guest ID (Including additional guests).
        :type guest_id: str
        :param allotment_block_code: Filters reservation with the supplied allotment block code.
        :type allotment_block_code: str
        :param group_code: Filters reservation with the supplied group code.
        :type group_code: str
        :param sort_by_recent: Sort response results by most recent action
        :type sort_by_recent: bool
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservations_get_serialize(
            property_id=property_id,
            status=status,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            check_in_from=check_in_from,
            check_in_to=check_in_to,
            check_out_from=check_out_from,
            check_out_to=check_out_to,
            dates_query_mode=dates_query_mode,
            room_id=room_id,
            room_name=room_name,
            room_type_id=room_type_id,
            include_guests_details=include_guests_details,
            include_guest_requirements=include_guest_requirements,
            include_custom_fields=include_custom_fields,
            include_all_rooms=include_all_rooms,
            source_id=source_id,
            source_reservation_id=source_reservation_id,
            rate_plan_id=rate_plan_id,
            first_name=first_name,
            last_name=last_name,
            guest_id=guest_id,
            allotment_block_code=allotment_block_code,
            group_code=group_code,
            sort_by_recent=sort_by_recent,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_reservations_get_serialize(
        self,
        property_id,
        status,
        results_from,
        results_to,
        modified_from,
        modified_to,
        check_in_from,
        check_in_to,
        check_out_from,
        check_out_to,
        dates_query_mode,
        room_id,
        room_name,
        room_type_id,
        include_guests_details,
        include_guest_requirements,
        include_custom_fields,
        include_all_rooms,
        source_id,
        source_reservation_id,
        rate_plan_id,
        first_name,
        last_name,
        guest_id,
        allotment_block_code,
        group_code,
        sort_by_recent,
        page_number,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if results_from is not None:
            if isinstance(results_from, datetime):
                _query_params.append(
                    (
                        'resultsFrom',
                        results_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('resultsFrom', results_from))
            
        if results_to is not None:
            if isinstance(results_to, datetime):
                _query_params.append(
                    (
                        'resultsTo',
                        results_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('resultsTo', results_to))
            
        if modified_from is not None:
            if isinstance(modified_from, datetime):
                _query_params.append(
                    (
                        'modifiedFrom',
                        modified_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('modifiedFrom', modified_from))
            
        if modified_to is not None:
            if isinstance(modified_to, datetime):
                _query_params.append(
                    (
                        'modifiedTo',
                        modified_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('modifiedTo', modified_to))
            
        if check_in_from is not None:
            if isinstance(check_in_from, date):
                _query_params.append(
                    (
                        'checkInFrom',
                        check_in_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('checkInFrom', check_in_from))
            
        if check_in_to is not None:
            if isinstance(check_in_to, date):
                _query_params.append(
                    (
                        'checkInTo',
                        check_in_to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('checkInTo', check_in_to))
            
        if check_out_from is not None:
            if isinstance(check_out_from, date):
                _query_params.append(
                    (
                        'checkOutFrom',
                        check_out_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('checkOutFrom', check_out_from))
            
        if check_out_to is not None:
            if isinstance(check_out_to, date):
                _query_params.append(
                    (
                        'checkOutTo',
                        check_out_to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('checkOutTo', check_out_to))
            
        if dates_query_mode is not None:
            
            _query_params.append(('datesQueryMode', dates_query_mode))
            
        if room_id is not None:
            
            _query_params.append(('roomID', room_id))
            
        if room_name is not None:
            
            _query_params.append(('roomName', room_name))
            
        if room_type_id is not None:
            
            _query_params.append(('roomTypeID', room_type_id))
            
        if include_guests_details is not None:
            
            _query_params.append(('includeGuestsDetails', include_guests_details))
            
        if include_guest_requirements is not None:
            
            _query_params.append(('includeGuestRequirements', include_guest_requirements))
            
        if include_custom_fields is not None:
            
            _query_params.append(('includeCustomFields', include_custom_fields))
            
        if include_all_rooms is not None:
            
            _query_params.append(('includeAllRooms', include_all_rooms))
            
        if source_id is not None:
            
            _query_params.append(('sourceId', source_id))
            
        if source_reservation_id is not None:
            
            _query_params.append(('sourceReservationId', source_reservation_id))
            
        if rate_plan_id is not None:
            
            _query_params.append(('ratePlanId', rate_plan_id))
            
        if first_name is not None:
            
            _query_params.append(('firstName', first_name))
            
        if last_name is not None:
            
            _query_params.append(('lastName', last_name))
            
        if guest_id is not None:
            
            _query_params.append(('guestID', guest_id))
            
        if allotment_block_code is not None:
            
            _query_params.append(('allotmentBlockCode', allotment_block_code))
            
        if group_code is not None:
            
            _query_params.append(('groupCode', group_code))
            
        if sort_by_recent is not None:
            
            _query_params.append(('sortByRecent', sort_by_recent))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getReservations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_reservations_with_rate_details_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        results_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations starting 2 years ago")] = None,
        results_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations up to current date")] = None,
        modified_from: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on modification date.")] = None,
        modified_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on modification date.")] = None,
        sort_by_recent: Annotated[Optional[StrictBool], Field(description="Sort response results by most recent action")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifiers, comma-separated, i.e. 37,345,89, used to return transactions limited to the selected reservations.")] = None,
        reservation_check_out_from: Annotated[Optional[date], Field(description="Superior limit datetime, used to filter reservations, based on reservation check-out date.")] = None,
        reservation_check_out_to: Annotated[Optional[date], Field(description="Superior limit datetime, used to filter reservations, based on reservation check-out date.")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Include deleted reservations")] = None,
        exclude_statuses: Annotated[Optional[StrictStr], Field(description="List of statuses (separated by comma) to be excluded from search")] = None,
        include_guests_details: Annotated[Optional[StrictBool], Field(description="If guests details should be included or not")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.")] = None,
        include_custom_fields: Annotated[Optional[StrictBool], Field(description="If reservation custom fields should be included or not")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Filters reservations with the supplied Guest ID (Including additional guests).")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetReservationsWithRateDetailsResponse:
        """getReservationsWithRateDetails

        Returns a list of reservations with added information regarding booked rates and sources. The results are limited to 2 years in the past unless resutsFrom parameter is set to another date.<br /> Please note that some reservations modification may not be reflected in this timestamp.

        :param property_id: Property ID
        :type property_id: str
        :param results_from: Inferior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations starting 2 years ago
        :type results_from: datetime
        :param results_to: Superior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations up to current date
        :type results_to: datetime
        :param modified_from: Superior limit datetime, used to filter reservations, based on modification date.
        :type modified_from: datetime
        :param modified_to: Superior limit datetime, used to filter reservations, based on modification date.
        :type modified_to: datetime
        :param sort_by_recent: Sort response results by most recent action
        :type sort_by_recent: bool
        :param reservation_id: Reservation identifiers, comma-separated, i.e. 37,345,89, used to return transactions limited to the selected reservations.
        :type reservation_id: str
        :param reservation_check_out_from: Superior limit datetime, used to filter reservations, based on reservation check-out date.
        :type reservation_check_out_from: date
        :param reservation_check_out_to: Superior limit datetime, used to filter reservations, based on reservation check-out date.
        :type reservation_check_out_to: date
        :param include_deleted: Include deleted reservations
        :type include_deleted: bool
        :param exclude_statuses: List of statuses (separated by comma) to be excluded from search
        :type exclude_statuses: str
        :param include_guests_details: If guests details should be included or not
        :type include_guests_details: bool
        :param include_guest_requirements: Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.
        :type include_guest_requirements: bool
        :param include_custom_fields: If reservation custom fields should be included or not
        :type include_custom_fields: bool
        :param guest_id: Filters reservations with the supplied Guest ID (Including additional guests).
        :type guest_id: str
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservations_with_rate_details_get_serialize(
            property_id=property_id,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            sort_by_recent=sort_by_recent,
            reservation_id=reservation_id,
            reservation_check_out_from=reservation_check_out_from,
            reservation_check_out_to=reservation_check_out_to,
            include_deleted=include_deleted,
            exclude_statuses=exclude_statuses,
            include_guests_details=include_guests_details,
            include_guest_requirements=include_guest_requirements,
            include_custom_fields=include_custom_fields,
            guest_id=guest_id,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationsWithRateDetailsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_reservations_with_rate_details_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        results_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations starting 2 years ago")] = None,
        results_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations up to current date")] = None,
        modified_from: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on modification date.")] = None,
        modified_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on modification date.")] = None,
        sort_by_recent: Annotated[Optional[StrictBool], Field(description="Sort response results by most recent action")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifiers, comma-separated, i.e. 37,345,89, used to return transactions limited to the selected reservations.")] = None,
        reservation_check_out_from: Annotated[Optional[date], Field(description="Superior limit datetime, used to filter reservations, based on reservation check-out date.")] = None,
        reservation_check_out_to: Annotated[Optional[date], Field(description="Superior limit datetime, used to filter reservations, based on reservation check-out date.")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Include deleted reservations")] = None,
        exclude_statuses: Annotated[Optional[StrictStr], Field(description="List of statuses (separated by comma) to be excluded from search")] = None,
        include_guests_details: Annotated[Optional[StrictBool], Field(description="If guests details should be included or not")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.")] = None,
        include_custom_fields: Annotated[Optional[StrictBool], Field(description="If reservation custom fields should be included or not")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Filters reservations with the supplied Guest ID (Including additional guests).")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetReservationsWithRateDetailsResponse]:
        """getReservationsWithRateDetails

        Returns a list of reservations with added information regarding booked rates and sources. The results are limited to 2 years in the past unless resutsFrom parameter is set to another date.<br /> Please note that some reservations modification may not be reflected in this timestamp.

        :param property_id: Property ID
        :type property_id: str
        :param results_from: Inferior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations starting 2 years ago
        :type results_from: datetime
        :param results_to: Superior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations up to current date
        :type results_to: datetime
        :param modified_from: Superior limit datetime, used to filter reservations, based on modification date.
        :type modified_from: datetime
        :param modified_to: Superior limit datetime, used to filter reservations, based on modification date.
        :type modified_to: datetime
        :param sort_by_recent: Sort response results by most recent action
        :type sort_by_recent: bool
        :param reservation_id: Reservation identifiers, comma-separated, i.e. 37,345,89, used to return transactions limited to the selected reservations.
        :type reservation_id: str
        :param reservation_check_out_from: Superior limit datetime, used to filter reservations, based on reservation check-out date.
        :type reservation_check_out_from: date
        :param reservation_check_out_to: Superior limit datetime, used to filter reservations, based on reservation check-out date.
        :type reservation_check_out_to: date
        :param include_deleted: Include deleted reservations
        :type include_deleted: bool
        :param exclude_statuses: List of statuses (separated by comma) to be excluded from search
        :type exclude_statuses: str
        :param include_guests_details: If guests details should be included or not
        :type include_guests_details: bool
        :param include_guest_requirements: Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.
        :type include_guest_requirements: bool
        :param include_custom_fields: If reservation custom fields should be included or not
        :type include_custom_fields: bool
        :param guest_id: Filters reservations with the supplied Guest ID (Including additional guests).
        :type guest_id: str
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservations_with_rate_details_get_serialize(
            property_id=property_id,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            sort_by_recent=sort_by_recent,
            reservation_id=reservation_id,
            reservation_check_out_from=reservation_check_out_from,
            reservation_check_out_to=reservation_check_out_to,
            include_deleted=include_deleted,
            exclude_statuses=exclude_statuses,
            include_guests_details=include_guests_details,
            include_guest_requirements=include_guest_requirements,
            include_custom_fields=include_custom_fields,
            guest_id=guest_id,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationsWithRateDetailsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_reservations_with_rate_details_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        results_from: Annotated[Optional[datetime], Field(description="Inferior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations starting 2 years ago")] = None,
        results_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations up to current date")] = None,
        modified_from: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on modification date.")] = None,
        modified_to: Annotated[Optional[datetime], Field(description="Superior limit datetime, used to filter reservations, based on modification date.")] = None,
        sort_by_recent: Annotated[Optional[StrictBool], Field(description="Sort response results by most recent action")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifiers, comma-separated, i.e. 37,345,89, used to return transactions limited to the selected reservations.")] = None,
        reservation_check_out_from: Annotated[Optional[date], Field(description="Superior limit datetime, used to filter reservations, based on reservation check-out date.")] = None,
        reservation_check_out_to: Annotated[Optional[date], Field(description="Superior limit datetime, used to filter reservations, based on reservation check-out date.")] = None,
        include_deleted: Annotated[Optional[StrictBool], Field(description="Include deleted reservations")] = None,
        exclude_statuses: Annotated[Optional[StrictStr], Field(description="List of statuses (separated by comma) to be excluded from search")] = None,
        include_guests_details: Annotated[Optional[StrictBool], Field(description="If guests details should be included or not")] = None,
        include_guest_requirements: Annotated[Optional[StrictBool], Field(description="Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.")] = None,
        include_custom_fields: Annotated[Optional[StrictBool], Field(description="If reservation custom fields should be included or not")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Filters reservations with the supplied Guest ID (Including additional guests).")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Results page number")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Results page size. Max = 100")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getReservationsWithRateDetails

        Returns a list of reservations with added information regarding booked rates and sources. The results are limited to 2 years in the past unless resutsFrom parameter is set to another date.<br /> Please note that some reservations modification may not be reflected in this timestamp.

        :param property_id: Property ID
        :type property_id: str
        :param results_from: Inferior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations starting 2 years ago
        :type results_from: datetime
        :param results_to: Superior limit datetime, used to filter reservations, based on booking date. If it is not set, will return the reservations up to current date
        :type results_to: datetime
        :param modified_from: Superior limit datetime, used to filter reservations, based on modification date.
        :type modified_from: datetime
        :param modified_to: Superior limit datetime, used to filter reservations, based on modification date.
        :type modified_to: datetime
        :param sort_by_recent: Sort response results by most recent action
        :type sort_by_recent: bool
        :param reservation_id: Reservation identifiers, comma-separated, i.e. 37,345,89, used to return transactions limited to the selected reservations.
        :type reservation_id: str
        :param reservation_check_out_from: Superior limit datetime, used to filter reservations, based on reservation check-out date.
        :type reservation_check_out_from: date
        :param reservation_check_out_to: Superior limit datetime, used to filter reservations, based on reservation check-out date.
        :type reservation_check_out_to: date
        :param include_deleted: Include deleted reservations
        :type include_deleted: bool
        :param exclude_statuses: List of statuses (separated by comma) to be excluded from search
        :type exclude_statuses: str
        :param include_guests_details: If guests details should be included or not
        :type include_guests_details: bool
        :param include_guest_requirements: Includes guest requirements data in the response. Requires `includeGuestsDetails=true`.
        :type include_guest_requirements: bool
        :param include_custom_fields: If reservation custom fields should be included or not
        :type include_custom_fields: bool
        :param guest_id: Filters reservations with the supplied Guest ID (Including additional guests).
        :type guest_id: str
        :param page_number: Results page number
        :type page_number: int
        :param page_size: Results page size. Max = 100
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_reservations_with_rate_details_get_serialize(
            property_id=property_id,
            results_from=results_from,
            results_to=results_to,
            modified_from=modified_from,
            modified_to=modified_to,
            sort_by_recent=sort_by_recent,
            reservation_id=reservation_id,
            reservation_check_out_from=reservation_check_out_from,
            reservation_check_out_to=reservation_check_out_to,
            include_deleted=include_deleted,
            exclude_statuses=exclude_statuses,
            include_guests_details=include_guests_details,
            include_guest_requirements=include_guest_requirements,
            include_custom_fields=include_custom_fields,
            guest_id=guest_id,
            page_number=page_number,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReservationsWithRateDetailsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_reservations_with_rate_details_get_serialize(
        self,
        property_id,
        results_from,
        results_to,
        modified_from,
        modified_to,
        sort_by_recent,
        reservation_id,
        reservation_check_out_from,
        reservation_check_out_to,
        include_deleted,
        exclude_statuses,
        include_guests_details,
        include_guest_requirements,
        include_custom_fields,
        guest_id,
        page_number,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if results_from is not None:
            if isinstance(results_from, datetime):
                _query_params.append(
                    (
                        'resultsFrom',
                        results_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('resultsFrom', results_from))
            
        if results_to is not None:
            if isinstance(results_to, datetime):
                _query_params.append(
                    (
                        'resultsTo',
                        results_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('resultsTo', results_to))
            
        if modified_from is not None:
            if isinstance(modified_from, datetime):
                _query_params.append(
                    (
                        'modifiedFrom',
                        modified_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('modifiedFrom', modified_from))
            
        if modified_to is not None:
            if isinstance(modified_to, datetime):
                _query_params.append(
                    (
                        'modifiedTo',
                        modified_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('modifiedTo', modified_to))
            
        if sort_by_recent is not None:
            
            _query_params.append(('sortByRecent', sort_by_recent))
            
        if reservation_id is not None:
            
            _query_params.append(('reservationID', reservation_id))
            
        if reservation_check_out_from is not None:
            if isinstance(reservation_check_out_from, date):
                _query_params.append(
                    (
                        'reservationCheckOutFrom',
                        reservation_check_out_from.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('reservationCheckOutFrom', reservation_check_out_from))
            
        if reservation_check_out_to is not None:
            if isinstance(reservation_check_out_to, date):
                _query_params.append(
                    (
                        'reservationCheckOutTo',
                        reservation_check_out_to.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('reservationCheckOutTo', reservation_check_out_to))
            
        if include_deleted is not None:
            
            _query_params.append(('includeDeleted', include_deleted))
            
        if exclude_statuses is not None:
            
            _query_params.append(('excludeStatuses', exclude_statuses))
            
        if include_guests_details is not None:
            
            _query_params.append(('includeGuestsDetails', include_guests_details))
            
        if include_guest_requirements is not None:
            
            _query_params.append(('includeGuestRequirements', include_guest_requirements))
            
        if include_custom_fields is not None:
            
            _query_params.append(('includeCustomFields', include_custom_fields))
            
        if guest_id is not None:
            
            _query_params.append(('guestID', guest_id))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getReservationsWithRateDetails',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_sources_get(
        self,
        property_ids: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br />")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetSourcesResponse:
        """getSources

        Gets available property sources

        :param property_ids: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br />
        :type property_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_get_serialize(
            property_ids=property_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetSourcesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_sources_get_with_http_info(
        self,
        property_ids: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br />")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetSourcesResponse]:
        """getSources

        Gets available property sources

        :param property_ids: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br />
        :type property_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_get_serialize(
            property_ids=property_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetSourcesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_sources_get_without_preload_content(
        self,
        property_ids: Annotated[Optional[StrictStr], Field(description="ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br />")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getSources

        Gets available property sources

        :param property_ids: ID for the properties to be queried (comma-separated, i.e. 37,345,89).<br />
        :type property_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_get_serialize(
            property_ids=property_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetSourcesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_sources_get_serialize(
        self,
        property_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_ids is not None:
            
            _query_params.append(('propertyIDs', property_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getSources',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_reservation_document_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Form-based File Upload<br/> Allowed file types: <code>*.pdf, *.rtf, *.doc, *.docx, *.txt, *.jpg, *.jpeg, *.png, *.gif, *.csv, *.xls, *.xlsx, *.xml</code><br/> Allowed max file size: 100MB")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostReservationDocumentResponse:
        """postReservationDocument

        Attaches a document to a reservation

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param file: Form-based File Upload<br/> Allowed file types: <code>*.pdf, *.rtf, *.doc, *.docx, *.txt, *.jpg, *.jpeg, *.png, *.gif, *.csv, *.xls, *.xlsx, *.xml</code><br/> Allowed max file size: 100MB
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_document_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationDocumentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_reservation_document_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Form-based File Upload<br/> Allowed file types: <code>*.pdf, *.rtf, *.doc, *.docx, *.txt, *.jpg, *.jpeg, *.png, *.gif, *.csv, *.xls, *.xlsx, *.xml</code><br/> Allowed max file size: 100MB")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostReservationDocumentResponse]:
        """postReservationDocument

        Attaches a document to a reservation

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param file: Form-based File Upload<br/> Allowed file types: <code>*.pdf, *.rtf, *.doc, *.docx, *.txt, *.jpg, *.jpeg, *.png, *.gif, *.csv, *.xls, *.xlsx, *.xml</code><br/> Allowed max file size: 100MB
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_document_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationDocumentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_reservation_document_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Form-based File Upload<br/> Allowed file types: <code>*.pdf, *.rtf, *.doc, *.docx, *.txt, *.jpg, *.jpeg, *.png, *.gif, *.csv, *.xls, *.xlsx, *.xml</code><br/> Allowed max file size: 100MB")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postReservationDocument

        Attaches a document to a reservation

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param file: Form-based File Upload<br/> Allowed file types: <code>*.pdf, *.rtf, *.doc, *.docx, *.txt, *.jpg, *.jpeg, *.png, *.gif, *.csv, *.xls, *.xlsx, *.xml</code><br/> Allowed max file size: 100MB
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_document_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationDocumentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_reservation_document_post_serialize(
        self,
        property_id,
        reservation_id,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if file is not None:
            _files['file'] = file
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postReservationDocument',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_reservation_note_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        reservation_note: Annotated[Optional[StrictStr], Field(description="Note to be added to reservation")] = None,
        user_id: Annotated[Optional[StrictStr], Field(description="User ID Identify the actual user that is posting the note")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Datetime the note was created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostReservationNoteResponse:
        """postReservationNote

        Adds a reservation note

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param reservation_note: Note to be added to reservation
        :type reservation_note: str
        :param user_id: User ID Identify the actual user that is posting the note
        :type user_id: str
        :param date_created: Datetime the note was created.
        :type date_created: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_note_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reservation_note=reservation_note,
            user_id=user_id,
            date_created=date_created,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_reservation_note_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        reservation_note: Annotated[Optional[StrictStr], Field(description="Note to be added to reservation")] = None,
        user_id: Annotated[Optional[StrictStr], Field(description="User ID Identify the actual user that is posting the note")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Datetime the note was created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostReservationNoteResponse]:
        """postReservationNote

        Adds a reservation note

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param reservation_note: Note to be added to reservation
        :type reservation_note: str
        :param user_id: User ID Identify the actual user that is posting the note
        :type user_id: str
        :param date_created: Datetime the note was created.
        :type date_created: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_note_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reservation_note=reservation_note,
            user_id=user_id,
            date_created=date_created,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_reservation_note_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        reservation_note: Annotated[Optional[StrictStr], Field(description="Note to be added to reservation")] = None,
        user_id: Annotated[Optional[StrictStr], Field(description="User ID Identify the actual user that is posting the note")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Datetime the note was created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postReservationNote

        Adds a reservation note

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param reservation_note: Note to be added to reservation
        :type reservation_note: str
        :param user_id: User ID Identify the actual user that is posting the note
        :type user_id: str
        :param date_created: Datetime the note was created.
        :type date_created: datetime
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_note_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reservation_note=reservation_note,
            user_id=user_id,
            date_created=date_created,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_reservation_note_post_serialize(
        self,
        property_id,
        reservation_id,
        reservation_note,
        user_id,
        date_created,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if reservation_note is not None:
            _form_params.append(('reservationNote', reservation_note))
        if user_id is not None:
            _form_params.append(('userID', user_id))
        if date_created is not None:
            _form_params.append(('dateCreated', date_created))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postReservationNote',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_reservation_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        source_id: Annotated[Optional[StrictStr], Field(description="The third-party source ID for this reservation.")] = None,
        third_party_identifier: Annotated[Optional[StrictStr], Field(description="If it was received from a booking channel, this can be an identifier from that channel.")] = None,
        start_date: Annotated[Optional[date], Field(description="Check-In date.")] = None,
        end_date: Annotated[Optional[date], Field(description="Check-Out date.")] = None,
        guest_first_name: Annotated[Optional[StrictStr], Field(description="First name of the guest")] = None,
        guest_last_name: Annotated[Optional[StrictStr], Field(description="Last name of the guest")] = None,
        guest_gender: Optional[StrictStr] = None,
        guest_country: Annotated[Optional[StrictStr], Field(description="Valid ISO-Code for Country (2 characters)")] = None,
        guest_zip: Annotated[Optional[StrictStr], Field(description="ZIP Code")] = None,
        guest_email: Annotated[Optional[StrictStr], Field(description="Guest email")] = None,
        guest_phone: Annotated[Optional[StrictStr], Field(description="Guest main phone number")] = None,
        guest_requirements: Annotated[Optional[List[Dict[str, Any]]], Field(description="Object with guest requirements information.")] = None,
        estimated_arrival_time: Annotated[Optional[StrictStr], Field(description="Estimated Arrival Time, 24-hour format.")] = None,
        rooms: Annotated[Optional[List[PostReservationRequestRoomsInner]], Field(description="Array with quantity of rooms")] = None,
        adults: Annotated[Optional[List[PostReservationRequestAdultsInner]], Field(description="Array with number of adults")] = None,
        children: Annotated[Optional[List[PostReservationRequestChildrenInner]], Field(description="Array with number of children")] = None,
        payment_method: Annotated[Optional[StrictStr], Field(description="Payment Method of choice.")] = None,
        card_token: Annotated[Optional[StrictStr], Field(description="Credit Card identifier. Payment Method must be credit. This field should be filled with credit card identifier according to gateway. Only available for Stripe and should send the Customer ID.")] = None,
        payment_authorization_code: Annotated[Optional[StrictStr], Field(description="Transaction identifier. Payment Method must be credit. This field should be filled with transaction identifier according to gateway. Only available for Stripe and it should be filled with Charge ID associated to the Payment Intent.")] = None,
        custom_fields: Annotated[Optional[List[PostReservationRequestCustomFieldsInner]], Field(description="Array with custom fields information")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="Promotional code. Required for specials and packages that uses it. \\\"rateID\\\" parameter required for using \\\"promoCode\\\".")] = None,
        allotment_block_code: Annotated[Optional[StrictStr], Field(description="Allotment block code to add reservation to allotment block.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Code from the Aggregate Allotment block the reservation will be added to.")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Date reservation was made. Defaults to current date if omitted.")] = None,
        send_email_confirmation: Annotated[Optional[StrictBool], Field(description="Send confirmation email to guest.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostReservationResponse:
        """postReservation

        Adds a reservation to the selected property

        :param property_id: Property ID
        :type property_id: str
        :param source_id: The third-party source ID for this reservation.
        :type source_id: str
        :param third_party_identifier: If it was received from a booking channel, this can be an identifier from that channel.
        :type third_party_identifier: str
        :param start_date: Check-In date.
        :type start_date: date
        :param end_date: Check-Out date.
        :type end_date: date
        :param guest_first_name: First name of the guest
        :type guest_first_name: str
        :param guest_last_name: Last name of the guest
        :type guest_last_name: str
        :param guest_gender: 
        :type guest_gender: str
        :param guest_country: Valid ISO-Code for Country (2 characters)
        :type guest_country: str
        :param guest_zip: ZIP Code
        :type guest_zip: str
        :param guest_email: Guest email
        :type guest_email: str
        :param guest_phone: Guest main phone number
        :type guest_phone: str
        :param guest_requirements: Object with guest requirements information.
        :type guest_requirements: List[object]
        :param estimated_arrival_time: Estimated Arrival Time, 24-hour format.
        :type estimated_arrival_time: str
        :param rooms: Array with quantity of rooms
        :type rooms: List[PostReservationRequestRoomsInner]
        :param adults: Array with number of adults
        :type adults: List[PostReservationRequestAdultsInner]
        :param children: Array with number of children
        :type children: List[PostReservationRequestChildrenInner]
        :param payment_method: Payment Method of choice.
        :type payment_method: str
        :param card_token: Credit Card identifier. Payment Method must be credit. This field should be filled with credit card identifier according to gateway. Only available for Stripe and should send the Customer ID.
        :type card_token: str
        :param payment_authorization_code: Transaction identifier. Payment Method must be credit. This field should be filled with transaction identifier according to gateway. Only available for Stripe and it should be filled with Charge ID associated to the Payment Intent.
        :type payment_authorization_code: str
        :param custom_fields: Array with custom fields information
        :type custom_fields: List[PostReservationRequestCustomFieldsInner]
        :param promo_code: Promotional code. Required for specials and packages that uses it. \\\"rateID\\\" parameter required for using \\\"promoCode\\\".
        :type promo_code: str
        :param allotment_block_code: Allotment block code to add reservation to allotment block.
        :type allotment_block_code: str
        :param group_code: Code from the Aggregate Allotment block the reservation will be added to.
        :type group_code: str
        :param date_created: Date reservation was made. Defaults to current date if omitted.
        :type date_created: datetime
        :param send_email_confirmation: Send confirmation email to guest.
        :type send_email_confirmation: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_post_serialize(
            property_id=property_id,
            source_id=source_id,
            third_party_identifier=third_party_identifier,
            start_date=start_date,
            end_date=end_date,
            guest_first_name=guest_first_name,
            guest_last_name=guest_last_name,
            guest_gender=guest_gender,
            guest_country=guest_country,
            guest_zip=guest_zip,
            guest_email=guest_email,
            guest_phone=guest_phone,
            guest_requirements=guest_requirements,
            estimated_arrival_time=estimated_arrival_time,
            rooms=rooms,
            adults=adults,
            children=children,
            payment_method=payment_method,
            card_token=card_token,
            payment_authorization_code=payment_authorization_code,
            custom_fields=custom_fields,
            promo_code=promo_code,
            allotment_block_code=allotment_block_code,
            group_code=group_code,
            date_created=date_created,
            send_email_confirmation=send_email_confirmation,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_reservation_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        source_id: Annotated[Optional[StrictStr], Field(description="The third-party source ID for this reservation.")] = None,
        third_party_identifier: Annotated[Optional[StrictStr], Field(description="If it was received from a booking channel, this can be an identifier from that channel.")] = None,
        start_date: Annotated[Optional[date], Field(description="Check-In date.")] = None,
        end_date: Annotated[Optional[date], Field(description="Check-Out date.")] = None,
        guest_first_name: Annotated[Optional[StrictStr], Field(description="First name of the guest")] = None,
        guest_last_name: Annotated[Optional[StrictStr], Field(description="Last name of the guest")] = None,
        guest_gender: Optional[StrictStr] = None,
        guest_country: Annotated[Optional[StrictStr], Field(description="Valid ISO-Code for Country (2 characters)")] = None,
        guest_zip: Annotated[Optional[StrictStr], Field(description="ZIP Code")] = None,
        guest_email: Annotated[Optional[StrictStr], Field(description="Guest email")] = None,
        guest_phone: Annotated[Optional[StrictStr], Field(description="Guest main phone number")] = None,
        guest_requirements: Annotated[Optional[List[Dict[str, Any]]], Field(description="Object with guest requirements information.")] = None,
        estimated_arrival_time: Annotated[Optional[StrictStr], Field(description="Estimated Arrival Time, 24-hour format.")] = None,
        rooms: Annotated[Optional[List[PostReservationRequestRoomsInner]], Field(description="Array with quantity of rooms")] = None,
        adults: Annotated[Optional[List[PostReservationRequestAdultsInner]], Field(description="Array with number of adults")] = None,
        children: Annotated[Optional[List[PostReservationRequestChildrenInner]], Field(description="Array with number of children")] = None,
        payment_method: Annotated[Optional[StrictStr], Field(description="Payment Method of choice.")] = None,
        card_token: Annotated[Optional[StrictStr], Field(description="Credit Card identifier. Payment Method must be credit. This field should be filled with credit card identifier according to gateway. Only available for Stripe and should send the Customer ID.")] = None,
        payment_authorization_code: Annotated[Optional[StrictStr], Field(description="Transaction identifier. Payment Method must be credit. This field should be filled with transaction identifier according to gateway. Only available for Stripe and it should be filled with Charge ID associated to the Payment Intent.")] = None,
        custom_fields: Annotated[Optional[List[PostReservationRequestCustomFieldsInner]], Field(description="Array with custom fields information")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="Promotional code. Required for specials and packages that uses it. \\\"rateID\\\" parameter required for using \\\"promoCode\\\".")] = None,
        allotment_block_code: Annotated[Optional[StrictStr], Field(description="Allotment block code to add reservation to allotment block.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Code from the Aggregate Allotment block the reservation will be added to.")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Date reservation was made. Defaults to current date if omitted.")] = None,
        send_email_confirmation: Annotated[Optional[StrictBool], Field(description="Send confirmation email to guest.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostReservationResponse]:
        """postReservation

        Adds a reservation to the selected property

        :param property_id: Property ID
        :type property_id: str
        :param source_id: The third-party source ID for this reservation.
        :type source_id: str
        :param third_party_identifier: If it was received from a booking channel, this can be an identifier from that channel.
        :type third_party_identifier: str
        :param start_date: Check-In date.
        :type start_date: date
        :param end_date: Check-Out date.
        :type end_date: date
        :param guest_first_name: First name of the guest
        :type guest_first_name: str
        :param guest_last_name: Last name of the guest
        :type guest_last_name: str
        :param guest_gender: 
        :type guest_gender: str
        :param guest_country: Valid ISO-Code for Country (2 characters)
        :type guest_country: str
        :param guest_zip: ZIP Code
        :type guest_zip: str
        :param guest_email: Guest email
        :type guest_email: str
        :param guest_phone: Guest main phone number
        :type guest_phone: str
        :param guest_requirements: Object with guest requirements information.
        :type guest_requirements: List[object]
        :param estimated_arrival_time: Estimated Arrival Time, 24-hour format.
        :type estimated_arrival_time: str
        :param rooms: Array with quantity of rooms
        :type rooms: List[PostReservationRequestRoomsInner]
        :param adults: Array with number of adults
        :type adults: List[PostReservationRequestAdultsInner]
        :param children: Array with number of children
        :type children: List[PostReservationRequestChildrenInner]
        :param payment_method: Payment Method of choice.
        :type payment_method: str
        :param card_token: Credit Card identifier. Payment Method must be credit. This field should be filled with credit card identifier according to gateway. Only available for Stripe and should send the Customer ID.
        :type card_token: str
        :param payment_authorization_code: Transaction identifier. Payment Method must be credit. This field should be filled with transaction identifier according to gateway. Only available for Stripe and it should be filled with Charge ID associated to the Payment Intent.
        :type payment_authorization_code: str
        :param custom_fields: Array with custom fields information
        :type custom_fields: List[PostReservationRequestCustomFieldsInner]
        :param promo_code: Promotional code. Required for specials and packages that uses it. \\\"rateID\\\" parameter required for using \\\"promoCode\\\".
        :type promo_code: str
        :param allotment_block_code: Allotment block code to add reservation to allotment block.
        :type allotment_block_code: str
        :param group_code: Code from the Aggregate Allotment block the reservation will be added to.
        :type group_code: str
        :param date_created: Date reservation was made. Defaults to current date if omitted.
        :type date_created: datetime
        :param send_email_confirmation: Send confirmation email to guest.
        :type send_email_confirmation: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_post_serialize(
            property_id=property_id,
            source_id=source_id,
            third_party_identifier=third_party_identifier,
            start_date=start_date,
            end_date=end_date,
            guest_first_name=guest_first_name,
            guest_last_name=guest_last_name,
            guest_gender=guest_gender,
            guest_country=guest_country,
            guest_zip=guest_zip,
            guest_email=guest_email,
            guest_phone=guest_phone,
            guest_requirements=guest_requirements,
            estimated_arrival_time=estimated_arrival_time,
            rooms=rooms,
            adults=adults,
            children=children,
            payment_method=payment_method,
            card_token=card_token,
            payment_authorization_code=payment_authorization_code,
            custom_fields=custom_fields,
            promo_code=promo_code,
            allotment_block_code=allotment_block_code,
            group_code=group_code,
            date_created=date_created,
            send_email_confirmation=send_email_confirmation,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_reservation_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        source_id: Annotated[Optional[StrictStr], Field(description="The third-party source ID for this reservation.")] = None,
        third_party_identifier: Annotated[Optional[StrictStr], Field(description="If it was received from a booking channel, this can be an identifier from that channel.")] = None,
        start_date: Annotated[Optional[date], Field(description="Check-In date.")] = None,
        end_date: Annotated[Optional[date], Field(description="Check-Out date.")] = None,
        guest_first_name: Annotated[Optional[StrictStr], Field(description="First name of the guest")] = None,
        guest_last_name: Annotated[Optional[StrictStr], Field(description="Last name of the guest")] = None,
        guest_gender: Optional[StrictStr] = None,
        guest_country: Annotated[Optional[StrictStr], Field(description="Valid ISO-Code for Country (2 characters)")] = None,
        guest_zip: Annotated[Optional[StrictStr], Field(description="ZIP Code")] = None,
        guest_email: Annotated[Optional[StrictStr], Field(description="Guest email")] = None,
        guest_phone: Annotated[Optional[StrictStr], Field(description="Guest main phone number")] = None,
        guest_requirements: Annotated[Optional[List[Dict[str, Any]]], Field(description="Object with guest requirements information.")] = None,
        estimated_arrival_time: Annotated[Optional[StrictStr], Field(description="Estimated Arrival Time, 24-hour format.")] = None,
        rooms: Annotated[Optional[List[PostReservationRequestRoomsInner]], Field(description="Array with quantity of rooms")] = None,
        adults: Annotated[Optional[List[PostReservationRequestAdultsInner]], Field(description="Array with number of adults")] = None,
        children: Annotated[Optional[List[PostReservationRequestChildrenInner]], Field(description="Array with number of children")] = None,
        payment_method: Annotated[Optional[StrictStr], Field(description="Payment Method of choice.")] = None,
        card_token: Annotated[Optional[StrictStr], Field(description="Credit Card identifier. Payment Method must be credit. This field should be filled with credit card identifier according to gateway. Only available for Stripe and should send the Customer ID.")] = None,
        payment_authorization_code: Annotated[Optional[StrictStr], Field(description="Transaction identifier. Payment Method must be credit. This field should be filled with transaction identifier according to gateway. Only available for Stripe and it should be filled with Charge ID associated to the Payment Intent.")] = None,
        custom_fields: Annotated[Optional[List[PostReservationRequestCustomFieldsInner]], Field(description="Array with custom fields information")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="Promotional code. Required for specials and packages that uses it. \\\"rateID\\\" parameter required for using \\\"promoCode\\\".")] = None,
        allotment_block_code: Annotated[Optional[StrictStr], Field(description="Allotment block code to add reservation to allotment block.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Code from the Aggregate Allotment block the reservation will be added to.")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Date reservation was made. Defaults to current date if omitted.")] = None,
        send_email_confirmation: Annotated[Optional[StrictBool], Field(description="Send confirmation email to guest.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postReservation

        Adds a reservation to the selected property

        :param property_id: Property ID
        :type property_id: str
        :param source_id: The third-party source ID for this reservation.
        :type source_id: str
        :param third_party_identifier: If it was received from a booking channel, this can be an identifier from that channel.
        :type third_party_identifier: str
        :param start_date: Check-In date.
        :type start_date: date
        :param end_date: Check-Out date.
        :type end_date: date
        :param guest_first_name: First name of the guest
        :type guest_first_name: str
        :param guest_last_name: Last name of the guest
        :type guest_last_name: str
        :param guest_gender: 
        :type guest_gender: str
        :param guest_country: Valid ISO-Code for Country (2 characters)
        :type guest_country: str
        :param guest_zip: ZIP Code
        :type guest_zip: str
        :param guest_email: Guest email
        :type guest_email: str
        :param guest_phone: Guest main phone number
        :type guest_phone: str
        :param guest_requirements: Object with guest requirements information.
        :type guest_requirements: List[object]
        :param estimated_arrival_time: Estimated Arrival Time, 24-hour format.
        :type estimated_arrival_time: str
        :param rooms: Array with quantity of rooms
        :type rooms: List[PostReservationRequestRoomsInner]
        :param adults: Array with number of adults
        :type adults: List[PostReservationRequestAdultsInner]
        :param children: Array with number of children
        :type children: List[PostReservationRequestChildrenInner]
        :param payment_method: Payment Method of choice.
        :type payment_method: str
        :param card_token: Credit Card identifier. Payment Method must be credit. This field should be filled with credit card identifier according to gateway. Only available for Stripe and should send the Customer ID.
        :type card_token: str
        :param payment_authorization_code: Transaction identifier. Payment Method must be credit. This field should be filled with transaction identifier according to gateway. Only available for Stripe and it should be filled with Charge ID associated to the Payment Intent.
        :type payment_authorization_code: str
        :param custom_fields: Array with custom fields information
        :type custom_fields: List[PostReservationRequestCustomFieldsInner]
        :param promo_code: Promotional code. Required for specials and packages that uses it. \\\"rateID\\\" parameter required for using \\\"promoCode\\\".
        :type promo_code: str
        :param allotment_block_code: Allotment block code to add reservation to allotment block.
        :type allotment_block_code: str
        :param group_code: Code from the Aggregate Allotment block the reservation will be added to.
        :type group_code: str
        :param date_created: Date reservation was made. Defaults to current date if omitted.
        :type date_created: datetime
        :param send_email_confirmation: Send confirmation email to guest.
        :type send_email_confirmation: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_reservation_post_serialize(
            property_id=property_id,
            source_id=source_id,
            third_party_identifier=third_party_identifier,
            start_date=start_date,
            end_date=end_date,
            guest_first_name=guest_first_name,
            guest_last_name=guest_last_name,
            guest_gender=guest_gender,
            guest_country=guest_country,
            guest_zip=guest_zip,
            guest_email=guest_email,
            guest_phone=guest_phone,
            guest_requirements=guest_requirements,
            estimated_arrival_time=estimated_arrival_time,
            rooms=rooms,
            adults=adults,
            children=children,
            payment_method=payment_method,
            card_token=card_token,
            payment_authorization_code=payment_authorization_code,
            custom_fields=custom_fields,
            promo_code=promo_code,
            allotment_block_code=allotment_block_code,
            group_code=group_code,
            date_created=date_created,
            send_email_confirmation=send_email_confirmation,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_reservation_post_serialize(
        self,
        property_id,
        source_id,
        third_party_identifier,
        start_date,
        end_date,
        guest_first_name,
        guest_last_name,
        guest_gender,
        guest_country,
        guest_zip,
        guest_email,
        guest_phone,
        guest_requirements,
        estimated_arrival_time,
        rooms,
        adults,
        children,
        payment_method,
        card_token,
        payment_authorization_code,
        custom_fields,
        promo_code,
        allotment_block_code,
        group_code,
        date_created,
        send_email_confirmation,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'guestRequirements': 'csv',
            'rooms': 'csv',
            'adults': 'csv',
            'children': 'csv',
            'customFields': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if source_id is not None:
            _form_params.append(('sourceID', source_id))
        if third_party_identifier is not None:
            _form_params.append(('thirdPartyIdentifier', third_party_identifier))
        if start_date is not None:
            _form_params.append(('startDate', start_date))
        if end_date is not None:
            _form_params.append(('endDate', end_date))
        if guest_first_name is not None:
            _form_params.append(('guestFirstName', guest_first_name))
        if guest_last_name is not None:
            _form_params.append(('guestLastName', guest_last_name))
        if guest_gender is not None:
            _form_params.append(('guestGender', guest_gender))
        if guest_country is not None:
            _form_params.append(('guestCountry', guest_country))
        if guest_zip is not None:
            _form_params.append(('guestZip', guest_zip))
        if guest_email is not None:
            _form_params.append(('guestEmail', guest_email))
        if guest_phone is not None:
            _form_params.append(('guestPhone', guest_phone))
        if guest_requirements is not None:
            _form_params.append(('guestRequirements', guest_requirements))
        if estimated_arrival_time is not None:
            _form_params.append(('estimatedArrivalTime', estimated_arrival_time))
        if rooms is not None:
            _form_params.append(('rooms', rooms))
        if adults is not None:
            _form_params.append(('adults', adults))
        if children is not None:
            _form_params.append(('children', children))
        if payment_method is not None:
            _form_params.append(('paymentMethod', payment_method))
        if card_token is not None:
            _form_params.append(('cardToken', card_token))
        if payment_authorization_code is not None:
            _form_params.append(('paymentAuthorizationCode', payment_authorization_code))
        if custom_fields is not None:
            _form_params.append(('customFields', custom_fields))
        if promo_code is not None:
            _form_params.append(('promoCode', promo_code))
        if allotment_block_code is not None:
            _form_params.append(('allotmentBlockCode', allotment_block_code))
        if group_code is not None:
            _form_params.append(('groupCode', group_code))
        if date_created is not None:
            _form_params.append(('dateCreated', date_created))
        if send_email_confirmation is not None:
            _form_params.append(('sendEmailConfirmation', send_email_confirmation))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postReservation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_reservation_note_put(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        reservation_note_id: Annotated[Optional[StrictStr], Field(description="Reservation Note ID")] = None,
        reservation_note: Annotated[Optional[StrictStr], Field(description="Note to be added to reservation")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PutReservationNoteResponse:
        """putReservationNote

        Updates an existing reservation note.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param reservation_note_id: Reservation Note ID
        :type reservation_note_id: str
        :param reservation_note: Note to be added to reservation
        :type reservation_note: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_reservation_note_put_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reservation_note_id=reservation_note_id,
            reservation_note=reservation_note,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_reservation_note_put_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        reservation_note_id: Annotated[Optional[StrictStr], Field(description="Reservation Note ID")] = None,
        reservation_note: Annotated[Optional[StrictStr], Field(description="Note to be added to reservation")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PutReservationNoteResponse]:
        """putReservationNote

        Updates an existing reservation note.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param reservation_note_id: Reservation Note ID
        :type reservation_note_id: str
        :param reservation_note: Note to be added to reservation
        :type reservation_note: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_reservation_note_put_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reservation_note_id=reservation_note_id,
            reservation_note=reservation_note,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_reservation_note_put_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier")] = None,
        reservation_note_id: Annotated[Optional[StrictStr], Field(description="Reservation Note ID")] = None,
        reservation_note: Annotated[Optional[StrictStr], Field(description="Note to be added to reservation")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """putReservationNote

        Updates an existing reservation note.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier
        :type reservation_id: str
        :param reservation_note_id: Reservation Note ID
        :type reservation_note_id: str
        :param reservation_note: Note to be added to reservation
        :type reservation_note: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_reservation_note_put_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reservation_note_id=reservation_note_id,
            reservation_note=reservation_note,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutReservationNoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_reservation_note_put_serialize(
        self,
        property_id,
        reservation_id,
        reservation_note_id,
        reservation_note,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if reservation_note_id is not None:
            _form_params.append(('reservationNoteID', reservation_note_id))
        if reservation_note is not None:
            _form_params.append(('reservationNote', reservation_note))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/putReservationNote',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_reservation_put(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier, one reservation ID per call.")] = None,
        estimated_arrival_time: Annotated[Optional[StrictStr], Field(description="Estimated Arrival Time, 24-hour format.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Reservation status<br /> 'confirmed' - Reservation is confirmed<br /> 'not_confirmed' - Reservation not passed confirmation<br /> 'canceled' - Reservation is canceled<br /> 'checked_in' - Guest is in hotel<br /> 'checked_out' - Guest already left hotel<br /> 'no_show' - Guest didn't showed up on check-in date")] = None,
        checkout_date: Annotated[Optional[date], Field(description="Update the checkoutDate across the whole reservation")] = None,
        custom_fields: Annotated[Optional[List[PutReservationRequestCustomFieldsInner]], Field(description="Array with custom fields information")] = None,
        rooms: Annotated[Optional[List[PutReservationRequestRoomsInner]], Field(description="Array with rooms information to change accommodations assigned to the reservation")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Date reservation was made. Do not change if omitted.")] = None,
        send_status_change_email: Annotated[Optional[StrictBool], Field(description="Send email on reservation status change to property and guest.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PutReservationResponse:
        """putReservation

        Updates a reservation, such as custom fields, estimated arrival time, room configuration and reservation status.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier, one reservation ID per call.
        :type reservation_id: str
        :param estimated_arrival_time: Estimated Arrival Time, 24-hour format.
        :type estimated_arrival_time: str
        :param status: Reservation status<br /> 'confirmed' - Reservation is confirmed<br /> 'not_confirmed' - Reservation not passed confirmation<br /> 'canceled' - Reservation is canceled<br /> 'checked_in' - Guest is in hotel<br /> 'checked_out' - Guest already left hotel<br /> 'no_show' - Guest didn't showed up on check-in date
        :type status: str
        :param checkout_date: Update the checkoutDate across the whole reservation
        :type checkout_date: date
        :param custom_fields: Array with custom fields information
        :type custom_fields: List[PutReservationRequestCustomFieldsInner]
        :param rooms: Array with rooms information to change accommodations assigned to the reservation
        :type rooms: List[PutReservationRequestRoomsInner]
        :param date_created: Date reservation was made. Do not change if omitted.
        :type date_created: datetime
        :param send_status_change_email: Send email on reservation status change to property and guest.
        :type send_status_change_email: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_reservation_put_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            estimated_arrival_time=estimated_arrival_time,
            status=status,
            checkout_date=checkout_date,
            custom_fields=custom_fields,
            rooms=rooms,
            date_created=date_created,
            send_status_change_email=send_status_change_email,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_reservation_put_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier, one reservation ID per call.")] = None,
        estimated_arrival_time: Annotated[Optional[StrictStr], Field(description="Estimated Arrival Time, 24-hour format.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Reservation status<br /> 'confirmed' - Reservation is confirmed<br /> 'not_confirmed' - Reservation not passed confirmation<br /> 'canceled' - Reservation is canceled<br /> 'checked_in' - Guest is in hotel<br /> 'checked_out' - Guest already left hotel<br /> 'no_show' - Guest didn't showed up on check-in date")] = None,
        checkout_date: Annotated[Optional[date], Field(description="Update the checkoutDate across the whole reservation")] = None,
        custom_fields: Annotated[Optional[List[PutReservationRequestCustomFieldsInner]], Field(description="Array with custom fields information")] = None,
        rooms: Annotated[Optional[List[PutReservationRequestRoomsInner]], Field(description="Array with rooms information to change accommodations assigned to the reservation")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Date reservation was made. Do not change if omitted.")] = None,
        send_status_change_email: Annotated[Optional[StrictBool], Field(description="Send email on reservation status change to property and guest.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PutReservationResponse]:
        """putReservation

        Updates a reservation, such as custom fields, estimated arrival time, room configuration and reservation status.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier, one reservation ID per call.
        :type reservation_id: str
        :param estimated_arrival_time: Estimated Arrival Time, 24-hour format.
        :type estimated_arrival_time: str
        :param status: Reservation status<br /> 'confirmed' - Reservation is confirmed<br /> 'not_confirmed' - Reservation not passed confirmation<br /> 'canceled' - Reservation is canceled<br /> 'checked_in' - Guest is in hotel<br /> 'checked_out' - Guest already left hotel<br /> 'no_show' - Guest didn't showed up on check-in date
        :type status: str
        :param checkout_date: Update the checkoutDate across the whole reservation
        :type checkout_date: date
        :param custom_fields: Array with custom fields information
        :type custom_fields: List[PutReservationRequestCustomFieldsInner]
        :param rooms: Array with rooms information to change accommodations assigned to the reservation
        :type rooms: List[PutReservationRequestRoomsInner]
        :param date_created: Date reservation was made. Do not change if omitted.
        :type date_created: datetime
        :param send_status_change_email: Send email on reservation status change to property and guest.
        :type send_status_change_email: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_reservation_put_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            estimated_arrival_time=estimated_arrival_time,
            status=status,
            checkout_date=checkout_date,
            custom_fields=custom_fields,
            rooms=rooms,
            date_created=date_created,
            send_status_change_email=send_status_change_email,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_reservation_put_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation Unique Identifier, one reservation ID per call.")] = None,
        estimated_arrival_time: Annotated[Optional[StrictStr], Field(description="Estimated Arrival Time, 24-hour format.")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Reservation status<br /> 'confirmed' - Reservation is confirmed<br /> 'not_confirmed' - Reservation not passed confirmation<br /> 'canceled' - Reservation is canceled<br /> 'checked_in' - Guest is in hotel<br /> 'checked_out' - Guest already left hotel<br /> 'no_show' - Guest didn't showed up on check-in date")] = None,
        checkout_date: Annotated[Optional[date], Field(description="Update the checkoutDate across the whole reservation")] = None,
        custom_fields: Annotated[Optional[List[PutReservationRequestCustomFieldsInner]], Field(description="Array with custom fields information")] = None,
        rooms: Annotated[Optional[List[PutReservationRequestRoomsInner]], Field(description="Array with rooms information to change accommodations assigned to the reservation")] = None,
        date_created: Annotated[Optional[datetime], Field(description="Date reservation was made. Do not change if omitted.")] = None,
        send_status_change_email: Annotated[Optional[StrictBool], Field(description="Send email on reservation status change to property and guest.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """putReservation

        Updates a reservation, such as custom fields, estimated arrival time, room configuration and reservation status.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation Unique Identifier, one reservation ID per call.
        :type reservation_id: str
        :param estimated_arrival_time: Estimated Arrival Time, 24-hour format.
        :type estimated_arrival_time: str
        :param status: Reservation status<br /> 'confirmed' - Reservation is confirmed<br /> 'not_confirmed' - Reservation not passed confirmation<br /> 'canceled' - Reservation is canceled<br /> 'checked_in' - Guest is in hotel<br /> 'checked_out' - Guest already left hotel<br /> 'no_show' - Guest didn't showed up on check-in date
        :type status: str
        :param checkout_date: Update the checkoutDate across the whole reservation
        :type checkout_date: date
        :param custom_fields: Array with custom fields information
        :type custom_fields: List[PutReservationRequestCustomFieldsInner]
        :param rooms: Array with rooms information to change accommodations assigned to the reservation
        :type rooms: List[PutReservationRequestRoomsInner]
        :param date_created: Date reservation was made. Do not change if omitted.
        :type date_created: datetime
        :param send_status_change_email: Send email on reservation status change to property and guest.
        :type send_status_change_email: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_reservation_put_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            estimated_arrival_time=estimated_arrival_time,
            status=status,
            checkout_date=checkout_date,
            custom_fields=custom_fields,
            rooms=rooms,
            date_created=date_created,
            send_status_change_email=send_status_change_email,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_reservation_put_serialize(
        self,
        property_id,
        reservation_id,
        estimated_arrival_time,
        status,
        checkout_date,
        custom_fields,
        rooms,
        date_created,
        send_status_change_email,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'customFields': 'csv',
            'rooms': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if estimated_arrival_time is not None:
            _form_params.append(('estimatedArrivalTime', estimated_arrival_time))
        if status is not None:
            _form_params.append(('status', status))
        if checkout_date is not None:
            _form_params.append(('checkoutDate', checkout_date))
        if custom_fields is not None:
            _form_params.append(('customFields', custom_fields))
        if rooms is not None:
            _form_params.append(('rooms', rooms))
        if date_created is not None:
            _form_params.append(('dateCreated', date_created))
        if send_status_change_email is not None:
            _form_params.append(('sendStatusChangeEmail', send_status_change_email))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/putReservation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


