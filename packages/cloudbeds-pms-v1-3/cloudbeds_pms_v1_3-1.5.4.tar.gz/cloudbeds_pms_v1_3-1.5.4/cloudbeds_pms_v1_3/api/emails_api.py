# coding: utf-8

"""
    Cloudbeds API

    <p>     Welcome to the documentation for <strong>Cloudbeds API Version v1.3</strong>!     If you are looking to learn how to use the Cloudbeds API to access guest information, reservations, or similar data     for your Cloudbeds customers, then you've come to the right place. </p>  <p>     In this document you will find all the API methods we provide along with explanations for parameters and response     examples. </p>  <p>     If you have questions about different implementation steps (e.g. how to implement OAuth 2.0), please refer to our     <a href=\"https://integrations.cloudbeds.com/hc/en-us\">Integrations Portal</a>. </p>  <p>     Be sure to <a href=\"https://go.pardot.com/l/308041/2018-07-24/qb2lg\">subscribe</a> to the monthly     Cloudbeds API announcement mailing list to receive information on new additions and improvements to the     Cloudbeds API and related developer tools. </p>  <p>     <strong>Endpoint:</strong> https://api.cloudbeds.com/api/v1.3/{method} </p>  <p>     <strong>HTTPS:</strong> Our API requires HTTPS. We'll respond with an appropriate error if you're not using it. </p>  <p>     <strong>Request Format:</strong> HTTP GET, POST and PUT (Content-Type: application/x-www-form-urlencoded) </p>  <p>     <strong>Response Format:</strong> JSON </p>  <p>     <strong>Response Header:</strong> X-Request-ID is added to response headers in all calls to help accelerate support     and troubleshooting. </p>  <p>     <strong>         <a href=\"https://integrations.cloudbeds.com/hc/en-us/articles/14104678058267-API-Documentation#postman-collection\">             <img src=\"https://run.pstmn.io/button.svg\" alt=\"Run in Postman\">         </a>     </strong> use this link to access our Public collection in Postman. </p>

    The version of the OpenAPI document: v1.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from cloudbeds_pms_v1_3.models.get_email_schedule_response import GetEmailScheduleResponse
from cloudbeds_pms_v1_3.models.get_email_templates_response import GetEmailTemplatesResponse
from cloudbeds_pms_v1_3.models.post_email_schedule_request_schedule import PostEmailScheduleRequestSchedule
from cloudbeds_pms_v1_3.models.post_email_schedule_response import PostEmailScheduleResponse
from cloudbeds_pms_v1_3.models.post_email_template_request_body import PostEmailTemplateRequestBody
from cloudbeds_pms_v1_3.models.post_email_template_request_subject import PostEmailTemplateRequestSubject
from cloudbeds_pms_v1_3.models.post_email_template_response import PostEmailTemplateResponse

from cloudbeds_pms_v1_3.api_client import ApiClient, RequestSerialized
from cloudbeds_pms_v1_3.api_response import ApiResponse
from cloudbeds_pms_v1_3.rest import RESTResponseType


class EmailsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_email_schedule_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetEmailScheduleResponse:
        """getEmailSchedule

        Returns a list of all existing email scheduling. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_email_schedule_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEmailScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_email_schedule_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetEmailScheduleResponse]:
        """getEmailSchedule

        Returns a list of all existing email scheduling. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_email_schedule_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEmailScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_email_schedule_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getEmailSchedule

        Returns a list of all existing email scheduling. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_email_schedule_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEmailScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_email_schedule_get_serialize(
        self,
        property_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getEmailSchedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_email_templates_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetEmailTemplatesResponse:
        """getEmailTemplates

        Returns a list of all existing email templates. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_email_templates_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEmailTemplatesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_email_templates_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetEmailTemplatesResponse]:
        """getEmailTemplates

        Returns a list of all existing email templates. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_email_templates_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEmailTemplatesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_email_templates_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getEmailTemplates

        Returns a list of all existing email templates. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_email_templates_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEmailTemplatesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_email_templates_get_serialize(
        self,
        property_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getEmailTemplates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_email_schedule_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        email_template_id: Annotated[Optional[StrictStr], Field(description="ID of the email template that will be used when sending an email.")] = None,
        schedule_name: Annotated[Optional[StrictStr], Field(description="User friendly schedule name that appears in the list. Should contain app name.")] = None,
        schedule: Optional[PostEmailScheduleRequestSchedule] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostEmailScheduleResponse:
        """postEmailSchedule

        Creates a new email schedule for existing email template. Email template can be scheduled based on two parameters: reservationStatusChange and reservationEvent. Only one of the parameters can be used. *reservationStatusChange* schedules email to be sent when reservation status transitions to a specific one, for instance: `confirmed`. *reservationEvent* schedules email to be sent number of days prior or after a specific event, for instance: `after_check_out` at a given time This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param email_template_id: ID of the email template that will be used when sending an email.
        :type email_template_id: str
        :param schedule_name: User friendly schedule name that appears in the list. Should contain app name.
        :type schedule_name: str
        :param schedule:
        :type schedule: PostEmailScheduleRequestSchedule
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_email_schedule_post_serialize(
            property_id=property_id,
            email_template_id=email_template_id,
            schedule_name=schedule_name,
            schedule=schedule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostEmailScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_email_schedule_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        email_template_id: Annotated[Optional[StrictStr], Field(description="ID of the email template that will be used when sending an email.")] = None,
        schedule_name: Annotated[Optional[StrictStr], Field(description="User friendly schedule name that appears in the list. Should contain app name.")] = None,
        schedule: Optional[PostEmailScheduleRequestSchedule] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostEmailScheduleResponse]:
        """postEmailSchedule

        Creates a new email schedule for existing email template. Email template can be scheduled based on two parameters: reservationStatusChange and reservationEvent. Only one of the parameters can be used. *reservationStatusChange* schedules email to be sent when reservation status transitions to a specific one, for instance: `confirmed`. *reservationEvent* schedules email to be sent number of days prior or after a specific event, for instance: `after_check_out` at a given time This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param email_template_id: ID of the email template that will be used when sending an email.
        :type email_template_id: str
        :param schedule_name: User friendly schedule name that appears in the list. Should contain app name.
        :type schedule_name: str
        :param schedule:
        :type schedule: PostEmailScheduleRequestSchedule
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_email_schedule_post_serialize(
            property_id=property_id,
            email_template_id=email_template_id,
            schedule_name=schedule_name,
            schedule=schedule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostEmailScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_email_schedule_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        email_template_id: Annotated[Optional[StrictStr], Field(description="ID of the email template that will be used when sending an email.")] = None,
        schedule_name: Annotated[Optional[StrictStr], Field(description="User friendly schedule name that appears in the list. Should contain app name.")] = None,
        schedule: Optional[PostEmailScheduleRequestSchedule] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postEmailSchedule

        Creates a new email schedule for existing email template. Email template can be scheduled based on two parameters: reservationStatusChange and reservationEvent. Only one of the parameters can be used. *reservationStatusChange* schedules email to be sent when reservation status transitions to a specific one, for instance: `confirmed`. *reservationEvent* schedules email to be sent number of days prior or after a specific event, for instance: `after_check_out` at a given time This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param email_template_id: ID of the email template that will be used when sending an email.
        :type email_template_id: str
        :param schedule_name: User friendly schedule name that appears in the list. Should contain app name.
        :type schedule_name: str
        :param schedule:
        :type schedule: PostEmailScheduleRequestSchedule
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_email_schedule_post_serialize(
            property_id=property_id,
            email_template_id=email_template_id,
            schedule_name=schedule_name,
            schedule=schedule,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostEmailScheduleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_email_schedule_post_serialize(
        self,
        property_id,
        email_template_id,
        schedule_name,
        schedule,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if email_template_id is not None:
            _form_params.append(('emailTemplateID', email_template_id))
        if schedule_name is not None:
            _form_params.append(('scheduleName', schedule_name))
        if schedule is not None:
            _form_params.append(('schedule', schedule))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postEmailSchedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_email_template_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        email_type: Annotated[Optional[StrictStr], Field(description="Type of the email template: Marketing or Non-Marketing. Only applicable to GDPR-compliant properties.")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Template name")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="Email address from which the email message may be sent")] = None,
        from_name: Annotated[Optional[StrictStr], Field(description="from which the email message may be sent. If empty email will be used")] = None,
        subject: Optional[PostEmailTemplateRequestSubject] = None,
        body: Optional[PostEmailTemplateRequestBody] = None,
        reply_to: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be replied. If empty, the value on from parameter will be used.")] = None,
        reply_to_name: Annotated[Optional[StrictStr], Field(description="Name to which the email message may be replied. If empty, email will be used.")] = None,
        autofill_all_languages: Annotated[Optional[StrictBool], Field(description="If set, all languages will be set with the value for the property language. If not informed and only one language is sent, it's considered true, if more than one language is sent, it'll be considered false.")] = None,
        cc: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be sent as a Carbon Copy")] = None,
        bcc: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be sent as a Blind Carbon Copy")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostEmailTemplateResponse:
        """postEmailTemplate

        Creates a new email template. See the full list of available language parameters <a href=\"https://integrations.cloudbeds.com/hc/en-us/articles/360007144993-FAQ#methods-and-parameters\">here</a>. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param email_type: Type of the email template: Marketing or Non-Marketing. Only applicable to GDPR-compliant properties.
        :type email_type: str
        :param name: Template name
        :type name: str
        :param var_from: Email address from which the email message may be sent
        :type var_from: str
        :param from_name: from which the email message may be sent. If empty email will be used
        :type from_name: str
        :param subject:
        :type subject: PostEmailTemplateRequestSubject
        :param body:
        :type body: PostEmailTemplateRequestBody
        :param reply_to: Email address to which the email message may be replied. If empty, the value on from parameter will be used.
        :type reply_to: str
        :param reply_to_name: Name to which the email message may be replied. If empty, email will be used.
        :type reply_to_name: str
        :param autofill_all_languages: If set, all languages will be set with the value for the property language. If not informed and only one language is sent, it's considered true, if more than one language is sent, it'll be considered false.
        :type autofill_all_languages: bool
        :param cc: Email address to which the email message may be sent as a Carbon Copy
        :type cc: str
        :param bcc: Email address to which the email message may be sent as a Blind Carbon Copy
        :type bcc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_email_template_post_serialize(
            property_id=property_id,
            email_type=email_type,
            name=name,
            var_from=var_from,
            from_name=from_name,
            subject=subject,
            body=body,
            reply_to=reply_to,
            reply_to_name=reply_to_name,
            autofill_all_languages=autofill_all_languages,
            cc=cc,
            bcc=bcc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostEmailTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_email_template_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        email_type: Annotated[Optional[StrictStr], Field(description="Type of the email template: Marketing or Non-Marketing. Only applicable to GDPR-compliant properties.")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Template name")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="Email address from which the email message may be sent")] = None,
        from_name: Annotated[Optional[StrictStr], Field(description="from which the email message may be sent. If empty email will be used")] = None,
        subject: Optional[PostEmailTemplateRequestSubject] = None,
        body: Optional[PostEmailTemplateRequestBody] = None,
        reply_to: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be replied. If empty, the value on from parameter will be used.")] = None,
        reply_to_name: Annotated[Optional[StrictStr], Field(description="Name to which the email message may be replied. If empty, email will be used.")] = None,
        autofill_all_languages: Annotated[Optional[StrictBool], Field(description="If set, all languages will be set with the value for the property language. If not informed and only one language is sent, it's considered true, if more than one language is sent, it'll be considered false.")] = None,
        cc: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be sent as a Carbon Copy")] = None,
        bcc: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be sent as a Blind Carbon Copy")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostEmailTemplateResponse]:
        """postEmailTemplate

        Creates a new email template. See the full list of available language parameters <a href=\"https://integrations.cloudbeds.com/hc/en-us/articles/360007144993-FAQ#methods-and-parameters\">here</a>. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param email_type: Type of the email template: Marketing or Non-Marketing. Only applicable to GDPR-compliant properties.
        :type email_type: str
        :param name: Template name
        :type name: str
        :param var_from: Email address from which the email message may be sent
        :type var_from: str
        :param from_name: from which the email message may be sent. If empty email will be used
        :type from_name: str
        :param subject:
        :type subject: PostEmailTemplateRequestSubject
        :param body:
        :type body: PostEmailTemplateRequestBody
        :param reply_to: Email address to which the email message may be replied. If empty, the value on from parameter will be used.
        :type reply_to: str
        :param reply_to_name: Name to which the email message may be replied. If empty, email will be used.
        :type reply_to_name: str
        :param autofill_all_languages: If set, all languages will be set with the value for the property language. If not informed and only one language is sent, it's considered true, if more than one language is sent, it'll be considered false.
        :type autofill_all_languages: bool
        :param cc: Email address to which the email message may be sent as a Carbon Copy
        :type cc: str
        :param bcc: Email address to which the email message may be sent as a Blind Carbon Copy
        :type bcc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_email_template_post_serialize(
            property_id=property_id,
            email_type=email_type,
            name=name,
            var_from=var_from,
            from_name=from_name,
            subject=subject,
            body=body,
            reply_to=reply_to,
            reply_to_name=reply_to_name,
            autofill_all_languages=autofill_all_languages,
            cc=cc,
            bcc=bcc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostEmailTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_email_template_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        email_type: Annotated[Optional[StrictStr], Field(description="Type of the email template: Marketing or Non-Marketing. Only applicable to GDPR-compliant properties.")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Template name")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="Email address from which the email message may be sent")] = None,
        from_name: Annotated[Optional[StrictStr], Field(description="from which the email message may be sent. If empty email will be used")] = None,
        subject: Optional[PostEmailTemplateRequestSubject] = None,
        body: Optional[PostEmailTemplateRequestBody] = None,
        reply_to: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be replied. If empty, the value on from parameter will be used.")] = None,
        reply_to_name: Annotated[Optional[StrictStr], Field(description="Name to which the email message may be replied. If empty, email will be used.")] = None,
        autofill_all_languages: Annotated[Optional[StrictBool], Field(description="If set, all languages will be set with the value for the property language. If not informed and only one language is sent, it's considered true, if more than one language is sent, it'll be considered false.")] = None,
        cc: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be sent as a Carbon Copy")] = None,
        bcc: Annotated[Optional[StrictStr], Field(description="Email address to which the email message may be sent as a Blind Carbon Copy")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postEmailTemplate

        Creates a new email template. See the full list of available language parameters <a href=\"https://integrations.cloudbeds.com/hc/en-us/articles/360007144993-FAQ#methods-and-parameters\">here</a>. This call is only available for third-party integration partners, and not for property client IDs.

        :param property_id: Property ID
        :type property_id: str
        :param email_type: Type of the email template: Marketing or Non-Marketing. Only applicable to GDPR-compliant properties.
        :type email_type: str
        :param name: Template name
        :type name: str
        :param var_from: Email address from which the email message may be sent
        :type var_from: str
        :param from_name: from which the email message may be sent. If empty email will be used
        :type from_name: str
        :param subject:
        :type subject: PostEmailTemplateRequestSubject
        :param body:
        :type body: PostEmailTemplateRequestBody
        :param reply_to: Email address to which the email message may be replied. If empty, the value on from parameter will be used.
        :type reply_to: str
        :param reply_to_name: Name to which the email message may be replied. If empty, email will be used.
        :type reply_to_name: str
        :param autofill_all_languages: If set, all languages will be set with the value for the property language. If not informed and only one language is sent, it's considered true, if more than one language is sent, it'll be considered false.
        :type autofill_all_languages: bool
        :param cc: Email address to which the email message may be sent as a Carbon Copy
        :type cc: str
        :param bcc: Email address to which the email message may be sent as a Blind Carbon Copy
        :type bcc: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_email_template_post_serialize(
            property_id=property_id,
            email_type=email_type,
            name=name,
            var_from=var_from,
            from_name=from_name,
            subject=subject,
            body=body,
            reply_to=reply_to,
            reply_to_name=reply_to_name,
            autofill_all_languages=autofill_all_languages,
            cc=cc,
            bcc=bcc,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostEmailTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_email_template_post_serialize(
        self,
        property_id,
        email_type,
        name,
        var_from,
        from_name,
        subject,
        body,
        reply_to,
        reply_to_name,
        autofill_all_languages,
        cc,
        bcc,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if email_type is not None:
            _form_params.append(('emailType', email_type))
        if name is not None:
            _form_params.append(('name', name))
        if var_from is not None:
            _form_params.append(('from', var_from))
        if from_name is not None:
            _form_params.append(('fromName', from_name))
        if subject is not None:
            _form_params.append(('subject', subject))
        if body is not None:
            _form_params.append(('body', body))
        if reply_to is not None:
            _form_params.append(('replyTo', reply_to))
        if reply_to_name is not None:
            _form_params.append(('replyToName', reply_to_name))
        if autofill_all_languages is not None:
            _form_params.append(('autofillAllLanguages', autofill_all_languages))
        if cc is not None:
            _form_params.append(('cc', cc))
        if bcc is not None:
            _form_params.append(('bcc', bcc))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postEmailTemplate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


