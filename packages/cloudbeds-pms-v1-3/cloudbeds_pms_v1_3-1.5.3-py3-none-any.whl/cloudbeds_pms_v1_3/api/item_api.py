# coding: utf-8

"""
    Cloudbeds API

    <p>     Welcome to the documentation for <strong>Cloudbeds API Version v1.3</strong>!     If you are looking to learn how to use the Cloudbeds API to access guest information, reservations, or similar data     for your Cloudbeds customers, then you've come to the right place. </p>  <p>     In this document you will find all the API methods we provide along with explanations for parameters and response     examples. </p>  <p>     If you have questions about different implementation steps (e.g. how to implement OAuth 2.0), please refer to our     <a href=\"https://integrations.cloudbeds.com/hc/en-us\">Integrations Portal</a>. </p>  <p>     Be sure to <a href=\"https://go.pardot.com/l/308041/2018-07-24/qb2lg\">subscribe</a> to the monthly     Cloudbeds API announcement mailing list to receive information on new additions and improvements to the     Cloudbeds API and related developer tools. </p>  <p>     <strong>Endpoint:</strong> https://api.cloudbeds.com/api/v1.3/{method} </p>  <p>     <strong>HTTPS:</strong> Our API requires HTTPS. We'll respond with an appropriate error if you're not using it. </p>  <p>     <strong>Request Format:</strong> HTTP GET, POST and PUT (Content-Type: application/x-www-form-urlencoded) </p>  <p>     <strong>Response Format:</strong> JSON </p>  <p>     <strong>Response Header:</strong> X-Request-ID is added to response headers in all calls to help accelerate support     and troubleshooting. </p>  <p>     <strong>         <a href=\"https://integrations.cloudbeds.com/hc/en-us/articles/14104678058267-API-Documentation#postman-collection\">             <img src=\"https://run.pstmn.io/button.svg\" alt=\"Run in Postman\">         </a>     </strong> use this link to access our Public collection in Postman. </p>

    The version of the OpenAPI document: v1.3
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from cloudbeds_pms_v1_3.models.get_item_categories_response import GetItemCategoriesResponse
from cloudbeds_pms_v1_3.models.get_item_response import GetItemResponse
from cloudbeds_pms_v1_3.models.get_items_response import GetItemsResponse
from cloudbeds_pms_v1_3.models.post_append_custom_item_response import PostAppendCustomItemResponse
from cloudbeds_pms_v1_3.models.post_custom_item_request_items_inner import PostCustomItemRequestItemsInner
from cloudbeds_pms_v1_3.models.post_custom_item_request_payments_inner import PostCustomItemRequestPaymentsInner
from cloudbeds_pms_v1_3.models.post_custom_item_response import PostCustomItemResponse
from cloudbeds_pms_v1_3.models.post_item_category_response import PostItemCategoryResponse
from cloudbeds_pms_v1_3.models.post_item_request_payments_inner import PostItemRequestPaymentsInner
from cloudbeds_pms_v1_3.models.post_item_response import PostItemResponse
from cloudbeds_pms_v1_3.models.post_items_to_inventory_request_item import PostItemsToInventoryRequestItem
from cloudbeds_pms_v1_3.models.post_items_to_inventory_response import PostItemsToInventoryResponse
from cloudbeds_pms_v1_3.models.post_void_item_response import PostVoidItemResponse
from cloudbeds_pms_v1_3.models.put_item_to_inventory_response import PutItemToInventoryResponse

from cloudbeds_pms_v1_3.api_client import ApiClient, RequestSerialized
from cloudbeds_pms_v1_3.api_response import ApiResponse
from cloudbeds_pms_v1_3.rest import RESTResponseType


class ItemApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def append_custom_item_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID is provided.")] = None,
        reference_id: Annotated[Optional[StrictStr], Field(description="partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room identifier (Ignored if subReservationID exist)")] = None,
        items: Annotated[Optional[List[PostCustomItemRequestItemsInner]], Field(description="list of items will be posted")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest identifier")] = None,
        guest_name: Annotated[Optional[StrictStr], Field(description="(Ignored if guestID exist)")] = None,
        payments: Annotated[Optional[List[PostCustomItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostAppendCustomItemResponse:
        """appendCustomItem

        Append single, or multiple, custom items and their associated payments to a existing one in a Reservation.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID is provided.
        :type reservation_id: str
        :param reference_id: partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates
        :type reference_id: str
        :param sub_reservation_id: Sub Reservation identifier
        :type sub_reservation_id: str
        :param room_id: Room identifier (Ignored if subReservationID exist)
        :type room_id: str
        :param items: list of items will be posted
        :type items: List[PostCustomItemRequestItemsInner]
        :param sale_date: posting date
        :type sale_date: datetime
        :param guest_id: Guest identifier
        :type guest_id: str
        :param guest_name: (Ignored if guestID exist)
        :type guest_name: str
        :param payments: list of payments If the item is already paid
        :type payments: List[PostCustomItemRequestPaymentsInner]
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)
        :type item_paid: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._append_custom_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reference_id=reference_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            items=items,
            sale_date=sale_date,
            guest_id=guest_id,
            guest_name=guest_name,
            payments=payments,
            item_paid=item_paid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostAppendCustomItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def append_custom_item_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID is provided.")] = None,
        reference_id: Annotated[Optional[StrictStr], Field(description="partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room identifier (Ignored if subReservationID exist)")] = None,
        items: Annotated[Optional[List[PostCustomItemRequestItemsInner]], Field(description="list of items will be posted")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest identifier")] = None,
        guest_name: Annotated[Optional[StrictStr], Field(description="(Ignored if guestID exist)")] = None,
        payments: Annotated[Optional[List[PostCustomItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostAppendCustomItemResponse]:
        """appendCustomItem

        Append single, or multiple, custom items and their associated payments to a existing one in a Reservation.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID is provided.
        :type reservation_id: str
        :param reference_id: partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates
        :type reference_id: str
        :param sub_reservation_id: Sub Reservation identifier
        :type sub_reservation_id: str
        :param room_id: Room identifier (Ignored if subReservationID exist)
        :type room_id: str
        :param items: list of items will be posted
        :type items: List[PostCustomItemRequestItemsInner]
        :param sale_date: posting date
        :type sale_date: datetime
        :param guest_id: Guest identifier
        :type guest_id: str
        :param guest_name: (Ignored if guestID exist)
        :type guest_name: str
        :param payments: list of payments If the item is already paid
        :type payments: List[PostCustomItemRequestPaymentsInner]
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)
        :type item_paid: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._append_custom_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reference_id=reference_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            items=items,
            sale_date=sale_date,
            guest_id=guest_id,
            guest_name=guest_name,
            payments=payments,
            item_paid=item_paid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostAppendCustomItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def append_custom_item_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID is provided.")] = None,
        reference_id: Annotated[Optional[StrictStr], Field(description="partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room identifier (Ignored if subReservationID exist)")] = None,
        items: Annotated[Optional[List[PostCustomItemRequestItemsInner]], Field(description="list of items will be posted")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest identifier")] = None,
        guest_name: Annotated[Optional[StrictStr], Field(description="(Ignored if guestID exist)")] = None,
        payments: Annotated[Optional[List[PostCustomItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """appendCustomItem

        Append single, or multiple, custom items and their associated payments to a existing one in a Reservation.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID is provided.
        :type reservation_id: str
        :param reference_id: partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates
        :type reference_id: str
        :param sub_reservation_id: Sub Reservation identifier
        :type sub_reservation_id: str
        :param room_id: Room identifier (Ignored if subReservationID exist)
        :type room_id: str
        :param items: list of items will be posted
        :type items: List[PostCustomItemRequestItemsInner]
        :param sale_date: posting date
        :type sale_date: datetime
        :param guest_id: Guest identifier
        :type guest_id: str
        :param guest_name: (Ignored if guestID exist)
        :type guest_name: str
        :param payments: list of payments If the item is already paid
        :type payments: List[PostCustomItemRequestPaymentsInner]
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)
        :type item_paid: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._append_custom_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            reference_id=reference_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            items=items,
            sale_date=sale_date,
            guest_id=guest_id,
            guest_name=guest_name,
            payments=payments,
            item_paid=item_paid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostAppendCustomItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _append_custom_item_post_serialize(
        self,
        property_id,
        reservation_id,
        reference_id,
        sub_reservation_id,
        room_id,
        items,
        sale_date,
        guest_id,
        guest_name,
        payments,
        item_paid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'items': 'csv',
            'payments': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if reference_id is not None:
            _form_params.append(('referenceID', reference_id))
        if sub_reservation_id is not None:
            _form_params.append(('subReservationID', sub_reservation_id))
        if room_id is not None:
            _form_params.append(('roomID', room_id))
        if items is not None:
            _form_params.append(('items', items))
        if sale_date is not None:
            _form_params.append(('saleDate', sale_date))
        if guest_id is not None:
            _form_params.append(('guestID', guest_id))
        if guest_name is not None:
            _form_params.append(('guestName', guest_name))
        if payments is not None:
            _form_params.append(('payments', payments))
        if item_paid is not None:
            _form_params.append(('itemPaid', item_paid))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/appendCustomItem',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_item_categories_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetItemCategoriesResponse:
        """getItemCategories

        Gets the item category list

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_item_categories_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemCategoriesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_item_categories_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetItemCategoriesResponse]:
        """getItemCategories

        Gets the item category list

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_item_categories_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemCategoriesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_item_categories_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getItemCategories

        Gets the item category list

        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_item_categories_get_serialize(
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemCategoriesResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_item_categories_get_serialize(
        self,
        property_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getItemCategories',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_item_get(
        self,
        item_id: Annotated[StrictStr, Field(description="Item identifier")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetItemResponse:
        """getItem

        Gets the details for the one itemID<br /> <sup>1</sup> only if data.stockInventory = true<br> <sup>2</sup> Taxes, fees and totals will show up only if an item has assigned tax or fee.<br>

        :param item_id: Item identifier (required)
        :type item_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_item_get_serialize(
            item_id=item_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_item_get_with_http_info(
        self,
        item_id: Annotated[StrictStr, Field(description="Item identifier")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetItemResponse]:
        """getItem

        Gets the details for the one itemID<br /> <sup>1</sup> only if data.stockInventory = true<br> <sup>2</sup> Taxes, fees and totals will show up only if an item has assigned tax or fee.<br>

        :param item_id: Item identifier (required)
        :type item_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_item_get_serialize(
            item_id=item_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_item_get_without_preload_content(
        self,
        item_id: Annotated[StrictStr, Field(description="Item identifier")],
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getItem

        Gets the details for the one itemID<br /> <sup>1</sup> only if data.stockInventory = true<br> <sup>2</sup> Taxes, fees and totals will show up only if an item has assigned tax or fee.<br>

        :param item_id: Item identifier (required)
        :type item_id: str
        :param property_id: Property ID
        :type property_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_item_get_serialize(
            item_id=item_id,
            property_id=property_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_item_get_serialize(
        self,
        item_id,
        property_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if item_id is not None:
            
            _query_params.append(('itemID', item_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getItem',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_items_get(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        item_category_id: Annotated[Optional[StrictStr], Field(description="Category identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetItemsResponse:
        """getItems

        Gets all the items and their prices the hotel has created in myfrontdesk<br> <sup>1</sup> only if data.stockInventory = true<br> <sup>2</sup> Taxes, fees and totals will show up only if an item has assigned tax or fee.<br>

        :param property_id: Property ID
        :type property_id: str
        :param item_category_id: Category identifier
        :type item_category_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_items_get_serialize(
            property_id=property_id,
            item_category_id=item_category_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_items_get_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        item_category_id: Annotated[Optional[StrictStr], Field(description="Category identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetItemsResponse]:
        """getItems

        Gets all the items and their prices the hotel has created in myfrontdesk<br> <sup>1</sup> only if data.stockInventory = true<br> <sup>2</sup> Taxes, fees and totals will show up only if an item has assigned tax or fee.<br>

        :param property_id: Property ID
        :type property_id: str
        :param item_category_id: Category identifier
        :type item_category_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_items_get_serialize(
            property_id=property_id,
            item_category_id=item_category_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_items_get_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        item_category_id: Annotated[Optional[StrictStr], Field(description="Category identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """getItems

        Gets all the items and their prices the hotel has created in myfrontdesk<br> <sup>1</sup> only if data.stockInventory = true<br> <sup>2</sup> Taxes, fees and totals will show up only if an item has assigned tax or fee.<br>

        :param property_id: Property ID
        :type property_id: str
        :param item_category_id: Category identifier
        :type item_category_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_items_get_serialize(
            property_id=property_id,
            item_category_id=item_category_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetItemsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_items_get_serialize(
        self,
        property_id,
        item_category_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if property_id is not None:
            
            _query_params.append(('propertyID', property_id))
            
        if item_category_id is not None:
            
            _query_params.append(('itemCategoryID', item_category_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/getItems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_custom_item_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        reference_id: Annotated[Optional[StrictStr], Field(description="partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room identifier (Ignored if subReservationID exist)")] = None,
        items: Annotated[Optional[List[PostCustomItemRequestItemsInner]], Field(description="list of items will be posted")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest identifier")] = None,
        guest_name: Annotated[Optional[StrictStr], Field(description="(Ignored if guestID exist)")] = None,
        payments: Annotated[Optional[List[PostCustomItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostCustomItemResponse:
        """postCustomItem

        Adds single, or multiple, custom items and their associated payments to a Reservation or House Account as a single transaction.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param reference_id: partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates
        :type reference_id: str
        :param sub_reservation_id: Sub Reservation identifier
        :type sub_reservation_id: str
        :param room_id: Room identifier (Ignored if subReservationID exist)
        :type room_id: str
        :param items: list of items will be posted
        :type items: List[PostCustomItemRequestItemsInner]
        :param sale_date: posting date
        :type sale_date: datetime
        :param guest_id: Guest identifier
        :type guest_id: str
        :param guest_name: (Ignored if guestID exist)
        :type guest_name: str
        :param payments: list of payments If the item is already paid
        :type payments: List[PostCustomItemRequestPaymentsInner]
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)
        :type item_paid: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_custom_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            reference_id=reference_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            items=items,
            sale_date=sale_date,
            guest_id=guest_id,
            guest_name=guest_name,
            payments=payments,
            item_paid=item_paid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCustomItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_custom_item_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        reference_id: Annotated[Optional[StrictStr], Field(description="partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room identifier (Ignored if subReservationID exist)")] = None,
        items: Annotated[Optional[List[PostCustomItemRequestItemsInner]], Field(description="list of items will be posted")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest identifier")] = None,
        guest_name: Annotated[Optional[StrictStr], Field(description="(Ignored if guestID exist)")] = None,
        payments: Annotated[Optional[List[PostCustomItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostCustomItemResponse]:
        """postCustomItem

        Adds single, or multiple, custom items and their associated payments to a Reservation or House Account as a single transaction.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param reference_id: partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates
        :type reference_id: str
        :param sub_reservation_id: Sub Reservation identifier
        :type sub_reservation_id: str
        :param room_id: Room identifier (Ignored if subReservationID exist)
        :type room_id: str
        :param items: list of items will be posted
        :type items: List[PostCustomItemRequestItemsInner]
        :param sale_date: posting date
        :type sale_date: datetime
        :param guest_id: Guest identifier
        :type guest_id: str
        :param guest_name: (Ignored if guestID exist)
        :type guest_name: str
        :param payments: list of payments If the item is already paid
        :type payments: List[PostCustomItemRequestPaymentsInner]
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)
        :type item_paid: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_custom_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            reference_id=reference_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            items=items,
            sale_date=sale_date,
            guest_id=guest_id,
            guest_name=guest_name,
            payments=payments,
            item_paid=item_paid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCustomItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_custom_item_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        reference_id: Annotated[Optional[StrictStr], Field(description="partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier")] = None,
        room_id: Annotated[Optional[StrictStr], Field(description="Room identifier (Ignored if subReservationID exist)")] = None,
        items: Annotated[Optional[List[PostCustomItemRequestItemsInner]], Field(description="list of items will be posted")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        guest_id: Annotated[Optional[StrictStr], Field(description="Guest identifier")] = None,
        guest_name: Annotated[Optional[StrictStr], Field(description="(Ignored if guestID exist)")] = None,
        payments: Annotated[Optional[List[PostCustomItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postCustomItem

        Adds single, or multiple, custom items and their associated payments to a Reservation or House Account as a single transaction.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param reference_id: partner's transaction reference. If exist then Cloudbeds will prevent adding of duplicates
        :type reference_id: str
        :param sub_reservation_id: Sub Reservation identifier
        :type sub_reservation_id: str
        :param room_id: Room identifier (Ignored if subReservationID exist)
        :type room_id: str
        :param items: list of items will be posted
        :type items: List[PostCustomItemRequestItemsInner]
        :param sale_date: posting date
        :type sale_date: datetime
        :param guest_id: Guest identifier
        :type guest_id: str
        :param guest_name: (Ignored if guestID exist)
        :type guest_name: str
        :param payments: list of payments If the item is already paid
        :type payments: List[PostCustomItemRequestPaymentsInner]
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. (Ignored if payments array exist)
        :type item_paid: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_custom_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            reference_id=reference_id,
            sub_reservation_id=sub_reservation_id,
            room_id=room_id,
            items=items,
            sale_date=sale_date,
            guest_id=guest_id,
            guest_name=guest_name,
            payments=payments,
            item_paid=item_paid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostCustomItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_custom_item_post_serialize(
        self,
        property_id,
        reservation_id,
        house_account_id,
        group_code,
        reference_id,
        sub_reservation_id,
        room_id,
        items,
        sale_date,
        guest_id,
        guest_name,
        payments,
        item_paid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'items': 'csv',
            'payments': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if house_account_id is not None:
            _form_params.append(('houseAccountID', house_account_id))
        if group_code is not None:
            _form_params.append(('groupCode', group_code))
        if reference_id is not None:
            _form_params.append(('referenceID', reference_id))
        if sub_reservation_id is not None:
            _form_params.append(('subReservationID', sub_reservation_id))
        if room_id is not None:
            _form_params.append(('roomID', room_id))
        if items is not None:
            _form_params.append(('items', items))
        if sale_date is not None:
            _form_params.append(('saleDate', sale_date))
        if guest_id is not None:
            _form_params.append(('guestID', guest_id))
        if guest_name is not None:
            _form_params.append(('guestName', guest_name))
        if payments is not None:
            _form_params.append(('payments', payments))
        if item_paid is not None:
            _form_params.append(('itemPaid', item_paid))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postCustomItem',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_item_category_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        category_name: Annotated[Optional[StrictStr], Field(description="Category name")] = None,
        category_code: Annotated[Optional[StrictStr], Field(description="Category code")] = None,
        item_id: Annotated[Optional[List[StrictInt]], Field(description="Existing ItemIDs to reassign to new category")] = None,
        category_color: Annotated[Optional[StrictStr], Field(description="Category color (like #3b7be7)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostItemCategoryResponse:
        """postItemCategory

        Adds new items category

        :param property_id: Property ID
        :type property_id: str
        :param category_name: Category name
        :type category_name: str
        :param category_code: Category code
        :type category_code: str
        :param item_id: Existing ItemIDs to reassign to new category
        :type item_id: List[int]
        :param category_color: Category color (like #3b7be7)
        :type category_color: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_item_category_post_serialize(
            property_id=property_id,
            category_name=category_name,
            category_code=category_code,
            item_id=item_id,
            category_color=category_color,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemCategoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_item_category_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        category_name: Annotated[Optional[StrictStr], Field(description="Category name")] = None,
        category_code: Annotated[Optional[StrictStr], Field(description="Category code")] = None,
        item_id: Annotated[Optional[List[StrictInt]], Field(description="Existing ItemIDs to reassign to new category")] = None,
        category_color: Annotated[Optional[StrictStr], Field(description="Category color (like #3b7be7)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostItemCategoryResponse]:
        """postItemCategory

        Adds new items category

        :param property_id: Property ID
        :type property_id: str
        :param category_name: Category name
        :type category_name: str
        :param category_code: Category code
        :type category_code: str
        :param item_id: Existing ItemIDs to reassign to new category
        :type item_id: List[int]
        :param category_color: Category color (like #3b7be7)
        :type category_color: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_item_category_post_serialize(
            property_id=property_id,
            category_name=category_name,
            category_code=category_code,
            item_id=item_id,
            category_color=category_color,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemCategoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_item_category_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        category_name: Annotated[Optional[StrictStr], Field(description="Category name")] = None,
        category_code: Annotated[Optional[StrictStr], Field(description="Category code")] = None,
        item_id: Annotated[Optional[List[StrictInt]], Field(description="Existing ItemIDs to reassign to new category")] = None,
        category_color: Annotated[Optional[StrictStr], Field(description="Category color (like #3b7be7)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postItemCategory

        Adds new items category

        :param property_id: Property ID
        :type property_id: str
        :param category_name: Category name
        :type category_name: str
        :param category_code: Category code
        :type category_code: str
        :param item_id: Existing ItemIDs to reassign to new category
        :type item_id: List[int]
        :param category_color: Category color (like #3b7be7)
        :type category_color: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_item_category_post_serialize(
            property_id=property_id,
            category_name=category_name,
            category_code=category_code,
            item_id=item_id,
            category_color=category_color,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemCategoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_item_category_post_serialize(
        self,
        property_id,
        category_name,
        category_code,
        item_id,
        category_color,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'itemID': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if category_name is not None:
            _form_params.append(('categoryName', category_name))
        if category_code is not None:
            _form_params.append(('categoryCode', category_code))
        if item_id is not None:
            _form_params.append(('itemID', item_id))
        if category_color is not None:
            _form_params.append(('categoryColor', category_color))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postItemCategory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_item_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier.")] = None,
        item_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        item_quantity: Annotated[Optional[StrictInt], Field(description="Items quantity")] = None,
        item_price: Annotated[Optional[StrictStr], Field(description="Item price, if not sent, items registered price will be used")] = None,
        item_note: Annotated[Optional[StrictStr], Field(description="Item note")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. If payments is set, itemPaid is ignored.")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        payments: Annotated[Optional[List[PostItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostItemResponse:
        """postItem

        Adds an item either to a reservation or to a house account.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param sub_reservation_id: Sub Reservation identifier.
        :type sub_reservation_id: str
        :param item_id: Item identifier
        :type item_id: str
        :param item_quantity: Items quantity
        :type item_quantity: int
        :param item_price: Item price, if not sent, items registered price will be used
        :type item_price: str
        :param item_note: Item note
        :type item_note: str
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. If payments is set, itemPaid is ignored.
        :type item_paid: bool
        :param sale_date: posting date
        :type sale_date: datetime
        :param payments: list of payments If the item is already paid
        :type payments: List[PostItemRequestPaymentsInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            sub_reservation_id=sub_reservation_id,
            item_id=item_id,
            item_quantity=item_quantity,
            item_price=item_price,
            item_note=item_note,
            item_paid=item_paid,
            sale_date=sale_date,
            payments=payments,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_item_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier.")] = None,
        item_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        item_quantity: Annotated[Optional[StrictInt], Field(description="Items quantity")] = None,
        item_price: Annotated[Optional[StrictStr], Field(description="Item price, if not sent, items registered price will be used")] = None,
        item_note: Annotated[Optional[StrictStr], Field(description="Item note")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. If payments is set, itemPaid is ignored.")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        payments: Annotated[Optional[List[PostItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostItemResponse]:
        """postItem

        Adds an item either to a reservation or to a house account.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param sub_reservation_id: Sub Reservation identifier.
        :type sub_reservation_id: str
        :param item_id: Item identifier
        :type item_id: str
        :param item_quantity: Items quantity
        :type item_quantity: int
        :param item_price: Item price, if not sent, items registered price will be used
        :type item_price: str
        :param item_note: Item note
        :type item_note: str
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. If payments is set, itemPaid is ignored.
        :type item_paid: bool
        :param sale_date: posting date
        :type sale_date: datetime
        :param payments: list of payments If the item is already paid
        :type payments: List[PostItemRequestPaymentsInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            sub_reservation_id=sub_reservation_id,
            item_id=item_id,
            item_quantity=item_quantity,
            item_price=item_price,
            item_note=item_note,
            item_paid=item_paid,
            sale_date=sale_date,
            payments=payments,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_item_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        sub_reservation_id: Annotated[Optional[StrictStr], Field(description="Sub Reservation identifier.")] = None,
        item_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        item_quantity: Annotated[Optional[StrictInt], Field(description="Items quantity")] = None,
        item_price: Annotated[Optional[StrictStr], Field(description="Item price, if not sent, items registered price will be used")] = None,
        item_note: Annotated[Optional[StrictStr], Field(description="Item note")] = None,
        item_paid: Annotated[Optional[StrictBool], Field(description="If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. If payments is set, itemPaid is ignored.")] = None,
        sale_date: Annotated[Optional[datetime], Field(description="posting date")] = None,
        payments: Annotated[Optional[List[PostItemRequestPaymentsInner]], Field(description="list of payments If the item is already paid")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postItem

        Adds an item either to a reservation or to a house account.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param sub_reservation_id: Sub Reservation identifier.
        :type sub_reservation_id: str
        :param item_id: Item identifier
        :type item_id: str
        :param item_quantity: Items quantity
        :type item_quantity: int
        :param item_price: Item price, if not sent, items registered price will be used
        :type item_price: str
        :param item_note: Item note
        :type item_note: str
        :param item_paid: If the item is already paid. Note: If set to true, a payment in cash will be registered for the total value of the item, taxes and fees. If this is not the expected behavior, set to false, and register the operation manually. If payments is set, itemPaid is ignored.
        :type item_paid: bool
        :param sale_date: posting date
        :type sale_date: datetime
        :param payments: list of payments If the item is already paid
        :type payments: List[PostItemRequestPaymentsInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            sub_reservation_id=sub_reservation_id,
            item_id=item_id,
            item_quantity=item_quantity,
            item_price=item_price,
            item_note=item_note,
            item_paid=item_paid,
            sale_date=sale_date,
            payments=payments,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_item_post_serialize(
        self,
        property_id,
        reservation_id,
        house_account_id,
        group_code,
        sub_reservation_id,
        item_id,
        item_quantity,
        item_price,
        item_note,
        item_paid,
        sale_date,
        payments,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'payments': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if house_account_id is not None:
            _form_params.append(('houseAccountID', house_account_id))
        if group_code is not None:
            _form_params.append(('groupCode', group_code))
        if sub_reservation_id is not None:
            _form_params.append(('subReservationID', sub_reservation_id))
        if item_id is not None:
            _form_params.append(('itemID', item_id))
        if item_quantity is not None:
            _form_params.append(('itemQuantity', item_quantity))
        if item_price is not None:
            _form_params.append(('itemPrice', item_price))
        if item_note is not None:
            _form_params.append(('itemNote', item_note))
        if item_paid is not None:
            _form_params.append(('itemPaid', item_paid))
        if sale_date is not None:
            _form_params.append(('saleDate', sale_date))
        if payments is not None:
            _form_params.append(('payments', payments))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postItem',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_items_to_inventory_post(
        self,
        item: Optional[PostItemsToInventoryRequestItem] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostItemsToInventoryResponse:
        """postItemsToInventory

        Adds new items batch<br /> ¹ only if item.stockInventory = true<br />

        :param item:
        :type item: PostItemsToInventoryRequestItem
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_items_to_inventory_post_serialize(
            item=item,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemsToInventoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_items_to_inventory_post_with_http_info(
        self,
        item: Optional[PostItemsToInventoryRequestItem] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostItemsToInventoryResponse]:
        """postItemsToInventory

        Adds new items batch<br /> ¹ only if item.stockInventory = true<br />

        :param item:
        :type item: PostItemsToInventoryRequestItem
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_items_to_inventory_post_serialize(
            item=item,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemsToInventoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_items_to_inventory_post_without_preload_content(
        self,
        item: Optional[PostItemsToInventoryRequestItem] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postItemsToInventory

        Adds new items batch<br /> ¹ only if item.stockInventory = true<br />

        :param item:
        :type item: PostItemsToInventoryRequestItem
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_items_to_inventory_post_serialize(
            item=item,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostItemsToInventoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_items_to_inventory_post_serialize(
        self,
        item,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if item is not None:
            _form_params.append(('item', item))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postItemsToInventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_void_item_post(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        sold_product_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostVoidItemResponse:
        """postVoidItem

        Voids the itemID transaction on the specified Reservation ID, House Account ID, or Group. If payments were sent in calls [postItem](https://developers.cloudbeds.com/reference/post_postitem) or [postCustomItem](https://developers.cloudbeds.com/reference/post_postcustomitem), they will be deleted too.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House Account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param sold_product_id: Item identifier
        :type sold_product_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_void_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            sold_product_id=sold_product_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostVoidItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_void_item_post_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        sold_product_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostVoidItemResponse]:
        """postVoidItem

        Voids the itemID transaction on the specified Reservation ID, House Account ID, or Group. If payments were sent in calls [postItem](https://developers.cloudbeds.com/reference/post_postitem) or [postCustomItem](https://developers.cloudbeds.com/reference/post_postcustomitem), they will be deleted too.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House Account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param sold_product_id: Item identifier
        :type sold_product_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_void_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            sold_product_id=sold_product_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostVoidItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_void_item_post_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        reservation_id: Annotated[Optional[StrictStr], Field(description="Reservation identifier. Required if no houseAccountID or groupCode is provided.")] = None,
        house_account_id: Annotated[Optional[StrictStr], Field(description="House Account identifier. Required if no reservationID or groupCode is provided.")] = None,
        group_code: Annotated[Optional[StrictStr], Field(description="Group identifier. Required if no reservationID or houseAccountID is provided.")] = None,
        sold_product_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """postVoidItem

        Voids the itemID transaction on the specified Reservation ID, House Account ID, or Group. If payments were sent in calls [postItem](https://developers.cloudbeds.com/reference/post_postitem) or [postCustomItem](https://developers.cloudbeds.com/reference/post_postcustomitem), they will be deleted too.

        :param property_id: Property ID
        :type property_id: str
        :param reservation_id: Reservation identifier. Required if no houseAccountID or groupCode is provided.
        :type reservation_id: str
        :param house_account_id: House Account identifier. Required if no reservationID or groupCode is provided.
        :type house_account_id: str
        :param group_code: Group identifier. Required if no reservationID or houseAccountID is provided.
        :type group_code: str
        :param sold_product_id: Item identifier
        :type sold_product_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_void_item_post_serialize(
            property_id=property_id,
            reservation_id=reservation_id,
            house_account_id=house_account_id,
            group_code=group_code,
            sold_product_id=sold_product_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PostVoidItemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_void_item_post_serialize(
        self,
        property_id,
        reservation_id,
        house_account_id,
        group_code,
        sold_product_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if reservation_id is not None:
            _form_params.append(('reservationID', reservation_id))
        if house_account_id is not None:
            _form_params.append(('houseAccountID', house_account_id))
        if group_code is not None:
            _form_params.append(('groupCode', group_code))
        if sold_product_id is not None:
            _form_params.append(('soldProductID', sold_product_id))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/postVoidItem',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_item_to_inventory_put(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        item_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        item_name: Annotated[Optional[StrictStr], Field(description="Item name")] = None,
        item_type: Annotated[Optional[StrictStr], Field(description="Item type")] = None,
        item_sku: Annotated[Optional[StrictStr], Field(description="Item SKU. Will be generated if not set")] = None,
        item_code: Annotated[Optional[StrictStr], Field(description="Item code")] = None,
        item_description: Annotated[Optional[StrictStr], Field(description="Item description")] = None,
        item_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Item price")] = None,
        stock_inventory: Annotated[Optional[StrictBool], Field(description="Track stock inventory for this item")] = None,
        item_quantity: Annotated[Optional[StrictInt], Field(description="¹ Current amount of item available")] = None,
        reorder_threshold: Annotated[Optional[StrictInt], Field(description="¹ Quantity at which to reorder item")] = None,
        stop_sell_met: Annotated[Optional[StrictBool], Field(description="¹ true - Whether item is at or below value set for stop-sell threshold.")] = None,
        stop_sell: Annotated[Optional[StrictInt], Field(description="¹ Quantity at which to stop selling product.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PutItemToInventoryResponse:
        """putItemToInventory

        Updates an item with information provided<br /> ¹ only if item.stockInventory = true<br />

        :param property_id: Property ID
        :type property_id: str
        :param item_id: Item identifier
        :type item_id: str
        :param item_name: Item name
        :type item_name: str
        :param item_type: Item type
        :type item_type: str
        :param item_sku: Item SKU. Will be generated if not set
        :type item_sku: str
        :param item_code: Item code
        :type item_code: str
        :param item_description: Item description
        :type item_description: str
        :param item_price: Item price
        :type item_price: float
        :param stock_inventory: Track stock inventory for this item
        :type stock_inventory: bool
        :param item_quantity: ¹ Current amount of item available
        :type item_quantity: int
        :param reorder_threshold: ¹ Quantity at which to reorder item
        :type reorder_threshold: int
        :param stop_sell_met: ¹ true - Whether item is at or below value set for stop-sell threshold.
        :type stop_sell_met: bool
        :param stop_sell: ¹ Quantity at which to stop selling product.
        :type stop_sell: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_item_to_inventory_put_serialize(
            property_id=property_id,
            item_id=item_id,
            item_name=item_name,
            item_type=item_type,
            item_sku=item_sku,
            item_code=item_code,
            item_description=item_description,
            item_price=item_price,
            stock_inventory=stock_inventory,
            item_quantity=item_quantity,
            reorder_threshold=reorder_threshold,
            stop_sell_met=stop_sell_met,
            stop_sell=stop_sell,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutItemToInventoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_item_to_inventory_put_with_http_info(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        item_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        item_name: Annotated[Optional[StrictStr], Field(description="Item name")] = None,
        item_type: Annotated[Optional[StrictStr], Field(description="Item type")] = None,
        item_sku: Annotated[Optional[StrictStr], Field(description="Item SKU. Will be generated if not set")] = None,
        item_code: Annotated[Optional[StrictStr], Field(description="Item code")] = None,
        item_description: Annotated[Optional[StrictStr], Field(description="Item description")] = None,
        item_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Item price")] = None,
        stock_inventory: Annotated[Optional[StrictBool], Field(description="Track stock inventory for this item")] = None,
        item_quantity: Annotated[Optional[StrictInt], Field(description="¹ Current amount of item available")] = None,
        reorder_threshold: Annotated[Optional[StrictInt], Field(description="¹ Quantity at which to reorder item")] = None,
        stop_sell_met: Annotated[Optional[StrictBool], Field(description="¹ true - Whether item is at or below value set for stop-sell threshold.")] = None,
        stop_sell: Annotated[Optional[StrictInt], Field(description="¹ Quantity at which to stop selling product.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PutItemToInventoryResponse]:
        """putItemToInventory

        Updates an item with information provided<br /> ¹ only if item.stockInventory = true<br />

        :param property_id: Property ID
        :type property_id: str
        :param item_id: Item identifier
        :type item_id: str
        :param item_name: Item name
        :type item_name: str
        :param item_type: Item type
        :type item_type: str
        :param item_sku: Item SKU. Will be generated if not set
        :type item_sku: str
        :param item_code: Item code
        :type item_code: str
        :param item_description: Item description
        :type item_description: str
        :param item_price: Item price
        :type item_price: float
        :param stock_inventory: Track stock inventory for this item
        :type stock_inventory: bool
        :param item_quantity: ¹ Current amount of item available
        :type item_quantity: int
        :param reorder_threshold: ¹ Quantity at which to reorder item
        :type reorder_threshold: int
        :param stop_sell_met: ¹ true - Whether item is at or below value set for stop-sell threshold.
        :type stop_sell_met: bool
        :param stop_sell: ¹ Quantity at which to stop selling product.
        :type stop_sell: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_item_to_inventory_put_serialize(
            property_id=property_id,
            item_id=item_id,
            item_name=item_name,
            item_type=item_type,
            item_sku=item_sku,
            item_code=item_code,
            item_description=item_description,
            item_price=item_price,
            stock_inventory=stock_inventory,
            item_quantity=item_quantity,
            reorder_threshold=reorder_threshold,
            stop_sell_met=stop_sell_met,
            stop_sell=stop_sell,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutItemToInventoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_item_to_inventory_put_without_preload_content(
        self,
        property_id: Annotated[Optional[StrictStr], Field(description="Property ID")] = None,
        item_id: Annotated[Optional[StrictStr], Field(description="Item identifier")] = None,
        item_name: Annotated[Optional[StrictStr], Field(description="Item name")] = None,
        item_type: Annotated[Optional[StrictStr], Field(description="Item type")] = None,
        item_sku: Annotated[Optional[StrictStr], Field(description="Item SKU. Will be generated if not set")] = None,
        item_code: Annotated[Optional[StrictStr], Field(description="Item code")] = None,
        item_description: Annotated[Optional[StrictStr], Field(description="Item description")] = None,
        item_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Item price")] = None,
        stock_inventory: Annotated[Optional[StrictBool], Field(description="Track stock inventory for this item")] = None,
        item_quantity: Annotated[Optional[StrictInt], Field(description="¹ Current amount of item available")] = None,
        reorder_threshold: Annotated[Optional[StrictInt], Field(description="¹ Quantity at which to reorder item")] = None,
        stop_sell_met: Annotated[Optional[StrictBool], Field(description="¹ true - Whether item is at or below value set for stop-sell threshold.")] = None,
        stop_sell: Annotated[Optional[StrictInt], Field(description="¹ Quantity at which to stop selling product.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """putItemToInventory

        Updates an item with information provided<br /> ¹ only if item.stockInventory = true<br />

        :param property_id: Property ID
        :type property_id: str
        :param item_id: Item identifier
        :type item_id: str
        :param item_name: Item name
        :type item_name: str
        :param item_type: Item type
        :type item_type: str
        :param item_sku: Item SKU. Will be generated if not set
        :type item_sku: str
        :param item_code: Item code
        :type item_code: str
        :param item_description: Item description
        :type item_description: str
        :param item_price: Item price
        :type item_price: float
        :param stock_inventory: Track stock inventory for this item
        :type stock_inventory: bool
        :param item_quantity: ¹ Current amount of item available
        :type item_quantity: int
        :param reorder_threshold: ¹ Quantity at which to reorder item
        :type reorder_threshold: int
        :param stop_sell_met: ¹ true - Whether item is at or below value set for stop-sell threshold.
        :type stop_sell_met: bool
        :param stop_sell: ¹ Quantity at which to stop selling product.
        :type stop_sell: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_item_to_inventory_put_serialize(
            property_id=property_id,
            item_id=item_id,
            item_name=item_name,
            item_type=item_type,
            item_sku=item_sku,
            item_code=item_code,
            item_description=item_description,
            item_price=item_price,
            stock_inventory=stock_inventory,
            item_quantity=item_quantity,
            reorder_threshold=reorder_threshold,
            stop_sell_met=stop_sell_met,
            stop_sell=stop_sell,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PutItemToInventoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_item_to_inventory_put_serialize(
        self,
        property_id,
        item_id,
        item_name,
        item_type,
        item_sku,
        item_code,
        item_description,
        item_price,
        stock_inventory,
        item_quantity,
        reorder_threshold,
        stop_sell_met,
        stop_sell,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if property_id is not None:
            _form_params.append(('propertyID', property_id))
        if item_id is not None:
            _form_params.append(('itemID', item_id))
        if item_name is not None:
            _form_params.append(('itemName', item_name))
        if item_type is not None:
            _form_params.append(('itemType', item_type))
        if item_sku is not None:
            _form_params.append(('itemSKU', item_sku))
        if item_code is not None:
            _form_params.append(('itemCode', item_code))
        if item_description is not None:
            _form_params.append(('itemDescription', item_description))
        if item_price is not None:
            _form_params.append(('itemPrice', item_price))
        if stock_inventory is not None:
            _form_params.append(('stockInventory', stock_inventory))
        if item_quantity is not None:
            _form_params.append(('itemQuantity', item_quantity))
        if reorder_threshold is not None:
            _form_params.append(('reorderThreshold', reorder_threshold))
        if stop_sell_met is not None:
            _form_params.append(('stopSellMet', stop_sell_met))
        if stop_sell is not None:
            _form_params.append(('stopSell', stop_sell))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'OAuth2', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/putItemToInventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


