Metadata-Version: 2.4
Name: arithmetipy
Version: 0.3.0
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Rust
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Programming Language :: Python :: Implementation :: PyPy
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: System :: Archiving :: Compression
License-File: LICENSE
Summary: Python bindings for a Rust implementation of arithmetic coding (encoder/decoder).
Keywords: arithmetic coding,compression,entropy coding,rust,bindings
Author-email: Mahdi Khodabandeh <20.mahdikh.0@gmail.com>
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Project-URL: Homepage, https://github.com/khoda81/arithmetipy
Project-URL: Repository, https://github.com/khoda81/arithmetipy
Project-URL: Issues, https://github.com/khoda81/arithmetipy/issues

# Arithmetipy

Python bindings for a Rust implementation of **arithmetic coding**.  
This library provides streaming **arithmetic encoder** and **decoder** with 32-bit precision.  
Itâ€™s built in Rust for speed, exposed to Python via [PyO3](https://github.com/PyO3/pyo3) and [maturin]

---

## Installation

```bash
pip install arithmetipy
```

## Develop

```bash
pip install maturin
git clone https://github.com/khoda81/arithmetipy
cd arithmetipy
maturin develop
````

## Usage

```python
from arithmetipy import ArithmeticEncoder, ArithmeticDecoder

# Our "alphabet" is integers {0, 1, 2}
alphabet_size = 3
seq = [0, 1, 2, 1, 1, 0, 1, 2]

# --- Encode ---
encoder = ArithmeticEncoder()
for symbol in seq:
    # here: (start, end, denominator)
    encoder.encode(symbol, symbol + 1, alphabet_size)

encoded = encoder.read()
print("Encoded bytes:", encoded)

# --- Decode ---
decoder = ArithmeticDecoder(encoded)
# All symbols have uniform weight
weights = [1] * alphabet_size
out = [decoder.decode_next(weights) for _ in seq]
print("Decoded symbols:", out)

assert out == seq
```

Output:

```
Encoded bytes: b'3\xd4'
Decoded symbols: [0, 1, 2, 1, 1, 0, 1, 2]
```

---

## API

### `ArithmeticEncoder`

* `encode(start: int, end: int, denominator: int) -> None`
  Encode a symbol interval.
* `read() -> bytes`
  Get the encoded byte stream and reset the internal buffer.

### `ArithmeticDecoder`

* `__init__(data: bytes)`
  Create a decoder from an encoded byte stream.
* `decode_next(weights: List[int]) -> int`
  Decode the next symbol given its weights (probability distribution).


