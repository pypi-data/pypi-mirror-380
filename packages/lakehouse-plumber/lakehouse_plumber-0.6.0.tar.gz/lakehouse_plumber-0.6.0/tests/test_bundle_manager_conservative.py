"""
Tests for BundleManager conservative logic.

Tests the new conservative approach for bundle resource file management:
- Scenario 1a: Python exists + LHP file exists → DON'T TOUCH  
- Scenario 1b: Python exists + User file exists → BACKUP + REPLACE
- Scenario 2:  Python exists + No file exists → CREATE
- Scenario 3:  Python missing + File exists → DELETE
- Scenario 4:  Multiple files exist → ERROR
- Scenario 5:  Mixed file types → Backup non-LHP only
- Scenario 6:  Error handling → Graceful degradation
"""

import pytest
import tempfile
import shutil
import yaml
from pathlib import Path
from unittest.mock import Mock, patch

from lhp.bundle.manager import BundleManager
from lhp.bundle.exceptions import BundleResourceError


class TestBundleManagerConservative:
    """Test suite for conservative bundle manager logic."""

    def setup_method(self):
        """Set up test environment for each test."""
        self.temp_dir = Path(tempfile.mkdtemp())
        self.project_root = self.temp_dir / "test_project"
        self.project_root.mkdir()
        
        # Create directory structure
        self.generated_dir = self.project_root / "generated" / "dev"
        self.generated_dir.mkdir(parents=True)
        self.resources_dir = self.project_root / "resources" / "lhp"  # Root level now
        self.resources_dir.mkdir(parents=True)
        
        self.manager = BundleManager(self.project_root)
        # Set the resources_dir to the root level directory (new behavior)
        self.manager.resources_dir = self.resources_dir

    def teardown_method(self):
        """Clean up test environment after each test."""
        shutil.rmtree(self.temp_dir)

    def create_python_pipeline_dir(self, pipeline_name: str):
        """Create a python pipeline directory with sample files."""
        pipeline_dir = self.generated_dir / pipeline_name
        pipeline_dir.mkdir()
        (pipeline_dir / "sample.py").write_text("# Sample python file")
        return pipeline_dir

    def create_lhp_bundle_file(self, pipeline_name: str, filename: str = None):
        """Create an LHP-generated bundle file."""
        if filename is None:
            filename = f"{pipeline_name}.pipeline.yml"
        
        content = f"""# Generated by LakehousePlumber - Bundle Resource for {pipeline_name}
resources:
  pipelines:
    {pipeline_name}_pipeline:
      name: {pipeline_name}_pipeline
      catalog: main
      schema: lhp_${{bundle.target}}
"""
        bundle_file = self.resources_dir / filename
        bundle_file.write_text(content)
        return bundle_file

    def create_user_bundle_file(self, pipeline_name: str, filename: str = None):
        """Create a user-created bundle file (no LHP header)."""
        if filename is None:
            filename = f"{pipeline_name}.pipeline.yml"
            
        content = f"""# User-created bundle file
resources:
  pipelines:
    {pipeline_name}_pipeline:
      name: {pipeline_name}_custom
"""
        bundle_file = self.resources_dir / filename
        bundle_file.write_text(content)
        return bundle_file

    # ============ SCENARIO 1A: PYTHON + LHP FILE → DON'T TOUCH ============

    def test_scenario_1a_lhp_file_preserved(self):
        """Should preserve existing LHP file when python directory exists."""
        # Setup: Create python directory and LHP bundle file
        self.create_python_pipeline_dir("test_pipeline")
        original_bundle = self.create_lhp_bundle_file("test_pipeline")
        original_content = original_bundle.read_text()
        original_mtime = original_bundle.stat().st_mtime

        # Act: Sync resources
        result = self.manager._sync_pipeline_resource("test_pipeline", self.generated_dir / "test_pipeline", "dev")

        # Assert: File preserved, no changes
        assert result is False  # No changes made
        assert original_bundle.exists()
        assert original_bundle.read_text() == original_content
        assert original_bundle.stat().st_mtime == original_mtime
        assert not any(f.suffix == '.bkup' for f in self.resources_dir.glob("*"))

    def test_scenario_1a_multiple_lhp_files_first_preserved(self):
        """Should preserve first LHP file and backup extras when python exists."""
        # Setup: Create python directory and multiple LHP bundle files
        self.create_python_pipeline_dir("test_pipeline")
        primary_bundle = self.create_lhp_bundle_file("test_pipeline", "test_pipeline.pipeline.yml")
        extra_bundle = self.create_lhp_bundle_file("test_pipeline", "test_pipeline_extra.pipeline.yml")
        
        # This should actually error with our new logic - let's test that
        with pytest.raises(BundleResourceError, match="Multiple bundle resource files found"):
            self.manager._sync_pipeline_resource("test_pipeline", self.generated_dir / "test_pipeline", "dev")

    # ============ SCENARIO 1B: PYTHON + USER FILE → BACKUP + REPLACE ============

    def test_scenario_1b_user_file_backed_up_and_replaced(self):
        """Should backup user file and create LHP version when python exists."""
        # Setup: Create python directory and user bundle file
        self.create_python_pipeline_dir("test_pipeline")
        user_bundle = self.create_user_bundle_file("test_pipeline")
        user_content = user_bundle.read_text()

        # Act: Sync resources
        result = self.manager._sync_pipeline_resource("test_pipeline", self.generated_dir / "test_pipeline", "dev")

        # Assert: User file backed up, LHP file created
        assert result is True  # Changes made
        assert user_bundle.exists()
        assert "Generated by LakehousePlumber" in user_bundle.read_text()  # Now LHP file
        
        # Check backup file created
        backup_files = list(self.resources_dir.glob("*.bkup*"))
        assert len(backup_files) == 1
        assert backup_files[0].read_text() == user_content

    def test_scenario_1b_user_file_in_yml_format(self):
        """Should handle user files with .yml extension."""
        # Setup: Create python directory and user .yml file
        self.create_python_pipeline_dir("test_pipeline")
        user_bundle = self.create_user_bundle_file("test_pipeline", "test_pipeline.yml")

        # Act: Sync resources
        result = self.manager._sync_pipeline_resource("test_pipeline", self.generated_dir / "test_pipeline", "dev")

        # Assert: Backup and replace logic works with .yml files
        assert result is True
        backup_files = list(self.resources_dir.glob("*.bkup*"))
        assert len(backup_files) == 1

    # ============ SCENARIO 2: PYTHON + NO FILE → CREATE ============

    def test_scenario_2_create_new_file(self):
        """Should create new LHP file when python exists but no bundle file."""
        # Setup: Create python directory only
        self.create_python_pipeline_dir("new_pipeline")

        # Act: Sync resources
        result = self.manager._sync_pipeline_resource("new_pipeline", self.generated_dir / "new_pipeline", "dev")

        # Assert: New LHP file created
        assert result is True
        expected_file = self.resources_dir / "new_pipeline.pipeline.yml"
        assert expected_file.exists()
        assert "Generated by LakehousePlumber" in expected_file.read_text()
        assert "new_pipeline" in expected_file.read_text()

    def test_scenario_2_create_with_environment_context(self):
        """Should create new file with proper environment context."""
        # Setup: Create python directory
        self.create_python_pipeline_dir("env_pipeline")

        # Act: Sync with specific environment
        result = self.manager._sync_pipeline_resource("env_pipeline", self.generated_dir / "env_pipeline", "prod")

        # Assert: File created with environment context
        assert result is True
        bundle_file = self.resources_dir / "env_pipeline.pipeline.yml"
        assert bundle_file.exists()
        # Environment-specific values should be in the file
        content = bundle_file.read_text()
        assert "Generated by LakehousePlumber" in content

    # ============ SCENARIO 3: NO PYTHON + FILE EXISTS → DELETE ============

    def test_scenario_3_delete_orphaned_lhp_file(self):
        """Should delete orphaned LHP files when python directory missing."""
        # Setup: Create LHP bundle file without python directory
        orphaned_bundle = self.create_lhp_bundle_file("orphaned_pipeline")
        
        # Act: Sync resources (no python directories exist)
        self.manager.sync_resources_with_generated_files(self.generated_dir, "dev")

        # Assert: Orphaned file deleted
        assert not orphaned_bundle.exists()
        assert not any(f.suffix == '.bkup' for f in self.resources_dir.glob("*"))

    def test_scenario_3_delete_orphaned_user_file(self):
        """Should delete orphaned user files when python directory missing."""
        # Setup: Create user bundle file without python directory
        orphaned_bundle = self.create_user_bundle_file("orphaned_user")
        
        # Act: Sync resources
        self.manager.sync_resources_with_generated_files(self.generated_dir, "dev")

        # Assert: Orphaned file deleted (not backed up)
        assert not orphaned_bundle.exists()
        assert not any(f.suffix == '.bkup' for f in self.resources_dir.glob("*"))

    def test_scenario_3_preserve_existing_when_python_exists(self):
        """Should not delete files when corresponding python directory exists."""
        # Setup: Create python directory and bundle file
        self.create_python_pipeline_dir("active_pipeline")
        active_bundle = self.create_lhp_bundle_file("active_pipeline")
        
        # Create orphaned file too
        orphaned_bundle = self.create_lhp_bundle_file("orphaned_pipeline")

        # Act: Sync resources
        self.manager.sync_resources_with_generated_files(self.generated_dir, "dev")

        # Assert: Active file preserved, orphaned deleted
        assert active_bundle.exists()
        assert not orphaned_bundle.exists()

    # ============ SCENARIO 4: MULTIPLE FILES → ERROR ============

    def test_scenario_4_multiple_files_error(self):
        """Should error when multiple bundle files exist for same pipeline."""
        # Setup: Create python directory and multiple bundle files
        self.create_python_pipeline_dir("multi_pipeline")
        self.create_lhp_bundle_file("multi_pipeline", "multi_pipeline.pipeline.yml")
        self.create_user_bundle_file("multi_pipeline", "multi_pipeline_custom.yml")

        # Act & Assert: Should raise error
        with pytest.raises(BundleResourceError) as exc_info:
            self.manager._sync_pipeline_resource("multi_pipeline", self.generated_dir / "multi_pipeline", "dev")
        
        assert "Multiple bundle resource files found" in str(exc_info.value)
        assert "multi_pipeline" in str(exc_info.value)
        assert "Only one resource file per pipeline is allowed" in str(exc_info.value)

    def test_scenario_4_multiple_files_different_extensions(self):
        """Should error for multiple files even with different extensions."""
        # Setup: Create files with .yml and .pipeline.yml extensions
        self.create_python_pipeline_dir("multi_ext")
        self.create_lhp_bundle_file("multi_ext", "multi_ext.yml")
        self.create_lhp_bundle_file("multi_ext", "multi_ext.pipeline.yml")

        # Act & Assert: Should raise error
        with pytest.raises(BundleResourceError, match="Multiple bundle resource files found"):
            self.manager._sync_pipeline_resource("multi_ext", self.generated_dir / "multi_ext", "dev")

    def test_scenario_4_error_provides_file_list(self):
        """Should provide list of conflicting files in error message."""
        # Setup: Create multiple files
        self.create_python_pipeline_dir("conflict_pipeline")
        file1 = self.create_lhp_bundle_file("conflict_pipeline", "conflict_pipeline.yml")
        file2 = self.create_user_bundle_file("conflict_pipeline", "conflict_pipeline_alt.yml")

        # Act & Assert: Error should list both files
        with pytest.raises(BundleResourceError) as exc_info:
            self.manager._sync_pipeline_resource("conflict_pipeline", self.generated_dir / "conflict_pipeline", "dev")
        
        error_msg = str(exc_info.value)
        assert str(file1) in error_msg
        assert str(file2) in error_msg

    # ============ SCENARIO 5: MIXED FILE TYPES → BACKUP NON-LHP ============

    def test_scenario_5_mixed_files_backup_non_lhp_only(self):
        """Should backup only non-LHP files when mixed types exist."""
        # This scenario is now covered by the multiple files error
        # But let's test the principle with the single file logic
        
        # Setup: Create python directory and user file
        self.create_python_pipeline_dir("mixed_pipeline")
        user_bundle = self.create_user_bundle_file("mixed_pipeline")

        # Act: Sync (should backup user file and create LHP)
        result = self.manager._sync_pipeline_resource("mixed_pipeline", self.generated_dir / "mixed_pipeline", "dev")

        # Assert: User file backed up, LHP file created
        assert result is True
        assert "Generated by LakehousePlumber" in user_bundle.read_text()
        assert len(list(self.resources_dir.glob("*.bkup*"))) == 1

    # ============ SCENARIO 6: ERROR HANDLING → GRACEFUL DEGRADATION ============

    def test_scenario_6_file_permission_error_handling(self):
        """Should handle file permission errors gracefully."""
        # Setup: Create python directory and user bundle file (no LHP file to avoid multiple files error)
        self.create_python_pipeline_dir("perm_pipeline")
        user_bundle = self.create_user_bundle_file("perm_pipeline")

        # Mock file permission error during backup
        with patch('pathlib.Path.rename', side_effect=PermissionError("Access denied")):
            with patch.object(self.manager.logger, 'warning') as mock_warning:
                # Try to sync user file (should gracefully handle backup failure)
                result = self.manager._sync_pipeline_resource("perm_pipeline", self.generated_dir / "perm_pipeline", "dev")
                
                # Assert: Warning logged, but operation continues
                assert result is True  # Still creates new file
                mock_warning.assert_called_once()
                assert "Failed to backup file" in mock_warning.call_args[0][0]

    def test_scenario_6_resources_directory_creation_error(self):
        """Should handle resources directory creation errors."""
        # Mock directory creation failure
        with patch.object(self.manager, 'ensure_resources_directory', side_effect=BundleResourceError("Directory creation failed")):
            with pytest.raises(BundleResourceError, match="Directory creation failed"):
                self.manager.sync_resources_with_generated_files(self.generated_dir, "dev")

    def test_scenario_6_yaml_file_corruption_handling(self):
        """Should handle corrupted YAML files gracefully."""
        # Create python directory
        self.create_python_pipeline_dir("corrupt_pipeline")
        
        # Create corrupted bundle file
        corrupt_file = self.resources_dir / "corrupt_pipeline.pipeline.yml"
        corrupt_file.write_text("corrupted: yaml: content: [unclosed")

        # Act: Should handle gracefully (treat as user file)
        result = self.manager._sync_pipeline_resource("corrupt_pipeline", self.generated_dir / "corrupt_pipeline", "dev")

        # Assert: Should backup corrupt file and create new LHP file
        assert result is True
        assert "Generated by LakehousePlumber" in corrupt_file.read_text()
        assert len(list(self.resources_dir.glob("*.bkup*"))) == 1

    # ============ INTEGRATION TESTS ============

    def test_full_sync_workflow_multiple_pipelines(self):
        """Should handle complete sync workflow with multiple pipelines."""
        # Setup: Multiple scenarios
        # Scenario 1a: LHP file exists
        self.create_python_pipeline_dir("bronze_load")
        lhp_bundle = self.create_lhp_bundle_file("bronze_load")
        original_content = lhp_bundle.read_text()
        
        # Scenario 1b: User file exists  
        self.create_python_pipeline_dir("silver_load")
        user_bundle = self.create_user_bundle_file("silver_load")
        
        # Scenario 2: No file exists
        self.create_python_pipeline_dir("gold_load")
        
        # Scenario 3: Orphaned file
        orphaned_bundle = self.create_lhp_bundle_file("old_pipeline")

        # Act: Full sync
        self.manager.sync_resources_with_generated_files(self.generated_dir, "dev")

        # Assert: All scenarios handled correctly
        # 1a: LHP file preserved
        assert lhp_bundle.exists()
        assert lhp_bundle.read_text() == original_content
        
        # 1b: User file replaced, backup created
        assert "Generated by LakehousePlumber" in user_bundle.read_text()
        backup_files = list(self.resources_dir.glob("*silver_load*.bkup*"))
        assert len(backup_files) == 1
        
        # 2: New file created
        gold_bundle = self.resources_dir / "gold_load.pipeline.yml"
        assert gold_bundle.exists()
        assert "Generated by LakehousePlumber" in gold_bundle.read_text()
        
        # 3: Orphaned file deleted
        assert not orphaned_bundle.exists()

    def test_conservative_approach_summary_logging(self):
        """Should log appropriate summary for conservative approach."""
        # Setup: Create scenario with no changes (all LHP files preserved)
        self.create_python_pipeline_dir("preserved_pipeline")
        self.create_lhp_bundle_file("preserved_pipeline")

        # Act: Sync with logging capture
        with patch.object(self.manager.logger, 'info') as mock_log:
            self.manager.sync_resources_with_generated_files(self.generated_dir, "dev")

        # Assert: Conservative approach mentioned in logging
        log_calls = [call.args[0] for call in mock_log.call_args_list]
        summary_logs = [log for log in log_calls if "bundle resources preserved" in log or "conservative approach" in log]
        assert len(summary_logs) > 0

    def test_deterministic_behavior_multiple_runs(self):
        """Should produce identical results across multiple runs."""
        # Setup: Mixed scenario
        self.create_python_pipeline_dir("stable_pipeline")
        self.create_lhp_bundle_file("stable_pipeline")

        # Act: Run sync multiple times
        results = []
        for i in range(3):
            # Reset and run sync
            result_files = list(self.resources_dir.glob("*"))
            results.append(len(result_files))
            self.manager.sync_resources_with_generated_files(self.generated_dir, "dev")

        # Assert: Consistent behavior
        assert all(r == results[0] for r in results[1:])
        # LHP file should be preserved (no changes)
        bundle_file = self.resources_dir / "stable_pipeline.pipeline.yml"
        assert bundle_file.exists()
        assert "Generated by LakehousePlumber" in bundle_file.read_text() 