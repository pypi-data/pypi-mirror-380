# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import ommx.v1
import typing
from . import _jijmodeling
from enum import Enum

__version__: builtins.str
class CompileError(builtins.Exception):
    ...

class Compiler:
    def get_constraint_id_by_name(self, name:builtins.str) -> dict:
        r"""
        Obtains a dictionary from subscript to constraint Id.
        """
    def eval_function(self, expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> ommx.v1.Function: ...
    def eval_constraints(self, constraint:Constraint) -> builtins.list[ommx.v1.Constraint]: ...
    def eval_problem(self, problem:Problem) -> ommx.v1.Instance: ...
    def get_decision_variable_by_name(self, name:builtins.str, subscript:typing.Optional[typing.Sequence[builtins.int]]=None) -> ommx.v1.DecisionVariable: ...
    def __new__(cls, namespace:Namespace, instance_data:typing.Mapping[builtins.str, builtins.int | builtins.float | numpy.typing.NDArray[numpy.float64] | numpy.typing.NDArray[numpy.int64] | list]) -> Compiler: ...
    @staticmethod
    def from_problem(problem:Problem, instance_data:typing.Mapping[builtins.str, builtins.int | builtins.float | numpy.typing.NDArray[numpy.float64] | numpy.typing.NDArray[numpy.int64] | list]) -> Compiler: ...

class Constraint:
    @property
    def name(self) -> builtins.str: ...
    @property
    def sense(self) -> ConstraintSense: ...
    @property
    def left(self) -> Expression: ...
    @property
    def right(self) -> Expression: ...
    @property
    def expression(self) -> Expression: ...
    @property
    def is_equality(self) -> builtins.bool:
        r"""
        Returns true if the constraint is an equality constraint.
        
        Returns
        --------
        `bool`: True if the constraint is an equality constraint. Otherwise, False.
        
        Examples
        ---------
        
        ```python
        >>> import jijmodeling as jm
        >>> N = jm.Placeholder("N")
        >>> i = jm.Element("i", belong_to=N)
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> constraint = jm.Constraint("constraint", jm.sum(i, x[i]) == 1)
        >>> assert constraint.is_equality()
        
        ```
        """
    @property
    def is_inequality(self) -> builtins.bool:
        r"""
        Returns true if the constraint is an inequality constraint.
        
        Returns
        --------
        `bool`: True if the constraint is an inequality constraint. Otherwise, False.
        
        Examples
        ---------
        
        ```python
        >>> import jijmodeling as jm
        >>> N = jm.Placeholder("N")
        >>> i = jm.Element("i", belong_to=N)
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> constraint = jm.Constraint("constraint", jm.sum(i, x[i]) <= 1)
        >>> assert constraint.is_inequality()
        
        ```
        """
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class DecisionVar:
    r"""
    A class representing a decision variable in a mathematical model.
    As the decision variables must belong to some namespace, you CANNOT construct it directly.
    Instead, you should use `Problem.DecisionVar`, `Problem.BinaryVar`,
    `Problem.IntegerVar`, `Problem.ContinuousVar`,`Problem.SemiIntegerVar`,
    or `Problem.SemiContinuousVar`.
    
    The `DecisonVar` class is used to create a continuous variable.
    The lower and upper bounds of the variable can be any scalar or tensor with the same shape as the variable expression which DOES NOT contain any decision variable.
    
    The `DecisionVar` class itself represents a definition of a decision variable,
    but you can use ordinary operations on `Expression`s to create expressions that contain decision variables.
    
    Attributes
    -----------
    - `name` (`str`): A name of the continuous variable.
    - `kind` (`DecisionVarKind`): The kind of the decision variable, which can be one of the following:
      - `BINARY`: A binary variable.
      - `INTEGER`: An integer variable.
      - `CONTINUOUS`: A continuous variable.
      - `SEMI_INTEGER`: A semi-integer variable.
      - `SEMI_CONTINUOUS`: A semi-continuous variable.
    - `shape` (`tuple`): A tuple with the size of each dimension of the integer variable. Empty if the variable is not multi-dimensional.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `description` (`str`): A description of the continuous variable.
    
    Examples
    ---------
    Create a scalar continuous variable whose name is "z" and domain is `[-1, 1]`.
    
    ```python
    >>> import jijmodeling as jm
    >>> problem = jm.Problem("example")
    >>> z = problem.DecisionVar(
    >>>     "z",
    >>>     kind=jm.DecisionVarKind.CONTINUOUS,
    >>>     lower_bound=-1, upper_bound=1
    >>> )
    
    ```
    
    or equivalently:
    
    ```python
    >>> import jijmodeling as jm
    >>> problem = jm.Problem("example")
    >>> z = problem.ContinuousVar("z", lower_bound=-1, upper_bound=1)
    
    ```
    
    Create a 2-dimensional integer variable...
    - whose name is "x".
    - whose domain is [0, 2].
    - where each dimension has length 2 (making this a 2x2 matrix).
    
    ```python
    >>> import jijmodeling as jm
    >>> problem = jm.Problem("example")
    >>> x = problem.IntegerVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
    
    ```
    
    Create a 1-dimensional continuous variable, and construct an expression
    accessing the 123rd component of it..
    
    ```python
    >>> import jijmodeling as jm
    >>> problem = jm.Problem("example")
    >>> x = problem.ContinuousVar("x", shape=[124], lower_bound=0, upper_bound=2)
    >>> x[123]
    x[123]
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def kind(self) -> DecisionVarKind: ...
    @property
    def description(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def shape(self) -> tuple: ...
    @property
    def lower_bound(self) -> Expression | builtins.list[Expression]: ...
    @property
    def upper_bound(self) -> Expression | builtins.list[Expression]: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    @typing.overload
    def max(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
        r"""
        Return the larger of this expression and rhs.
        """
    @typing.overload
    def max(self) -> Expression:
        r"""
        Return the maximum element of this foldable expression.
        """
    @typing.overload
    def min(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
        r"""
        Return the smaller of this expression and rhs.
        """
    @typing.overload
    def min(self) -> Expression:
        r"""
        Return the minimum element of this foldable expression.
        """
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> Expression: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> Expression: ...
    def __add__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __radd__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __sub__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rsub__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __mul__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rmul__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __truediv__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rtruediv__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __mod__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rmod__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __neg__(self) -> Expression: ...
    def abs(self) -> Expression: ...
    def sqrt(self) -> Expression: ...
    def sin(self) -> Expression: ...
    def cos(self) -> Expression: ...
    def tan(self) -> Expression: ...
    def asin(self) -> Expression: ...
    def acos(self) -> Expression: ...
    def atan(self) -> Expression: ...
    def sinh(self) -> Expression: ...
    def cosh(self) -> Expression: ...
    def tanh(self) -> Expression: ...
    def asinh(self) -> Expression: ...
    def acosh(self) -> Expression: ...
    def atanh(self) -> Expression: ...
    def exp(self) -> Expression: ...
    def ln(self) -> Expression: ...
    def log10(self) -> Expression: ...
    def log2(self) -> Expression: ...
    def ceil(self) -> Expression: ...
    def floor(self) -> Expression: ...
    def map(self, func:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def roll(self, shift:typing.Any, *, axis:typing.Optional[builtins.int]=None) -> Expression: ...
    def filter(self, predicate:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def flat_map(self, func:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def rows(self) -> Expression: ...
    def __getitem__(self, subscripts:typing.Any) -> Expression: ...
    def sum(self, axis:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | builtins.int | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[builtins.int]]=None) -> Expression: ...
    def prod(self, axis:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | builtins.int | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[builtins.int]]=None) -> Expression: ...
    def __eq__(self, other:typing.Any) -> Expression: ...  # type: ignore[reportIncompatibleMethodOverride]
    def __ne__(self, other:typing.Any) -> Expression: ...  # type: ignore[reportIncompatibleMethodOverride]
    def __lt__(self, other:typing.Any) -> Expression: ...
    def __le__(self, other:typing.Any) -> Expression: ...
    def __gt__(self, other:typing.Any) -> Expression: ...
    def __ge__(self, other:typing.Any) -> Expression: ...

class DecoratedProblem(typing.Protocol):
    r"""
    A variant of `Problem` that is only available in Decorator API provided by `Problem.compile`.
    """
    @typing.overload
    def Constraint(self, name:builtins.str, expressions:typing.Generator[Expression], description:typing.Optional[builtins.str]=None) -> Constraint:
        r"""
        Constructs `Constraint` object with comprehension syntax, __WITHOUT__ registering it to the problem.
        Use `+=` operator to register the constraint to the problem.
        """
    @typing.overload
    def Constraint(self, name:builtins.str, expression:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], domain:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], description:typing.Optional[builtins.str]=None) -> Constraint:
        r"""
        Constructs `Constraint` object from index set and function to build comparison expression from each index, __WITHOUT__ registering it to the problem.
        Use `+=` operator to register the constraint to the problem.
        """
    @typing.overload
    def Constraint(self, name:builtins.str, expression:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], description:typing.Optional[builtins.str]=None) -> Constraint:
        r"""
        Constructs `Constraint` object from comparison expression, __WITHOUT__ registering it to the problem.
        Use `+=` operator to register the constraint to the problem.
        """
    def __iadd__(self, other:typing.Any) -> DecoratedProblem: ...
    def used_placeholders(self) -> builtins.list[Placeholder]: ...
    def get_problem_schema(self) -> dict:
        r"""
        Returns the schema of the problem.
        
        Returns
        --------
        - `schema`: The dictionary containing the schema of the problem.
        """
    def generate_random_dataset(self, _default:typing.Any, _options:typing.Any, _seed:typing.Optional[builtins.int]) -> typing.Any:
        r"""
        Generates a dictionary of random `InstanceDataValue` for a given problem.
        To generate `ommx.v1.Instance` object directly, use `InstanceDataValue.generate_random_instance` instead.
        
        Args
        -----
        - `options` (optional): a dictionary of range parameters for each separate placeholders. The key must be the name of the placeholder and the value must be range parameter (as described in "Range Parameters and Range Syntax" below).
        - `default` (optional): default range parameters for placeholders which is not specified in `options`.
        - `seed` (optional): seed for random number generation.
        
        Returns
        --------
        `dict`: The dictionary from the name of placeholders to the generated `InstanceDataValue` objects. To be fed to `Interpreter.eval_problem`.
        
        Range Parameters and Range Syntax
        ----------------------------------
        A range parameter is a dictionary consisting of the following fields:
        - `size` (optional): interval of natural numbers for the size of each array dimension (default: `range(1, 6)`)
        - `value` (optional): interval of real numbers for the value of each array element (default: `range(-1.0, 1.0)` - a uniform distribution on a closed interval $[-1.0, 1.0]$).
        
        Example range parameter config:
        
        ```python
        {"size": range(2, 10), "value": jm.range.value.closed(100.0, 200.0)}
        ```
        
        Intervals are expressed as a range object.
        Currently, the following syntax is supported for range objects:
        
        1. Direct value of type `int` or `float` - it corresponds to a singleton interval $[a, a] = \{a\}$. In random generation context, this just means a constant fixed value.
        2. Use the functions from `jijmodeling.range`, `jijmodeling.range.size`, or `jijmodeling.range.value` modules.
           - Use functions from `jij.modeling.range.size` to specify (non-negative) integer intervals, and `jij.modeling.range.value` for real intervals. `jij.modeling.range` dynamically determines the type of the range based on the input.
           - These three modules provides the following combinators (see the module documents for more details.):
                    - `closed(a, b)`: a closed interval $[a, b]$
                    - `open(a, b)`: an open interval $(a, b)$
                    - `closed_open(a, b)`: an upper half-open interval $[a, b)$
                    - `open_closed(a, b)`: a lower half-open interval $(a, b]$
                    - `greater_than(a)`: an open interval $(a, \infty)$
                    - `at_least(a)`: a closed interval $[a, \infty)$
                    - `less_than(a)`: an open interval $(-\infty, a)$
                    - `at_most(a)`: a closed interval $(-\infty, a]$
        3. Use `range` builtin function: this is equivalent to `jijmodeling.range.value.closed_open(a, b)`.
           - Any python range object with `step = 1` can be used as a size range; otherwise it results in runtime error.
        4. Use a tuple: raw tuple `(a, b)` is equivalent to `jijmodeling.range.closed_open(a, b)` if `a` and `b` are either `int` or `float`.
           - You can also use bound object as a tuple component; in such case, both tuple components must be one of the following:
        
                1. A string `"Unbounded"` means $-\infty$ (in the first component) or $\infty$ (the second).
                2. A dictionary `{"Included": a}` means the endpoint is inclusive.
                3. A dictionary `{"Excluded": a}` means the endpoint is exclusive.
           - Examples:
                    - `(1.2, 4)` is equivalent to `closed_open(1.2, 4)`,
                    - `(-1, {"Included": 1})` is equivalent to `closed(-1, 1)`,
                    - `(-5, {"Excluded": 4})` is equivalent to `closed_open(-5, 4)` and built in function `range(-5, 4)`,
                    - `({"Excluded": 1}, {"Excluded": 2.5})` is equivalent to `open(1, 2.5)`,
                    - `({"Included": -1}, "Unbounded")` is equivalent to `at_least(-1)`.
                    - `(5, "Unbounded")` is **INVALID**; `5` must be bound object.
        5. The range object: A dictionary of form `{"start": lb, "end": ub}`, where both `lb` and `ub` are the bound object described as above.
        
        Examples
        ---------
        ```python
        >>> import jijmodeling as jm
        >>> import builtins
        >>> N = jm.Placeholder("N", dtype=jm.DataType.INTEGER)
        >>> c = jm.Placeholder("c", dtype=jm.DataType.FLOAT, shape=(N,))
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> i = jm.Element("i", belong_to=N)
        
        >>> problem = jm.Problem("problem")
        >>> problem += jm.sum(i, c[i] * x[i])
        
        >>> inputs = problem.generate_random_dataset(
        ...     options={
        ...         'N': {"value": builtins.range(10, 20)},
        ...         'c': {"value": jm.range.value.closed(-1.0, 1.0)}
        ...          # You can also specify "size" for the range of jagged array dimension size.
        ...     },
        ...     seed=123 # omittable
        ... )
        >>> assert set(inputs.keys()) == {"N", "c"}
        >>> inputs
        {'N': 11.0, 'c': array([ 0.93914459, -0.06511935, -0.7460324 , -0.32443706,  0.99981451,
               -0.24407535,  0.31329469,  0.52206453, -0.1291936 ,  0.30443087,
                0.53125838])}
        
        ```
        """
    def generate_random_instance(self, _default:typing.Any, _options:typing.Any, _seed:typing.Optional[builtins.int], _hints:typing.Optional[typing.Any]) -> typing.Any:
        r"""
        Generates random `ommx.v1.Instance` for a given problem.
        See also `InstanceDataValue.generate_random_dataset`.
        
        Args
        -----
        - `options` (optional): a dictionary of range parameters for each separate placeholders. The key must be the name of the placeholder and the value must be range parameter (as described in "Range Parameters and Range Syntax" section in :func:`~jijmodeling.Problem.generate_random_dataset`).
        - `default` (optional): default range parameters for placeholders which is not specified in `options`.
        - `seed` (optional): seed for random number generation.
        - `hints` (optional): the hints to be detected during compilation see `Interpreter.eval_problem` for more details.
        
        Returns
        --------
        `instance`: The OMMX v1 instance object.
        
        Examples
        ---------
        ```python
        >>> import jijmodeling as jm
        >>> import builtins
        >>> import ommx.v1
        >>> N = jm.Placeholder("N", dtype=jm.DataType.INTEGER)
        >>> c = jm.Placeholder("c", dtype=jm.DataType.FLOAT, shape=(N,))
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> i = jm.Element("i", belong_to=N)
        
        >>> problem = jm.Problem("problem")
        >>> problem += jm.sum(i, c[i] * x[i])
        
        >>> instance = problem.generate_random_instance(
        ...     options={
        ...         'N': {"value": builtins.range(10, 20)},
        ...         'c': {"value": jm.range.value.closed(-1.0, 1.0)}
        ...     },
        ...     seed=123
        ... )
        >>> assert type(instance) is ommx.v1.Instance
        
        ```
        """
    def type_of(self, name:builtins.str) -> Type: ...
    def infer(self, expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Type: ...
    def decision_vars(self) -> builtins.dict[builtins.str, DecisionVar]:
        r"""
        Returns a dictionary of decision variables in the problem.
        
        Returns
        --------
        `dict[str, DecisionVar]`: Dictionary mapping variable names to DecisionVar objects.
        """
    def placeholders(self) -> builtins.dict[builtins.str, Placeholder]:
        r"""
        Returns a dictionary of placeholders in the problem.
        
        Returns
        --------
        `dict[str, Placeholder]`: Dictionary mapping placeholder names to Placeholder objects.
        """
    def Placeholder(self, name:typing.Optional[builtins.str]=None, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, dtype:DataType | type | tuple=DataType.FLOAT, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder: ...
    def Integer(self, name:typing.Optional[builtins.str]=None, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A shorthand for `Problem.Placeholder(dtype=int)`
        """
    def Float(self, name:typing.Optional[builtins.str]=None, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A shorthand for `Problem.Placeholder(dtype=DataType.FLOAT)`
        """
    def Natural(self, name:typing.Optional[builtins.str]=None, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A shorthand for `Problem.Placeholder(dtype=DataType.NATURAL)`
        """
    def Length(self, name:typing.Optional[builtins.str]=None, *, ndim:typing.Optional[builtins.int]=0, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A plceholder expressing array length.
        This is just a shorthand for `Problem.Natural()`.
        When omitted, `ndim` is set to be `0`.
        """
    def Dim(self, name:typing.Optional[builtins.str]=None, *, ndim:typing.Optional[builtins.int]=0, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A placeholder expressing array dimension.
        This is just a shorthand for `Problem.Natural()`.
        When omitted, `ndim` is set to be `0`.
        """
    def Binary(self, name:typing.Optional[builtins.str]=None, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A shorthand for `Problem.Placeholder(dtype=DataType.BINARY)`
        """
    def Graph(self, name:typing.Optional[builtins.str]=None, *, vertex:DataType | type | tuple=DataType.NATURAL, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A placeholder expressing a directed graph (without edge weights), represented by a 1-dimensional array of tuples.
        This is just a shorthand for `Problem.Placeholder(dtype=(vertex, vertex), ndim=1)`.
        """
    def DecisionVar(self, name:typing.Optional[builtins.str]=None, *, kind:DecisionVarKind, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar:
        r"""
        A function to create a decision variable and register to the problem namespace. See `DecisionVar` for more details.
        
        Args
        -----
        - `name` (`str`): A name of the binary variable. If omitted, local variable name is used.
        - `kind` (`DecisionVarKind`): A kind of the decision variable.
        - `shape` (`list | tuple`): A sequence with the size of each dimension of the binary variable. Defaults to an empty tuple (a scalar value).
          - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
        - `lower_bound` and `upper_bound` (`jijmodeling.Expression`): A lower and upper bounds of the binary variable.
        - `kind` (`DecisionVarKind`): A kind of the decision variable.
        - `latex` (`str`, optional): A LaTeX-name of the binary variable to be represented in Jupyter notebook.
          - It is set to `name` by default.
        - `description` (`str`, optional): A description of the binary variable.
        
        Examples
        ---------
        Create a scalar binary variable whose name is "z".
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> z = problem.DecisionVar("z", kind=jm.DecisionVarKind.BINARY, lower_bound=0, upper_bound=1)
        
        ```
        
        Create a 2-dimensional binary variable whose name is "x" and has a 2x2 shape.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problem.BinaryVar("x", shape=[2, 2])
        
        ```
        
        Create a 1-dimensional binary variable with the index of `123`.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = jm.BinaryVar("x", shape=[124])
        >>> x[123]
        BinaryVar(name='x', shape=[NumberLit(value=124)])[NumberLit(value=123)]
        
        ```
        """
    def BinaryVar(self, name:typing.Optional[builtins.str]=None, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar:
        r"""
        A function to create a binary decision variable and register to the problem namespace. See `DecisionVar` for more details.
        
        Args
        -----
        - `name` (`str`): A name of the binary variable. If omitted, local variable name is used.
        - `shape` (`list | tuple`): A sequence with the size of each dimension of the binary variable. Defaults to an empty tuple (a scalar value).
          - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
        - `latex` (`str`, optional): A LaTeX-name of the binary variable to be represented in Jupyter notebook.
          - It is set to `name` by default.
        - `description` (`str`, optional): A description of the binary variable.
        
        Examples
        ---------
        Create a scalar binary variable whose name is "z".
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> z = problem.BinaryVar("z")
        
        ```
        
        Create a 2-dimensional binary variable whose name is "x" and has a 2x2 shape.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problem.BinaryVar("x", shape=[2, 2])
        
        ```
        
        Create a 1-dimensional binary variable with the index of `123`.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problemm.BinaryVar("x", shape=[124])
        >>> x[123]
        x[123]
        
        ```
        """
    def IntegerVar(self, name:typing.Optional[builtins.str]=None, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar:
        r"""
        A function to create a decision variable and register to the problem namespace. See `DecisionVar` for more details.
        
        Args
        -----
        - `name` (`str): A name of the integer variable. If omitted, local variable name is used.
        - `shape` (`list | tuple`): A sequence with the size of each dimension of the integer variable. Defaults to an empty tuple (a scalar value).
          - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
        - `lower_bound`: The lower bound of the variable.
        - `upper_bound`: The upper bound of the variable.
        - `latex` (`str`, optional): A LaTeX-name of the integer variable to be represented in Jupyter notebook.
          - It is set to `name` by default.
        - `description` (`str`, optional): A description of the integer variable.
        
        Raises
        -------
        `ModelingError`: Raises if a bound is a `Placeholder` or `Subscript` object whose `ndim`
        is neither `0` nor the same value as `ndim` of the integer variable.
        
        Examples
        ---------
        Create a scalar integer variable whose name is "z" and domain is `[-1, 1]`.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> z = problem.IntegerVar("z", lower_bound=-1, upper_bound=1)
        
        ```
        
        Create a 2-dimensional integer variable...
        - whose name is "x".
        - whose domain is [0, 2].
        - where each dimension has length 2 (making this a 2x2 matrix).
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problem.IntegerVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
        
        ```
        
        Create a 1-dimensional integer variable with the index of `123`.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problem.IntegerVar("x", shape=[124], lower_bound=0, upper_bound=2)
        >>> x[123]
        x[123]
        
        ```
        """
    def SemiIntegerVar(self, name:typing.Optional[builtins.str]=None, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar: ...
    def ContinuousVar(self, name:typing.Optional[builtins.str]=None, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar:
        r"""
        A function to create a decision variable and register to the problem namespace. See `DecisionVar` for more details.
        
        Args
        -----
        - `name` (`str`): A name of the continuous variable.
        - `shape` (`list | tuple`): A sequence with the size of each dimension of the continuous variable. Defaults to an empty tuple (a scalar value).
          - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
        - `lower_bound`: The lower bound of the variable.
        - `upper_bound`: The upper bound of the variable.
        - `latex` (`str`, optional): A LaTeX-name of the continuous variable to be represented in Jupyter notebook.
          - It is set to `name` by default.
        - `description` (`str`, optional): A description of the continuous variable.
        
        Raises
        -------
        `ModelingError`: Raises if a bound is a `Placeholder` or `Subscript` object whose `ndim` is neither `0` nor the same value as `ndim` of the continuous variable.
        
        Examples
        ---------
        Create a scalar continuous variable whose name is "z" and domain is `[-1, 1]`.
        
        ```python
        >>> import jijmodeling as jm
        >>> z = jm.ContinuousVar("z", lower_bound=-1, upper_bound=1)
        
        ```
        
        Create a 2-dimensional continuous variable...
        - whose name is "x".
        - whose domain is [0, 2].
        - where each dimension has length 2 (making this a 2x2 matrix).
        
        ```python
        >>> import jijmodeling as jm
        >>> x = jm.ContinuousVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
        
        ```
        
        Create a 1-dimensional continuous variable with the index of `123`.
        
        ```python
        >>> import jijmodeling as jm
        >>> x = jm.ContinuousVar("x", shape=[124], lower_bound=0, upper_bound=2)
        >>> x[123]
        ContinuousVar(name='x', shape=[NumberLit(value=124)], lower_bound=NumberLit(value=0), upper_bound=NumberLit(value=2))[NumberLit(value=123)]
        
        ```
        """
    def SemiContinuousVar(self, name:typing.Optional[builtins.str]=None, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar: ...

class DesugaredProblemBuilder:
    def __call__(self) -> None: ...

class Expression:
    r"""
    Any expression in Python.
    """
    def _repr_latex_(self) -> builtins.str: ...
    def __call__(self, *args) -> Expression: ...
    def shape(self) -> Expression: ...
    def len_at(self, axis:builtins.int) -> Expression: ...
    def __repr__(self) -> builtins.str: ...
    def or_else(self, default:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
        r"""
        Returns the value inside `option` if `Some`, otherwise returns `default`.
        """
    def map_or_else(self, default:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], mapper:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
        r"""
        If self is `Some(value)`, applies `mapper(value)`, otherwise returns `default`.
        """
    @typing.overload
    def max(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
        r"""
        Return the larger of this expression and rhs.
        """
    @typing.overload
    def max(self) -> Expression:
        r"""
        Return the maximum element of this foldable expression.
        """
    @typing.overload
    def min(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
        r"""
        Return the smaller of this expression and rhs.
        """
    @typing.overload
    def min(self) -> Expression:
        r"""
        Return the minimum element of this foldable expression.
        """
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> Expression: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> Expression: ...
    def __add__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __radd__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __sub__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rsub__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __mul__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rmul__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __truediv__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rtruediv__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __mod__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rmod__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __neg__(self) -> Expression: ...
    def abs(self) -> Expression: ...
    def sqrt(self) -> Expression: ...
    def sin(self) -> Expression: ...
    def cos(self) -> Expression: ...
    def tan(self) -> Expression: ...
    def asin(self) -> Expression: ...
    def acos(self) -> Expression: ...
    def atan(self) -> Expression: ...
    def sinh(self) -> Expression: ...
    def cosh(self) -> Expression: ...
    def tanh(self) -> Expression: ...
    def asinh(self) -> Expression: ...
    def acosh(self) -> Expression: ...
    def atanh(self) -> Expression: ...
    def exp(self) -> Expression: ...
    def ln(self) -> Expression: ...
    def log10(self) -> Expression: ...
    def log2(self) -> Expression: ...
    def ceil(self) -> Expression: ...
    def floor(self) -> Expression: ...
    def map(self, func:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def roll(self, shift:typing.Any, *, axis:typing.Optional[builtins.int]=None) -> Expression: ...
    def filter(self, predicate:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def flat_map(self, func:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def rows(self) -> Expression: ...
    def __getitem__(self, subscripts:typing.Any) -> Expression: ...
    def sum(self, axis:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | builtins.int | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[builtins.int]]=None) -> Expression: ...
    def prod(self, axis:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | builtins.int | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[builtins.int]]=None) -> Expression: ...
    def __and__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rand__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __or__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __ror__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __xor__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rxor__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def diff(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def bnot(self) -> Expression: ...
    def __eq__(self, other:typing.Any) -> Expression: ...  # type: ignore[reportIncompatibleMethodOverride]
    def __ne__(self, other:typing.Any) -> Expression: ...  # type: ignore[reportIncompatibleMethodOverride]
    def __lt__(self, other:typing.Any) -> Expression: ...
    def __le__(self, other:typing.Any) -> Expression: ...
    def __gt__(self, other:typing.Any) -> Expression: ...
    def __ge__(self, other:typing.Any) -> Expression: ...

class ModelingError(builtins.Exception):
    ...

class Namespace:
    def __new__(cls) -> Namespace: ...
    @staticmethod
    def from_problem(problem:Problem) -> Namespace: ...
    def add_placeholder(self, placeholder:Placeholder) -> None: ...
    def Placeholder(self, name:builtins.str, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, dtype:DataType | type | tuple=DataType.FLOAT, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder: ...
    def add_decision_var(self, var:DecisionVar) -> None: ...
    def type_of(self, name:builtins.str) -> Type: ...
    def infer(self, expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Type: ...

class Placeholder:
    r"""
    A spec of a placeholder value.
    
    The Placeholder class represents a spec Placeholder, which is maintained in namespace (i.e. Problem).
    It is a symbol to be replaced by a numerical value when you evaluate an optimization problem before solving it.
    
    Expressions on Placeholder automatically turns into an `Expression` object.
    
    Attributes
    -----------
    - `name` (`str`): A name of the placeholder.
    - `ndim` (`int`): The number of dimensions of the placeholder.
    - `shape` (`tuple` of `Optional[Expression]`, optional): The (partial) shape of the placeholder if given.
    - `dtype` (`DataType`, optional): The data type (`DataType.INT` or `DataType.FLOAT`) of the placeholder.
    - `jagged` (`boolean`, defaut: `False`): `True` if the placeholder will be treated as a jagged array in random data generation. Ignored for scalars.
    - `description` (`str`, optional): A description of the placeholder.
    
    Args
    -----
    - `name` (`str`): A name of the placeholder.
    - `ndim` (`Optional[int]`): The number of dimensions of the placeholder. Defaults to `0`. The `ndim` must be set to a non-negative value and must concide with the length of `shape` if both specified. If `None` is given, you must specify `shape` explicitly and the length of `shape` will be used.
    - `shape` (`list[Optional[Expression]]`, optional): The (partial) shape of the placeholder. Used for random data generation.
    - `dtype` (`DataType`, optional): The data type (`DataType.INT` or `DataType.FLOAT`) of the placeholder. Used for random data generation.
    - `jagged` (`boolean`, defaut: `False`): `True` if the placeholder will be treated as a jagged array in random data generation. Ignored for scalars.
    - `latex` (`str`, optional): A LaTeX-name of the placeholder to be represented in Jupyter notebook.
      It is set to `name` by default.
    - `description` (`str`, optional): A description of the placeholder.
    
    Raises
    -------
    - `TypeError`: Raises if set a float value to `ndim`.
    - `OverflowError`: Raises if set a negative value to `ndim`.
    
    Examples
    ---------
    Create a scalar (or `ndim` is `0`) placeholder whose name is "a".
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    
    ```
    
    Create a 2-dimensional placeholder whose name is "m".
    
    ```python
    >>> import jijmodeling as jm
    >>> problem = jm.Problem("example")
    >>> m = problem.Placeholder("m", ndim=2)
    
    ```
    
    Create a 1-dimensional placeholder with the index of `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> problem = jm.Problem("example")
    >>> a = problem.Placeholder("a", ndim=2)
    >>> a[123]
    a[123]
    >>> problem.get_placeholde("a")
    Placeholder(name='a', ndim=2, shape=None, dtype=typing.float, jagged=False)
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def shape(self) -> typing.Tuple[Expression,...]:
        r"""
        Get the shape tuple of the placeholder, consisting of `Expression`s.
        See also `Problem.shape_spec` property to get the original value
        given at the declaration time.
        Can be converted into a `Problem`.
        
        ## Difference between `Problem.shape` and `Problem.shape_spec`
        
        - `Problem.shape` property always returns a tuple of `Expression`s,
          filling `None` with `len_at` expressions so that i-th component
          coincides with the value of `ph.len_at(i)`
        - `Problem.shape_spec` just returns the original `shape` definition,
          hence the spec itself can be `None` or contain `None` components.
        
        ## Use cases
        
        - use `Placeholder.shape` property if you want to construct expressions involving the shape of the placeholder.
        - use `Problem.shape_spec` property if you want to inspect the very definition of the placeholder.
        """
    @property
    def shape_spec(self) -> typing.Optional[typing.Tuple[typing.Optional[Expression],...]]:
        r"""
        Get the original definition of shape given at the declaration time, possibly `None` if omitted.
        See also `Placeholder.shape` property to get the shape as `Expression`s.
        
        ## Difference between `Problem.shape` and `Problem.shape_spec`
        
        - `Problem.shape` property always returns a tuple of `Expression`s,
          filling `None` with `len_at` expressions so that i-th component
          coincides with the value of `ph.len_at(i)`
        - `Problem.shape_spec` just returns the original `shape` definition,
          hence the spec itself can be `None` or contain `None` components.
        
        ## Use cases
        
        - use `Problem.shape_spec` property if you want to inspect the very definition of the placeholder.
        - use `Placeholder.shape` property if you want to construct expressions involving the shape of the placeholder.
        """
    @property
    def dtype(self) -> DataType | type | tuple: ...
    @property
    def jagged(self) -> builtins.bool: ...
    @property
    def description(self) -> typing.Optional[builtins.str]: ...
    @property
    def custom_latex(self) -> typing.Optional[builtins.str]: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def len_at(self, index:builtins.int) -> Expression: ...
    @typing.overload
    def max(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
        r"""
        Return the larger of this expression and rhs.
        """
    @typing.overload
    def max(self) -> Expression:
        r"""
        Return the maximum element of this foldable expression.
        """
    @typing.overload
    def min(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
        r"""
        Return the smaller of this expression and rhs.
        """
    @typing.overload
    def min(self) -> Expression:
        r"""
        Return the minimum element of this foldable expression.
        """
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> Expression: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> Expression: ...
    def __add__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __radd__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __sub__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rsub__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __mul__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rmul__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __truediv__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rtruediv__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __mod__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rmod__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __neg__(self) -> Expression: ...
    def abs(self) -> Expression: ...
    def sqrt(self) -> Expression: ...
    def sin(self) -> Expression: ...
    def cos(self) -> Expression: ...
    def tan(self) -> Expression: ...
    def asin(self) -> Expression: ...
    def acos(self) -> Expression: ...
    def atan(self) -> Expression: ...
    def sinh(self) -> Expression: ...
    def cosh(self) -> Expression: ...
    def tanh(self) -> Expression: ...
    def asinh(self) -> Expression: ...
    def acosh(self) -> Expression: ...
    def atanh(self) -> Expression: ...
    def exp(self) -> Expression: ...
    def ln(self) -> Expression: ...
    def log10(self) -> Expression: ...
    def log2(self) -> Expression: ...
    def ceil(self) -> Expression: ...
    def floor(self) -> Expression: ...
    def map(self, func:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def roll(self, shift:typing.Any, *, axis:typing.Optional[builtins.int]=None) -> Expression: ...
    def filter(self, predicate:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def flat_map(self, func:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def rows(self) -> Expression: ...
    def __getitem__(self, subscripts:typing.Any) -> Expression: ...
    def sum(self, axis:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | builtins.int | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[builtins.int]]=None) -> Expression: ...
    def prod(self, axis:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | builtins.int | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[builtins.int]]=None) -> Expression: ...
    def __and__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rand__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __or__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __ror__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __xor__(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def __rxor__(self, lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def diff(self, rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...
    def bnot(self) -> Expression: ...
    def __eq__(self, other:typing.Any) -> Expression: ...  # type: ignore[reportIncompatibleMethodOverride]
    def __ne__(self, other:typing.Any) -> Expression: ...  # type: ignore[reportIncompatibleMethodOverride]
    def __lt__(self, other:typing.Any) -> Expression: ...
    def __le__(self, other:typing.Any) -> Expression: ...
    def __gt__(self, other:typing.Any) -> Expression: ...
    def __ge__(self, other:typing.Any) -> Expression: ...

class Problem:
    r"""
    A class for creating an optimization problem
    
    The Problem class is used to create an optimization problem.
    
    Attributes
    -----------
    - `name` (`str`): A name of the optimization problem.
    - `sense`: Sense of the optimization problem.
    - `objective`: The objective function of the optimization problem.
    - `constraints` (`dict`): A dictionary that stores constraints.
      - A key is the name of a constraint and the value is the constraint object.
    - `custom_penalty_terms` (`dict`): A dictionary that stores custom penalty terms.
      - A key is the name of a custom penalty and the value is the custom penalty object.
    
    Args
    -----
    - `name` (`str`): A name of the optimization problem.
    - `sense` (optional): Sense of the optimization problem. Defaults to `ProblemSense.MINIMIZE`.
    """
    @property
    def objective(self) -> Expression: ...
    @property
    def description(self) -> builtins.str: ...
    @property
    def constraints(self) -> builtins.dict[builtins.str, builtins.list[Constraint]]: ...
    @property
    def used_placeholders(self) -> builtins.list[Placeholder]: ...
    @property
    def decision_vars(self) -> builtins.dict[builtins.str, DecisionVar]:
        r"""
        Returns a dictionary of decision variables in the problem.
        The dictionary may contain decision variables that are not used in the problem.
        
        Returns
        --------
        `dict[str, DecisionVar]`: Dictionary mapping variable names to DecisionVar objects.
        """
    @property
    def placeholders(self) -> builtins.dict[builtins.str, Placeholder]:
        r"""
        Returns a dictionary of placeholders in the problem.
        The dictionary may contain placeholders that are not used in the problem;
        to get only used placeholders, use `used_placeholders` method.
        
        Returns
        --------
        `dict[str, Placeholder]`: Dictionary mapping placeholder names to Placeholder objects.
        """
    def __iadd__(self, other:typing.Any) -> Problem: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def eval(self, instance_data:dict) -> ommx.v1.Instance: ...
    def Placeholder(self, name:builtins.str, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, dtype:DataType | type | tuple=DataType.FLOAT, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder: ...
    def Integer(self, name:builtins.str, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A shorthand for `Problem.Placeholder(dtype=int)`
        """
    def Float(self, name:builtins.str, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A shorthand for `Problem.Placeholder(dtype=float)`
        """
    def Natural(self, name:builtins.str, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A shorthand for `Problem.Placeholder(dtype=DataType.NATURAL)`
        """
    def Length(self, name:builtins.str, *, ndim:typing.Optional[builtins.int]=0, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A plceholder expressing array length.
        This is just a shorthand for `Problem.Natural()`.
        When omitted, `ndim` is set to be `0`.
        """
    def Dim(self, name:builtins.str, *, ndim:typing.Optional[builtins.int]=0, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A placeholder expressing array dimension.
        This is just a shorthand for `Problem.Natural()`.
        When omitted, `ndim` is set to be `0`.
        """
    def Binary(self, name:builtins.str, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]] | typing.Sequence[typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A shorthand for `Problem.Placeholder(dtype=DataType.BINARY)`
        """
    def Graph(self, name:builtins.str, *, vertex:DataType | type | tuple=DataType.NATURAL, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder:
        r"""
        A placeholder expressing a directed graph (without edge weights), represented by a 1-dimensional array of tuples.
        This is just a shorthand for `Problem.Placeholder(dtype=(vertex, vertex), ndim=1)`.
        """
    def DecisionVar(self, name:builtins.str, *, kind:DecisionVarKind, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar:
        r"""
        A function to create a decision variable and register to the problem namespace. See `DecisionVar` for more details.
        
        Args
        -----
        - `name` (`str`): A name of the binary variable.
        - `kind` (`DecisionVarKind`): A kind of the decision variable.
        - `shape` (`list | tuple`): A sequence with the size of each dimension of the binary variable. Defaults to an empty tuple (a scalar value).
          - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
        - `lower_bound` and `upper_bound` (`jijmodeling.Expression`): A lower and upper bounds of the binary variable.
        - `kind` (`DecisionVarKind`): A kind of the decision variable.
        - `latex` (`str`, optional): A LaTeX-name of the binary variable to be represented in Jupyter notebook.
          - It is set to `name` by default.
        - `description` (`str`, optional): A description of the binary variable.
        
        Examples
        ---------
        Create a scalar binary variable whose name is "z".
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> z = problem.DecisionVar("z", kind=jm.DecisionVarKind.BINARY, lower_bound=0, upper_bound=1)
        
        ```
        
        Create a 2-dimensional binary variable whose name is "x" and has a 2x2 shape.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problem.BinaryVar("x", shape=[2, 2])
        
        ```
        
        Create a 1-dimensional binary variable with the index of `123`.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = jm.BinaryVar("x", shape=[124])
        >>> x[123]
        BinaryVar(name='x', shape=[NumberLit(value=124)])[NumberLit(value=123)]
        
        ```
        """
    def BinaryVar(self, name:builtins.str, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar:
        r"""
        A function to create a binary decision variable and register to the problem namespace. See `DecisionVar` for more details.
        
        Args
        -----
        - `name` (`str`): A name of the binary variable.
        - `shape` (`list | tuple`): A sequence with the size of each dimension of the binary variable. Defaults to an empty tuple (a scalar value).
          - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
        - `latex` (`str`, optional): A LaTeX-name of the binary variable to be represented in Jupyter notebook.
          - It is set to `name` by default.
        - `description` (`str`, optional): A description of the binary variable.
        
        Examples
        ---------
        Create a scalar binary variable whose name is "z".
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> z = problem.BinaryVar("z")
        
        ```
        
        Create a 2-dimensional binary variable whose name is "x" and has a 2x2 shape.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problem.BinaryVar("x", shape=[2, 2])
        
        ```
        
        Create a 1-dimensional binary variable with the index of `123`.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problemm.BinaryVar("x", shape=[124])
        >>> x[123]
        x[123]
        
        ```
        """
    def IntegerVar(self, name:builtins.str, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar:
        r"""
        A function to create a decision variable and register to the problem namespace. See `DecisionVar` for more details.
        
        Args
        -----
        - `name` (`str): A name of the integer variable.
        - `shape` (`list | tuple`): A sequence with the size of each dimension of the integer variable. Defaults to an empty tuple (a scalar value).
          - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
        - `lower_bound`: The lower bound of the variable.
        - `upper_bound`: The upper bound of the variable.
        - `latex` (`str`, optional): A LaTeX-name of the integer variable to be represented in Jupyter notebook.
          - It is set to `name` by default.
        - `description` (`str`, optional): A description of the integer variable.
        
        Raises
        -------
        `ModelingError`: Raises if a bound is a `Placeholder` or `Subscript` object whose `ndim`
        is neither `0` nor the same value as `ndim` of the integer variable.
        
        Examples
        ---------
        Create a scalar integer variable whose name is "z" and domain is `[-1, 1]`.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> z = problem.IntegerVar("z", lower_bound=-1, upper_bound=1)
        
        ```
        
        Create a 2-dimensional integer variable...
        - whose name is "x".
        - whose domain is [0, 2].
        - where each dimension has length 2 (making this a 2x2 matrix).
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problem.IntegerVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
        
        ```
        
        Create a 1-dimensional integer variable with the index of `123`.
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("my_problem")
        >>> x = problem.IntegerVar("x", shape=[124], lower_bound=0, upper_bound=2)
        >>> x[123]
        x[123]
        
        ```
        """
    def SemiIntegerVar(self, name:builtins.str, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar: ...
    def ContinuousVar(self, name:builtins.str, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar:
        r"""
        A function to create a decision variable and register to the problem namespace. See `DecisionVar` for more details.
        
        Args
        -----
        - `name` (`str`): A name of the continuous variable.
        - `shape` (`list | tuple`): A sequence with the size of each dimension of the continuous variable. Defaults to an empty tuple (a scalar value).
          - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
        - `lower_bound`: The lower bound of the variable.
        - `upper_bound`: The upper bound of the variable.
        - `latex` (`str`, optional): A LaTeX-name of the continuous variable to be represented in Jupyter notebook.
          - It is set to `name` by default.
        - `description` (`str`, optional): A description of the continuous variable.
        
        Raises
        -------
        `ModelingError`: Raises if a bound is a `Placeholder` or `Subscript` object whose `ndim` is neither `0` nor the same value as `ndim` of the continuous variable.
        
        Examples
        ---------
        Create a scalar continuous variable whose name is "z" and domain is `[-1, 1]`.
        
        ```python
        >>> import jijmodeling as jm
        >>> z = jm.ContinuousVar("z", lower_bound=-1, upper_bound=1)
        
        ```
        
        Create a 2-dimensional continuous variable...
        - whose name is "x".
        - whose domain is [0, 2].
        - where each dimension has length 2 (making this a 2x2 matrix).
        
        ```python
        >>> import jijmodeling as jm
        >>> x = jm.ContinuousVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
        
        ```
        
        Create a 1-dimensional continuous variable with the index of `123`.
        
        ```python
        >>> import jijmodeling as jm
        >>> x = jm.ContinuousVar("x", shape=[124], lower_bound=0, upper_bound=2)
        >>> x[123]
        ContinuousVar(name='x', shape=[NumberLit(value=124)], lower_bound=NumberLit(value=0), upper_bound=NumberLit(value=2))[NumberLit(value=123)]
        
        ```
        """
    def SemiContinuousVar(self, name:builtins.str, *, shape:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]]=None, lower_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], upper_bound:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any] | typing.Sequence[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]], latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> DecisionVar: ...
    def namespace(self) -> Namespace: ...
    def update(self, func:typing.Callable[[DecoratedProblem]]) -> DesugaredProblemBuilder:
        r"""
        A function decorator to modify an existing `Problem` using the decorated API.
        This must be decorated to a function that takes `DecoratedProblem` as the only argument and returns None.
        You can call `update` multiple times.
        The given function will automatically be evaluated exactly once by the decocrator, so you DO NOT need to call the original function again.
        
        Example
        -------
        
        ```python
        >>> import jijmodeling as jm
        >>> problem = jm.Problem("Knapsack Problem", sense=jm.ProblemSense.MAXIMIZE)
        >>>
        >>> @problem.update
        >>> def my_updater(problem: jm.DecoratedProblem):
        >>>     w = problem.Float(ndim=1, description="Weights of the items")
        >>>     N = w.len_at(0)
        >>>     v = problem.Float(ndim=1, description="Values of the items")
        >>>     W = problem.Float(description="Total weight")
        >>>     x = problem.BinaryVar(shape=(N,), description="Selected items")
        >>>
        >>>     problem += problem.Constraint("weight", jm.sum(w * x) <= W)
        >>>     problem += jm.sum(v * x)
        >>>
        >>> w_data = [10, 20, 30]
        >>> v_data = [60, 100, 120]
        >>> instance_data = {"w": w_data, "v": v_data, "W": 50}
        >>> instance = problem.eval(instance_data)
        ```
        """
    def get_problem_schema(self) -> dict:
        r"""
        Returns the schema of the problem.
        
        Returns
        --------
        - `schema`: The dictionary containing the schema of the problem.
        """
    def generate_random_dataset(self, _default:typing.Any, _options:typing.Any, _seed:typing.Optional[builtins.int]) -> typing.Any:
        r"""
        Generates a dictionary of random `InstanceDataValue` for a given problem.
        To generate `ommx.v1.Instance` object directly, use `InstanceDataValue.generate_random_instance` instead.
        
        Args
        -----
        - `options` (optional): a dictionary of range parameters for each separate placeholders. The key must be the name of the placeholder and the value must be range parameter (as described in "Range Parameters and Range Syntax" below).
        - `default` (optional): default range parameters for placeholders which is not specified in `options`.
        - `seed` (optional): seed for random number generation.
        
        Returns
        --------
        `dict`: The dictionary from the name of placeholders to the generated `InstanceDataValue` objects. To be fed to `Interpreter.eval_problem`.
        
        Range Parameters and Range Syntax
        ----------------------------------
        A range parameter is a dictionary consisting of the following fields:
        - `size` (optional): interval of natural numbers for the size of each array dimension (default: `range(1, 6)`)
        - `value` (optional): interval of real numbers for the value of each array element (default: `range(-1.0, 1.0)` - a uniform distribution on a closed interval $[-1.0, 1.0]$).
        
        Example range parameter config:
        
        ```python
        {"size": range(2, 10), "value": jm.range.value.closed(100.0, 200.0)}
        ```
        
        Intervals are expressed as a range object.
        Currently, the following syntax is supported for range objects:
        
        1. Direct value of type `int` or `float` - it corresponds to a singleton interval $[a, a] = \{a\}$. In random generation context, this just means a constant fixed value.
        2. Use the functions from `jijmodeling.range`, `jijmodeling.range.size`, or `jijmodeling.range.value` modules.
           - Use functions from `jij.modeling.range.size` to specify (non-negative) integer intervals, and `jij.modeling.range.value` for real intervals. `jij.modeling.range` dynamically determines the type of the range based on the input.
           - These three modules provides the following combinators (see the module documents for more details.):
                    - `closed(a, b)`: a closed interval $[a, b]$
                    - `open(a, b)`: an open interval $(a, b)$
                    - `closed_open(a, b)`: an upper half-open interval $[a, b)$
                    - `open_closed(a, b)`: a lower half-open interval $(a, b]$
                    - `greater_than(a)`: an open interval $(a, \infty)$
                    - `at_least(a)`: a closed interval $[a, \infty)$
                    - `less_than(a)`: an open interval $(-\infty, a)$
                    - `at_most(a)`: a closed interval $(-\infty, a]$
        3. Use `range` builtin function: this is equivalent to `jijmodeling.range.value.closed_open(a, b)`.
           - Any python range object with `step = 1` can be used as a size range; otherwise it results in runtime error.
        4. Use a tuple: raw tuple `(a, b)` is equivalent to `jijmodeling.range.closed_open(a, b)` if `a` and `b` are either `int` or `float`.
           - You can also use bound object as a tuple component; in such case, both tuple components must be one of the following:
        
                1. A string `"Unbounded"` means $-\infty$ (in the first component) or $\infty$ (the second).
                2. A dictionary `{"Included": a}` means the endpoint is inclusive.
                3. A dictionary `{"Excluded": a}` means the endpoint is exclusive.
           - Examples:
                    - `(1.2, 4)` is equivalent to `closed_open(1.2, 4)`,
                    - `(-1, {"Included": 1})` is equivalent to `closed(-1, 1)`,
                    - `(-5, {"Excluded": 4})` is equivalent to `closed_open(-5, 4)` and built in function `range(-5, 4)`,
                    - `({"Excluded": 1}, {"Excluded": 2.5})` is equivalent to `open(1, 2.5)`,
                    - `({"Included": -1}, "Unbounded")` is equivalent to `at_least(-1)`.
                    - `(5, "Unbounded")` is **INVALID**; `5` must be bound object.
        5. The range object: A dictionary of form `{"start": lb, "end": ub}`, where both `lb` and `ub` are the bound object described as above.
        
        Examples
        ---------
        ```python
        >>> import jijmodeling as jm
        >>> import builtins
        >>> N = jm.Placeholder("N", dtype=jm.DataType.INTEGER)
        >>> c = jm.Placeholder("c", dtype=jm.DataType.FLOAT, shape=(N,))
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> i = jm.Element("i", belong_to=N)
        
        >>> problem = jm.Problem("problem")
        >>> problem += jm.sum(i, c[i] * x[i])
        
        >>> inputs = problem.generate_random_dataset(
        ...     options={
        ...         'N': {"value": builtins.range(10, 20)},
        ...         'c': {"value": jm.range.value.closed(-1.0, 1.0)}
        ...          # You can also specify "size" for the range of jagged array dimension size.
        ...     },
        ...     seed=123 # omittable
        ... )
        >>> assert set(inputs.keys()) == {"N", "c"}
        >>> inputs
        {'N': 11.0, 'c': array([ 0.93914459, -0.06511935, -0.7460324 , -0.32443706,  0.99981451,
               -0.24407535,  0.31329469,  0.52206453, -0.1291936 ,  0.30443087,
                0.53125838])}
        
        ```
        """
    def generate_random_instance(self, _default:typing.Any, _options:typing.Any, _seed:typing.Optional[builtins.int], _hints:typing.Optional[typing.Any]) -> typing.Any:
        r"""
        Generates random `ommx.v1.Instance` for a given problem.
        See also `InstanceDataValue.generate_random_dataset`.
        
        Args
        -----
        - `options` (optional): a dictionary of range parameters for each separate placeholders. The key must be the name of the placeholder and the value must be range parameter (as described in "Range Parameters and Range Syntax" section in :func:`~jijmodeling.Problem.generate_random_dataset`).
        - `default` (optional): default range parameters for placeholders which is not specified in `options`.
        - `seed` (optional): seed for random number generation.
        - `hints` (optional): the hints to be detected during compilation see `Interpreter.eval_problem` for more details.
        
        Returns
        --------
        `instance`: The OMMX v1 instance object.
        
        Examples
        ---------
        ```python
        >>> import jijmodeling as jm
        >>> import builtins
        >>> import ommx.v1
        >>> N = jm.Placeholder("N", dtype=jm.DataType.INTEGER)
        >>> c = jm.Placeholder("c", dtype=jm.DataType.FLOAT, shape=(N,))
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> i = jm.Element("i", belong_to=N)
        
        >>> problem = jm.Problem("problem")
        >>> problem += jm.sum(i, c[i] * x[i])
        
        >>> instance = problem.generate_random_instance(
        ...     options={
        ...         'N': {"value": builtins.range(10, 20)},
        ...         'c': {"value": jm.range.value.closed(-1.0, 1.0)}
        ...     },
        ...     seed=123
        ... )
        >>> assert type(instance) is ommx.v1.Instance
        
        ```
        """
    def type_of(self, name:builtins.str) -> Type: ...
    def infer(self, expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Type: ...
    @typing.overload
    def Constraint(self, name:builtins.str, expression:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], domain:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], description:typing.Optional[builtins.str]=None) -> Constraint:
        r"""
        Constructs `Constraint` object from index set and function to build comparison expression from each index, __WITHOUT__ registering it to the problem.
        Use `+=` operator to register the constraint to the problem.
        """
    @typing.overload
    def Constraint(self, name:builtins.str, expression:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], description:typing.Optional[builtins.str]=None) -> Constraint:
        r"""
        Constructs `Constraint` object from comparison expression, __WITHOUT__ registering it to the problem.
        Use `+=` operator to register the constraint to the problem.
        """
    def __new__(cls, name:builtins.str, *, sense:ProblemSense=ProblemSense.MINIMIZE, description:typing.Optional[builtins.str]=None) -> Problem: ...

class Type:
    def __eq__(self, other:builtins.object) -> builtins.bool: ...

class TypeError(builtins.Exception):
    ...

class ConstraintSense(Enum):
    EQUAL = ...
    LESS_THAN_EQUAL = ...
    GREATER_THAN_EQUAL = ...

class DataType(Enum):
    INTEGER = ...
    FLOAT = ...
    BINARY = ...
    NATURAL = ...

class DecisionVarKind(Enum):
    BINARY = ...
    INTEGER = ...
    CONTINUOUS = ...
    SEMI_INTEGER = ...
    SEMI_CONTINUOUS = ...

class ProblemSense(Enum):
    r"""
    An optimization sense
    """
    MINIMIZE = ...
    MAXIMIZE = ...

def Some(inner:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def abs(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def acos(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def acosh(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def asin(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def asinh(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def atan(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def atanh(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def band(lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def bnot(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def bor(lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def ceil(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def cos(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def cosh(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def diff(lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def exp(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def filter(predicate:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], operand:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def flat_map(func:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], arg:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def floor(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def is_same(src:typing.Any, dst:typing.Any) -> builtins.bool:
    r"""
    Return `true` if `src` and `dst` are the same object defined by Jijmodeling.
    
    
    Args
    -----
    - `src`: An object defined by Jijmodeling module, or an iterable of Jijmodeling objects.
    - `dst`: An object defined by Jijmodeling module, or an iterable of Jijmodeling objects.
    
    Returns
    --------
    `bool`: `true` if `src` and `dst` is the same object. Otherwise `false`.
    
    Examples
    ---------
    Check if the two placeholders are the same.
    
    ```python
    >>> import jijmodeling as jm
    >>> problem = jm.Problem("problem")
    >>> a = problem.Placeholder("name")
    >>> b = problem.Placeholder("name")
    >>> assert jm.is_same(a, b)
    >>> c = problem.Placeholder("name", ndim=2)
    >>> assert not jm.is_same(a, c) # the value of `ndim` is different
    ```
    
    Raises
    -------
    `TypeError`: Raises if
    - `src` and `dst` are of different types which are not iterable
    - called on a type not defined by Jijmodeling (e.g. `str`)
    
    Note
    -----
    This function does not check the following attributes:
    - `description`
    - `latex`
    
    For example,
    
    ```python
    >>> import jijmodeling as jm
    >>> problem = jm.Problem("problem")
    >>> src = problem.Placeholder("placeholder", latex="src")
    >>> dst = problem.Placeholder("placeholder", latex="dst")
    >>> assert jm.is_same(src, dst)
    ```
    
    this code works without any exception.
    """

def ln(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def log10(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def log2(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def map(func:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], arg:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def map_or_else(option:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], default:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], mapper:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
    r"""
    If option is `Some(value)`, applies `mapper(value)`, otherwise returns default.
    """

@typing.overload
def max(operand:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
    r"""
    Return the maximum element of a list or tensor expression.
    """

@typing.overload
def max(lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
    r"""
    Return the larger of two expressions.
    """

@typing.overload
def min(operand:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
    r"""
    Return the minimum element of a list or tensor expression
    """

@typing.overload
def min(lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
    r"""
    Return the smaller of two expressions.
    """

def neg(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def or_else(option:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], default:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
    r"""
    Returns the value inside option if Some, otherwise returns default.
    """

@typing.overload
def prod(index:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], operand:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
    r"""
    Takes an index and an operand representing the product operation in positional style. Eg. `jm.prod(N, lambda i: x[i])`
    """

@typing.overload
def prod(operand:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], axis:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]=None) -> Expression:
    r"""
    Takes the product of a set or tensor-like expression. You can use `axis` to partially reducing the tensor along specified axes. Eg. `jm.prod(N.map(lambda i: x[i]))`
    """

@typing.overload
def prod(x:typing.Generator[Expression]) -> Expression:
    r"""
    Comprehension syntax for jm.prod (NOTE: only works with decorated API!)
    """

def product(*sets) -> Expression:
    r"""
    Takes the cartesian product of given set-like expressions.
    """

def roll(operand:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], shift:typing.Any, *, axis:typing.Optional[builtins.int]=None) -> Expression: ...

def rows(array:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def set(operand:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def sin(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def sinh(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def sqrt(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

@typing.overload
def sum(index:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], operand:typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression:
    r"""
    Takes an index and an operand representing the summation operation in positional style. Eg. `jm.sum(N, lambda i: x[i])`
    """

@typing.overload
def sum(operand:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], axis:typing.Optional[Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]]=None) -> Expression:
    r"""
    Takes the summation of set or tensor-like expression. You can use `axis` to partially reducing the tensor along specified axes. Eg. `jm.sum(N.map(lambda i: x[i]))`
    """

@typing.overload
def sum(x:typing.Generator[Expression]) -> Expression:
    r"""
    Comprehension syntax for jm.sum (NOTE: only works with decorated API!)
    """

def tan(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def tanh(expr:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

def xor(lhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any], rhs:Expression | builtins.int | builtins.float | DecisionVar | Placeholder | list | tuple | typing.Callable[[Expression], typing.Any] | typing.Callable[[Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression], typing.Any] | typing.Callable[[Expression, Expression, Expression, Expression, Expression], typing.Any]) -> Expression: ...

