# This file was auto-generated by Fern from our API Definition.

import contextlib
import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError as core_api_error_ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.conflict_error import ConflictError
from ..errors.content_too_large_error import ContentTooLargeError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.locked_error import LockedError
from ..errors.method_not_allowed_error import MethodNotAllowedError
from ..errors.not_found_error import NotFoundError
from ..errors.precondition_failed_error import PreconditionFailedError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.action_run import ActionRun
from ..types.action_run_job import ActionRunJob
from ..types.action_task_response import ActionTaskResponse
from ..types.action_variable import ActionVariable
from ..types.activity import Activity
from ..types.annotated_tag import AnnotatedTag
from ..types.api_error import ApiError as types_api_error_ApiError
from ..types.api_repo_archived_error import ApiRepoArchivedError
from ..types.api_unauthorized_error import ApiUnauthorizedError
from ..types.attachment import Attachment
from ..types.branch import Branch
from ..types.branch_protection import BranchProtection
from ..types.change_file_operation import ChangeFileOperation
from ..types.changed_file import ChangedFile
from ..types.combined_status import CombinedStatus
from ..types.commit import Commit
from ..types.commit_date_options import CommitDateOptions
from ..types.commit_status import CommitStatus
from ..types.commit_status_state import CommitStatusState
from ..types.compare import Compare
from ..types.contents_response import ContentsResponse
from ..types.create_hook_option_config import CreateHookOptionConfig
from ..types.create_hook_option_type import CreateHookOptionType
from ..types.create_pull_review_comment import CreatePullReviewComment
from ..types.create_repo_option_object_format_name import \
    CreateRepoOptionObjectFormatName
from ..types.create_repo_option_trust_model import CreateRepoOptionTrustModel
from ..types.deploy_key import DeployKey
from ..types.dispatch_workflow_run import DispatchWorkflowRun
from ..types.external_tracker import ExternalTracker
from ..types.external_wiki import ExternalWiki
from ..types.file_delete_response import FileDeleteResponse
from ..types.file_response import FileResponse
from ..types.files_response import FilesResponse
from ..types.git_blob import GitBlob
from ..types.git_hook import GitHook
from ..types.git_tree_response import GitTreeResponse
from ..types.hook import Hook
from ..types.identity import Identity
from ..types.internal_tracker import InternalTracker
from ..types.issue import Issue
from ..types.issue_config import IssueConfig
from ..types.issue_config_validation import IssueConfigValidation
from ..types.issue_template import IssueTemplate
from ..types.list_action_run_response import ListActionRunResponse
from ..types.new_issue_pins_allowed import NewIssuePinsAllowed
from ..types.note import Note
from ..types.pull_request import PullRequest
from ..types.pull_review import PullReview
from ..types.pull_review_comment import PullReviewComment
from ..types.push_mirror import PushMirror
from ..types.reference import Reference
from ..types.registration_token import RegistrationToken
from ..types.release import Release
from ..types.repo_collaborator_permission import RepoCollaboratorPermission
from ..types.repository import Repository
from ..types.review_state_type import ReviewStateType
from ..types.search_results import SearchResults
from ..types.secret import Secret
from ..types.sync_fork_info import SyncForkInfo
from ..types.tag import Tag
from ..types.tag_protection import TagProtection
from ..types.team import Team
from ..types.topic_name import TopicName
from ..types.tracked_time import TrackedTime
from ..types.user import User
from ..types.watch_info import WatchInfo
from ..types.wiki_commit_list import WikiCommitList
from ..types.wiki_page import WikiPage
from ..types.wiki_page_meta_data import WikiPageMetaData
from .types.add_collaborator_option_permission import \
    AddCollaboratorOptionPermission
from .types.list_action_runs_request_status_item import \
    ListActionRunsRequestStatusItem
from .types.merge_pull_request_option_do import MergePullRequestOptionDo
from .types.migrate_repo_options_service import MigrateRepoOptionsService
from .types.repo_download_commit_diff_or_patch_request_diff_type import \
    RepoDownloadCommitDiffOrPatchRequestDiffType
from .types.repo_download_pull_diff_or_patch_request_diff_type import \
    RepoDownloadPullDiffOrPatchRequestDiffType
from .types.repo_get_contents_response import RepoGetContentsResponse
from .types.repo_get_pull_request_files_request_whitespace import \
    RepoGetPullRequestFilesRequestWhitespace
from .types.repo_list_pull_requests_request_sort import \
    RepoListPullRequestsRequestSort
from .types.repo_list_pull_requests_request_state import \
    RepoListPullRequestsRequestState
from .types.repo_list_statuses_by_ref_request_sort import \
    RepoListStatusesByRefRequestSort
from .types.repo_list_statuses_by_ref_request_state import \
    RepoListStatusesByRefRequestState
from .types.repo_list_statuses_request_sort import RepoListStatusesRequestSort
from .types.repo_list_statuses_request_state import \
    RepoListStatusesRequestState
from .types.repo_search_request_order import RepoSearchRequestOrder
from .types.repo_search_request_sort import RepoSearchRequestSort
from .types.repo_update_pull_request_request_style import \
    RepoUpdatePullRequestRequestStyle
from .types.topic_search_results import TopicSearchResults

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawRepositoryClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def repo_migrate(
        self,
        *,
        clone_addr: str,
        repo_name: str,
        auth_password: typing.Optional[str] = OMIT,
        auth_token: typing.Optional[str] = OMIT,
        auth_username: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        issues: typing.Optional[bool] = OMIT,
        labels: typing.Optional[bool] = OMIT,
        lfs: typing.Optional[bool] = OMIT,
        lfs_endpoint: typing.Optional[str] = OMIT,
        milestones: typing.Optional[bool] = OMIT,
        mirror: typing.Optional[bool] = OMIT,
        mirror_interval: typing.Optional[str] = OMIT,
        private: typing.Optional[bool] = OMIT,
        pull_requests: typing.Optional[bool] = OMIT,
        releases: typing.Optional[bool] = OMIT,
        repo_owner: typing.Optional[str] = OMIT,
        service: typing.Optional[MigrateRepoOptionsService] = OMIT,
        uid: typing.Optional[int] = OMIT,
        wiki: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        clone_addr : str

        repo_name : str

        auth_password : typing.Optional[str]

        auth_token : typing.Optional[str]

        auth_username : typing.Optional[str]

        description : typing.Optional[str]

        issues : typing.Optional[bool]

        labels : typing.Optional[bool]

        lfs : typing.Optional[bool]

        lfs_endpoint : typing.Optional[str]

        milestones : typing.Optional[bool]

        mirror : typing.Optional[bool]

        mirror_interval : typing.Optional[str]

        private : typing.Optional[bool]

        pull_requests : typing.Optional[bool]

        releases : typing.Optional[bool]

        repo_owner : typing.Optional[str]
            Name of User or Organisation who will own Repo after migration

        service : typing.Optional[MigrateRepoOptionsService]

        uid : typing.Optional[int]
            deprecated (only for backwards compatibility)

        wiki : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            "repos/migrate",
            method="POST",
            json={
                "auth_password": auth_password,
                "auth_token": auth_token,
                "auth_username": auth_username,
                "clone_addr": clone_addr,
                "description": description,
                "issues": issues,
                "labels": labels,
                "lfs": lfs,
                "lfs_endpoint": lfs_endpoint,
                "milestones": milestones,
                "mirror": mirror,
                "mirror_interval": mirror_interval,
                "private": private,
                "pull_requests": pull_requests,
                "releases": releases,
                "repo_name": repo_name,
                "repo_owner": repo_owner,
                "service": service,
                "uid": uid,
                "wiki": wiki,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_search(
        self,
        *,
        q: typing.Optional[str] = None,
        topic: typing.Optional[bool] = None,
        include_desc: typing.Optional[bool] = None,
        uid: typing.Optional[int] = None,
        priority_owner_id: typing.Optional[int] = None,
        team_id: typing.Optional[int] = None,
        starred_by: typing.Optional[int] = None,
        private: typing.Optional[bool] = None,
        is_private: typing.Optional[bool] = None,
        template: typing.Optional[bool] = None,
        archived: typing.Optional[bool] = None,
        mode: typing.Optional[str] = None,
        exclusive: typing.Optional[bool] = None,
        sort: typing.Optional[RepoSearchRequestSort] = None,
        order: typing.Optional[RepoSearchRequestOrder] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SearchResults]:
        """
        Parameters
        ----------
        q : typing.Optional[str]
            keyword

        topic : typing.Optional[bool]
            Limit search to repositories with keyword as topic

        include_desc : typing.Optional[bool]
            include search of keyword within repository description

        uid : typing.Optional[int]
            search only for repos that the user with the given id owns or contributes to

        priority_owner_id : typing.Optional[int]
            repo owner to prioritize in the results

        team_id : typing.Optional[int]
            search only for repos that belong to the given team id

        starred_by : typing.Optional[int]
            search only for repos that the user with the given id has starred

        private : typing.Optional[bool]
            include private repositories this user has access to (defaults to true)

        is_private : typing.Optional[bool]
            show only public, private or all repositories (defaults to all)

        template : typing.Optional[bool]
            include template repositories this user has access to (defaults to true)

        archived : typing.Optional[bool]
            show only archived, non-archived or all repositories (defaults to all)

        mode : typing.Optional[str]
            type of repository to search for. Supported values are "fork", "source", "mirror" and "collaborative"

        exclusive : typing.Optional[bool]
            if `uid` is given, search only for repos that the user owns

        sort : typing.Optional[RepoSearchRequestSort]
            sort repos by attribute. Supported values are "alpha", "created", "updated", "size", "git_size", "lfs_size", "stars", "forks" and "id". Default is "alpha"

        order : typing.Optional[RepoSearchRequestOrder]
            sort order, either "asc" (ascending) or "desc" (descending). Default is "asc", ignored if "sort" is not specified.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SearchResults]
            SearchResults
        """
        _response = self._client_wrapper.httpx_client.request(
            "repos/search",
            method="GET",
            params={
                "q": q,
                "topic": topic,
                "includeDesc": include_desc,
                "uid": uid,
                "priority_owner_id": priority_owner_id,
                "team_id": team_id,
                "starredBy": starred_by,
                "private": private,
                "is_private": is_private,
                "template": template,
                "archived": archived,
                "mode": mode,
                "exclusive": exclusive,
                "sort": sort,
                "order": order,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SearchResults,
                    parse_obj_as(
                        type_=SearchResults,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to delete

        repo : str
            name of the repo to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit(
        self,
        owner: str,
        repo: str,
        *,
        allow_fast_forward_only_merge: typing.Optional[bool] = OMIT,
        allow_manual_merge: typing.Optional[bool] = OMIT,
        allow_merge_commits: typing.Optional[bool] = OMIT,
        allow_rebase: typing.Optional[bool] = OMIT,
        allow_rebase_explicit: typing.Optional[bool] = OMIT,
        allow_rebase_update: typing.Optional[bool] = OMIT,
        allow_squash_merge: typing.Optional[bool] = OMIT,
        archived: typing.Optional[bool] = OMIT,
        autodetect_manual_merge: typing.Optional[bool] = OMIT,
        default_allow_maintainer_edit: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        default_delete_branch_after_merge: typing.Optional[bool] = OMIT,
        default_merge_style: typing.Optional[str] = OMIT,
        default_update_style: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        enable_prune: typing.Optional[bool] = OMIT,
        external_tracker: typing.Optional[ExternalTracker] = OMIT,
        external_wiki: typing.Optional[ExternalWiki] = OMIT,
        globally_editable_wiki: typing.Optional[bool] = OMIT,
        has_actions: typing.Optional[bool] = OMIT,
        has_issues: typing.Optional[bool] = OMIT,
        has_packages: typing.Optional[bool] = OMIT,
        has_projects: typing.Optional[bool] = OMIT,
        has_pull_requests: typing.Optional[bool] = OMIT,
        has_releases: typing.Optional[bool] = OMIT,
        has_wiki: typing.Optional[bool] = OMIT,
        ignore_whitespace_conflicts: typing.Optional[bool] = OMIT,
        internal_tracker: typing.Optional[InternalTracker] = OMIT,
        mirror_interval: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        private: typing.Optional[bool] = OMIT,
        template: typing.Optional[bool] = OMIT,
        website: typing.Optional[str] = OMIT,
        wiki_branch: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to edit

        repo : str
            name of the repo to edit

        allow_fast_forward_only_merge : typing.Optional[bool]
            either `true` to allow fast-forward-only merging pull requests, or `false` to prevent fast-forward-only merging.

        allow_manual_merge : typing.Optional[bool]
            either `true` to allow mark pr as merged manually, or `false` to prevent it.

        allow_merge_commits : typing.Optional[bool]
            either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.

        allow_rebase : typing.Optional[bool]
            either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.

        allow_rebase_explicit : typing.Optional[bool]
            either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits.

        allow_rebase_update : typing.Optional[bool]
            either `true` to allow updating pull request branch by rebase, or `false` to prevent it.

        allow_squash_merge : typing.Optional[bool]
            either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.

        archived : typing.Optional[bool]
            set to `true` to archive this repository.

        autodetect_manual_merge : typing.Optional[bool]
            either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur.

        default_allow_maintainer_edit : typing.Optional[bool]
            set to `true` to allow edits from maintainers by default

        default_branch : typing.Optional[str]
            sets the default branch for this repository.

        default_delete_branch_after_merge : typing.Optional[bool]
            set to `true` to delete pr branch after merge by default

        default_merge_style : typing.Optional[str]
            set to a merge style to be used by this repository: "merge", "rebase", "rebase-merge", "squash", "fast-forward-only", "manually-merged", or "rebase-update-only".

        default_update_style : typing.Optional[str]
            set to a update style to be used by this repository: "rebase" or "merge"

        description : typing.Optional[str]
            a short description of the repository.

        enable_prune : typing.Optional[bool]
            enable prune - remove obsolete remote-tracking references when mirroring

        external_tracker : typing.Optional[ExternalTracker]

        external_wiki : typing.Optional[ExternalWiki]

        globally_editable_wiki : typing.Optional[bool]
            set the globally editable state of the wiki

        has_actions : typing.Optional[bool]
            either `true` to enable actions unit, or `false` to disable them.

        has_issues : typing.Optional[bool]
            either `true` to enable issues for this repository or `false` to disable them.

        has_packages : typing.Optional[bool]
            either `true` to enable packages unit, or `false` to disable them.

        has_projects : typing.Optional[bool]
            either `true` to enable project unit, or `false` to disable them.

        has_pull_requests : typing.Optional[bool]
            either `true` to allow pull requests, or `false` to prevent pull request.

        has_releases : typing.Optional[bool]
            either `true` to enable releases unit, or `false` to disable them.

        has_wiki : typing.Optional[bool]
            either `true` to enable the wiki for this repository or `false` to disable it.

        ignore_whitespace_conflicts : typing.Optional[bool]
            either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace.

        internal_tracker : typing.Optional[InternalTracker]

        mirror_interval : typing.Optional[str]
            set to a string like `8h30m0s` to set the mirror interval time

        name : typing.Optional[str]
            name of the repository

        private : typing.Optional[bool]
            either `true` to make the repository private or `false` to make it public.
            Note: you will get a 422 error if the organization restricts changing repository visibility to organization
            owners and a non-owner tries to change the value of private.

        template : typing.Optional[bool]
            either `true` to make this repository a template or `false` to make it a normal repository

        website : typing.Optional[str]
            a URL with more information about the repository.

        wiki_branch : typing.Optional[str]
            sets the branch used for this repository's wiki.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="PATCH",
            json={
                "allow_fast_forward_only_merge": allow_fast_forward_only_merge,
                "allow_manual_merge": allow_manual_merge,
                "allow_merge_commits": allow_merge_commits,
                "allow_rebase": allow_rebase,
                "allow_rebase_explicit": allow_rebase_explicit,
                "allow_rebase_update": allow_rebase_update,
                "allow_squash_merge": allow_squash_merge,
                "archived": archived,
                "autodetect_manual_merge": autodetect_manual_merge,
                "default_allow_maintainer_edit": default_allow_maintainer_edit,
                "default_branch": default_branch,
                "default_delete_branch_after_merge": default_delete_branch_after_merge,
                "default_merge_style": default_merge_style,
                "default_update_style": default_update_style,
                "description": description,
                "enable_prune": enable_prune,
                "external_tracker": convert_and_respect_annotation_metadata(
                    object_=external_tracker,
                    annotation=ExternalTracker,
                    direction="write",
                ),
                "external_wiki": convert_and_respect_annotation_metadata(
                    object_=external_wiki, annotation=ExternalWiki, direction="write"
                ),
                "globally_editable_wiki": globally_editable_wiki,
                "has_actions": has_actions,
                "has_issues": has_issues,
                "has_packages": has_packages,
                "has_projects": has_projects,
                "has_pull_requests": has_pull_requests,
                "has_releases": has_releases,
                "has_wiki": has_wiki,
                "ignore_whitespace_conflicts": ignore_whitespace_conflicts,
                "internal_tracker": convert_and_respect_annotation_metadata(
                    object_=internal_tracker,
                    annotation=InternalTracker,
                    direction="write",
                ),
                "mirror_interval": mirror_interval,
                "name": name,
                "private": private,
                "template": template,
                "website": website,
                "wiki_branch": wiki_branch,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_search_run_jobs(
        self,
        owner: str,
        repo: str,
        *,
        labels: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[ActionRunJob]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        labels : typing.Optional[str]
            a comma separated list of run job labels to search for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[ActionRunJob]]
            RunJobList is a list of action run jobs
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runners/jobs",
            method="GET",
            params={
                "labels": labels,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ActionRunJob],
                    parse_obj_as(
                        type_=typing.List[ActionRunJob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_runner_registration_token(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RegistrationToken]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RegistrationToken]
            RegistrationToken is a string used to register a runner with a server
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runners/registration-token",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RegistrationToken,
                    parse_obj_as(
                        type_=RegistrationToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_action_runs(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        event: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        status: typing.Optional[
            typing.Union[
                ListActionRunsRequestStatusItem,
                typing.Sequence[ListActionRunsRequestStatusItem],
            ]
        ] = None,
        run_number: typing.Optional[int] = None,
        head_sha: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListActionRunResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        event : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Returns workflow run triggered by the specified events. For example, `push`, `pull_request` or `workflow_dispatch`.

        status : typing.Optional[typing.Union[ListActionRunsRequestStatusItem, typing.Sequence[ListActionRunsRequestStatusItem]]]
            Returns workflow runs with the check run status or conclusion that is specified. For example, a conclusion can be success or a status can be in_progress. Only Forgejo Actions can set a status of waiting, pending, or requested.

        run_number : typing.Optional[int]
            Returns the workflow run associated with the run number.

        head_sha : typing.Optional[str]
            Only returns workflow runs that are associated with the specified head_sha.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListActionRunResponse]
            ActionRunList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runs",
            method="GET",
            params={
                "page": page,
                "limit": limit,
                "event": event,
                "status": status,
                "run_number": run_number,
                "head_sha": head_sha,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListActionRunResponse,
                    parse_obj_as(
                        type_=ListActionRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def action_run(
        self,
        owner: str,
        repo: str,
        run_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ActionRun]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        run_id : int
            id of the action run

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ActionRun]
            ActionRun
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runs/{jsonable_encoder(run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActionRun,
                    parse_obj_as(
                        type_=ActionRun,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_actions_secrets(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Secret]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Secret]]
            SecretList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Secret],
                    parse_obj_as(
                        type_=typing.List[Secret],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def update_repo_secret(
        self,
        owner: str,
        repo: str,
        secretname: str,
        *,
        data: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        secretname : str
            name of the secret

        data : str
            Data of the secret to update

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets/{jsonable_encoder(secretname)}",
            method="PUT",
            json={
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_repo_secret(
        self,
        owner: str,
        repo: str,
        secretname: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        secretname : str
            name of the secret

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets/{jsonable_encoder(secretname)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_action_tasks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ActionTaskResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ActionTaskResponse]
            TasksList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/tasks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActionTaskResponse,
                    parse_obj_as(
                        type_=ActionTaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_repo_variables_list(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[ActionVariable]]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[ActionVariable]]
            VariableList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ActionVariable],
                    parse_obj_as(
                        type_=typing.List[ActionVariable],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ActionVariable]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ActionVariable]
            ActionVariable
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActionVariable,
                    parse_obj_as(
                        type_=ActionVariable,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        value: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        value : str
            Value of the variable to create

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="POST",
            json={
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def update_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        value: str,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        value : str
            Value of the variable to update

        name : typing.Optional[str]
            New name for the variable. If the field is empty, the variable name won't be updated.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="PUT",
            json={
                "name": name,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def dispatch_workflow(
        self,
        owner: str,
        repo: str,
        workflowfilename: str,
        *,
        ref: str,
        inputs: typing.Optional[typing.Dict[str, str]] = OMIT,
        return_run_info: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DispatchWorkflowRun]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        workflowfilename : str
            name of the workflow

        ref : str
            Git reference for the workflow

        inputs : typing.Optional[typing.Dict[str, str]]
            Input keys and values configured in the workflow file.

        return_run_info : typing.Optional[bool]
            Flag to return the run info

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DispatchWorkflowRun]
            DispatchWorkflowRun is a Workflow Run after dispatching
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/workflows/{jsonable_encoder(workflowfilename)}/dispatches",
            method="POST",
            json={
                "inputs": inputs,
                "ref": ref,
                "return_run_info": return_run_info,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DispatchWorkflowRun,
                    parse_obj_as(
                        type_=DispatchWorkflowRun,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_activity_feeds(
        self,
        owner: str,
        repo: str,
        *,
        date: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Activity]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        date : typing.Optional[str]
            the date of the activities to be found

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Activity]]
            ActivityFeedsList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/activities/feeds",
            method="GET",
            params={
                "date": date,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Activity],
                    parse_obj_as(
                        type_=typing.List[Activity],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_archive(
        self,
        owner: str,
        repo: str,
        archive: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        archive : str
            the git reference for download with attached archive format (e.g. master.zip)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/archive/{jsonable_encoder(archive)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_assignees(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[User]]
            UserList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/assignees",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_update_avatar(
        self,
        owner: str,
        repo: str,
        *,
        image: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        image : typing.Optional[str]
            image must be base64 encoded

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/avatar",
            method="POST",
            json={
                "image": image,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_avatar(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/avatar",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_branch_protection(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[BranchProtection]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[BranchProtection]]
            BranchProtectionList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[BranchProtection],
                    parse_obj_as(
                        type_=typing.List[BranchProtection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_branch_protection(
        self,
        owner: str,
        repo: str,
        *,
        apply_to_admins: typing.Optional[bool] = OMIT,
        approvals_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        approvals_whitelist_username: typing.Optional[typing.Sequence[str]] = OMIT,
        block_on_official_review_requests: typing.Optional[bool] = OMIT,
        block_on_outdated_branch: typing.Optional[bool] = OMIT,
        block_on_rejected_reviews: typing.Optional[bool] = OMIT,
        branch_name: typing.Optional[str] = OMIT,
        dismiss_stale_approvals: typing.Optional[bool] = OMIT,
        enable_approvals_whitelist: typing.Optional[bool] = OMIT,
        enable_merge_whitelist: typing.Optional[bool] = OMIT,
        enable_push: typing.Optional[bool] = OMIT,
        enable_push_whitelist: typing.Optional[bool] = OMIT,
        enable_status_check: typing.Optional[bool] = OMIT,
        ignore_stale_approvals: typing.Optional[bool] = OMIT,
        merge_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        merge_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        protected_file_patterns: typing.Optional[str] = OMIT,
        push_whitelist_deploy_keys: typing.Optional[bool] = OMIT,
        push_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        push_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        require_signed_commits: typing.Optional[bool] = OMIT,
        required_approvals: typing.Optional[int] = OMIT,
        rule_name: typing.Optional[str] = OMIT,
        status_check_contexts: typing.Optional[typing.Sequence[str]] = OMIT,
        unprotected_file_patterns: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BranchProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        apply_to_admins : typing.Optional[bool]

        approvals_whitelist_teams : typing.Optional[typing.Sequence[str]]

        approvals_whitelist_username : typing.Optional[typing.Sequence[str]]

        block_on_official_review_requests : typing.Optional[bool]

        block_on_outdated_branch : typing.Optional[bool]

        block_on_rejected_reviews : typing.Optional[bool]

        branch_name : typing.Optional[str]
            Deprecated: true

        dismiss_stale_approvals : typing.Optional[bool]

        enable_approvals_whitelist : typing.Optional[bool]

        enable_merge_whitelist : typing.Optional[bool]

        enable_push : typing.Optional[bool]

        enable_push_whitelist : typing.Optional[bool]

        enable_status_check : typing.Optional[bool]

        ignore_stale_approvals : typing.Optional[bool]

        merge_whitelist_teams : typing.Optional[typing.Sequence[str]]

        merge_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        protected_file_patterns : typing.Optional[str]

        push_whitelist_deploy_keys : typing.Optional[bool]

        push_whitelist_teams : typing.Optional[typing.Sequence[str]]

        push_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        require_signed_commits : typing.Optional[bool]

        required_approvals : typing.Optional[int]

        rule_name : typing.Optional[str]

        status_check_contexts : typing.Optional[typing.Sequence[str]]

        unprotected_file_patterns : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BranchProtection]
            BranchProtection
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections",
            method="POST",
            json={
                "apply_to_admins": apply_to_admins,
                "approvals_whitelist_teams": approvals_whitelist_teams,
                "approvals_whitelist_username": approvals_whitelist_username,
                "block_on_official_review_requests": block_on_official_review_requests,
                "block_on_outdated_branch": block_on_outdated_branch,
                "block_on_rejected_reviews": block_on_rejected_reviews,
                "branch_name": branch_name,
                "dismiss_stale_approvals": dismiss_stale_approvals,
                "enable_approvals_whitelist": enable_approvals_whitelist,
                "enable_merge_whitelist": enable_merge_whitelist,
                "enable_push": enable_push,
                "enable_push_whitelist": enable_push_whitelist,
                "enable_status_check": enable_status_check,
                "ignore_stale_approvals": ignore_stale_approvals,
                "merge_whitelist_teams": merge_whitelist_teams,
                "merge_whitelist_usernames": merge_whitelist_usernames,
                "protected_file_patterns": protected_file_patterns,
                "push_whitelist_deploy_keys": push_whitelist_deploy_keys,
                "push_whitelist_teams": push_whitelist_teams,
                "push_whitelist_usernames": push_whitelist_usernames,
                "require_signed_commits": require_signed_commits,
                "required_approvals": required_approvals,
                "rule_name": rule_name,
                "status_check_contexts": status_check_contexts,
                "unprotected_file_patterns": unprotected_file_patterns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BranchProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BranchProtection]
            BranchProtection
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        apply_to_admins: typing.Optional[bool] = OMIT,
        approvals_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        approvals_whitelist_username: typing.Optional[typing.Sequence[str]] = OMIT,
        block_on_official_review_requests: typing.Optional[bool] = OMIT,
        block_on_outdated_branch: typing.Optional[bool] = OMIT,
        block_on_rejected_reviews: typing.Optional[bool] = OMIT,
        dismiss_stale_approvals: typing.Optional[bool] = OMIT,
        enable_approvals_whitelist: typing.Optional[bool] = OMIT,
        enable_merge_whitelist: typing.Optional[bool] = OMIT,
        enable_push: typing.Optional[bool] = OMIT,
        enable_push_whitelist: typing.Optional[bool] = OMIT,
        enable_status_check: typing.Optional[bool] = OMIT,
        ignore_stale_approvals: typing.Optional[bool] = OMIT,
        merge_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        merge_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        protected_file_patterns: typing.Optional[str] = OMIT,
        push_whitelist_deploy_keys: typing.Optional[bool] = OMIT,
        push_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        push_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        require_signed_commits: typing.Optional[bool] = OMIT,
        required_approvals: typing.Optional[int] = OMIT,
        status_check_contexts: typing.Optional[typing.Sequence[str]] = OMIT,
        unprotected_file_patterns: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BranchProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        apply_to_admins : typing.Optional[bool]

        approvals_whitelist_teams : typing.Optional[typing.Sequence[str]]

        approvals_whitelist_username : typing.Optional[typing.Sequence[str]]

        block_on_official_review_requests : typing.Optional[bool]

        block_on_outdated_branch : typing.Optional[bool]

        block_on_rejected_reviews : typing.Optional[bool]

        dismiss_stale_approvals : typing.Optional[bool]

        enable_approvals_whitelist : typing.Optional[bool]

        enable_merge_whitelist : typing.Optional[bool]

        enable_push : typing.Optional[bool]

        enable_push_whitelist : typing.Optional[bool]

        enable_status_check : typing.Optional[bool]

        ignore_stale_approvals : typing.Optional[bool]

        merge_whitelist_teams : typing.Optional[typing.Sequence[str]]

        merge_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        protected_file_patterns : typing.Optional[str]

        push_whitelist_deploy_keys : typing.Optional[bool]

        push_whitelist_teams : typing.Optional[typing.Sequence[str]]

        push_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        require_signed_commits : typing.Optional[bool]

        required_approvals : typing.Optional[int]

        status_check_contexts : typing.Optional[typing.Sequence[str]]

        unprotected_file_patterns : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BranchProtection]
            BranchProtection
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="PATCH",
            json={
                "apply_to_admins": apply_to_admins,
                "approvals_whitelist_teams": approvals_whitelist_teams,
                "approvals_whitelist_username": approvals_whitelist_username,
                "block_on_official_review_requests": block_on_official_review_requests,
                "block_on_outdated_branch": block_on_outdated_branch,
                "block_on_rejected_reviews": block_on_rejected_reviews,
                "dismiss_stale_approvals": dismiss_stale_approvals,
                "enable_approvals_whitelist": enable_approvals_whitelist,
                "enable_merge_whitelist": enable_merge_whitelist,
                "enable_push": enable_push,
                "enable_push_whitelist": enable_push_whitelist,
                "enable_status_check": enable_status_check,
                "ignore_stale_approvals": ignore_stale_approvals,
                "merge_whitelist_teams": merge_whitelist_teams,
                "merge_whitelist_usernames": merge_whitelist_usernames,
                "protected_file_patterns": protected_file_patterns,
                "push_whitelist_deploy_keys": push_whitelist_deploy_keys,
                "push_whitelist_teams": push_whitelist_teams,
                "push_whitelist_usernames": push_whitelist_usernames,
                "require_signed_commits": require_signed_commits,
                "required_approvals": required_approvals,
                "status_check_contexts": status_check_contexts,
                "unprotected_file_patterns": unprotected_file_patterns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_branches(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Branch]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Branch]]
            BranchList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Branch],
                    parse_obj_as(
                        type_=typing.List[Branch],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_branch(
        self,
        owner: str,
        repo: str,
        *,
        new_branch_name: str,
        old_branch_name: typing.Optional[str] = OMIT,
        old_ref_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Branch]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        new_branch_name : str
            Name of the branch to create

        old_branch_name : typing.Optional[str]
            Deprecated: true
            Name of the old branch to create from

        old_ref_name : typing.Optional[str]
            Name of the old branch/tag/commit to create from

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Branch]
            Branch
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches",
            method="POST",
            json={
                "new_branch_name": new_branch_name,
                "old_branch_name": old_branch_name,
                "old_ref_name": old_ref_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Branch,
                    parse_obj_as(
                        type_=Branch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Branch]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            branch to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Branch]
            Branch
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Branch,
                    parse_obj_as(
                        type_=Branch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            branch to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_update_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            name of the branch

        name : str
            New branch name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="PATCH",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_collaborators(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[User]]
            UserList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_check_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        If the user is a collaborator, return 204. If the user is not a collaborator, return 404.

        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_add_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        permission: typing.Optional[AddCollaboratorOptionPermission] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator to add

        permission : typing.Optional[AddCollaboratorOptionPermission]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="PUT",
            json={
                "permission": permission,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_repo_permissions(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RepoCollaboratorPermission]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RepoCollaboratorPermission]
            RepoCollaboratorPermission
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}/permission",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RepoCollaboratorPermission,
                    parse_obj_as(
                        type_=RepoCollaboratorPermission,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_all_commits(
        self,
        owner: str,
        repo: str,
        *,
        sha: typing.Optional[str] = None,
        path: typing.Optional[str] = None,
        stat: typing.Optional[bool] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        not_: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Commit]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : typing.Optional[str]
            SHA or branch to start listing commits from (usually 'master')

        path : typing.Optional[str]
            filepath of a file/dir

        stat : typing.Optional[bool]
            include diff stats for every commit (disable for speedup, default 'true')

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results (ignored if used with 'path')

        not_ : typing.Optional[str]
            commits that match the given specifier will not be listed.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Commit]]
            CommitList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits",
            method="GET",
            params={
                "sha": sha,
                "path": path,
                "stat": stat,
                "verification": verification,
                "files": files,
                "page": page,
                "limit": limit,
                "not": not_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Commit],
                    parse_obj_as(
                        type_=typing.List[Commit],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_combined_status_by_ref(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CombinedStatus]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            name of branch/tag/commit

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CombinedStatus]
            CombinedStatus
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(ref)}/status",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CombinedStatus,
                    parse_obj_as(
                        type_=CombinedStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_statuses_by_ref(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        sort: typing.Optional[RepoListStatusesByRefRequestSort] = None,
        state: typing.Optional[RepoListStatusesByRefRequestState] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[CommitStatus]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            name of branch/tag/commit

        sort : typing.Optional[RepoListStatusesByRefRequestSort]
            type of sort

        state : typing.Optional[RepoListStatusesByRefRequestState]
            type of state

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[CommitStatus]]
            CommitStatusList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(ref)}/statuses",
            method="GET",
            params={
                "sort": sort,
                "state": state,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CommitStatus],
                    parse_obj_as(
                        type_=typing.List[CommitStatus],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_commit_pull_request(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            SHA of the commit to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullRequest]
            PullRequest
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(sha)}/pull",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_compare_diff(
        self,
        owner: str,
        repo: str,
        basehead: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Compare]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        basehead : str
            compare two branches or commits

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Compare]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/compare/{jsonable_encoder(basehead)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Compare,
                    parse_obj_as(
                        type_=Compare,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_contents_list(
        self,
        owner: str,
        repo: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[ContentsResponse]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[ContentsResponse]]
            ContentsListResponse
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ContentsResponse],
                    parse_obj_as(
                        type_=typing.List[ContentsResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_change_files(
        self,
        owner: str,
        repo: str,
        *,
        files: typing.Sequence[ChangeFileOperation],
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FilesResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        files : typing.Sequence[ChangeFileOperation]
            list of file operations

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FilesResponse]
            FilesResponse
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[ChangeFileOperation],
                    direction="write",
                ),
                "message": message,
                "new_branch": new_branch,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FilesResponse,
                    parse_obj_as(
                        type_=FilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_contents(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RepoGetContentsResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the dir, file, symlink or submodule in the repo

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RepoGetContentsResponse]
            A single file's contents or a directory listing
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RepoGetContentsResponse,
                    parse_obj_as(
                        type_=RepoGetContentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        content: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FileResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to create

        content : str
            content must be base64 encoded

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FileResponse]
            FileResponse
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "message": message,
                "new_branch": new_branch,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_update_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        content: str,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        from_path: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FileResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to update

        content : str
            content must be base64 encoded

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        from_path : typing.Optional[str]
            from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FileResponse]
            FileResponse
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="PUT",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "from_path": from_path,
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FileDeleteResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to delete

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FileDeleteResponse]
            FileDeleteResponse
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="DELETE",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileDeleteResponse,
                    parse_obj_as(
                        type_=FileDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_convert(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to convert

        repo : str
            name of the repo to convert

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/convert",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_apply_diff_patch(
        self,
        owner: str,
        repo: str,
        *,
        content: str,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        from_path: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FileResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        content : str
            content must be base64 encoded

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        from_path : typing.Optional[str]
            from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FileResponse]
            FileResponse
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/diffpatch",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "from_path": from_path,
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_editor_config(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Dict[str, str]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, str]]
            definitions
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/editorconfig/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, str],
                    parse_obj_as(
                        type_=typing.Dict[str, str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_flags(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[str]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[str]]
            StringSlice
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_replace_all_flags(
        self,
        owner: str,
        repo: str,
        *,
        flags: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flags : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="PUT",
            json={
                "flags": flags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_all_flags(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_check_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_add_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_forks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Repository]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Repository]]
            RepositoryList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/forks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Repository],
                    parse_obj_as(
                        type_=typing.List[Repository],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_fork(
        self,
        owner: str,
        repo: str,
        *,
        name: typing.Optional[str] = OMIT,
        organization: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to fork

        repo : str
            name of the repo to fork

        name : typing.Optional[str]
            name of the forked repository

        organization : typing.Optional[str]
            organization name, if forking into an organization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/forks",
            method="POST",
            json={
                "name": name,
                "organization": organization,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_blobs(
        self,
        owner: str,
        repo: str,
        *,
        shas: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[GitBlob]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        shas : str
            a comma separated list of blob-sha (mind the overall URL-length limit of ~2,083 chars)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[GitBlob]]
            GitBlobList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/blobs",
            method="GET",
            params={
                "shas": shas,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[GitBlob],
                    parse_obj_as(
                        type_=typing.List[GitBlob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_blob(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GitBlob]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the blob to retrieve

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GitBlob]
            GitBlob
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/blobs/{jsonable_encoder(sha)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GitBlob,
                    parse_obj_as(
                        type_=GitBlob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_single_commit(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        stat: typing.Optional[bool] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Commit]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        stat : typing.Optional[bool]
            include diff stats for every commit (disable for speedup, default 'true')

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Commit]
            Commit
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/commits/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "stat": stat,
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Commit,
                    parse_obj_as(
                        type_=Commit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_download_commit_diff_or_patch(
        self,
        owner: str,
        repo: str,
        sha: str,
        diff_type: RepoDownloadCommitDiffOrPatchRequestDiffType,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[str]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            SHA of the commit to get

        diff_type : RepoDownloadCommitDiffOrPatchRequestDiffType
            whether the output is diff or patch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[str]
            APIString is a string response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/commits/{jsonable_encoder(sha)}.{jsonable_encoder(diff_type)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    str,
                    parse_obj_as(
                        type_=str,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Note]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Note]
            Note
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Note,
                    parse_obj_as(
                        type_=Note,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_set_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        message: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Note]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        message : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Note]
            Note
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="POST",
            json={
                "message": message,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Note,
                    parse_obj_as(
                        type_=Note,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_remove_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_all_git_refs(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Reference]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Reference]]
            ReferenceList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/refs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Reference],
                    parse_obj_as(
                        type_=typing.List[Reference],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_git_refs(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Reference]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            part or full name of the ref

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Reference]]
            ReferenceList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/refs/{jsonable_encoder(ref)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Reference],
                    parse_obj_as(
                        type_=typing.List[Reference],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_annotated_tag(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AnnotatedTag]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AnnotatedTag]
            AnnotatedTag
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/tags/{jsonable_encoder(sha)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AnnotatedTag,
                    parse_obj_as(
                        type_=AnnotatedTag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_tree(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        recursive: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GitTreeResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        recursive : typing.Optional[bool]
            show all directories and files

        page : typing.Optional[int]
            page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page

        per_page : typing.Optional[int]
            number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GitTreeResponse]
            GitTreeResponse
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/trees/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "recursive": recursive,
                "page": page,
                "per_page": per_page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GitTreeResponse,
                    parse_obj_as(
                        type_=GitTreeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_hooks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Hook]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Hook]]
            HookList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Hook],
                    parse_obj_as(
                        type_=typing.List[Hook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_hook(
        self,
        owner: str,
        repo: str,
        *,
        config: CreateHookOptionConfig,
        type: CreateHookOptionType,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Hook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        config : CreateHookOptionConfig

        type : CreateHookOptionType

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Hook]
            Hook
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks",
            method="POST",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
                "type": type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_git_hooks(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[GitHook]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[GitHook]]
            GitHookList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[GitHook],
                    parse_obj_as(
                        type_=typing.List[GitHook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GitHook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GitHook]
            GitHook
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GitHook,
                    parse_obj_as(
                        type_=GitHook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GitHook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GitHook]
            GitHook
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GitHook,
                    parse_obj_as(
                        type_=GitHook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Hook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Hook]
            Hook
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, str]] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Hook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            index of the hook

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        config : typing.Optional[typing.Dict[str, str]]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Hook]
            Hook
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_test_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to test

        ref : typing.Optional[str]
            The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}/tests",
            method="POST",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_issue_config(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[IssueConfig]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[IssueConfig]
            RepoIssueConfig
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_config",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IssueConfig,
                    parse_obj_as(
                        type_=IssueConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_validate_issue_config(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[IssueConfigValidation]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[IssueConfigValidation]
            RepoIssueConfigValidation
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_config/validate",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IssueConfigValidation,
                    parse_obj_as(
                        type_=IssueConfigValidation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_issue_templates(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[IssueTemplate]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[IssueTemplate]]
            IssueTemplates
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_templates",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[IssueTemplate],
                    parse_obj_as(
                        type_=typing.List[IssueTemplate],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_pinned_issues(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/pinned",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_keys(
        self,
        owner: str,
        repo: str,
        *,
        key_id: typing.Optional[int] = None,
        fingerprint: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[DeployKey]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        key_id : typing.Optional[int]
            the key_id to search for

        fingerprint : typing.Optional[str]
            fingerprint of the key

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[DeployKey]]
            DeployKeyList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys",
            method="GET",
            params={
                "key_id": key_id,
                "fingerprint": fingerprint,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[DeployKey],
                    parse_obj_as(
                        type_=typing.List[DeployKey],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_key(
        self,
        owner: str,
        repo: str,
        *,
        key: str,
        title: str,
        read_only: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeployKey]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        key : str
            An armored SSH key to add

        title : str
            Title of the key to add

        read_only : typing.Optional[bool]
            Describe if the key has only read access or read/write

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeployKey]
            DeployKey
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys",
            method="POST",
            json={
                "key": key,
                "read_only": read_only,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeployKey,
                    parse_obj_as(
                        type_=DeployKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_key(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeployKey]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the key to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeployKey]
            DeployKey
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeployKey,
                    parse_obj_as(
                        type_=DeployKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_key(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the key to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_languages(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Dict[str, int]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Dict[str, int]]
            LanguageStatistics
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/languages",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, int],
                    parse_obj_as(
                        type_=typing.Dict[str, int],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    @contextlib.contextmanager
    def repo_get_raw_file_or_lfs(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[bytes]]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of the file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.Iterator[HttpResponse[typing.Iterator[bytes]]]
            Returns raw file content.
        """
        with self._client_wrapper.httpx_client.stream(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/media/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        ) as _response:

            def _stream() -> HttpResponse[typing.Iterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = (
                            request_options.get("chunk_size", None)
                            if request_options is not None
                            else None
                        )
                        return HttpResponse(
                            response=_response,
                            data=(
                                _chunk
                                for _chunk in _response.iter_bytes(
                                    chunk_size=_chunk_size
                                )
                            ),
                        )
                    _response.read()
                    if _response.status_code == 404:
                        raise NotFoundError(
                            headers=dict(_response.headers),
                            body=typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            ),
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise core_api_error_ApiError(
                        status_code=_response.status_code,
                        headers=dict(_response.headers),
                        body=_response.text,
                    )
                raise core_api_error_ApiError(
                    status_code=_response.status_code,
                    headers=dict(_response.headers),
                    body=_response_json,
                )

            yield _stream()

    def repo_mirror_sync(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to sync

        repo : str
            name of the repo to sync

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/mirror-sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_new_pin_allowed(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[NewIssuePinsAllowed]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[NewIssuePinsAllowed]
            RepoNewIssuePinsAllowed
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/new_pin_allowed",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    NewIssuePinsAllowed,
                    parse_obj_as(
                        type_=NewIssuePinsAllowed,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_pull_requests(
        self,
        owner: str,
        repo: str,
        *,
        state: typing.Optional[RepoListPullRequestsRequestState] = None,
        sort: typing.Optional[RepoListPullRequestsRequestSort] = None,
        milestone: typing.Optional[int] = None,
        labels: typing.Optional[typing.Union[int, typing.Sequence[int]]] = None,
        poster: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PullRequest]]:
        """
        Parameters
        ----------
        owner : str
            Owner of the repo

        repo : str
            Name of the repo

        state : typing.Optional[RepoListPullRequestsRequestState]
            State of pull request

        sort : typing.Optional[RepoListPullRequestsRequestSort]
            Type of sort

        milestone : typing.Optional[int]
            ID of the milestone

        labels : typing.Optional[typing.Union[int, typing.Sequence[int]]]
            Label IDs

        poster : typing.Optional[str]
            Filter by pull request author

        page : typing.Optional[int]
            Page number of results to return (1-based)

        limit : typing.Optional[int]
            Page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PullRequest]]
            PullRequestList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls",
            method="GET",
            params={
                "state": state,
                "sort": sort,
                "milestone": milestone,
                "labels": labels,
                "poster": poster,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullRequest],
                    parse_obj_as(
                        type_=typing.List[PullRequest],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_pull_request(
        self,
        owner: str,
        repo: str,
        *,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        base: typing.Optional[str] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        head: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        assignee : typing.Optional[str]

        assignees : typing.Optional[typing.Sequence[str]]

        base : typing.Optional[str]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        head : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[int]]

        milestone : typing.Optional[int]

        title : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullRequest]
            PullRequest
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls",
            method="POST",
            json={
                "assignee": assignee,
                "assignees": assignees,
                "base": base,
                "body": body,
                "due_date": due_date,
                "head": head,
                "labels": labels,
                "milestone": milestone,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_pinned_pull_requests(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PullRequest]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PullRequest]]
            PullRequestList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/pinned",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullRequest],
                    parse_obj_as(
                        type_=typing.List[PullRequest],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_pull_request_by_base_head(
        self,
        owner: str,
        repo: str,
        base: str,
        head: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        base : str
            base of the pull request to get

        head : str
            head of the pull request to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullRequest]
            PullRequest
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(base)}/{jsonable_encoder(head)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullRequest]
            PullRequest
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        allow_maintainer_edit: typing.Optional[bool] = OMIT,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        base: typing.Optional[str] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        state: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        unset_due_date: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to edit

        allow_maintainer_edit : typing.Optional[bool]

        assignee : typing.Optional[str]

        assignees : typing.Optional[typing.Sequence[str]]

        base : typing.Optional[str]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        labels : typing.Optional[typing.Sequence[int]]

        milestone : typing.Optional[int]

        state : typing.Optional[str]

        title : typing.Optional[str]

        unset_due_date : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullRequest]
            PullRequest
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}",
            method="PATCH",
            json={
                "allow_maintainer_edit": allow_maintainer_edit,
                "assignee": assignee,
                "assignees": assignees,
                "base": base,
                "body": body,
                "due_date": due_date,
                "labels": labels,
                "milestone": milestone,
                "state": state,
                "title": title,
                "unset_due_date": unset_due_date,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_download_pull_diff_or_patch(
        self,
        owner: str,
        repo: str,
        index: int,
        diff_type: RepoDownloadPullDiffOrPatchRequestDiffType,
        *,
        binary: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[str]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        diff_type : RepoDownloadPullDiffOrPatchRequestDiffType
            whether the output is diff or patch

        binary : typing.Optional[bool]
            whether to include binary file changes. if true, the diff is applicable with `git apply`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[str]
            APIString is a string response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}.{jsonable_encoder(diff_type)}",
            method="GET",
            params={
                "binary": binary,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    str,
                    parse_obj_as(
                        type_=str,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_pull_request_commits(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Commit]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Commit]]
            CommitList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/commits",
            method="GET",
            params={
                "page": page,
                "limit": limit,
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Commit],
                    parse_obj_as(
                        type_=typing.List[Commit],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_pull_request_files(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        skip_to: typing.Optional[str] = None,
        whitespace: typing.Optional[RepoGetPullRequestFilesRequestWhitespace] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[ChangedFile]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        skip_to : typing.Optional[str]
            skip to given file

        whitespace : typing.Optional[RepoGetPullRequestFilesRequestWhitespace]
            whitespace behavior

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[ChangedFile]]
            ChangedFileList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/files",
            method="GET",
            params={
                "skip-to": skip_to,
                "whitespace": whitespace,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ChangedFile],
                    parse_obj_as(
                        type_=typing.List[ChangedFile],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_pull_request_is_merged(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_merge_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        do: MergePullRequestOptionDo,
        merge_commit_id: typing.Optional[str] = OMIT,
        merge_message_field: typing.Optional[str] = OMIT,
        merge_title_field: typing.Optional[str] = OMIT,
        delete_branch_after_merge: typing.Optional[bool] = OMIT,
        force_merge: typing.Optional[bool] = OMIT,
        head_commit_id: typing.Optional[str] = OMIT,
        merge_when_checks_succeed: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to merge

        do : MergePullRequestOptionDo

        merge_commit_id : typing.Optional[str]

        merge_message_field : typing.Optional[str]

        merge_title_field : typing.Optional[str]

        delete_branch_after_merge : typing.Optional[bool]

        force_merge : typing.Optional[bool]

        head_commit_id : typing.Optional[str]

        merge_when_checks_succeed : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="POST",
            json={
                "Do": do,
                "MergeCommitID": merge_commit_id,
                "MergeMessageField": merge_message_field,
                "MergeTitleField": merge_title_field,
                "delete_branch_after_merge": delete_branch_after_merge,
                "force_merge": force_merge,
                "head_commit_id": head_commit_id,
                "merge_when_checks_succeed": merge_when_checks_succeed,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_cancel_scheduled_auto_merge(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to merge

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_pull_review_requests(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        team_reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PullReview]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        reviewers : typing.Optional[typing.Sequence[str]]

        team_reviewers : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PullReview]]
            PullReviewList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/requested_reviewers",
            method="POST",
            json={
                "reviewers": reviewers,
                "team_reviewers": team_reviewers,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullReview],
                    parse_obj_as(
                        type_=typing.List[PullReview],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_pull_review_requests(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        team_reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        reviewers : typing.Optional[typing.Sequence[str]]

        team_reviewers : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/requested_reviewers",
            method="DELETE",
            json={
                "reviewers": reviewers,
                "team_reviewers": team_reviewers,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_pull_reviews(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PullReview]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PullReview]]
            PullReviewList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullReview],
                    parse_obj_as(
                        type_=typing.List[PullReview],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        body: typing.Optional[str] = OMIT,
        comments: typing.Optional[typing.Sequence[CreatePullReviewComment]] = OMIT,
        commit_id: typing.Optional[str] = OMIT,
        event: typing.Optional[ReviewStateType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        body : typing.Optional[str]

        comments : typing.Optional[typing.Sequence[CreatePullReviewComment]]

        commit_id : typing.Optional[str]

        event : typing.Optional[ReviewStateType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullReview]
            PullReview
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews",
            method="POST",
            json={
                "body": body,
                "comments": convert_and_respect_annotation_metadata(
                    object_=comments,
                    annotation=typing.Sequence[CreatePullReviewComment],
                    direction="write",
                ),
                "commit_id": commit_id,
                "event": event,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullReview]
            PullReview
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_submit_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        event: typing.Optional[ReviewStateType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        body : typing.Optional[str]

        event : typing.Optional[ReviewStateType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullReview]
            PullReview
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="POST",
            json={
                "body": body,
                "event": event,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_pull_review_comments(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PullReviewComment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PullReviewComment]]
            PullCommentList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullReviewComment],
                    parse_obj_as(
                        type_=typing.List[PullReviewComment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        new_position: typing.Optional[int] = OMIT,
        old_position: typing.Optional[int] = OMIT,
        path: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullReviewComment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        body : typing.Optional[str]

        new_position : typing.Optional[int]
            if comment to new file line or 0

        old_position : typing.Optional[int]
            if comment to old file line or 0

        path : typing.Optional[str]
            the tree path

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullReviewComment]
            PullComment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments",
            method="POST",
            json={
                "body": body,
                "new_position": new_position,
                "old_position": old_position,
                "path": path,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReviewComment,
                    parse_obj_as(
                        type_=PullReviewComment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        comment: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullReviewComment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        comment : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullReviewComment]
            PullComment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments/{jsonable_encoder(comment)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReviewComment,
                    parse_obj_as(
                        type_=PullReviewComment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        comment: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        comment : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments/{jsonable_encoder(comment)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_dismiss_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        message: typing.Optional[str] = OMIT,
        priors: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        message : typing.Optional[str]

        priors : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullReview]
            PullReview
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/dismissals",
            method="POST",
            json={
                "message": message,
                "priors": priors,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_un_dismiss_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PullReview]
            PullReview
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/undismissals",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_update_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        style: typing.Optional[RepoUpdatePullRequestRequestStyle] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        style : typing.Optional[RepoUpdatePullRequestRequestStyle]
            how to update pull request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/update",
            method="POST",
            params={
                "style": style,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_push_mirrors(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[PushMirror]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[PushMirror]]
            PushMirrorList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PushMirror],
                    parse_obj_as(
                        type_=typing.List[PushMirror],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_add_push_mirror(
        self,
        owner: str,
        repo: str,
        *,
        branch_filter: typing.Optional[str] = OMIT,
        interval: typing.Optional[str] = OMIT,
        remote_address: typing.Optional[str] = OMIT,
        remote_password: typing.Optional[str] = OMIT,
        remote_username: typing.Optional[str] = OMIT,
        sync_on_commit: typing.Optional[bool] = OMIT,
        use_ssh: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PushMirror]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch_filter : typing.Optional[str]

        interval : typing.Optional[str]

        remote_address : typing.Optional[str]

        remote_password : typing.Optional[str]

        remote_username : typing.Optional[str]

        sync_on_commit : typing.Optional[bool]

        use_ssh : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PushMirror]
            PushMirror
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors",
            method="POST",
            json={
                "branch_filter": branch_filter,
                "interval": interval,
                "remote_address": remote_address,
                "remote_password": remote_password,
                "remote_username": remote_username,
                "sync_on_commit": sync_on_commit,
                "use_ssh": use_ssh,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PushMirror,
                    parse_obj_as(
                        type_=PushMirror,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_push_mirror_sync(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to sync

        repo : str
            name of the repo to sync

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors-sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_push_mirror_by_remote_name(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PushMirror]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            remote name of push mirror

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PushMirror]
            PushMirror
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors/{jsonable_encoder(name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PushMirror,
                    parse_obj_as(
                        type_=PushMirror,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_push_mirror(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            remote name of the pushMirror

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors/{jsonable_encoder(name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    @contextlib.contextmanager
    def repo_get_raw_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[bytes]]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of the file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.Iterator[HttpResponse[typing.Iterator[bytes]]]
            Returns raw file content.
        """
        with self._client_wrapper.httpx_client.stream(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/raw/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        ) as _response:

            def _stream() -> HttpResponse[typing.Iterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = (
                            request_options.get("chunk_size", None)
                            if request_options is not None
                            else None
                        )
                        return HttpResponse(
                            response=_response,
                            data=(
                                _chunk
                                for _chunk in _response.iter_bytes(
                                    chunk_size=_chunk_size
                                )
                            ),
                        )
                    _response.read()
                    if _response.status_code == 404:
                        raise NotFoundError(
                            headers=dict(_response.headers),
                            body=typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            ),
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise core_api_error_ApiError(
                        status_code=_response.status_code,
                        headers=dict(_response.headers),
                        body=_response.text,
                    )
                raise core_api_error_ApiError(
                    status_code=_response.status_code,
                    headers=dict(_response.headers),
                    body=_response_json,
                )

            yield _stream()

    def repo_list_releases(
        self,
        owner: str,
        repo: str,
        *,
        draft: typing.Optional[bool] = None,
        pre_release: typing.Optional[bool] = None,
        q: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Release]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        draft : typing.Optional[bool]
            filter (exclude / include) drafts, if you dont have repo write access none will show

        pre_release : typing.Optional[bool]
            filter (exclude / include) pre-releases

        q : typing.Optional[str]
            Search string

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Release]]
            ReleaseList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases",
            method="GET",
            params={
                "draft": draft,
                "pre-release": pre_release,
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Release],
                    parse_obj_as(
                        type_=typing.List[Release],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_release(
        self,
        owner: str,
        repo: str,
        *,
        tag_name: str,
        body: typing.Optional[str] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        hide_archive_links: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        prerelease: typing.Optional[bool] = OMIT,
        target_commitish: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag_name : str

        body : typing.Optional[str]

        draft : typing.Optional[bool]

        hide_archive_links : typing.Optional[bool]

        name : typing.Optional[str]

        prerelease : typing.Optional[bool]

        target_commitish : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Release]
            Release
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases",
            method="POST",
            json={
                "body": body,
                "draft": draft,
                "hide_archive_links": hide_archive_links,
                "name": name,
                "prerelease": prerelease,
                "tag_name": tag_name,
                "target_commitish": target_commitish,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_latest_release(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Release]
            Release
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/latest",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_release_by_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            tag name of the release to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Release]
            Release
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/tags/{jsonable_encoder(tag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_release_by_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            tag name of the release to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/tags/{jsonable_encoder(tag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Release]
            Release
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        hide_archive_links: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        prerelease: typing.Optional[bool] = OMIT,
        tag_name: typing.Optional[str] = OMIT,
        target_commitish: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to edit

        body : typing.Optional[str]

        draft : typing.Optional[bool]

        hide_archive_links : typing.Optional[bool]

        name : typing.Optional[str]

        prerelease : typing.Optional[bool]

        tag_name : typing.Optional[str]

        target_commitish : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Release]
            Release
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "body": body,
                "draft": draft,
                "hide_archive_links": hide_archive_links,
                "name": name,
                "prerelease": prerelease,
                "tag_name": tag_name,
                "target_commitish": target_commitish,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_release_attachments(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Attachment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Attachment]]
            AttachmentList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Attachment],
                    parse_obj_as(
                        type_=typing.List[Attachment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request: typing.Union[
            bytes, typing.Iterator[bytes], typing.AsyncIterator[bytes]
        ],
        name: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        request : typing.Union[bytes, typing.Iterator[bytes], typing.AsyncIterator[bytes]]

        name : typing.Optional[str]
            name of the attachment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets",
            method="POST",
            params={
                "name": name,
            },
            content=request,
            headers={
                "content-type": "application/octet-stream",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        browser_download_url: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to edit

        browser_download_url : typing.Optional[str]
            (Can only be set if existing attachment is of external type)

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="PATCH",
            json={
                "browser_download_url": browser_download_url,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_reviewers(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[User]]
            UserList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/reviewers",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_signing_key(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[str]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[str]
            GPG armored public key
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/signing-key.gpg",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=_response.text)  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_stargazers(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[User]]
            UserList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/stargazers",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_statuses(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        sort: typing.Optional[RepoListStatusesRequestSort] = None,
        state: typing.Optional[RepoListStatusesRequestState] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[CommitStatus]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        sort : typing.Optional[RepoListStatusesRequestSort]
            type of sort

        state : typing.Optional[RepoListStatusesRequestState]
            type of state

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[CommitStatus]]
            CommitStatusList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/statuses/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "sort": sort,
                "state": state,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CommitStatus],
                    parse_obj_as(
                        type_=typing.List[CommitStatus],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_status(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        context: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        state: typing.Optional[CommitStatusState] = OMIT,
        target_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CommitStatus]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        context : typing.Optional[str]

        description : typing.Optional[str]

        state : typing.Optional[CommitStatusState]

        target_url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CommitStatus]
            CommitStatus
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/statuses/{jsonable_encoder(sha)}",
            method="POST",
            json={
                "context": context,
                "description": description,
                "state": state,
                "target_url": target_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CommitStatus,
                    parse_obj_as(
                        type_=CommitStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_subscribers(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[User]]
            UserList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscribers",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def user_current_check_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WatchInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WatchInfo]
            WatchInfo
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def user_current_put_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WatchInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WatchInfo]
            WatchInfo
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def user_current_delete_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_sync_fork_default_info(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SyncForkInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SyncForkInfo]
            SyncForkInfo
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/sync_fork",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SyncForkInfo,
                    parse_obj_as(
                        type_=SyncForkInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_sync_fork_default(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/sync_fork",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_sync_fork_branch_info(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SyncForkInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            The branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SyncForkInfo]
            SyncForkInfo
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/sync_fork/{jsonable_encoder(branch)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SyncForkInfo,
                    parse_obj_as(
                        type_=SyncForkInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_sync_fork_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            The branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/sync_fork/{jsonable_encoder(branch)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_tag_protection(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[TagProtection]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[TagProtection]]
            TagProtectionList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TagProtection],
                    parse_obj_as(
                        type_=typing.List[TagProtection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_tag_protection(
        self,
        owner: str,
        repo: str,
        *,
        name_pattern: typing.Optional[str] = OMIT,
        whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TagProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name_pattern : typing.Optional[str]

        whitelist_teams : typing.Optional[typing.Sequence[str]]

        whitelist_usernames : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TagProtection]
            TagProtection
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections",
            method="POST",
            json={
                "name_pattern": name_pattern,
                "whitelist_teams": whitelist_teams,
                "whitelist_usernames": whitelist_usernames,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TagProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the tag protect to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TagProtection]
            TagProtection
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of protected tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        name_pattern: typing.Optional[str] = OMIT,
        whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TagProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of protected tag

        name_pattern : typing.Optional[str]

        whitelist_teams : typing.Optional[typing.Sequence[str]]

        whitelist_usernames : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TagProtection]
            TagProtection
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "name_pattern": name_pattern,
                "whitelist_teams": whitelist_teams,
                "whitelist_usernames": whitelist_usernames,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_tags(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Tag]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Tag]]
            TagList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Tag],
                    parse_obj_as(
                        type_=typing.List[Tag],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_tag(
        self,
        owner: str,
        repo: str,
        *,
        tag_name: str,
        message: typing.Optional[str] = OMIT,
        target: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Tag]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag_name : str

        message : typing.Optional[str]

        target : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Tag]
            Tag
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags",
            method="POST",
            json={
                "message": message,
                "tag_name": tag_name,
                "target": target,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tag,
                    parse_obj_as(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Tag]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            name of tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Tag]
            Tag
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags/{jsonable_encoder(tag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tag,
                    parse_obj_as(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            name of tag to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags/{jsonable_encoder(tag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_teams(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Team]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Team]]
            TeamList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Team],
                    parse_obj_as(
                        type_=typing.List[Team],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_check_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Team]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Team]
            Team
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Team,
                    parse_obj_as(
                        type_=Team,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_add_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_tracked_times(
        self,
        owner: str,
        repo: str,
        *,
        user: typing.Optional[str] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[TrackedTime]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        user : typing.Optional[str]
            optional filter by user (available for issue managers)

        since : typing.Optional[dt.datetime]
            Only show times updated after the given time. This is a timestamp in RFC 3339 format

        before : typing.Optional[dt.datetime]
            Only show times updated before the given time. This is a timestamp in RFC 3339 format

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[TrackedTime]]
            TrackedTimeList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/times",
            method="GET",
            params={
                "user": user,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def user_tracked_times(
        self,
        owner: str,
        repo: str,
        user: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[TrackedTime]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        user : str
            username of user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[TrackedTime]]
            TrackedTimeList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/times/{jsonable_encoder(user)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_list_topics(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TopicName]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TopicName]
            TopicNames
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TopicName,
                    parse_obj_as(
                        type_=TopicName,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_update_topics(
        self,
        owner: str,
        repo: str,
        *,
        topics: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topics : typing.Optional[typing.Sequence[str]]
            list of topic names

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics",
            method="PUT",
            json={
                "topics": topics,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_add_topic(
        self,
        owner: str,
        repo: str,
        topic: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topic : str
            name of the topic to add

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics/{jsonable_encoder(topic)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_topic(
        self,
        owner: str,
        repo: str,
        topic: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topic : str
            name of the topic to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics/{jsonable_encoder(topic)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        new_owner: str,
        team_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        new_owner : str

        team_ids : typing.Optional[typing.Sequence[int]]
            ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer",
            method="POST",
            json={
                "new_owner": new_owner,
                "team_ids": team_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def accept_repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer/accept",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def reject_repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer/reject",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_create_wiki_page(
        self,
        owner: str,
        repo: str,
        *,
        content_base_64: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WikiPage]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        content_base_64 : typing.Optional[str]
            content must be base64 encoded

        message : typing.Optional[str]
            optional commit message summarizing the change

        title : typing.Optional[str]
            page title. leave empty to keep unchanged

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WikiPage]
            WikiPage
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/new",
            method="POST",
            json={
                "content_base64": content_base_64,
                "message": message,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WikiPage]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WikiPage]
            WikiPage
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_delete_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_edit_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        content_base_64: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WikiPage]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        content_base_64 : typing.Optional[str]
            content must be base64 encoded

        message : typing.Optional[str]
            optional commit message summarizing the change

        title : typing.Optional[str]
            page title. leave empty to keep unchanged

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WikiPage]
            WikiPage
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="PATCH",
            json={
                "content_base64": content_base_64,
                "message": message,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_wiki_pages(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[WikiPageMetaData]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[WikiPageMetaData]]
            WikiPageList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/pages",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WikiPageMetaData],
                    parse_obj_as(
                        type_=typing.List[WikiPageMetaData],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_wiki_page_revisions(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WikiCommitList]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        page : typing.Optional[int]
            page number of results to return (1-based)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WikiCommitList]
            WikiCommitList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/revisions/{jsonable_encoder(page_name)}",
            method="GET",
            params={
                "page": page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WikiCommitList,
                    parse_obj_as(
                        type_=WikiCommitList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def generate_repo(
        self,
        template_owner: str,
        template_repo: str,
        *,
        name: str,
        owner: str,
        avatar: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        git_content: typing.Optional[bool] = OMIT,
        git_hooks: typing.Optional[bool] = OMIT,
        labels: typing.Optional[bool] = OMIT,
        private: typing.Optional[bool] = OMIT,
        protected_branch: typing.Optional[bool] = OMIT,
        topics: typing.Optional[bool] = OMIT,
        webhooks: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        template_owner : str
            name of the template repository owner

        template_repo : str
            name of the template repository

        name : str
            Name of the repository to create

        owner : str
            The organization or person who will own the new repository

        avatar : typing.Optional[bool]
            include avatar of the template repo

        default_branch : typing.Optional[str]
            Default branch of the new repository

        description : typing.Optional[str]
            Description of the repository to create

        git_content : typing.Optional[bool]
            include git content of default branch in template repo

        git_hooks : typing.Optional[bool]
            include git hooks in template repo

        labels : typing.Optional[bool]
            include labels in template repo

        private : typing.Optional[bool]
            Whether the repository is private

        protected_branch : typing.Optional[bool]
            include protected branches in template repo

        topics : typing.Optional[bool]
            include topics in template repo

        webhooks : typing.Optional[bool]
            include webhooks in template repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(template_owner)}/{jsonable_encoder(template_repo)}/generate",
            method="POST",
            json={
                "avatar": avatar,
                "default_branch": default_branch,
                "description": description,
                "git_content": git_content,
                "git_hooks": git_hooks,
                "labels": labels,
                "name": name,
                "owner": owner,
                "private": private,
                "protected_branch": protected_branch,
                "topics": topics,
                "webhooks": webhooks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def repo_get_by_id(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        id : int
            id of the repo to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repositories/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def topic_search(
        self,
        *,
        q: str,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TopicSearchResults]:
        """
        Parameters
        ----------
        q : str
            keyword to search for

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TopicSearchResults]
            SearchResults of a successful search
        """
        _response = self._client_wrapper.httpx_client.request(
            "topics/search",
            method="GET",
            params={
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TopicSearchResults,
                    parse_obj_as(
                        type_=TopicSearchResults,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_current_user_repo(
        self,
        *,
        name: str,
        auto_init: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        gitignores: typing.Optional[str] = OMIT,
        issue_labels: typing.Optional[str] = OMIT,
        license: typing.Optional[str] = OMIT,
        object_format_name: typing.Optional[CreateRepoOptionObjectFormatName] = OMIT,
        private: typing.Optional[bool] = OMIT,
        readme: typing.Optional[str] = OMIT,
        template: typing.Optional[bool] = OMIT,
        trust_model: typing.Optional[CreateRepoOptionTrustModel] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Repository]:
        """
        Parameters
        ----------
        name : str
            Name of the repository to create

        auto_init : typing.Optional[bool]
            Whether the repository should be auto-initialized?

        default_branch : typing.Optional[str]
            DefaultBranch of the repository (used when initializes and in template)

        description : typing.Optional[str]
            Description of the repository to create

        gitignores : typing.Optional[str]
            Gitignores to use

        issue_labels : typing.Optional[str]
            Label-Set to use

        license : typing.Optional[str]
            License to use

        object_format_name : typing.Optional[CreateRepoOptionObjectFormatName]
            ObjectFormatName of the underlying git repository

        private : typing.Optional[bool]
            Whether the repository is private

        readme : typing.Optional[str]
            Readme of the repository to create

        template : typing.Optional[bool]
            Whether the repository is template

        trust_model : typing.Optional[CreateRepoOptionTrustModel]
            TrustModel of the repository

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Repository]
            Repository
        """
        _response = self._client_wrapper.httpx_client.request(
            "user/repos",
            method="POST",
            json={
                "auto_init": auto_init,
                "default_branch": default_branch,
                "description": description,
                "gitignores": gitignores,
                "issue_labels": issue_labels,
                "license": license,
                "name": name,
                "object_format_name": object_format_name,
                "private": private,
                "readme": readme,
                "template": template,
                "trust_model": trust_model,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiUnauthorizedError,
                        parse_obj_as(
                            type_=ApiUnauthorizedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )


class AsyncRawRepositoryClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def repo_migrate(
        self,
        *,
        clone_addr: str,
        repo_name: str,
        auth_password: typing.Optional[str] = OMIT,
        auth_token: typing.Optional[str] = OMIT,
        auth_username: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        issues: typing.Optional[bool] = OMIT,
        labels: typing.Optional[bool] = OMIT,
        lfs: typing.Optional[bool] = OMIT,
        lfs_endpoint: typing.Optional[str] = OMIT,
        milestones: typing.Optional[bool] = OMIT,
        mirror: typing.Optional[bool] = OMIT,
        mirror_interval: typing.Optional[str] = OMIT,
        private: typing.Optional[bool] = OMIT,
        pull_requests: typing.Optional[bool] = OMIT,
        releases: typing.Optional[bool] = OMIT,
        repo_owner: typing.Optional[str] = OMIT,
        service: typing.Optional[MigrateRepoOptionsService] = OMIT,
        uid: typing.Optional[int] = OMIT,
        wiki: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        clone_addr : str

        repo_name : str

        auth_password : typing.Optional[str]

        auth_token : typing.Optional[str]

        auth_username : typing.Optional[str]

        description : typing.Optional[str]

        issues : typing.Optional[bool]

        labels : typing.Optional[bool]

        lfs : typing.Optional[bool]

        lfs_endpoint : typing.Optional[str]

        milestones : typing.Optional[bool]

        mirror : typing.Optional[bool]

        mirror_interval : typing.Optional[str]

        private : typing.Optional[bool]

        pull_requests : typing.Optional[bool]

        releases : typing.Optional[bool]

        repo_owner : typing.Optional[str]
            Name of User or Organisation who will own Repo after migration

        service : typing.Optional[MigrateRepoOptionsService]

        uid : typing.Optional[int]
            deprecated (only for backwards compatibility)

        wiki : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            "repos/migrate",
            method="POST",
            json={
                "auth_password": auth_password,
                "auth_token": auth_token,
                "auth_username": auth_username,
                "clone_addr": clone_addr,
                "description": description,
                "issues": issues,
                "labels": labels,
                "lfs": lfs,
                "lfs_endpoint": lfs_endpoint,
                "milestones": milestones,
                "mirror": mirror,
                "mirror_interval": mirror_interval,
                "private": private,
                "pull_requests": pull_requests,
                "releases": releases,
                "repo_name": repo_name,
                "repo_owner": repo_owner,
                "service": service,
                "uid": uid,
                "wiki": wiki,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_search(
        self,
        *,
        q: typing.Optional[str] = None,
        topic: typing.Optional[bool] = None,
        include_desc: typing.Optional[bool] = None,
        uid: typing.Optional[int] = None,
        priority_owner_id: typing.Optional[int] = None,
        team_id: typing.Optional[int] = None,
        starred_by: typing.Optional[int] = None,
        private: typing.Optional[bool] = None,
        is_private: typing.Optional[bool] = None,
        template: typing.Optional[bool] = None,
        archived: typing.Optional[bool] = None,
        mode: typing.Optional[str] = None,
        exclusive: typing.Optional[bool] = None,
        sort: typing.Optional[RepoSearchRequestSort] = None,
        order: typing.Optional[RepoSearchRequestOrder] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SearchResults]:
        """
        Parameters
        ----------
        q : typing.Optional[str]
            keyword

        topic : typing.Optional[bool]
            Limit search to repositories with keyword as topic

        include_desc : typing.Optional[bool]
            include search of keyword within repository description

        uid : typing.Optional[int]
            search only for repos that the user with the given id owns or contributes to

        priority_owner_id : typing.Optional[int]
            repo owner to prioritize in the results

        team_id : typing.Optional[int]
            search only for repos that belong to the given team id

        starred_by : typing.Optional[int]
            search only for repos that the user with the given id has starred

        private : typing.Optional[bool]
            include private repositories this user has access to (defaults to true)

        is_private : typing.Optional[bool]
            show only public, private or all repositories (defaults to all)

        template : typing.Optional[bool]
            include template repositories this user has access to (defaults to true)

        archived : typing.Optional[bool]
            show only archived, non-archived or all repositories (defaults to all)

        mode : typing.Optional[str]
            type of repository to search for. Supported values are "fork", "source", "mirror" and "collaborative"

        exclusive : typing.Optional[bool]
            if `uid` is given, search only for repos that the user owns

        sort : typing.Optional[RepoSearchRequestSort]
            sort repos by attribute. Supported values are "alpha", "created", "updated", "size", "git_size", "lfs_size", "stars", "forks" and "id". Default is "alpha"

        order : typing.Optional[RepoSearchRequestOrder]
            sort order, either "asc" (ascending) or "desc" (descending). Default is "asc", ignored if "sort" is not specified.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SearchResults]
            SearchResults
        """
        _response = await self._client_wrapper.httpx_client.request(
            "repos/search",
            method="GET",
            params={
                "q": q,
                "topic": topic,
                "includeDesc": include_desc,
                "uid": uid,
                "priority_owner_id": priority_owner_id,
                "team_id": team_id,
                "starredBy": starred_by,
                "private": private,
                "is_private": is_private,
                "template": template,
                "archived": archived,
                "mode": mode,
                "exclusive": exclusive,
                "sort": sort,
                "order": order,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SearchResults,
                    parse_obj_as(
                        type_=SearchResults,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to delete

        repo : str
            name of the repo to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit(
        self,
        owner: str,
        repo: str,
        *,
        allow_fast_forward_only_merge: typing.Optional[bool] = OMIT,
        allow_manual_merge: typing.Optional[bool] = OMIT,
        allow_merge_commits: typing.Optional[bool] = OMIT,
        allow_rebase: typing.Optional[bool] = OMIT,
        allow_rebase_explicit: typing.Optional[bool] = OMIT,
        allow_rebase_update: typing.Optional[bool] = OMIT,
        allow_squash_merge: typing.Optional[bool] = OMIT,
        archived: typing.Optional[bool] = OMIT,
        autodetect_manual_merge: typing.Optional[bool] = OMIT,
        default_allow_maintainer_edit: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        default_delete_branch_after_merge: typing.Optional[bool] = OMIT,
        default_merge_style: typing.Optional[str] = OMIT,
        default_update_style: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        enable_prune: typing.Optional[bool] = OMIT,
        external_tracker: typing.Optional[ExternalTracker] = OMIT,
        external_wiki: typing.Optional[ExternalWiki] = OMIT,
        globally_editable_wiki: typing.Optional[bool] = OMIT,
        has_actions: typing.Optional[bool] = OMIT,
        has_issues: typing.Optional[bool] = OMIT,
        has_packages: typing.Optional[bool] = OMIT,
        has_projects: typing.Optional[bool] = OMIT,
        has_pull_requests: typing.Optional[bool] = OMIT,
        has_releases: typing.Optional[bool] = OMIT,
        has_wiki: typing.Optional[bool] = OMIT,
        ignore_whitespace_conflicts: typing.Optional[bool] = OMIT,
        internal_tracker: typing.Optional[InternalTracker] = OMIT,
        mirror_interval: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        private: typing.Optional[bool] = OMIT,
        template: typing.Optional[bool] = OMIT,
        website: typing.Optional[str] = OMIT,
        wiki_branch: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to edit

        repo : str
            name of the repo to edit

        allow_fast_forward_only_merge : typing.Optional[bool]
            either `true` to allow fast-forward-only merging pull requests, or `false` to prevent fast-forward-only merging.

        allow_manual_merge : typing.Optional[bool]
            either `true` to allow mark pr as merged manually, or `false` to prevent it.

        allow_merge_commits : typing.Optional[bool]
            either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.

        allow_rebase : typing.Optional[bool]
            either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.

        allow_rebase_explicit : typing.Optional[bool]
            either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits.

        allow_rebase_update : typing.Optional[bool]
            either `true` to allow updating pull request branch by rebase, or `false` to prevent it.

        allow_squash_merge : typing.Optional[bool]
            either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.

        archived : typing.Optional[bool]
            set to `true` to archive this repository.

        autodetect_manual_merge : typing.Optional[bool]
            either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur.

        default_allow_maintainer_edit : typing.Optional[bool]
            set to `true` to allow edits from maintainers by default

        default_branch : typing.Optional[str]
            sets the default branch for this repository.

        default_delete_branch_after_merge : typing.Optional[bool]
            set to `true` to delete pr branch after merge by default

        default_merge_style : typing.Optional[str]
            set to a merge style to be used by this repository: "merge", "rebase", "rebase-merge", "squash", "fast-forward-only", "manually-merged", or "rebase-update-only".

        default_update_style : typing.Optional[str]
            set to a update style to be used by this repository: "rebase" or "merge"

        description : typing.Optional[str]
            a short description of the repository.

        enable_prune : typing.Optional[bool]
            enable prune - remove obsolete remote-tracking references when mirroring

        external_tracker : typing.Optional[ExternalTracker]

        external_wiki : typing.Optional[ExternalWiki]

        globally_editable_wiki : typing.Optional[bool]
            set the globally editable state of the wiki

        has_actions : typing.Optional[bool]
            either `true` to enable actions unit, or `false` to disable them.

        has_issues : typing.Optional[bool]
            either `true` to enable issues for this repository or `false` to disable them.

        has_packages : typing.Optional[bool]
            either `true` to enable packages unit, or `false` to disable them.

        has_projects : typing.Optional[bool]
            either `true` to enable project unit, or `false` to disable them.

        has_pull_requests : typing.Optional[bool]
            either `true` to allow pull requests, or `false` to prevent pull request.

        has_releases : typing.Optional[bool]
            either `true` to enable releases unit, or `false` to disable them.

        has_wiki : typing.Optional[bool]
            either `true` to enable the wiki for this repository or `false` to disable it.

        ignore_whitespace_conflicts : typing.Optional[bool]
            either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace.

        internal_tracker : typing.Optional[InternalTracker]

        mirror_interval : typing.Optional[str]
            set to a string like `8h30m0s` to set the mirror interval time

        name : typing.Optional[str]
            name of the repository

        private : typing.Optional[bool]
            either `true` to make the repository private or `false` to make it public.
            Note: you will get a 422 error if the organization restricts changing repository visibility to organization
            owners and a non-owner tries to change the value of private.

        template : typing.Optional[bool]
            either `true` to make this repository a template or `false` to make it a normal repository

        website : typing.Optional[str]
            a URL with more information about the repository.

        wiki_branch : typing.Optional[str]
            sets the branch used for this repository's wiki.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}",
            method="PATCH",
            json={
                "allow_fast_forward_only_merge": allow_fast_forward_only_merge,
                "allow_manual_merge": allow_manual_merge,
                "allow_merge_commits": allow_merge_commits,
                "allow_rebase": allow_rebase,
                "allow_rebase_explicit": allow_rebase_explicit,
                "allow_rebase_update": allow_rebase_update,
                "allow_squash_merge": allow_squash_merge,
                "archived": archived,
                "autodetect_manual_merge": autodetect_manual_merge,
                "default_allow_maintainer_edit": default_allow_maintainer_edit,
                "default_branch": default_branch,
                "default_delete_branch_after_merge": default_delete_branch_after_merge,
                "default_merge_style": default_merge_style,
                "default_update_style": default_update_style,
                "description": description,
                "enable_prune": enable_prune,
                "external_tracker": convert_and_respect_annotation_metadata(
                    object_=external_tracker,
                    annotation=ExternalTracker,
                    direction="write",
                ),
                "external_wiki": convert_and_respect_annotation_metadata(
                    object_=external_wiki, annotation=ExternalWiki, direction="write"
                ),
                "globally_editable_wiki": globally_editable_wiki,
                "has_actions": has_actions,
                "has_issues": has_issues,
                "has_packages": has_packages,
                "has_projects": has_projects,
                "has_pull_requests": has_pull_requests,
                "has_releases": has_releases,
                "has_wiki": has_wiki,
                "ignore_whitespace_conflicts": ignore_whitespace_conflicts,
                "internal_tracker": convert_and_respect_annotation_metadata(
                    object_=internal_tracker,
                    annotation=InternalTracker,
                    direction="write",
                ),
                "mirror_interval": mirror_interval,
                "name": name,
                "private": private,
                "template": template,
                "website": website,
                "wiki_branch": wiki_branch,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_search_run_jobs(
        self,
        owner: str,
        repo: str,
        *,
        labels: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[ActionRunJob]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        labels : typing.Optional[str]
            a comma separated list of run job labels to search for

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[ActionRunJob]]
            RunJobList is a list of action run jobs
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runners/jobs",
            method="GET",
            params={
                "labels": labels,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ActionRunJob],
                    parse_obj_as(
                        type_=typing.List[ActionRunJob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_runner_registration_token(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RegistrationToken]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RegistrationToken]
            RegistrationToken is a string used to register a runner with a server
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runners/registration-token",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RegistrationToken,
                    parse_obj_as(
                        type_=RegistrationToken,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_action_runs(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        event: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        status: typing.Optional[
            typing.Union[
                ListActionRunsRequestStatusItem,
                typing.Sequence[ListActionRunsRequestStatusItem],
            ]
        ] = None,
        run_number: typing.Optional[int] = None,
        head_sha: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListActionRunResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        event : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Returns workflow run triggered by the specified events. For example, `push`, `pull_request` or `workflow_dispatch`.

        status : typing.Optional[typing.Union[ListActionRunsRequestStatusItem, typing.Sequence[ListActionRunsRequestStatusItem]]]
            Returns workflow runs with the check run status or conclusion that is specified. For example, a conclusion can be success or a status can be in_progress. Only Forgejo Actions can set a status of waiting, pending, or requested.

        run_number : typing.Optional[int]
            Returns the workflow run associated with the run number.

        head_sha : typing.Optional[str]
            Only returns workflow runs that are associated with the specified head_sha.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListActionRunResponse]
            ActionRunList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runs",
            method="GET",
            params={
                "page": page,
                "limit": limit,
                "event": event,
                "status": status,
                "run_number": run_number,
                "head_sha": head_sha,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListActionRunResponse,
                    parse_obj_as(
                        type_=ListActionRunResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def action_run(
        self,
        owner: str,
        repo: str,
        run_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ActionRun]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        run_id : int
            id of the action run

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ActionRun]
            ActionRun
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/runs/{jsonable_encoder(run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActionRun,
                    parse_obj_as(
                        type_=ActionRun,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_actions_secrets(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Secret]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Secret]]
            SecretList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Secret],
                    parse_obj_as(
                        type_=typing.List[Secret],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def update_repo_secret(
        self,
        owner: str,
        repo: str,
        secretname: str,
        *,
        data: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        secretname : str
            name of the secret

        data : str
            Data of the secret to update

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets/{jsonable_encoder(secretname)}",
            method="PUT",
            json={
                "data": data,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_repo_secret(
        self,
        owner: str,
        repo: str,
        secretname: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repository

        repo : str
            name of the repository

        secretname : str
            name of the secret

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/secrets/{jsonable_encoder(secretname)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_action_tasks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ActionTaskResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ActionTaskResponse]
            TasksList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/tasks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActionTaskResponse,
                    parse_obj_as(
                        type_=ActionTaskResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_repo_variables_list(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[ActionVariable]]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[ActionVariable]]
            VariableList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ActionVariable],
                    parse_obj_as(
                        type_=typing.List[ActionVariable],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ActionVariable]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ActionVariable]
            ActionVariable
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActionVariable,
                    parse_obj_as(
                        type_=ActionVariable,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        value: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        value : str
            Value of the variable to create

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="POST",
            json={
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def update_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        value: str,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        value : str
            Value of the variable to update

        name : typing.Optional[str]
            New name for the variable. If the field is empty, the variable name won't be updated.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="PUT",
            json={
                "name": name,
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_repo_variable(
        self,
        owner: str,
        repo: str,
        variablename: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            name of the owner

        repo : str
            name of the repository

        variablename : str
            name of the variable

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/variables/{jsonable_encoder(variablename)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def dispatch_workflow(
        self,
        owner: str,
        repo: str,
        workflowfilename: str,
        *,
        ref: str,
        inputs: typing.Optional[typing.Dict[str, str]] = OMIT,
        return_run_info: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DispatchWorkflowRun]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        workflowfilename : str
            name of the workflow

        ref : str
            Git reference for the workflow

        inputs : typing.Optional[typing.Dict[str, str]]
            Input keys and values configured in the workflow file.

        return_run_info : typing.Optional[bool]
            Flag to return the run info

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DispatchWorkflowRun]
            DispatchWorkflowRun is a Workflow Run after dispatching
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/actions/workflows/{jsonable_encoder(workflowfilename)}/dispatches",
            method="POST",
            json={
                "inputs": inputs,
                "ref": ref,
                "return_run_info": return_run_info,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DispatchWorkflowRun,
                    parse_obj_as(
                        type_=DispatchWorkflowRun,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_activity_feeds(
        self,
        owner: str,
        repo: str,
        *,
        date: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Activity]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        date : typing.Optional[str]
            the date of the activities to be found

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Activity]]
            ActivityFeedsList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/activities/feeds",
            method="GET",
            params={
                "date": date,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Activity],
                    parse_obj_as(
                        type_=typing.List[Activity],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_archive(
        self,
        owner: str,
        repo: str,
        archive: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        archive : str
            the git reference for download with attached archive format (e.g. master.zip)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/archive/{jsonable_encoder(archive)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_assignees(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[User]]
            UserList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/assignees",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_update_avatar(
        self,
        owner: str,
        repo: str,
        *,
        image: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        image : typing.Optional[str]
            image must be base64 encoded

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/avatar",
            method="POST",
            json={
                "image": image,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_avatar(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/avatar",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_branch_protection(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[BranchProtection]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[BranchProtection]]
            BranchProtectionList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[BranchProtection],
                    parse_obj_as(
                        type_=typing.List[BranchProtection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_branch_protection(
        self,
        owner: str,
        repo: str,
        *,
        apply_to_admins: typing.Optional[bool] = OMIT,
        approvals_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        approvals_whitelist_username: typing.Optional[typing.Sequence[str]] = OMIT,
        block_on_official_review_requests: typing.Optional[bool] = OMIT,
        block_on_outdated_branch: typing.Optional[bool] = OMIT,
        block_on_rejected_reviews: typing.Optional[bool] = OMIT,
        branch_name: typing.Optional[str] = OMIT,
        dismiss_stale_approvals: typing.Optional[bool] = OMIT,
        enable_approvals_whitelist: typing.Optional[bool] = OMIT,
        enable_merge_whitelist: typing.Optional[bool] = OMIT,
        enable_push: typing.Optional[bool] = OMIT,
        enable_push_whitelist: typing.Optional[bool] = OMIT,
        enable_status_check: typing.Optional[bool] = OMIT,
        ignore_stale_approvals: typing.Optional[bool] = OMIT,
        merge_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        merge_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        protected_file_patterns: typing.Optional[str] = OMIT,
        push_whitelist_deploy_keys: typing.Optional[bool] = OMIT,
        push_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        push_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        require_signed_commits: typing.Optional[bool] = OMIT,
        required_approvals: typing.Optional[int] = OMIT,
        rule_name: typing.Optional[str] = OMIT,
        status_check_contexts: typing.Optional[typing.Sequence[str]] = OMIT,
        unprotected_file_patterns: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BranchProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        apply_to_admins : typing.Optional[bool]

        approvals_whitelist_teams : typing.Optional[typing.Sequence[str]]

        approvals_whitelist_username : typing.Optional[typing.Sequence[str]]

        block_on_official_review_requests : typing.Optional[bool]

        block_on_outdated_branch : typing.Optional[bool]

        block_on_rejected_reviews : typing.Optional[bool]

        branch_name : typing.Optional[str]
            Deprecated: true

        dismiss_stale_approvals : typing.Optional[bool]

        enable_approvals_whitelist : typing.Optional[bool]

        enable_merge_whitelist : typing.Optional[bool]

        enable_push : typing.Optional[bool]

        enable_push_whitelist : typing.Optional[bool]

        enable_status_check : typing.Optional[bool]

        ignore_stale_approvals : typing.Optional[bool]

        merge_whitelist_teams : typing.Optional[typing.Sequence[str]]

        merge_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        protected_file_patterns : typing.Optional[str]

        push_whitelist_deploy_keys : typing.Optional[bool]

        push_whitelist_teams : typing.Optional[typing.Sequence[str]]

        push_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        require_signed_commits : typing.Optional[bool]

        required_approvals : typing.Optional[int]

        rule_name : typing.Optional[str]

        status_check_contexts : typing.Optional[typing.Sequence[str]]

        unprotected_file_patterns : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BranchProtection]
            BranchProtection
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections",
            method="POST",
            json={
                "apply_to_admins": apply_to_admins,
                "approvals_whitelist_teams": approvals_whitelist_teams,
                "approvals_whitelist_username": approvals_whitelist_username,
                "block_on_official_review_requests": block_on_official_review_requests,
                "block_on_outdated_branch": block_on_outdated_branch,
                "block_on_rejected_reviews": block_on_rejected_reviews,
                "branch_name": branch_name,
                "dismiss_stale_approvals": dismiss_stale_approvals,
                "enable_approvals_whitelist": enable_approvals_whitelist,
                "enable_merge_whitelist": enable_merge_whitelist,
                "enable_push": enable_push,
                "enable_push_whitelist": enable_push_whitelist,
                "enable_status_check": enable_status_check,
                "ignore_stale_approvals": ignore_stale_approvals,
                "merge_whitelist_teams": merge_whitelist_teams,
                "merge_whitelist_usernames": merge_whitelist_usernames,
                "protected_file_patterns": protected_file_patterns,
                "push_whitelist_deploy_keys": push_whitelist_deploy_keys,
                "push_whitelist_teams": push_whitelist_teams,
                "push_whitelist_usernames": push_whitelist_usernames,
                "require_signed_commits": require_signed_commits,
                "required_approvals": required_approvals,
                "rule_name": rule_name,
                "status_check_contexts": status_check_contexts,
                "unprotected_file_patterns": unprotected_file_patterns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BranchProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BranchProtection]
            BranchProtection
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit_branch_protection(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        apply_to_admins: typing.Optional[bool] = OMIT,
        approvals_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        approvals_whitelist_username: typing.Optional[typing.Sequence[str]] = OMIT,
        block_on_official_review_requests: typing.Optional[bool] = OMIT,
        block_on_outdated_branch: typing.Optional[bool] = OMIT,
        block_on_rejected_reviews: typing.Optional[bool] = OMIT,
        dismiss_stale_approvals: typing.Optional[bool] = OMIT,
        enable_approvals_whitelist: typing.Optional[bool] = OMIT,
        enable_merge_whitelist: typing.Optional[bool] = OMIT,
        enable_push: typing.Optional[bool] = OMIT,
        enable_push_whitelist: typing.Optional[bool] = OMIT,
        enable_status_check: typing.Optional[bool] = OMIT,
        ignore_stale_approvals: typing.Optional[bool] = OMIT,
        merge_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        merge_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        protected_file_patterns: typing.Optional[str] = OMIT,
        push_whitelist_deploy_keys: typing.Optional[bool] = OMIT,
        push_whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        push_whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        require_signed_commits: typing.Optional[bool] = OMIT,
        required_approvals: typing.Optional[int] = OMIT,
        status_check_contexts: typing.Optional[typing.Sequence[str]] = OMIT,
        unprotected_file_patterns: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BranchProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            name of protected branch

        apply_to_admins : typing.Optional[bool]

        approvals_whitelist_teams : typing.Optional[typing.Sequence[str]]

        approvals_whitelist_username : typing.Optional[typing.Sequence[str]]

        block_on_official_review_requests : typing.Optional[bool]

        block_on_outdated_branch : typing.Optional[bool]

        block_on_rejected_reviews : typing.Optional[bool]

        dismiss_stale_approvals : typing.Optional[bool]

        enable_approvals_whitelist : typing.Optional[bool]

        enable_merge_whitelist : typing.Optional[bool]

        enable_push : typing.Optional[bool]

        enable_push_whitelist : typing.Optional[bool]

        enable_status_check : typing.Optional[bool]

        ignore_stale_approvals : typing.Optional[bool]

        merge_whitelist_teams : typing.Optional[typing.Sequence[str]]

        merge_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        protected_file_patterns : typing.Optional[str]

        push_whitelist_deploy_keys : typing.Optional[bool]

        push_whitelist_teams : typing.Optional[typing.Sequence[str]]

        push_whitelist_usernames : typing.Optional[typing.Sequence[str]]

        require_signed_commits : typing.Optional[bool]

        required_approvals : typing.Optional[int]

        status_check_contexts : typing.Optional[typing.Sequence[str]]

        unprotected_file_patterns : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BranchProtection]
            BranchProtection
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branch_protections/{jsonable_encoder(name)}",
            method="PATCH",
            json={
                "apply_to_admins": apply_to_admins,
                "approvals_whitelist_teams": approvals_whitelist_teams,
                "approvals_whitelist_username": approvals_whitelist_username,
                "block_on_official_review_requests": block_on_official_review_requests,
                "block_on_outdated_branch": block_on_outdated_branch,
                "block_on_rejected_reviews": block_on_rejected_reviews,
                "dismiss_stale_approvals": dismiss_stale_approvals,
                "enable_approvals_whitelist": enable_approvals_whitelist,
                "enable_merge_whitelist": enable_merge_whitelist,
                "enable_push": enable_push,
                "enable_push_whitelist": enable_push_whitelist,
                "enable_status_check": enable_status_check,
                "ignore_stale_approvals": ignore_stale_approvals,
                "merge_whitelist_teams": merge_whitelist_teams,
                "merge_whitelist_usernames": merge_whitelist_usernames,
                "protected_file_patterns": protected_file_patterns,
                "push_whitelist_deploy_keys": push_whitelist_deploy_keys,
                "push_whitelist_teams": push_whitelist_teams,
                "push_whitelist_usernames": push_whitelist_usernames,
                "require_signed_commits": require_signed_commits,
                "required_approvals": required_approvals,
                "status_check_contexts": status_check_contexts,
                "unprotected_file_patterns": unprotected_file_patterns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BranchProtection,
                    parse_obj_as(
                        type_=BranchProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_branches(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Branch]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Branch]]
            BranchList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Branch],
                    parse_obj_as(
                        type_=typing.List[Branch],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_branch(
        self,
        owner: str,
        repo: str,
        *,
        new_branch_name: str,
        old_branch_name: typing.Optional[str] = OMIT,
        old_ref_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Branch]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        new_branch_name : str
            Name of the branch to create

        old_branch_name : typing.Optional[str]
            Deprecated: true
            Name of the old branch to create from

        old_ref_name : typing.Optional[str]
            Name of the old branch/tag/commit to create from

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Branch]
            Branch
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches",
            method="POST",
            json={
                "new_branch_name": new_branch_name,
                "old_branch_name": old_branch_name,
                "old_ref_name": old_ref_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Branch,
                    parse_obj_as(
                        type_=Branch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Branch]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            branch to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Branch]
            Branch
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Branch,
                    parse_obj_as(
                        type_=Branch,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            branch to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_update_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        name: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            name of the branch

        name : str
            New branch name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/branches/{jsonable_encoder(branch)}",
            method="PATCH",
            json={
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_collaborators(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[User]]
            UserList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_check_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        If the user is a collaborator, return 204. If the user is not a collaborator, return 404.

        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_add_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        permission: typing.Optional[AddCollaboratorOptionPermission] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator to add

        permission : typing.Optional[AddCollaboratorOptionPermission]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="PUT",
            json={
                "permission": permission,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_collaborator(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_repo_permissions(
        self,
        owner: str,
        repo: str,
        collaborator: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RepoCollaboratorPermission]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        collaborator : str
            username of the collaborator

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RepoCollaboratorPermission]
            RepoCollaboratorPermission
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/collaborators/{jsonable_encoder(collaborator)}/permission",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RepoCollaboratorPermission,
                    parse_obj_as(
                        type_=RepoCollaboratorPermission,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_all_commits(
        self,
        owner: str,
        repo: str,
        *,
        sha: typing.Optional[str] = None,
        path: typing.Optional[str] = None,
        stat: typing.Optional[bool] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        not_: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Commit]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : typing.Optional[str]
            SHA or branch to start listing commits from (usually 'master')

        path : typing.Optional[str]
            filepath of a file/dir

        stat : typing.Optional[bool]
            include diff stats for every commit (disable for speedup, default 'true')

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results (ignored if used with 'path')

        not_ : typing.Optional[str]
            commits that match the given specifier will not be listed.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Commit]]
            CommitList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits",
            method="GET",
            params={
                "sha": sha,
                "path": path,
                "stat": stat,
                "verification": verification,
                "files": files,
                "page": page,
                "limit": limit,
                "not": not_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Commit],
                    parse_obj_as(
                        type_=typing.List[Commit],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_combined_status_by_ref(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CombinedStatus]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            name of branch/tag/commit

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CombinedStatus]
            CombinedStatus
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(ref)}/status",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CombinedStatus,
                    parse_obj_as(
                        type_=CombinedStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_statuses_by_ref(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        sort: typing.Optional[RepoListStatusesByRefRequestSort] = None,
        state: typing.Optional[RepoListStatusesByRefRequestState] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[CommitStatus]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            name of branch/tag/commit

        sort : typing.Optional[RepoListStatusesByRefRequestSort]
            type of sort

        state : typing.Optional[RepoListStatusesByRefRequestState]
            type of state

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[CommitStatus]]
            CommitStatusList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(ref)}/statuses",
            method="GET",
            params={
                "sort": sort,
                "state": state,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CommitStatus],
                    parse_obj_as(
                        type_=typing.List[CommitStatus],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_commit_pull_request(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            SHA of the commit to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullRequest]
            PullRequest
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/commits/{jsonable_encoder(sha)}/pull",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_compare_diff(
        self,
        owner: str,
        repo: str,
        basehead: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Compare]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        basehead : str
            compare two branches or commits

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Compare]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/compare/{jsonable_encoder(basehead)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Compare,
                    parse_obj_as(
                        type_=Compare,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_contents_list(
        self,
        owner: str,
        repo: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[ContentsResponse]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[ContentsResponse]]
            ContentsListResponse
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ContentsResponse],
                    parse_obj_as(
                        type_=typing.List[ContentsResponse],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_change_files(
        self,
        owner: str,
        repo: str,
        *,
        files: typing.Sequence[ChangeFileOperation],
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FilesResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        files : typing.Sequence[ChangeFileOperation]
            list of file operations

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FilesResponse]
            FilesResponse
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[ChangeFileOperation],
                    direction="write",
                ),
                "message": message,
                "new_branch": new_branch,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FilesResponse,
                    parse_obj_as(
                        type_=FilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_contents(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RepoGetContentsResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the dir, file, symlink or submodule in the repo

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RepoGetContentsResponse]
            A single file's contents or a directory listing
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RepoGetContentsResponse,
                    parse_obj_as(
                        type_=RepoGetContentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        content: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FileResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to create

        content : str
            content must be base64 encoded

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FileResponse]
            FileResponse
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "message": message,
                "new_branch": new_branch,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_update_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        content: str,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        from_path: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FileResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to update

        content : str
            content must be base64 encoded

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        from_path : typing.Optional[str]
            from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FileResponse]
            FileResponse
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="PUT",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "from_path": from_path,
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FileDeleteResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            path of the file to delete

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FileDeleteResponse]
            FileDeleteResponse
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/contents/{jsonable_encoder(filepath)}",
            method="DELETE",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileDeleteResponse,
                    parse_obj_as(
                        type_=FileDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_convert(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to convert

        repo : str
            name of the repo to convert

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/convert",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_apply_diff_patch(
        self,
        owner: str,
        repo: str,
        *,
        content: str,
        sha: str,
        author: typing.Optional[Identity] = OMIT,
        branch: typing.Optional[str] = OMIT,
        committer: typing.Optional[Identity] = OMIT,
        dates: typing.Optional[CommitDateOptions] = OMIT,
        from_path: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        new_branch: typing.Optional[str] = OMIT,
        signoff: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FileResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        content : str
            content must be base64 encoded

        sha : str
            sha is the SHA for the file that already exists

        author : typing.Optional[Identity]

        branch : typing.Optional[str]
            branch (optional) to base this file from. if not given, the default branch is used

        committer : typing.Optional[Identity]

        dates : typing.Optional[CommitDateOptions]

        from_path : typing.Optional[str]
            from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL

        message : typing.Optional[str]
            message (optional) for the commit of this file. if not supplied, a default message will be used

        new_branch : typing.Optional[str]
            new_branch (optional) will make a new branch from `branch` before creating the file

        signoff : typing.Optional[bool]
            Add a Signed-off-by trailer by the committer at the end of the commit log message.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FileResponse]
            FileResponse
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/diffpatch",
            method="POST",
            json={
                "author": convert_and_respect_annotation_metadata(
                    object_=author, annotation=Identity, direction="write"
                ),
                "branch": branch,
                "committer": convert_and_respect_annotation_metadata(
                    object_=committer, annotation=Identity, direction="write"
                ),
                "content": content,
                "dates": convert_and_respect_annotation_metadata(
                    object_=dates, annotation=CommitDateOptions, direction="write"
                ),
                "from_path": from_path,
                "message": message,
                "new_branch": new_branch,
                "sha": sha,
                "signoff": signoff,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    FileResponse,
                    parse_obj_as(
                        type_=FileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_editor_config(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Dict[str, str]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, str]]
            definitions
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/editorconfig/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, str],
                    parse_obj_as(
                        type_=typing.Dict[str, str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_flags(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[str]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[str]]
            StringSlice
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_replace_all_flags(
        self,
        owner: str,
        repo: str,
        *,
        flags: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flags : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="PUT",
            json={
                "flags": flags,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_all_flags(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_check_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_add_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_flag(
        self,
        owner: str,
        repo: str,
        flag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        flag : str
            name of the flag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/flags/{jsonable_encoder(flag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_forks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Repository]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Repository]]
            RepositoryList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/forks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Repository],
                    parse_obj_as(
                        type_=typing.List[Repository],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_fork(
        self,
        owner: str,
        repo: str,
        *,
        name: typing.Optional[str] = OMIT,
        organization: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to fork

        repo : str
            name of the repo to fork

        name : typing.Optional[str]
            name of the forked repository

        organization : typing.Optional[str]
            organization name, if forking into an organization

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/forks",
            method="POST",
            json={
                "name": name,
                "organization": organization,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_blobs(
        self,
        owner: str,
        repo: str,
        *,
        shas: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[GitBlob]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        shas : str
            a comma separated list of blob-sha (mind the overall URL-length limit of ~2,083 chars)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[GitBlob]]
            GitBlobList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/blobs",
            method="GET",
            params={
                "shas": shas,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[GitBlob],
                    parse_obj_as(
                        type_=typing.List[GitBlob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_blob(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GitBlob]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the blob to retrieve

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GitBlob]
            GitBlob
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/blobs/{jsonable_encoder(sha)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GitBlob,
                    parse_obj_as(
                        type_=GitBlob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_single_commit(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        stat: typing.Optional[bool] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Commit]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        stat : typing.Optional[bool]
            include diff stats for every commit (disable for speedup, default 'true')

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Commit]
            Commit
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/commits/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "stat": stat,
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Commit,
                    parse_obj_as(
                        type_=Commit,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_download_commit_diff_or_patch(
        self,
        owner: str,
        repo: str,
        sha: str,
        diff_type: RepoDownloadCommitDiffOrPatchRequestDiffType,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[str]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            SHA of the commit to get

        diff_type : RepoDownloadCommitDiffOrPatchRequestDiffType
            whether the output is diff or patch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[str]
            APIString is a string response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/commits/{jsonable_encoder(sha)}.{jsonable_encoder(diff_type)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    str,
                    parse_obj_as(
                        type_=str,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Note]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Note]
            Note
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Note,
                    parse_obj_as(
                        type_=Note,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_set_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        message: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Note]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        message : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Note]
            Note
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="POST",
            json={
                "message": message,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Note,
                    parse_obj_as(
                        type_=Note,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_remove_note(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            a git ref or commit sha

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/notes/{jsonable_encoder(sha)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_all_git_refs(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Reference]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Reference]]
            ReferenceList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/refs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Reference],
                    parse_obj_as(
                        type_=typing.List[Reference],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_git_refs(
        self,
        owner: str,
        repo: str,
        ref: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Reference]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        ref : str
            part or full name of the ref

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Reference]]
            ReferenceList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/refs/{jsonable_encoder(ref)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Reference],
                    parse_obj_as(
                        type_=typing.List[Reference],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_annotated_tag(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AnnotatedTag]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AnnotatedTag]
            AnnotatedTag
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/tags/{jsonable_encoder(sha)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AnnotatedTag,
                    parse_obj_as(
                        type_=AnnotatedTag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_tree(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        recursive: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GitTreeResponse]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        recursive : typing.Optional[bool]
            show all directories and files

        page : typing.Optional[int]
            page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page

        per_page : typing.Optional[int]
            number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GitTreeResponse]
            GitTreeResponse
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/git/trees/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "recursive": recursive,
                "page": page,
                "per_page": per_page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GitTreeResponse,
                    parse_obj_as(
                        type_=GitTreeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_hooks(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Hook]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Hook]]
            HookList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Hook],
                    parse_obj_as(
                        type_=typing.List[Hook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_hook(
        self,
        owner: str,
        repo: str,
        *,
        config: CreateHookOptionConfig,
        type: CreateHookOptionType,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Hook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        config : CreateHookOptionConfig

        type : CreateHookOptionType

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Hook]
            Hook
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks",
            method="POST",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
                "type": type,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_git_hooks(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[GitHook]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[GitHook]]
            GitHookList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[GitHook],
                    parse_obj_as(
                        type_=typing.List[GitHook],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GitHook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GitHook]
            GitHook
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GitHook,
                    parse_obj_as(
                        type_=GitHook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit_git_hook(
        self,
        owner: str,
        repo: str,
        id: str,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GitHook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : str
            id of the hook to get

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GitHook]
            GitHook
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/git/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GitHook,
                    parse_obj_as(
                        type_=GitHook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Hook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Hook]
            Hook
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        active: typing.Optional[bool] = OMIT,
        authorization_header: typing.Optional[str] = OMIT,
        branch_filter: typing.Optional[str] = OMIT,
        config: typing.Optional[typing.Dict[str, str]] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Hook]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            index of the hook

        active : typing.Optional[bool]

        authorization_header : typing.Optional[str]

        branch_filter : typing.Optional[str]

        config : typing.Optional[typing.Dict[str, str]]

        events : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Hook]
            Hook
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "active": active,
                "authorization_header": authorization_header,
                "branch_filter": branch_filter,
                "config": config,
                "events": events,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Hook,
                    parse_obj_as(
                        type_=Hook,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_test_hook(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the hook to test

        ref : typing.Optional[str]
            The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/hooks/{jsonable_encoder(id)}/tests",
            method="POST",
            params={
                "ref": ref,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_issue_config(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[IssueConfig]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[IssueConfig]
            RepoIssueConfig
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_config",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IssueConfig,
                    parse_obj_as(
                        type_=IssueConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_validate_issue_config(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[IssueConfigValidation]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[IssueConfigValidation]
            RepoIssueConfigValidation
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_config/validate",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IssueConfigValidation,
                    parse_obj_as(
                        type_=IssueConfigValidation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_issue_templates(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[IssueTemplate]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[IssueTemplate]]
            IssueTemplates
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issue_templates",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[IssueTemplate],
                    parse_obj_as(
                        type_=typing.List[IssueTemplate],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_pinned_issues(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/pinned",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_keys(
        self,
        owner: str,
        repo: str,
        *,
        key_id: typing.Optional[int] = None,
        fingerprint: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[DeployKey]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        key_id : typing.Optional[int]
            the key_id to search for

        fingerprint : typing.Optional[str]
            fingerprint of the key

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[DeployKey]]
            DeployKeyList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys",
            method="GET",
            params={
                "key_id": key_id,
                "fingerprint": fingerprint,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[DeployKey],
                    parse_obj_as(
                        type_=typing.List[DeployKey],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_key(
        self,
        owner: str,
        repo: str,
        *,
        key: str,
        title: str,
        read_only: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeployKey]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        key : str
            An armored SSH key to add

        title : str
            Title of the key to add

        read_only : typing.Optional[bool]
            Describe if the key has only read access or read/write

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeployKey]
            DeployKey
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys",
            method="POST",
            json={
                "key": key,
                "read_only": read_only,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeployKey,
                    parse_obj_as(
                        type_=DeployKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_key(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeployKey]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the key to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeployKey]
            DeployKey
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeployKey,
                    parse_obj_as(
                        type_=DeployKey,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_key(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the key to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/keys/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_languages(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Dict[str, int]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Dict[str, int]]
            LanguageStatistics
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/languages",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Dict[str, int],
                    parse_obj_as(
                        type_=typing.Dict[str, int],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    @contextlib.asynccontextmanager
    async def repo_get_raw_file_or_lfs(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of the file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]
            Returns raw file content.
        """
        async with self._client_wrapper.httpx_client.stream(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/media/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        ) as _response:

            async def _stream() -> AsyncHttpResponse[typing.AsyncIterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = (
                            request_options.get("chunk_size", None)
                            if request_options is not None
                            else None
                        )
                        return AsyncHttpResponse(
                            response=_response,
                            data=(
                                _chunk
                                async for _chunk in _response.aiter_bytes(
                                    chunk_size=_chunk_size
                                )
                            ),
                        )
                    await _response.aread()
                    if _response.status_code == 404:
                        raise NotFoundError(
                            headers=dict(_response.headers),
                            body=typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            ),
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise core_api_error_ApiError(
                        status_code=_response.status_code,
                        headers=dict(_response.headers),
                        body=_response.text,
                    )
                raise core_api_error_ApiError(
                    status_code=_response.status_code,
                    headers=dict(_response.headers),
                    body=_response_json,
                )

            yield await _stream()

    async def repo_mirror_sync(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to sync

        repo : str
            name of the repo to sync

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/mirror-sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_new_pin_allowed(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[NewIssuePinsAllowed]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[NewIssuePinsAllowed]
            RepoNewIssuePinsAllowed
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/new_pin_allowed",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    NewIssuePinsAllowed,
                    parse_obj_as(
                        type_=NewIssuePinsAllowed,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_pull_requests(
        self,
        owner: str,
        repo: str,
        *,
        state: typing.Optional[RepoListPullRequestsRequestState] = None,
        sort: typing.Optional[RepoListPullRequestsRequestSort] = None,
        milestone: typing.Optional[int] = None,
        labels: typing.Optional[typing.Union[int, typing.Sequence[int]]] = None,
        poster: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PullRequest]]:
        """
        Parameters
        ----------
        owner : str
            Owner of the repo

        repo : str
            Name of the repo

        state : typing.Optional[RepoListPullRequestsRequestState]
            State of pull request

        sort : typing.Optional[RepoListPullRequestsRequestSort]
            Type of sort

        milestone : typing.Optional[int]
            ID of the milestone

        labels : typing.Optional[typing.Union[int, typing.Sequence[int]]]
            Label IDs

        poster : typing.Optional[str]
            Filter by pull request author

        page : typing.Optional[int]
            Page number of results to return (1-based)

        limit : typing.Optional[int]
            Page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PullRequest]]
            PullRequestList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls",
            method="GET",
            params={
                "state": state,
                "sort": sort,
                "milestone": milestone,
                "labels": labels,
                "poster": poster,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullRequest],
                    parse_obj_as(
                        type_=typing.List[PullRequest],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_pull_request(
        self,
        owner: str,
        repo: str,
        *,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        base: typing.Optional[str] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        head: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        assignee : typing.Optional[str]

        assignees : typing.Optional[typing.Sequence[str]]

        base : typing.Optional[str]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        head : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[int]]

        milestone : typing.Optional[int]

        title : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullRequest]
            PullRequest
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls",
            method="POST",
            json={
                "assignee": assignee,
                "assignees": assignees,
                "base": base,
                "body": body,
                "due_date": due_date,
                "head": head,
                "labels": labels,
                "milestone": milestone,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_pinned_pull_requests(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PullRequest]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PullRequest]]
            PullRequestList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/pinned",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullRequest],
                    parse_obj_as(
                        type_=typing.List[PullRequest],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_pull_request_by_base_head(
        self,
        owner: str,
        repo: str,
        base: str,
        head: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        base : str
            base of the pull request to get

        head : str
            head of the pull request to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullRequest]
            PullRequest
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(base)}/{jsonable_encoder(head)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullRequest]
            PullRequest
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        allow_maintainer_edit: typing.Optional[bool] = OMIT,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        base: typing.Optional[str] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        state: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        unset_due_date: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullRequest]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to edit

        allow_maintainer_edit : typing.Optional[bool]

        assignee : typing.Optional[str]

        assignees : typing.Optional[typing.Sequence[str]]

        base : typing.Optional[str]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        labels : typing.Optional[typing.Sequence[int]]

        milestone : typing.Optional[int]

        state : typing.Optional[str]

        title : typing.Optional[str]

        unset_due_date : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullRequest]
            PullRequest
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}",
            method="PATCH",
            json={
                "allow_maintainer_edit": allow_maintainer_edit,
                "assignee": assignee,
                "assignees": assignees,
                "base": base,
                "body": body,
                "due_date": due_date,
                "labels": labels,
                "milestone": milestone,
                "state": state,
                "title": title,
                "unset_due_date": unset_due_date,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullRequest,
                    parse_obj_as(
                        type_=PullRequest,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_download_pull_diff_or_patch(
        self,
        owner: str,
        repo: str,
        index: int,
        diff_type: RepoDownloadPullDiffOrPatchRequestDiffType,
        *,
        binary: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[str]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        diff_type : RepoDownloadPullDiffOrPatchRequestDiffType
            whether the output is diff or patch

        binary : typing.Optional[bool]
            whether to include binary file changes. if true, the diff is applicable with `git apply`

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[str]
            APIString is a string response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}.{jsonable_encoder(diff_type)}",
            method="GET",
            params={
                "binary": binary,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    str,
                    parse_obj_as(
                        type_=str,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_pull_request_commits(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        verification: typing.Optional[bool] = None,
        files: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Commit]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        verification : typing.Optional[bool]
            include verification for every commit (disable for speedup, default 'true')

        files : typing.Optional[bool]
            include a list of affected files for every commit (disable for speedup, default 'true')

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Commit]]
            CommitList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/commits",
            method="GET",
            params={
                "page": page,
                "limit": limit,
                "verification": verification,
                "files": files,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Commit],
                    parse_obj_as(
                        type_=typing.List[Commit],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_pull_request_files(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        skip_to: typing.Optional[str] = None,
        whitespace: typing.Optional[RepoGetPullRequestFilesRequestWhitespace] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[ChangedFile]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        skip_to : typing.Optional[str]
            skip to given file

        whitespace : typing.Optional[RepoGetPullRequestFilesRequestWhitespace]
            whitespace behavior

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[ChangedFile]]
            ChangedFileList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/files",
            method="GET",
            params={
                "skip-to": skip_to,
                "whitespace": whitespace,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[ChangedFile],
                    parse_obj_as(
                        type_=typing.List[ChangedFile],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_pull_request_is_merged(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_merge_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        do: MergePullRequestOptionDo,
        merge_commit_id: typing.Optional[str] = OMIT,
        merge_message_field: typing.Optional[str] = OMIT,
        merge_title_field: typing.Optional[str] = OMIT,
        delete_branch_after_merge: typing.Optional[bool] = OMIT,
        force_merge: typing.Optional[bool] = OMIT,
        head_commit_id: typing.Optional[str] = OMIT,
        merge_when_checks_succeed: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to merge

        do : MergePullRequestOptionDo

        merge_commit_id : typing.Optional[str]

        merge_message_field : typing.Optional[str]

        merge_title_field : typing.Optional[str]

        delete_branch_after_merge : typing.Optional[bool]

        force_merge : typing.Optional[bool]

        head_commit_id : typing.Optional[str]

        merge_when_checks_succeed : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="POST",
            json={
                "Do": do,
                "MergeCommitID": merge_commit_id,
                "MergeMessageField": merge_message_field,
                "MergeTitleField": merge_title_field,
                "delete_branch_after_merge": delete_branch_after_merge,
                "force_merge": force_merge,
                "head_commit_id": head_commit_id,
                "merge_when_checks_succeed": merge_when_checks_succeed,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_cancel_scheduled_auto_merge(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to merge

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/merge",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_pull_review_requests(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        team_reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PullReview]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        reviewers : typing.Optional[typing.Sequence[str]]

        team_reviewers : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PullReview]]
            PullReviewList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/requested_reviewers",
            method="POST",
            json={
                "reviewers": reviewers,
                "team_reviewers": team_reviewers,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullReview],
                    parse_obj_as(
                        type_=typing.List[PullReview],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_pull_review_requests(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        team_reviewers: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        reviewers : typing.Optional[typing.Sequence[str]]

        team_reviewers : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/requested_reviewers",
            method="DELETE",
            json={
                "reviewers": reviewers,
                "team_reviewers": team_reviewers,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_pull_reviews(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PullReview]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PullReview]]
            PullReviewList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullReview],
                    parse_obj_as(
                        type_=typing.List[PullReview],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        body: typing.Optional[str] = OMIT,
        comments: typing.Optional[typing.Sequence[CreatePullReviewComment]] = OMIT,
        commit_id: typing.Optional[str] = OMIT,
        event: typing.Optional[ReviewStateType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        body : typing.Optional[str]

        comments : typing.Optional[typing.Sequence[CreatePullReviewComment]]

        commit_id : typing.Optional[str]

        event : typing.Optional[ReviewStateType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullReview]
            PullReview
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews",
            method="POST",
            json={
                "body": body,
                "comments": convert_and_respect_annotation_metadata(
                    object_=comments,
                    annotation=typing.Sequence[CreatePullReviewComment],
                    direction="write",
                ),
                "commit_id": commit_id,
                "event": event,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullReview]
            PullReview
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_submit_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        event: typing.Optional[ReviewStateType] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        body : typing.Optional[str]

        event : typing.Optional[ReviewStateType]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullReview]
            PullReview
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="POST",
            json={
                "body": body,
                "event": event,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_pull_review_comments(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PullReviewComment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PullReviewComment]]
            PullCommentList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PullReviewComment],
                    parse_obj_as(
                        type_=typing.List[PullReviewComment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        new_position: typing.Optional[int] = OMIT,
        old_position: typing.Optional[int] = OMIT,
        path: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullReviewComment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        body : typing.Optional[str]

        new_position : typing.Optional[int]
            if comment to new file line or 0

        old_position : typing.Optional[int]
            if comment to old file line or 0

        path : typing.Optional[str]
            the tree path

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullReviewComment]
            PullComment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments",
            method="POST",
            json={
                "body": body,
                "new_position": new_position,
                "old_position": old_position,
                "path": path,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReviewComment,
                    parse_obj_as(
                        type_=PullReviewComment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        comment: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullReviewComment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        comment : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullReviewComment]
            PullComment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments/{jsonable_encoder(comment)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReviewComment,
                    parse_obj_as(
                        type_=PullReviewComment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_pull_review_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        comment: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        comment : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/comments/{jsonable_encoder(comment)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_dismiss_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        message: typing.Optional[str] = OMIT,
        priors: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        message : typing.Optional[str]

        priors : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullReview]
            PullReview
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/dismissals",
            method="POST",
            json={
                "message": message,
                "priors": priors,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_un_dismiss_pull_review(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PullReview]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request

        id : int
            id of the review

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PullReview]
            PullReview
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/reviews/{jsonable_encoder(id)}/undismissals",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PullReview,
                    parse_obj_as(
                        type_=PullReview,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_update_pull_request(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        style: typing.Optional[RepoUpdatePullRequestRequestStyle] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the pull request to get

        style : typing.Optional[RepoUpdatePullRequestRequestStyle]
            how to update pull request

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/pulls/{jsonable_encoder(index)}/update",
            method="POST",
            params={
                "style": style,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_push_mirrors(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[PushMirror]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[PushMirror]]
            PushMirrorList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[PushMirror],
                    parse_obj_as(
                        type_=typing.List[PushMirror],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_add_push_mirror(
        self,
        owner: str,
        repo: str,
        *,
        branch_filter: typing.Optional[str] = OMIT,
        interval: typing.Optional[str] = OMIT,
        remote_address: typing.Optional[str] = OMIT,
        remote_password: typing.Optional[str] = OMIT,
        remote_username: typing.Optional[str] = OMIT,
        sync_on_commit: typing.Optional[bool] = OMIT,
        use_ssh: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PushMirror]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch_filter : typing.Optional[str]

        interval : typing.Optional[str]

        remote_address : typing.Optional[str]

        remote_password : typing.Optional[str]

        remote_username : typing.Optional[str]

        sync_on_commit : typing.Optional[bool]

        use_ssh : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PushMirror]
            PushMirror
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors",
            method="POST",
            json={
                "branch_filter": branch_filter,
                "interval": interval,
                "remote_address": remote_address,
                "remote_password": remote_password,
                "remote_username": remote_username,
                "sync_on_commit": sync_on_commit,
                "use_ssh": use_ssh,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PushMirror,
                    parse_obj_as(
                        type_=PushMirror,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_push_mirror_sync(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to sync

        repo : str
            name of the repo to sync

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors-sync",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_push_mirror_by_remote_name(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PushMirror]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            remote name of push mirror

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PushMirror]
            PushMirror
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors/{jsonable_encoder(name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PushMirror,
                    parse_obj_as(
                        type_=PushMirror,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_push_mirror(
        self,
        owner: str,
        repo: str,
        name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name : str
            remote name of the pushMirror

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/push_mirrors/{jsonable_encoder(name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    @contextlib.asynccontextmanager
    async def repo_get_raw_file(
        self,
        owner: str,
        repo: str,
        filepath: str,
        *,
        ref: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        filepath : str
            filepath of the file to get

        ref : typing.Optional[str]
            The name of the commit/branch/tag. Default the repositorys default branch (usually master)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]
            Returns raw file content.
        """
        async with self._client_wrapper.httpx_client.stream(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/raw/{jsonable_encoder(filepath)}",
            method="GET",
            params={
                "ref": ref,
            },
            request_options=request_options,
        ) as _response:

            async def _stream() -> AsyncHttpResponse[typing.AsyncIterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = (
                            request_options.get("chunk_size", None)
                            if request_options is not None
                            else None
                        )
                        return AsyncHttpResponse(
                            response=_response,
                            data=(
                                _chunk
                                async for _chunk in _response.aiter_bytes(
                                    chunk_size=_chunk_size
                                )
                            ),
                        )
                    await _response.aread()
                    if _response.status_code == 404:
                        raise NotFoundError(
                            headers=dict(_response.headers),
                            body=typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            ),
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise core_api_error_ApiError(
                        status_code=_response.status_code,
                        headers=dict(_response.headers),
                        body=_response.text,
                    )
                raise core_api_error_ApiError(
                    status_code=_response.status_code,
                    headers=dict(_response.headers),
                    body=_response_json,
                )

            yield await _stream()

    async def repo_list_releases(
        self,
        owner: str,
        repo: str,
        *,
        draft: typing.Optional[bool] = None,
        pre_release: typing.Optional[bool] = None,
        q: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Release]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        draft : typing.Optional[bool]
            filter (exclude / include) drafts, if you dont have repo write access none will show

        pre_release : typing.Optional[bool]
            filter (exclude / include) pre-releases

        q : typing.Optional[str]
            Search string

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Release]]
            ReleaseList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases",
            method="GET",
            params={
                "draft": draft,
                "pre-release": pre_release,
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Release],
                    parse_obj_as(
                        type_=typing.List[Release],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_release(
        self,
        owner: str,
        repo: str,
        *,
        tag_name: str,
        body: typing.Optional[str] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        hide_archive_links: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        prerelease: typing.Optional[bool] = OMIT,
        target_commitish: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag_name : str

        body : typing.Optional[str]

        draft : typing.Optional[bool]

        hide_archive_links : typing.Optional[bool]

        name : typing.Optional[str]

        prerelease : typing.Optional[bool]

        target_commitish : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Release]
            Release
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases",
            method="POST",
            json={
                "body": body,
                "draft": draft,
                "hide_archive_links": hide_archive_links,
                "name": name,
                "prerelease": prerelease,
                "tag_name": tag_name,
                "target_commitish": target_commitish,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_latest_release(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Release]
            Release
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/latest",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_release_by_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            tag name of the release to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Release]
            Release
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/tags/{jsonable_encoder(tag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_release_by_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            tag name of the release to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/tags/{jsonable_encoder(tag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Release]
            Release
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit_release(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        body: typing.Optional[str] = OMIT,
        draft: typing.Optional[bool] = OMIT,
        hide_archive_links: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        prerelease: typing.Optional[bool] = OMIT,
        tag_name: typing.Optional[str] = OMIT,
        target_commitish: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Release]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release to edit

        body : typing.Optional[str]

        draft : typing.Optional[bool]

        hide_archive_links : typing.Optional[bool]

        name : typing.Optional[str]

        prerelease : typing.Optional[bool]

        tag_name : typing.Optional[str]

        target_commitish : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Release]
            Release
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "body": body,
                "draft": draft,
                "hide_archive_links": hide_archive_links,
                "name": name,
                "prerelease": prerelease,
                "tag_name": tag_name,
                "target_commitish": target_commitish,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Release,
                    parse_obj_as(
                        type_=Release,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_release_attachments(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Attachment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Attachment]]
            AttachmentList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Attachment],
                    parse_obj_as(
                        type_=typing.List[Attachment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request: typing.Union[
            bytes, typing.Iterator[bytes], typing.AsyncIterator[bytes]
        ],
        name: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        request : typing.Union[bytes, typing.Iterator[bytes], typing.AsyncIterator[bytes]]

        name : typing.Optional[str]
            name of the attachment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets",
            method="POST",
            params={
                "name": name,
            },
            content=request,
            headers={
                "content-type": "application/octet-stream",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit_release_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        browser_download_url: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the release

        attachment_id : int
            id of the attachment to edit

        browser_download_url : typing.Optional[str]
            (Can only be set if existing attachment is of external type)

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/releases/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="PATCH",
            json={
                "browser_download_url": browser_download_url,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_reviewers(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[User]]
            UserList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/reviewers",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_signing_key(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[str]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[str]
            GPG armored public key
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/signing-key.gpg",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=_response.text)  # type: ignore
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_stargazers(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[User]]
            UserList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/stargazers",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_statuses(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        sort: typing.Optional[RepoListStatusesRequestSort] = None,
        state: typing.Optional[RepoListStatusesRequestState] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[CommitStatus]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        sort : typing.Optional[RepoListStatusesRequestSort]
            type of sort

        state : typing.Optional[RepoListStatusesRequestState]
            type of state

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[CommitStatus]]
            CommitStatusList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/statuses/{jsonable_encoder(sha)}",
            method="GET",
            params={
                "sort": sort,
                "state": state,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[CommitStatus],
                    parse_obj_as(
                        type_=typing.List[CommitStatus],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_status(
        self,
        owner: str,
        repo: str,
        sha: str,
        *,
        context: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        state: typing.Optional[CommitStatusState] = OMIT,
        target_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CommitStatus]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sha : str
            sha of the commit

        context : typing.Optional[str]

        description : typing.Optional[str]

        state : typing.Optional[CommitStatusState]

        target_url : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CommitStatus]
            CommitStatus
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/statuses/{jsonable_encoder(sha)}",
            method="POST",
            json={
                "context": context,
                "description": description,
                "state": state,
                "target_url": target_url,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CommitStatus,
                    parse_obj_as(
                        type_=CommitStatus,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_subscribers(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[User]]
            UserList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscribers",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def user_current_check_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WatchInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WatchInfo]
            WatchInfo
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def user_current_put_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WatchInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WatchInfo]
            WatchInfo
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def user_current_delete_subscription(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/subscription",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_sync_fork_default_info(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SyncForkInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SyncForkInfo]
            SyncForkInfo
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/sync_fork",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SyncForkInfo,
                    parse_obj_as(
                        type_=SyncForkInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_sync_fork_default(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/sync_fork",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_sync_fork_branch_info(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SyncForkInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            The branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SyncForkInfo]
            SyncForkInfo
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/sync_fork/{jsonable_encoder(branch)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SyncForkInfo,
                    parse_obj_as(
                        type_=SyncForkInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_sync_fork_branch(
        self,
        owner: str,
        repo: str,
        branch: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        branch : str
            The branch

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/sync_fork/{jsonable_encoder(branch)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_tag_protection(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[TagProtection]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[TagProtection]]
            TagProtectionList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TagProtection],
                    parse_obj_as(
                        type_=typing.List[TagProtection],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_tag_protection(
        self,
        owner: str,
        repo: str,
        *,
        name_pattern: typing.Optional[str] = OMIT,
        whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TagProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        name_pattern : typing.Optional[str]

        whitelist_teams : typing.Optional[typing.Sequence[str]]

        whitelist_usernames : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TagProtection]
            TagProtection
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections",
            method="POST",
            json={
                "name_pattern": name_pattern,
                "whitelist_teams": whitelist_teams,
                "whitelist_usernames": whitelist_usernames,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TagProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the tag protect to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TagProtection]
            TagProtection
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of protected tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit_tag_protection(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        name_pattern: typing.Optional[str] = OMIT,
        whitelist_teams: typing.Optional[typing.Sequence[str]] = OMIT,
        whitelist_usernames: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TagProtection]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of protected tag

        name_pattern : typing.Optional[str]

        whitelist_teams : typing.Optional[typing.Sequence[str]]

        whitelist_usernames : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TagProtection]
            TagProtection
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tag_protections/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "name_pattern": name_pattern,
                "whitelist_teams": whitelist_teams,
                "whitelist_usernames": whitelist_usernames,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TagProtection,
                    parse_obj_as(
                        type_=TagProtection,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_tags(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Tag]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results, default maximum page size is 50

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Tag]]
            TagList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Tag],
                    parse_obj_as(
                        type_=typing.List[Tag],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_tag(
        self,
        owner: str,
        repo: str,
        *,
        tag_name: str,
        message: typing.Optional[str] = OMIT,
        target: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Tag]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag_name : str

        message : typing.Optional[str]

        target : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Tag]
            Tag
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags",
            method="POST",
            json={
                "message": message,
                "tag_name": tag_name,
                "target": target,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tag,
                    parse_obj_as(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Tag]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            name of tag

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Tag]
            Tag
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags/{jsonable_encoder(tag)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Tag,
                    parse_obj_as(
                        type_=Tag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_tag(
        self,
        owner: str,
        repo: str,
        tag: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        tag : str
            name of tag to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/tags/{jsonable_encoder(tag)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_teams(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Team]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Team]]
            TeamList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Team],
                    parse_obj_as(
                        type_=typing.List[Team],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_check_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Team]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Team]
            Team
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Team,
                    parse_obj_as(
                        type_=Team,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_add_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_team(
        self,
        owner: str,
        repo: str,
        team: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        team : str
            team name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/teams/{jsonable_encoder(team)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_tracked_times(
        self,
        owner: str,
        repo: str,
        *,
        user: typing.Optional[str] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[TrackedTime]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        user : typing.Optional[str]
            optional filter by user (available for issue managers)

        since : typing.Optional[dt.datetime]
            Only show times updated after the given time. This is a timestamp in RFC 3339 format

        before : typing.Optional[dt.datetime]
            Only show times updated before the given time. This is a timestamp in RFC 3339 format

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[TrackedTime]]
            TrackedTimeList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/times",
            method="GET",
            params={
                "user": user,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def user_tracked_times(
        self,
        owner: str,
        repo: str,
        user: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[TrackedTime]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        user : str
            username of user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[TrackedTime]]
            TrackedTimeList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/times/{jsonable_encoder(user)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_list_topics(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TopicName]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TopicName]
            TopicNames
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TopicName,
                    parse_obj_as(
                        type_=TopicName,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_update_topics(
        self,
        owner: str,
        repo: str,
        *,
        topics: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topics : typing.Optional[typing.Sequence[str]]
            list of topic names

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics",
            method="PUT",
            json={
                "topics": topics,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_add_topic(
        self,
        owner: str,
        repo: str,
        topic: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topic : str
            name of the topic to add

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics/{jsonable_encoder(topic)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_topic(
        self,
        owner: str,
        repo: str,
        topic: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        topic : str
            name of the topic to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/topics/{jsonable_encoder(topic)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        new_owner: str,
        team_ids: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        new_owner : str

        team_ids : typing.Optional[typing.Sequence[int]]
            ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer",
            method="POST",
            json={
                "new_owner": new_owner,
                "team_ids": team_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def accept_repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer/accept",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def reject_repo_transfer(
        self,
        owner: str,
        repo: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo to transfer

        repo : str
            name of the repo to transfer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/transfer/reject",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_create_wiki_page(
        self,
        owner: str,
        repo: str,
        *,
        content_base_64: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WikiPage]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        content_base_64 : typing.Optional[str]
            content must be base64 encoded

        message : typing.Optional[str]
            optional commit message summarizing the change

        title : typing.Optional[str]
            page title. leave empty to keep unchanged

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WikiPage]
            WikiPage
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/new",
            method="POST",
            json={
                "content_base64": content_base_64,
                "message": message,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WikiPage]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WikiPage]
            WikiPage
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_delete_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_edit_wiki_page(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        content_base_64: typing.Optional[str] = OMIT,
        message: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WikiPage]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        content_base_64 : typing.Optional[str]
            content must be base64 encoded

        message : typing.Optional[str]
            optional commit message summarizing the change

        title : typing.Optional[str]
            page title. leave empty to keep unchanged

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WikiPage]
            WikiPage
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/page/{jsonable_encoder(page_name)}",
            method="PATCH",
            json={
                "content_base64": content_base_64,
                "message": message,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WikiPage,
                    parse_obj_as(
                        type_=WikiPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_wiki_pages(
        self,
        owner: str,
        repo: str,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[WikiPageMetaData]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[WikiPageMetaData]]
            WikiPageList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/pages",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[WikiPageMetaData],
                    parse_obj_as(
                        type_=typing.List[WikiPageMetaData],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_wiki_page_revisions(
        self,
        owner: str,
        repo: str,
        page_name: str,
        *,
        page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WikiCommitList]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        page_name : str
            name of the page

        page : typing.Optional[int]
            page number of results to return (1-based)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WikiCommitList]
            WikiCommitList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/wiki/revisions/{jsonable_encoder(page_name)}",
            method="GET",
            params={
                "page": page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WikiCommitList,
                    parse_obj_as(
                        type_=WikiCommitList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def generate_repo(
        self,
        template_owner: str,
        template_repo: str,
        *,
        name: str,
        owner: str,
        avatar: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        git_content: typing.Optional[bool] = OMIT,
        git_hooks: typing.Optional[bool] = OMIT,
        labels: typing.Optional[bool] = OMIT,
        private: typing.Optional[bool] = OMIT,
        protected_branch: typing.Optional[bool] = OMIT,
        topics: typing.Optional[bool] = OMIT,
        webhooks: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        template_owner : str
            name of the template repository owner

        template_repo : str
            name of the template repository

        name : str
            Name of the repository to create

        owner : str
            The organization or person who will own the new repository

        avatar : typing.Optional[bool]
            include avatar of the template repo

        default_branch : typing.Optional[str]
            Default branch of the new repository

        description : typing.Optional[str]
            Description of the repository to create

        git_content : typing.Optional[bool]
            include git content of default branch in template repo

        git_hooks : typing.Optional[bool]
            include git hooks in template repo

        labels : typing.Optional[bool]
            include labels in template repo

        private : typing.Optional[bool]
            Whether the repository is private

        protected_branch : typing.Optional[bool]
            include protected branches in template repo

        topics : typing.Optional[bool]
            include topics in template repo

        webhooks : typing.Optional[bool]
            include webhooks in template repo

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(template_owner)}/{jsonable_encoder(template_repo)}/generate",
            method="POST",
            json={
                "avatar": avatar,
                "default_branch": default_branch,
                "description": description,
                "git_content": git_content,
                "git_hooks": git_hooks,
                "labels": labels,
                "name": name,
                "owner": owner,
                "private": private,
                "protected_branch": protected_branch,
                "topics": topics,
                "webhooks": webhooks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def repo_get_by_id(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        id : int
            id of the repo to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repositories/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def topic_search(
        self,
        *,
        q: str,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TopicSearchResults]:
        """
        Parameters
        ----------
        q : str
            keyword to search for

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TopicSearchResults]
            SearchResults of a successful search
        """
        _response = await self._client_wrapper.httpx_client.request(
            "topics/search",
            method="GET",
            params={
                "q": q,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TopicSearchResults,
                    parse_obj_as(
                        type_=TopicSearchResults,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_current_user_repo(
        self,
        *,
        name: str,
        auto_init: typing.Optional[bool] = OMIT,
        default_branch: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        gitignores: typing.Optional[str] = OMIT,
        issue_labels: typing.Optional[str] = OMIT,
        license: typing.Optional[str] = OMIT,
        object_format_name: typing.Optional[CreateRepoOptionObjectFormatName] = OMIT,
        private: typing.Optional[bool] = OMIT,
        readme: typing.Optional[str] = OMIT,
        template: typing.Optional[bool] = OMIT,
        trust_model: typing.Optional[CreateRepoOptionTrustModel] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Repository]:
        """
        Parameters
        ----------
        name : str
            Name of the repository to create

        auto_init : typing.Optional[bool]
            Whether the repository should be auto-initialized?

        default_branch : typing.Optional[str]
            DefaultBranch of the repository (used when initializes and in template)

        description : typing.Optional[str]
            Description of the repository to create

        gitignores : typing.Optional[str]
            Gitignores to use

        issue_labels : typing.Optional[str]
            Label-Set to use

        license : typing.Optional[str]
            License to use

        object_format_name : typing.Optional[CreateRepoOptionObjectFormatName]
            ObjectFormatName of the underlying git repository

        private : typing.Optional[bool]
            Whether the repository is private

        readme : typing.Optional[str]
            Readme of the repository to create

        template : typing.Optional[bool]
            Whether the repository is template

        trust_model : typing.Optional[CreateRepoOptionTrustModel]
            TrustModel of the repository

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Repository]
            Repository
        """
        _response = await self._client_wrapper.httpx_client.request(
            "user/repos",
            method="POST",
            json={
                "auto_init": auto_init,
                "default_branch": default_branch,
                "description": description,
                "gitignores": gitignores,
                "issue_labels": issue_labels,
                "license": license,
                "name": name,
                "object_format_name": object_format_name,
                "private": private,
                "readme": readme,
                "template": template,
                "trust_model": trust_model,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Repository,
                    parse_obj_as(
                        type_=Repository,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiUnauthorizedError,
                        parse_obj_as(
                            type_=ApiUnauthorizedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )
