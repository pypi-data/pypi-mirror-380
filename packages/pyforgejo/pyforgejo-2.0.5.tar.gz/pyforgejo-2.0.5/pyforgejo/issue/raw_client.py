# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from .. import core
from ..core.api_error import ApiError as core_api_error_ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..errors.conflict_error import ConflictError
from ..errors.content_too_large_error import ContentTooLargeError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.locked_error import LockedError
from ..errors.not_found_error import NotFoundError
from ..errors.precondition_failed_error import PreconditionFailedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.api_error import ApiError as types_api_error_ApiError
from ..types.api_repo_archived_error import ApiRepoArchivedError
from ..types.attachment import Attachment
from ..types.comment import Comment
from ..types.issue import Issue
from ..types.issue_deadline import IssueDeadline
from ..types.label import Label
from ..types.milestone import Milestone
from ..types.reaction import Reaction
from ..types.timeline_comment import TimelineComment
from ..types.tracked_time import TrackedTime
from ..types.user import User
from ..types.watch_info import WatchInfo
from .types.create_milestone_option_state import CreateMilestoneOptionState
from .types.issue_list_issues_request_sort import IssueListIssuesRequestSort
from .types.issue_list_issues_request_state import IssueListIssuesRequestState
from .types.issue_list_issues_request_type import IssueListIssuesRequestType
from .types.issue_list_labels_request_sort import IssueListLabelsRequestSort
from .types.issue_search_issues_request_sort import \
    IssueSearchIssuesRequestSort
from .types.issue_search_issues_request_state import \
    IssueSearchIssuesRequestState
from .types.issue_search_issues_request_type import \
    IssueSearchIssuesRequestType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawIssueClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def search_issues(
        self,
        *,
        state: typing.Optional[IssueSearchIssuesRequestState] = None,
        labels: typing.Optional[str] = None,
        milestones: typing.Optional[str] = None,
        q: typing.Optional[str] = None,
        priority_repo_id: typing.Optional[int] = None,
        type: typing.Optional[IssueSearchIssuesRequestType] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        assigned: typing.Optional[bool] = None,
        created: typing.Optional[bool] = None,
        mentioned: typing.Optional[bool] = None,
        review_requested: typing.Optional[bool] = None,
        reviewed: typing.Optional[bool] = None,
        owner: typing.Optional[str] = None,
        team: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        sort: typing.Optional[IssueSearchIssuesRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        state : typing.Optional[IssueSearchIssuesRequestState]
            State of the issue

        labels : typing.Optional[str]
            Comma-separated list of label names. Fetch only issues that have any of these labels. Non existent labels are discarded.

        milestones : typing.Optional[str]
            Comma-separated list of milestone names. Fetch only issues that have any of these milestones. Non existent milestones are discarded.

        q : typing.Optional[str]
            Search string

        priority_repo_id : typing.Optional[int]
            Repository ID to prioritize in the results

        type : typing.Optional[IssueSearchIssuesRequestType]
            Filter by issue type

        since : typing.Optional[dt.datetime]
            Only show issues updated after the given time (RFC 3339 format)

        before : typing.Optional[dt.datetime]
            Only show issues updated before the given time (RFC 3339 format)

        assigned : typing.Optional[bool]
            Filter issues or pulls assigned to the authenticated user

        created : typing.Optional[bool]
            Filter issues or pulls created by the authenticated user

        mentioned : typing.Optional[bool]
            Filter issues or pulls mentioning the authenticated user

        review_requested : typing.Optional[bool]
            Filter pull requests where the authenticated user's review was requested

        reviewed : typing.Optional[bool]
            Filter pull requests reviewed by the authenticated user

        owner : typing.Optional[str]
            Filter by repository owner

        team : typing.Optional[str]
            Filter by team (requires organization owner parameter)

        page : typing.Optional[int]
            Page number of results to return (1-based)

        limit : typing.Optional[int]
            Number of items per page

        sort : typing.Optional[IssueSearchIssuesRequestSort]
            Type of sort

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = self._client_wrapper.httpx_client.request(
            "repos/issues/search",
            method="GET",
            params={
                "state": state,
                "labels": labels,
                "milestones": milestones,
                "q": q,
                "priority_repo_id": priority_repo_id,
                "type": type,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "assigned": assigned,
                "created": created,
                "mentioned": mentioned,
                "review_requested": review_requested,
                "reviewed": reviewed,
                "owner": owner,
                "team": team,
                "page": page,
                "limit": limit,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_issues(
        self,
        owner: str,
        repo: str,
        *,
        state: typing.Optional[IssueListIssuesRequestState] = None,
        labels: typing.Optional[str] = None,
        q: typing.Optional[str] = None,
        type: typing.Optional[IssueListIssuesRequestType] = None,
        milestones: typing.Optional[str] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        created_by: typing.Optional[str] = None,
        assigned_by: typing.Optional[str] = None,
        mentioned_by: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        sort: typing.Optional[IssueListIssuesRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        state : typing.Optional[IssueListIssuesRequestState]
            whether issue is open or closed

        labels : typing.Optional[str]
            comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded

        q : typing.Optional[str]
            search string

        type : typing.Optional[IssueListIssuesRequestType]
            filter by type (issues / pulls) if set

        milestones : typing.Optional[str]
            comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded

        since : typing.Optional[dt.datetime]
            Only show items updated after the given time. This is a timestamp in RFC 3339 format

        before : typing.Optional[dt.datetime]
            Only show items updated before the given time. This is a timestamp in RFC 3339 format

        created_by : typing.Optional[str]
            Only show items which were created by the given user

        assigned_by : typing.Optional[str]
            Only show items for which the given user is assigned

        mentioned_by : typing.Optional[str]
            Only show items in which the given user was mentioned

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        sort : typing.Optional[IssueListIssuesRequestSort]
            Type of sort

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues",
            method="GET",
            params={
                "state": state,
                "labels": labels,
                "q": q,
                "type": type,
                "milestones": milestones,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "created_by": created_by,
                "assigned_by": assigned_by,
                "mentioned_by": mentioned_by,
                "page": page,
                "limit": limit,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_issue(
        self,
        owner: str,
        repo: str,
        *,
        title: str,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        body: typing.Optional[str] = OMIT,
        closed: typing.Optional[bool] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        ref: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Issue]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        title : str

        assignee : typing.Optional[str]
            deprecated

        assignees : typing.Optional[typing.Sequence[str]]

        body : typing.Optional[str]

        closed : typing.Optional[bool]

        due_date : typing.Optional[dt.datetime]

        labels : typing.Optional[typing.Sequence[int]]
            list of label ids

        milestone : typing.Optional[int]
            milestone id

        ref : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Issue]
            Issue
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues",
            method="POST",
            json={
                "assignee": assignee,
                "assignees": assignees,
                "body": body,
                "closed": closed,
                "due_date": due_date,
                "labels": labels,
                "milestone": milestone,
                "ref": ref,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_repo_comments(
        self,
        owner: str,
        repo: str,
        *,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Comment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        since : typing.Optional[dt.datetime]
            if provided, only comments updated since the provided time are returned.

        before : typing.Optional[dt.datetime]
            if provided, only comments updated before the provided time are returned.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Comment]]
            CommentList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments",
            method="GET",
            params={
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Comment],
                    parse_obj_as(
                        type_=typing.List[Comment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_comment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Comment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Comment]
            Comment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Comment,
                    parse_obj_as(
                        type_=Comment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_comment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of comment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_comment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        body: str,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Comment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment to edit

        body : str

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Comment]
            Comment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "body": body,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Comment,
                    parse_obj_as(
                        type_=Comment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_issue_comment_attachments(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Attachment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Attachment]]
            AttachmentList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Attachment],
                    parse_obj_as(
                        type_=typing.List[Attachment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_issue_comment_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        attachment: core.File,
        name: typing.Optional[str] = None,
        updated_at: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        attachment : core.File
            See core.File for more documentation

        name : typing.Optional[str]
            name of the attachment

        updated_at : typing.Optional[dt.datetime]
            time of the attachment's creation. This is a timestamp in RFC 3339 format

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets",
            method="POST",
            params={
                "name": name,
                "updated_at": serialize_datetime(updated_at)
                if updated_at is not None
                else None,
            },
            data={},
            files={
                "attachment": attachment,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_issue_comment_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        attachment_id : int
            id of the attachment to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_issue_comment_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        attachment_id : int
            id of the attachment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_issue_comment_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        browser_download_url: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        attachment_id : int
            id of the attachment to edit

        browser_download_url : typing.Optional[str]
            (Can only be set if existing attachment is of external type)

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="PATCH",
            json={
                "browser_download_url": browser_download_url,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_comment_reactions(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Reaction]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment to edit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Reaction]]
            ReactionList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/reactions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Reaction],
                    parse_obj_as(
                        type_=typing.List[Reaction],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def post_comment_reaction(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Reaction]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment to edit

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Reaction]
            Reaction
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/reactions",
            method="POST",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Reaction,
                    parse_obj_as(
                        type_=Reaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_comment_reaction(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment to edit

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/reactions",
            method="DELETE",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_issue(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Issue]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Issue]
            Issue
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of issue to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_issue(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        ref: typing.Optional[str] = OMIT,
        state: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        unset_due_date: typing.Optional[bool] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Issue]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to edit

        assignee : typing.Optional[str]
            deprecated

        assignees : typing.Optional[typing.Sequence[str]]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        milestone : typing.Optional[int]

        ref : typing.Optional[str]

        state : typing.Optional[str]

        title : typing.Optional[str]

        unset_due_date : typing.Optional[bool]

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Issue]
            Issue
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}",
            method="PATCH",
            json={
                "assignee": assignee,
                "assignees": assignees,
                "body": body,
                "due_date": due_date,
                "milestone": milestone,
                "ref": ref,
                "state": state,
                "title": title,
                "unset_due_date": unset_due_date,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_issue_attachments(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Attachment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Attachment]]
            AttachmentList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Attachment],
                    parse_obj_as(
                        type_=typing.List[Attachment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_issue_attachment(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        attachment: core.File,
        name: typing.Optional[str] = None,
        updated_at: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        attachment : core.File
            See core.File for more documentation

        name : typing.Optional[str]
            name of the attachment

        updated_at : typing.Optional[dt.datetime]
            time of the attachment's creation. This is a timestamp in RFC 3339 format

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets",
            method="POST",
            params={
                "name": name,
                "updated_at": serialize_datetime(updated_at)
                if updated_at is not None
                else None,
            },
            data={},
            files={
                "attachment": attachment,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_issue_attachment(
        self,
        owner: str,
        repo: str,
        index: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        attachment_id : int
            id of the attachment to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets/{jsonable_encoder(attachment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_issue_attachment(
        self,
        owner: str,
        repo: str,
        index: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        attachment_id : int
            id of the attachment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets/{jsonable_encoder(attachment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_issue_attachment(
        self,
        owner: str,
        repo: str,
        index: int,
        attachment_id: int,
        *,
        browser_download_url: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        attachment_id : int
            id of the attachment to edit

        browser_download_url : typing.Optional[str]
            (Can only be set if existing attachment is of external type)

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Attachment]
            Attachment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets/{jsonable_encoder(attachment_id)}",
            method="PATCH",
            json={
                "browser_download_url": browser_download_url,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_blocks(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/blocks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_issue_blocking(
        self,
        owner_: str,
        repo_: str,
        index_: int,
        *,
        index: typing.Optional[int] = OMIT,
        owner: typing.Optional[str] = OMIT,
        repo: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Issue]:
        """
        Parameters
        ----------
        owner_ : str
            owner of the repo

        repo_ : str
            name of the repo

        index_ : int
            index of the issue

        index : typing.Optional[int]

        owner : typing.Optional[str]

        repo : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Issue]
            Issue
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner_)}/{jsonable_encoder(repo_)}/issues/{jsonable_encoder(index_)}/blocks",
            method="POST",
            json={
                "index": index,
                "owner": owner,
                "repo": repo,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def remove_issue_blocking(
        self,
        owner_: str,
        repo_: str,
        index_: int,
        *,
        index: typing.Optional[int] = OMIT,
        owner: typing.Optional[str] = OMIT,
        repo: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Issue]:
        """
        Parameters
        ----------
        owner_ : str
            owner of the repo

        repo_ : str
            name of the repo

        index_ : int
            index of the issue

        index : typing.Optional[int]

        owner : typing.Optional[str]

        repo : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Issue]
            Issue
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner_)}/{jsonable_encoder(repo_)}/issues/{jsonable_encoder(index_)}/blocks",
            method="DELETE",
            json={
                "index": index,
                "owner": owner,
                "repo": repo,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_comments(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Comment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        since : typing.Optional[dt.datetime]
            if provided, only comments updated since the specified time are returned.

        before : typing.Optional[dt.datetime]
            if provided, only comments updated before the provided time are returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Comment]]
            CommentList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/comments",
            method="GET",
            params={
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Comment],
                    parse_obj_as(
                        type_=typing.List[Comment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        body: str,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Comment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        body : str

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Comment]
            Comment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/comments",
            method="POST",
            json={
                "body": body,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Comment,
                    parse_obj_as(
                        type_=Comment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_comment_deprecated(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            this parameter is ignored

        id : int
            id of comment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/comments/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_comment_deprecated(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: str,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Comment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            this parameter is ignored

        id : int
            id of the comment to edit

        body : str

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Comment]
            Comment
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/comments/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "body": body,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Comment,
                    parse_obj_as(
                        type_=Comment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_issue_deadline(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        due_date: dt.datetime,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[IssueDeadline]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to create or update a deadline on

        due_date : dt.datetime

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[IssueDeadline]
            IssueDeadline
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/deadline",
            method="POST",
            json={
                "due_date": due_date,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IssueDeadline,
                    parse_obj_as(
                        type_=IssueDeadline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_issue_dependencies(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/dependencies",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_issue_dependencies(
        self,
        owner_: str,
        repo_: str,
        index_: int,
        *,
        index: typing.Optional[int] = OMIT,
        owner: typing.Optional[str] = OMIT,
        repo: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Issue]:
        """
        Parameters
        ----------
        owner_ : str
            owner of the repo

        repo_ : str
            name of the repo

        index_ : int
            index of the issue

        index : typing.Optional[int]

        owner : typing.Optional[str]

        repo : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Issue]
            Issue
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner_)}/{jsonable_encoder(repo_)}/issues/{jsonable_encoder(index_)}/dependencies",
            method="POST",
            json={
                "index": index,
                "owner": owner,
                "repo": repo,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def remove_issue_dependencies(
        self,
        owner_: str,
        repo_: str,
        index_: int,
        *,
        index: typing.Optional[int] = OMIT,
        owner: typing.Optional[str] = OMIT,
        repo: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Issue]:
        """
        Parameters
        ----------
        owner_ : str
            owner of the repo

        repo_ : str
            name of the repo

        index_ : int
            index of the issue

        index : typing.Optional[int]

        owner : typing.Optional[str]

        repo : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Issue]
            Issue
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner_)}/{jsonable_encoder(repo_)}/issues/{jsonable_encoder(index_)}/dependencies",
            method="DELETE",
            json={
                "index": index,
                "owner": owner,
                "repo": repo,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_labels(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Label]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Label]]
            LabelList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Label],
                    parse_obj_as(
                        type_=typing.List[Label],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def add_label(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        labels: typing.Optional[
            typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]
        ] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Label]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        labels : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            Labels can be a list of integers representing label IDs
            or a list of strings representing label names

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Label]]
            LabelList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels",
            method="POST",
            json={
                "labels": labels,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Label],
                    parse_obj_as(
                        type_=typing.List[Label],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def replace_labels(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        labels: typing.Optional[
            typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]
        ] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Label]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        labels : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            Labels can be a list of integers representing label IDs
            or a list of strings representing label names

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Label]]
            LabelList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels",
            method="PUT",
            json={
                "labels": labels,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Label],
                    parse_obj_as(
                        type_=typing.List[Label],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def clear_labels(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels",
            method="DELETE",
            json={
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def remove_label(
        self,
        owner: str,
        repo: str,
        index: int,
        identifier: str,
        *,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        identifier : str
            name or id of the label to remove

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels/{jsonable_encoder(identifier)}",
            method="DELETE",
            json={
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def pin_issue(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of issue to pin

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/pin",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def unpin_issue(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of issue to unpin

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/pin",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def move_issue_pin(
        self,
        owner: str,
        repo: str,
        index: int,
        position: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of issue

        position : int
            the new position

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/pin/{jsonable_encoder(position)}",
            method="PATCH",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_issue_reactions(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Reaction]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Reaction]]
            ReactionList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/reactions",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Reaction],
                    parse_obj_as(
                        type_=typing.List[Reaction],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def post_issue_reaction(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Reaction]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Reaction]
            Reaction
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/reactions",
            method="POST",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Reaction,
                    parse_obj_as(
                        type_=Reaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_issue_reaction(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/reactions",
            method="DELETE",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_stop_watch(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to stop the stopwatch on

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/stopwatch/delete",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def start_stop_watch(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to create the stopwatch on

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/stopwatch/start",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def stop_stop_watch(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to stop the stopwatch on

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/stopwatch/stop",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def subscriptions(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[User]]
            UserList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/subscriptions",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def check_subscription(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[WatchInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WatchInfo]
            WatchInfo
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/subscriptions/check",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def add_subscription(
        self,
        owner: str,
        repo: str,
        index: int,
        user: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        user : str
            user to subscribe

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/subscriptions/{jsonable_encoder(user)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_subscription(
        self,
        owner: str,
        repo: str,
        index: int,
        user: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        user : str
            user witch unsubscribe

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/subscriptions/{jsonable_encoder(user)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_comments_and_timeline(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        since: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        before: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[TimelineComment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        since : typing.Optional[dt.datetime]
            if provided, only comments updated since the specified time are returned.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        before : typing.Optional[dt.datetime]
            if provided, only comments updated before the provided time are returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[TimelineComment]]
            TimelineList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/timeline",
            method="GET",
            params={
                "since": serialize_datetime(since) if since is not None else None,
                "page": page,
                "limit": limit,
                "before": serialize_datetime(before) if before is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TimelineComment],
                    parse_obj_as(
                        type_=typing.List[TimelineComment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def tracked_times(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        user: typing.Optional[str] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[TrackedTime]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        user : typing.Optional[str]
            optional filter by user (available for issue managers)

        since : typing.Optional[dt.datetime]
            Only show times updated after the given time. This is a timestamp in RFC 3339 format

        before : typing.Optional[dt.datetime]
            Only show times updated before the given time. This is a timestamp in RFC 3339 format

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[TrackedTime]]
            TrackedTimeList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/times",
            method="GET",
            params={
                "user": user,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def add_time(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        time: int,
        created: typing.Optional[dt.datetime] = OMIT,
        user_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TrackedTime]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        time : int
            time in seconds

        created : typing.Optional[dt.datetime]

        user_name : typing.Optional[str]
            User who spent the time (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TrackedTime]
            TrackedTime
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/times",
            method="POST",
            json={
                "created": created,
                "time": time,
                "user_name": user_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TrackedTime,
                    parse_obj_as(
                        type_=TrackedTime,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def reset_time(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to add tracked time to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/times",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_time(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        id : int
            id of time to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/times/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def list_labels(
        self,
        owner: str,
        repo: str,
        *,
        sort: typing.Optional[IssueListLabelsRequestSort] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Label]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sort : typing.Optional[IssueListLabelsRequestSort]
            Specifies the sorting method: mostissues, leastissues, or reversealphabetically.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Label]]
            LabelList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels",
            method="GET",
            params={
                "sort": sort,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Label],
                    parse_obj_as(
                        type_=typing.List[Label],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_label(
        self,
        owner: str,
        repo: str,
        *,
        color: str,
        name: str,
        description: typing.Optional[str] = OMIT,
        exclusive: typing.Optional[bool] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Label]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        color : str

        name : str

        description : typing.Optional[str]

        exclusive : typing.Optional[bool]

        is_archived : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Label]
            Label
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels",
            method="POST",
            json={
                "color": color,
                "description": description,
                "exclusive": exclusive,
                "is_archived": is_archived,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Label,
                    parse_obj_as(
                        type_=Label,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_label(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Label]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the label to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Label]
            Label
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Label,
                    parse_obj_as(
                        type_=Label,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_label(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the label to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_label(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        color: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        exclusive: typing.Optional[bool] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Label]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the label to edit

        color : typing.Optional[str]

        description : typing.Optional[str]

        exclusive : typing.Optional[bool]

        is_archived : typing.Optional[bool]

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Label]
            Label
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "color": color,
                "description": description,
                "exclusive": exclusive,
                "is_archived": is_archived,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Label,
                    parse_obj_as(
                        type_=Label,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_milestones_list(
        self,
        owner: str,
        repo: str,
        *,
        state: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[Milestone]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        state : typing.Optional[str]
            Milestone state, Recognized values are open, closed and all. Defaults to "open"

        name : typing.Optional[str]
            filter by milestone name

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Milestone]]
            MilestoneList
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones",
            method="GET",
            params={
                "state": state,
                "name": name,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Milestone],
                    parse_obj_as(
                        type_=typing.List[Milestone],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def create_milestone(
        self,
        owner: str,
        repo: str,
        *,
        description: typing.Optional[str] = OMIT,
        due_on: typing.Optional[dt.datetime] = OMIT,
        state: typing.Optional[CreateMilestoneOptionState] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Milestone]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        description : typing.Optional[str]

        due_on : typing.Optional[dt.datetime]

        state : typing.Optional[CreateMilestoneOptionState]

        title : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Milestone]
            Milestone
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones",
            method="POST",
            json={
                "description": description,
                "due_on": due_on,
                "state": state,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Milestone,
                    parse_obj_as(
                        type_=Milestone,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def get_milestone(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Milestone]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            the milestone to get, identified by ID and if not available by name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Milestone]
            Milestone
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Milestone,
                    parse_obj_as(
                        type_=Milestone,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def delete_milestone(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            the milestone to delete, identified by ID and if not available by name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    def edit_milestone(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        description: typing.Optional[str] = OMIT,
        due_on: typing.Optional[dt.datetime] = OMIT,
        state: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Milestone]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            the milestone to edit, identified by ID and if not available by name

        description : typing.Optional[str]

        due_on : typing.Optional[dt.datetime]

        state : typing.Optional[str]

        title : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Milestone]
            Milestone
        """
        _response = self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "description": description,
                "due_on": due_on,
                "state": state,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Milestone,
                    parse_obj_as(
                        type_=Milestone,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )


class AsyncRawIssueClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def search_issues(
        self,
        *,
        state: typing.Optional[IssueSearchIssuesRequestState] = None,
        labels: typing.Optional[str] = None,
        milestones: typing.Optional[str] = None,
        q: typing.Optional[str] = None,
        priority_repo_id: typing.Optional[int] = None,
        type: typing.Optional[IssueSearchIssuesRequestType] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        assigned: typing.Optional[bool] = None,
        created: typing.Optional[bool] = None,
        mentioned: typing.Optional[bool] = None,
        review_requested: typing.Optional[bool] = None,
        reviewed: typing.Optional[bool] = None,
        owner: typing.Optional[str] = None,
        team: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        sort: typing.Optional[IssueSearchIssuesRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        state : typing.Optional[IssueSearchIssuesRequestState]
            State of the issue

        labels : typing.Optional[str]
            Comma-separated list of label names. Fetch only issues that have any of these labels. Non existent labels are discarded.

        milestones : typing.Optional[str]
            Comma-separated list of milestone names. Fetch only issues that have any of these milestones. Non existent milestones are discarded.

        q : typing.Optional[str]
            Search string

        priority_repo_id : typing.Optional[int]
            Repository ID to prioritize in the results

        type : typing.Optional[IssueSearchIssuesRequestType]
            Filter by issue type

        since : typing.Optional[dt.datetime]
            Only show issues updated after the given time (RFC 3339 format)

        before : typing.Optional[dt.datetime]
            Only show issues updated before the given time (RFC 3339 format)

        assigned : typing.Optional[bool]
            Filter issues or pulls assigned to the authenticated user

        created : typing.Optional[bool]
            Filter issues or pulls created by the authenticated user

        mentioned : typing.Optional[bool]
            Filter issues or pulls mentioning the authenticated user

        review_requested : typing.Optional[bool]
            Filter pull requests where the authenticated user's review was requested

        reviewed : typing.Optional[bool]
            Filter pull requests reviewed by the authenticated user

        owner : typing.Optional[str]
            Filter by repository owner

        team : typing.Optional[str]
            Filter by team (requires organization owner parameter)

        page : typing.Optional[int]
            Page number of results to return (1-based)

        limit : typing.Optional[int]
            Number of items per page

        sort : typing.Optional[IssueSearchIssuesRequestSort]
            Type of sort

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = await self._client_wrapper.httpx_client.request(
            "repos/issues/search",
            method="GET",
            params={
                "state": state,
                "labels": labels,
                "milestones": milestones,
                "q": q,
                "priority_repo_id": priority_repo_id,
                "type": type,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "assigned": assigned,
                "created": created,
                "mentioned": mentioned,
                "review_requested": review_requested,
                "reviewed": reviewed,
                "owner": owner,
                "team": team,
                "page": page,
                "limit": limit,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_issues(
        self,
        owner: str,
        repo: str,
        *,
        state: typing.Optional[IssueListIssuesRequestState] = None,
        labels: typing.Optional[str] = None,
        q: typing.Optional[str] = None,
        type: typing.Optional[IssueListIssuesRequestType] = None,
        milestones: typing.Optional[str] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        created_by: typing.Optional[str] = None,
        assigned_by: typing.Optional[str] = None,
        mentioned_by: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        sort: typing.Optional[IssueListIssuesRequestSort] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        state : typing.Optional[IssueListIssuesRequestState]
            whether issue is open or closed

        labels : typing.Optional[str]
            comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded

        q : typing.Optional[str]
            search string

        type : typing.Optional[IssueListIssuesRequestType]
            filter by type (issues / pulls) if set

        milestones : typing.Optional[str]
            comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded

        since : typing.Optional[dt.datetime]
            Only show items updated after the given time. This is a timestamp in RFC 3339 format

        before : typing.Optional[dt.datetime]
            Only show items updated before the given time. This is a timestamp in RFC 3339 format

        created_by : typing.Optional[str]
            Only show items which were created by the given user

        assigned_by : typing.Optional[str]
            Only show items for which the given user is assigned

        mentioned_by : typing.Optional[str]
            Only show items in which the given user was mentioned

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        sort : typing.Optional[IssueListIssuesRequestSort]
            Type of sort

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues",
            method="GET",
            params={
                "state": state,
                "labels": labels,
                "q": q,
                "type": type,
                "milestones": milestones,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "created_by": created_by,
                "assigned_by": assigned_by,
                "mentioned_by": mentioned_by,
                "page": page,
                "limit": limit,
                "sort": sort,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_issue(
        self,
        owner: str,
        repo: str,
        *,
        title: str,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        body: typing.Optional[str] = OMIT,
        closed: typing.Optional[bool] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        labels: typing.Optional[typing.Sequence[int]] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        ref: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Issue]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        title : str

        assignee : typing.Optional[str]
            deprecated

        assignees : typing.Optional[typing.Sequence[str]]

        body : typing.Optional[str]

        closed : typing.Optional[bool]

        due_date : typing.Optional[dt.datetime]

        labels : typing.Optional[typing.Sequence[int]]
            list of label ids

        milestone : typing.Optional[int]
            milestone id

        ref : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Issue]
            Issue
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues",
            method="POST",
            json={
                "assignee": assignee,
                "assignees": assignees,
                "body": body,
                "closed": closed,
                "due_date": due_date,
                "labels": labels,
                "milestone": milestone,
                "ref": ref,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_repo_comments(
        self,
        owner: str,
        repo: str,
        *,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Comment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        since : typing.Optional[dt.datetime]
            if provided, only comments updated since the provided time are returned.

        before : typing.Optional[dt.datetime]
            if provided, only comments updated before the provided time are returned.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Comment]]
            CommentList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments",
            method="GET",
            params={
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Comment],
                    parse_obj_as(
                        type_=typing.List[Comment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_comment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Comment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Comment]
            Comment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Comment,
                    parse_obj_as(
                        type_=Comment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_comment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of comment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_comment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        body: str,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Comment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment to edit

        body : str

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Comment]
            Comment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "body": body,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Comment,
                    parse_obj_as(
                        type_=Comment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_issue_comment_attachments(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Attachment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Attachment]]
            AttachmentList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Attachment],
                    parse_obj_as(
                        type_=typing.List[Attachment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_issue_comment_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        attachment: core.File,
        name: typing.Optional[str] = None,
        updated_at: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        attachment : core.File
            See core.File for more documentation

        name : typing.Optional[str]
            name of the attachment

        updated_at : typing.Optional[dt.datetime]
            time of the attachment's creation. This is a timestamp in RFC 3339 format

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets",
            method="POST",
            params={
                "name": name,
                "updated_at": serialize_datetime(updated_at)
                if updated_at is not None
                else None,
            },
            data={},
            files={
                "attachment": attachment,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_issue_comment_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        attachment_id : int
            id of the attachment to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_issue_comment_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        attachment_id : int
            id of the attachment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_issue_comment_attachment(
        self,
        owner: str,
        repo: str,
        id: int,
        attachment_id: int,
        *,
        browser_download_url: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment

        attachment_id : int
            id of the attachment to edit

        browser_download_url : typing.Optional[str]
            (Can only be set if existing attachment is of external type)

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/assets/{jsonable_encoder(attachment_id)}",
            method="PATCH",
            json={
                "browser_download_url": browser_download_url,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_comment_reactions(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Reaction]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment to edit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Reaction]]
            ReactionList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/reactions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Reaction],
                    parse_obj_as(
                        type_=typing.List[Reaction],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def post_comment_reaction(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Reaction]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment to edit

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Reaction]
            Reaction
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/reactions",
            method="POST",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Reaction,
                    parse_obj_as(
                        type_=Reaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_comment_reaction(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the comment to edit

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/comments/{jsonable_encoder(id)}/reactions",
            method="DELETE",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_issue(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Issue]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Issue]
            Issue
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of issue to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_issue(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        assignee: typing.Optional[str] = OMIT,
        assignees: typing.Optional[typing.Sequence[str]] = OMIT,
        body: typing.Optional[str] = OMIT,
        due_date: typing.Optional[dt.datetime] = OMIT,
        milestone: typing.Optional[int] = OMIT,
        ref: typing.Optional[str] = OMIT,
        state: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        unset_due_date: typing.Optional[bool] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Issue]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to edit

        assignee : typing.Optional[str]
            deprecated

        assignees : typing.Optional[typing.Sequence[str]]

        body : typing.Optional[str]

        due_date : typing.Optional[dt.datetime]

        milestone : typing.Optional[int]

        ref : typing.Optional[str]

        state : typing.Optional[str]

        title : typing.Optional[str]

        unset_due_date : typing.Optional[bool]

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Issue]
            Issue
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}",
            method="PATCH",
            json={
                "assignee": assignee,
                "assignees": assignees,
                "body": body,
                "due_date": due_date,
                "milestone": milestone,
                "ref": ref,
                "state": state,
                "title": title,
                "unset_due_date": unset_due_date,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 412:
                raise PreconditionFailedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_issue_attachments(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Attachment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Attachment]]
            AttachmentList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Attachment],
                    parse_obj_as(
                        type_=typing.List[Attachment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_issue_attachment(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        attachment: core.File,
        name: typing.Optional[str] = None,
        updated_at: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        attachment : core.File
            See core.File for more documentation

        name : typing.Optional[str]
            name of the attachment

        updated_at : typing.Optional[dt.datetime]
            time of the attachment's creation. This is a timestamp in RFC 3339 format

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets",
            method="POST",
            params={
                "name": name,
                "updated_at": serialize_datetime(updated_at)
                if updated_at is not None
                else None,
            },
            data={},
            files={
                "attachment": attachment,
            },
            request_options=request_options,
            omit=OMIT,
            force_multipart=True,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_issue_attachment(
        self,
        owner: str,
        repo: str,
        index: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        attachment_id : int
            id of the attachment to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets/{jsonable_encoder(attachment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_issue_attachment(
        self,
        owner: str,
        repo: str,
        index: int,
        attachment_id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        attachment_id : int
            id of the attachment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets/{jsonable_encoder(attachment_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_issue_attachment(
        self,
        owner: str,
        repo: str,
        index: int,
        attachment_id: int,
        *,
        browser_download_url: typing.Optional[str] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Attachment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        attachment_id : int
            id of the attachment to edit

        browser_download_url : typing.Optional[str]
            (Can only be set if existing attachment is of external type)

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Attachment]
            Attachment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/assets/{jsonable_encoder(attachment_id)}",
            method="PATCH",
            json={
                "browser_download_url": browser_download_url,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Attachment,
                    parse_obj_as(
                        type_=Attachment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_blocks(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/blocks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_issue_blocking(
        self,
        owner_: str,
        repo_: str,
        index_: int,
        *,
        index: typing.Optional[int] = OMIT,
        owner: typing.Optional[str] = OMIT,
        repo: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Issue]:
        """
        Parameters
        ----------
        owner_ : str
            owner of the repo

        repo_ : str
            name of the repo

        index_ : int
            index of the issue

        index : typing.Optional[int]

        owner : typing.Optional[str]

        repo : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Issue]
            Issue
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner_)}/{jsonable_encoder(repo_)}/issues/{jsonable_encoder(index_)}/blocks",
            method="POST",
            json={
                "index": index,
                "owner": owner,
                "repo": repo,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def remove_issue_blocking(
        self,
        owner_: str,
        repo_: str,
        index_: int,
        *,
        index: typing.Optional[int] = OMIT,
        owner: typing.Optional[str] = OMIT,
        repo: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Issue]:
        """
        Parameters
        ----------
        owner_ : str
            owner of the repo

        repo_ : str
            name of the repo

        index_ : int
            index of the issue

        index : typing.Optional[int]

        owner : typing.Optional[str]

        repo : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Issue]
            Issue
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner_)}/{jsonable_encoder(repo_)}/issues/{jsonable_encoder(index_)}/blocks",
            method="DELETE",
            json={
                "index": index,
                "owner": owner,
                "repo": repo,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_comments(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Comment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        since : typing.Optional[dt.datetime]
            if provided, only comments updated since the specified time are returned.

        before : typing.Optional[dt.datetime]
            if provided, only comments updated before the provided time are returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Comment]]
            CommentList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/comments",
            method="GET",
            params={
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Comment],
                    parse_obj_as(
                        type_=typing.List[Comment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_comment(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        body: str,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Comment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        body : str

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Comment]
            Comment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/comments",
            method="POST",
            json={
                "body": body,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Comment,
                    parse_obj_as(
                        type_=Comment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_comment_deprecated(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            this parameter is ignored

        id : int
            id of comment to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/comments/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_comment_deprecated(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        body: str,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Comment]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            this parameter is ignored

        id : int
            id of the comment to edit

        body : str

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Comment]
            Comment
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/comments/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "body": body,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Comment,
                    parse_obj_as(
                        type_=Comment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_issue_deadline(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        due_date: dt.datetime,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[IssueDeadline]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to create or update a deadline on

        due_date : dt.datetime

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[IssueDeadline]
            IssueDeadline
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/deadline",
            method="POST",
            json={
                "due_date": due_date,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    IssueDeadline,
                    parse_obj_as(
                        type_=IssueDeadline,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_issue_dependencies(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Issue]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Issue]]
            IssueList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/dependencies",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Issue],
                    parse_obj_as(
                        type_=typing.List[Issue],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_issue_dependencies(
        self,
        owner_: str,
        repo_: str,
        index_: int,
        *,
        index: typing.Optional[int] = OMIT,
        owner: typing.Optional[str] = OMIT,
        repo: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Issue]:
        """
        Parameters
        ----------
        owner_ : str
            owner of the repo

        repo_ : str
            name of the repo

        index_ : int
            index of the issue

        index : typing.Optional[int]

        owner : typing.Optional[str]

        repo : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Issue]
            Issue
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner_)}/{jsonable_encoder(repo_)}/issues/{jsonable_encoder(index_)}/dependencies",
            method="POST",
            json={
                "index": index,
                "owner": owner,
                "repo": repo,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def remove_issue_dependencies(
        self,
        owner_: str,
        repo_: str,
        index_: int,
        *,
        index: typing.Optional[int] = OMIT,
        owner: typing.Optional[str] = OMIT,
        repo: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Issue]:
        """
        Parameters
        ----------
        owner_ : str
            owner of the repo

        repo_ : str
            name of the repo

        index_ : int
            index of the issue

        index : typing.Optional[int]

        owner : typing.Optional[str]

        repo : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Issue]
            Issue
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner_)}/{jsonable_encoder(repo_)}/issues/{jsonable_encoder(index_)}/dependencies",
            method="DELETE",
            json={
                "index": index,
                "owner": owner,
                "repo": repo,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Issue,
                    parse_obj_as(
                        type_=Issue,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 423:
                raise LockedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ApiRepoArchivedError,
                        parse_obj_as(
                            type_=ApiRepoArchivedError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_labels(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Label]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Label]]
            LabelList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Label],
                    parse_obj_as(
                        type_=typing.List[Label],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def add_label(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        labels: typing.Optional[
            typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]
        ] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Label]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        labels : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            Labels can be a list of integers representing label IDs
            or a list of strings representing label names

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Label]]
            LabelList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels",
            method="POST",
            json={
                "labels": labels,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Label],
                    parse_obj_as(
                        type_=typing.List[Label],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def replace_labels(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        labels: typing.Optional[
            typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]
        ] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Label]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        labels : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            Labels can be a list of integers representing label IDs
            or a list of strings representing label names

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Label]]
            LabelList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels",
            method="PUT",
            json={
                "labels": labels,
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Label],
                    parse_obj_as(
                        type_=typing.List[Label],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def clear_labels(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels",
            method="DELETE",
            json={
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def remove_label(
        self,
        owner: str,
        repo: str,
        index: int,
        identifier: str,
        *,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        identifier : str
            name or id of the label to remove

        updated_at : typing.Optional[dt.datetime]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/labels/{jsonable_encoder(identifier)}",
            method="DELETE",
            json={
                "updated_at": updated_at,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def pin_issue(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of issue to pin

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/pin",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def unpin_issue(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of issue to unpin

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/pin",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def move_issue_pin(
        self,
        owner: str,
        repo: str,
        index: int,
        position: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of issue

        position : int
            the new position

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/pin/{jsonable_encoder(position)}",
            method="PATCH",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_issue_reactions(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Reaction]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Reaction]]
            ReactionList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/reactions",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Reaction],
                    parse_obj_as(
                        type_=typing.List[Reaction],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def post_issue_reaction(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Reaction]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Reaction]
            Reaction
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/reactions",
            method="POST",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Reaction,
                    parse_obj_as(
                        type_=Reaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_issue_reaction(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        content : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/reactions",
            method="DELETE",
            json={
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_stop_watch(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to stop the stopwatch on

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/stopwatch/delete",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def start_stop_watch(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to create the stopwatch on

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/stopwatch/start",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def stop_stop_watch(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to stop the stopwatch on

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/stopwatch/stop",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def subscriptions(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[User]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[User]]
            UserList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/subscriptions",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[User],
                    parse_obj_as(
                        type_=typing.List[User],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def check_subscription(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[WatchInfo]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WatchInfo]
            WatchInfo
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/subscriptions/check",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WatchInfo,
                    parse_obj_as(
                        type_=WatchInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def add_subscription(
        self,
        owner: str,
        repo: str,
        index: int,
        user: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        user : str
            user to subscribe

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/subscriptions/{jsonable_encoder(user)}",
            method="PUT",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_subscription(
        self,
        owner: str,
        repo: str,
        index: int,
        user: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        user : str
            user witch unsubscribe

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/subscriptions/{jsonable_encoder(user)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_comments_and_timeline(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        since: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        before: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[TimelineComment]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        since : typing.Optional[dt.datetime]
            if provided, only comments updated since the specified time are returned.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        before : typing.Optional[dt.datetime]
            if provided, only comments updated before the provided time are returned.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[TimelineComment]]
            TimelineList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/timeline",
            method="GET",
            params={
                "since": serialize_datetime(since) if since is not None else None,
                "page": page,
                "limit": limit,
                "before": serialize_datetime(before) if before is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TimelineComment],
                    parse_obj_as(
                        type_=typing.List[TimelineComment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def tracked_times(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        user: typing.Optional[str] = None,
        since: typing.Optional[dt.datetime] = None,
        before: typing.Optional[dt.datetime] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[TrackedTime]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        user : typing.Optional[str]
            optional filter by user (available for issue managers)

        since : typing.Optional[dt.datetime]
            Only show times updated after the given time. This is a timestamp in RFC 3339 format

        before : typing.Optional[dt.datetime]
            Only show times updated before the given time. This is a timestamp in RFC 3339 format

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[TrackedTime]]
            TrackedTimeList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/times",
            method="GET",
            params={
                "user": user,
                "since": serialize_datetime(since) if since is not None else None,
                "before": serialize_datetime(before) if before is not None else None,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[TrackedTime],
                    parse_obj_as(
                        type_=typing.List[TrackedTime],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def add_time(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        time: int,
        created: typing.Optional[dt.datetime] = OMIT,
        user_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TrackedTime]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        time : int
            time in seconds

        created : typing.Optional[dt.datetime]

        user_name : typing.Optional[str]
            User who spent the time (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TrackedTime]
            TrackedTime
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/times",
            method="POST",
            json={
                "created": created,
                "time": time,
                "user_name": user_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TrackedTime,
                    parse_obj_as(
                        type_=TrackedTime,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def reset_time(
        self,
        owner: str,
        repo: str,
        index: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue to add tracked time to

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/times",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_time(
        self,
        owner: str,
        repo: str,
        index: int,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        index : int
            index of the issue

        id : int
            id of time to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/issues/{jsonable_encoder(index)}/times/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def list_labels(
        self,
        owner: str,
        repo: str,
        *,
        sort: typing.Optional[IssueListLabelsRequestSort] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Label]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        sort : typing.Optional[IssueListLabelsRequestSort]
            Specifies the sorting method: mostissues, leastissues, or reversealphabetically.

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Label]]
            LabelList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels",
            method="GET",
            params={
                "sort": sort,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Label],
                    parse_obj_as(
                        type_=typing.List[Label],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_label(
        self,
        owner: str,
        repo: str,
        *,
        color: str,
        name: str,
        description: typing.Optional[str] = OMIT,
        exclusive: typing.Optional[bool] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Label]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        color : str

        name : str

        description : typing.Optional[str]

        exclusive : typing.Optional[bool]

        is_archived : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Label]
            Label
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels",
            method="POST",
            json={
                "color": color,
                "description": description,
                "exclusive": exclusive,
                "is_archived": is_archived,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Label,
                    parse_obj_as(
                        type_=Label,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_label(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Label]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the label to get

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Label]
            Label
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Label,
                    parse_obj_as(
                        type_=Label,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_label(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the label to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_label(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        color: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        exclusive: typing.Optional[bool] = OMIT,
        is_archived: typing.Optional[bool] = OMIT,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Label]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            id of the label to edit

        color : typing.Optional[str]

        description : typing.Optional[str]

        exclusive : typing.Optional[bool]

        is_archived : typing.Optional[bool]

        name : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Label]
            Label
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/labels/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "color": color,
                "description": description,
                "exclusive": exclusive,
                "is_archived": is_archived,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Label,
                    parse_obj_as(
                        type_=Label,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_milestones_list(
        self,
        owner: str,
        repo: str,
        *,
        state: typing.Optional[str] = None,
        name: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[Milestone]]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        state : typing.Optional[str]
            Milestone state, Recognized values are open, closed and all. Defaults to "open"

        name : typing.Optional[str]
            filter by milestone name

        page : typing.Optional[int]
            page number of results to return (1-based)

        limit : typing.Optional[int]
            page size of results

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Milestone]]
            MilestoneList
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones",
            method="GET",
            params={
                "state": state,
                "name": name,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Milestone],
                    parse_obj_as(
                        type_=typing.List[Milestone],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def create_milestone(
        self,
        owner: str,
        repo: str,
        *,
        description: typing.Optional[str] = OMIT,
        due_on: typing.Optional[dt.datetime] = OMIT,
        state: typing.Optional[CreateMilestoneOptionState] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Milestone]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        description : typing.Optional[str]

        due_on : typing.Optional[dt.datetime]

        state : typing.Optional[CreateMilestoneOptionState]

        title : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Milestone]
            Milestone
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones",
            method="POST",
            json={
                "description": description,
                "due_on": due_on,
                "state": state,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Milestone,
                    parse_obj_as(
                        type_=Milestone,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def get_milestone(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Milestone]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            the milestone to get, identified by ID and if not available by name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Milestone]
            Milestone
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Milestone,
                    parse_obj_as(
                        type_=Milestone,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def delete_milestone(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            the milestone to delete, identified by ID and if not available by name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )

    async def edit_milestone(
        self,
        owner: str,
        repo: str,
        id: int,
        *,
        description: typing.Optional[str] = OMIT,
        due_on: typing.Optional[dt.datetime] = OMIT,
        state: typing.Optional[str] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Milestone]:
        """
        Parameters
        ----------
        owner : str
            owner of the repo

        repo : str
            name of the repo

        id : int
            the milestone to edit, identified by ID and if not available by name

        description : typing.Optional[str]

        due_on : typing.Optional[dt.datetime]

        state : typing.Optional[str]

        title : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Milestone]
            Milestone
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"repos/{jsonable_encoder(owner)}/{jsonable_encoder(repo)}/milestones/{jsonable_encoder(id)}",
            method="PATCH",
            json={
                "description": description,
                "due_on": due_on,
                "state": state,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Milestone,
                    parse_obj_as(
                        type_=Milestone,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code,
                headers=dict(_response.headers),
                body=_response.text,
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code,
            headers=dict(_response.headers),
            body=_response_json,
        )
