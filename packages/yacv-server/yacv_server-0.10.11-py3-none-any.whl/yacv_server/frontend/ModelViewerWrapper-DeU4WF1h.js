import{a9 as Xe,V as z,aa as We,L as G,h as At,ab as wt,S as Ze,d as ot,B as Q,ac as tn,ad as en,ae as nn,af as _e,M as Ae,ag as sn,ah as rn,j as on,ai as cn,aj as Se,r as J,l as an,ak as ln,al as un,am as fn,an as pn,ao as yn,ap as dn,aq as Me,a8 as et,R as nt,P as Rt,v as Ut,ar as mn,as as Ce,at as hn,au as xn,av as wn,$ as gn,q as An,aw as Dt,a7 as Tn}from"./index-E76cnppT.js";const Ye=0,bn=1,Bn=2,Le=2,te=1.25,ze=1,Lt=32,Ot=65535,vn=Math.pow(2,-24),ee=Symbol("SKIP_GENERATION");function Pn(n){return n.index?n.index.count:n.attributes.position.count}function Tt(n){return Pn(n)/3}function _n(n,e=ArrayBuffer){return n>65535?new Uint32Array(new e(4*n)):new Uint16Array(new e(2*n))}function Sn(n,e){if(!n.index){const t=n.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=_n(t,s);n.setIndex(new Xe(i,1));for(let a=0;a<t;a++)i[a]=a}}function Ke(n,e){const t=Tt(n),s=e||n.drawRange,i=s.start/3,a=(s.start+s.count)/3,r=Math.max(0,i),c=Math.min(t,a)-r;return[{offset:Math.floor(r),count:Math.floor(c)}]}function Je(n,e){if(!n.groups||!n.groups.length)return Ke(n,e);const t=[],s=new Set,i=e||n.drawRange,a=i.start/3,r=(i.start+i.count)/3;for(const o of n.groups){const p=o.start/3,u=(o.start+o.count)/3;s.add(Math.max(a,p)),s.add(Math.min(r,u))}const c=Array.from(s.values()).sort((o,p)=>o-p);for(let o=0;o<c.length-1;o++){const p=c[o],u=c[o+1];t.push({offset:Math.floor(p),count:Math.floor(u-p)})}return t}function Mn(n,e){const t=Tt(n),s=Je(n,e).sort((r,c)=>r.offset-c.offset),i=s[s.length-1];i.count=Math.min(t-i.offset,i.count);let a=0;return s.forEach(({count:r})=>a+=r),t!==a}function ne(n,e,t,s,i){let a=1/0,r=1/0,c=1/0,o=-1/0,p=-1/0,u=-1/0,f=1/0,l=1/0,y=1/0,A=-1/0,T=-1/0,h=-1/0;for(let m=e*6,d=(e+t)*6;m<d;m+=6){const w=n[m+0],x=n[m+1],g=w-x,B=w+x;g<a&&(a=g),B>o&&(o=B),w<f&&(f=w),w>A&&(A=w);const b=n[m+2],P=n[m+3],_=b-P,M=b+P;_<r&&(r=_),M>p&&(p=M),b<l&&(l=b),b>T&&(T=b);const C=n[m+4],S=n[m+5],v=C-S,L=C+S;v<c&&(c=v),L>u&&(u=L),C<y&&(y=C),C>h&&(h=C)}s[0]=a,s[1]=r,s[2]=c,s[3]=o,s[4]=p,s[5]=u,i[0]=f,i[1]=l,i[2]=y,i[3]=A,i[4]=T,i[5]=h}function Cn(n,e=null,t=null,s=null){const i=n.attributes.position,a=n.index?n.index.array:null,r=Tt(n),c=i.normalized;let o;e===null?(o=new Float32Array(r*6),t=0,s=r):(o=e,t=t||0,s=s||r);const p=i.array,u=i.offset||0;let f=3;i.isInterleavedBufferAttribute&&(f=i.data.stride);const l=["getX","getY","getZ"];for(let y=t;y<t+s;y++){const A=y*3,T=y*6;let h=A+0,m=A+1,d=A+2;a&&(h=a[h],m=a[m],d=a[d]),c||(h=h*f+u,m=m*f+u,d=d*f+u);for(let w=0;w<3;w++){let x,g,B;c?(x=i[l[w]](h),g=i[l[w]](m),B=i[l[w]](d)):(x=p[h+w],g=p[m+w],B=p[d+w]);let b=x;g<b&&(b=g),B<b&&(b=B);let P=x;g>P&&(P=g),B>P&&(P=B);const _=(P-b)/2,M=w*2;o[T+M+0]=b+_,o[T+M+1]=_+(Math.abs(b)+_)*vn}}return o}function F(n,e,t){return t.min.x=e[n],t.min.y=e[n+1],t.min.z=e[n+2],t.max.x=e[n+3],t.max.y=e[n+4],t.max.z=e[n+5],t}function Re(n){let e=-1,t=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>t&&(t=i,e=s)}return e}function Ue(n,e){e.set(n)}function De(n,e,t){let s,i;for(let a=0;a<3;a++){const r=a+3;s=n[a],i=e[a],t[a]=s<i?s:i,s=n[r],i=e[r],t[r]=s>i?s:i}}function Ft(n,e,t){for(let s=0;s<3;s++){const i=e[n+2*s],a=e[n+2*s+1],r=i-a,c=i+a;r<t[s]&&(t[s]=r),c>t[s+3]&&(t[s+3]=c)}}function bt(n){const e=n[3]-n[0],t=n[4]-n[1],s=n[5]-n[2];return 2*(e*t+t*s+s*e)}const O=32,Ln=(n,e)=>n.candidate-e.candidate,st=new Array(O).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Et=new Float32Array(6);function zn(n,e,t,s,i,a){let r=-1,c=0;if(a===Ye)r=Re(e),r!==-1&&(c=(e[r]+e[r+3])/2);else if(a===bn)r=Re(n),r!==-1&&(c=Rn(t,s,i,r));else if(a===Bn){const o=bt(n);let p=te*i;const u=s*6,f=(s+i)*6;for(let l=0;l<3;l++){const y=e[l],h=(e[l+3]-y)/O;if(i<O/4){const m=[...st];m.length=i;let d=0;for(let x=u;x<f;x+=6,d++){const g=m[d];g.candidate=t[x+2*l],g.count=0;const{bounds:B,leftCacheBounds:b,rightCacheBounds:P}=g;for(let _=0;_<3;_++)P[_]=1/0,P[_+3]=-1/0,b[_]=1/0,b[_+3]=-1/0,B[_]=1/0,B[_+3]=-1/0;Ft(x,t,B)}m.sort(Ln);let w=i;for(let x=0;x<w;x++){const g=m[x];for(;x+1<w&&m[x+1].candidate===g.candidate;)m.splice(x+1,1),w--}for(let x=u;x<f;x+=6){const g=t[x+2*l];for(let B=0;B<w;B++){const b=m[B];g>=b.candidate?Ft(x,t,b.rightCacheBounds):(Ft(x,t,b.leftCacheBounds),b.count++)}}for(let x=0;x<w;x++){const g=m[x],B=g.count,b=i-g.count,P=g.leftCacheBounds,_=g.rightCacheBounds;let M=0;B!==0&&(M=bt(P)/o);let C=0;b!==0&&(C=bt(_)/o);const S=ze+te*(M*B+C*b);S<p&&(r=l,p=S,c=g.candidate)}}else{for(let w=0;w<O;w++){const x=st[w];x.count=0,x.candidate=y+h+w*h;const g=x.bounds;for(let B=0;B<3;B++)g[B]=1/0,g[B+3]=-1/0}for(let w=u;w<f;w+=6){let B=~~((t[w+2*l]-y)/h);B>=O&&(B=O-1);const b=st[B];b.count++,Ft(w,t,b.bounds)}const m=st[O-1];Ue(m.bounds,m.rightCacheBounds);for(let w=O-2;w>=0;w--){const x=st[w],g=st[w+1];De(x.bounds,g.rightCacheBounds,x.rightCacheBounds)}let d=0;for(let w=0;w<O-1;w++){const x=st[w],g=x.count,B=x.bounds,P=st[w+1].rightCacheBounds;g!==0&&(d===0?Ue(B,Et):De(B,Et,Et)),d+=g;let _=0,M=0;d!==0&&(_=bt(Et)/o);const C=i-d;C!==0&&(M=bt(P)/o);const S=ze+te*(_*d+M*C);S<p&&(r=l,p=S,c=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:r,pos:c}}function Rn(n,e,t,s){let i=0;for(let a=e,r=e+t;a<r;a++)i+=n[a*6+s*2];return i/t}class se{constructor(){this.boundingData=new Float32Array(6)}}function Un(n,e,t,s,i,a){let r=s,c=s+i-1;const o=a.pos,p=a.axis*2;for(;;){for(;r<=c&&t[r*6+p]<o;)r++;for(;r<=c&&t[c*6+p]>=o;)c--;if(r<c){for(let u=0;u<3;u++){let f=e[r*3+u];e[r*3+u]=e[c*3+u],e[c*3+u]=f}for(let u=0;u<6;u++){let f=t[r*6+u];t[r*6+u]=t[c*6+u],t[c*6+u]=f}r++,c--}else return r}}function Dn(n,e,t,s,i,a){let r=s,c=s+i-1;const o=a.pos,p=a.axis*2;for(;;){for(;r<=c&&t[r*6+p]<o;)r++;for(;r<=c&&t[c*6+p]>=o;)c--;if(r<c){let u=n[r];n[r]=n[c],n[c]=u;for(let f=0;f<6;f++){let l=t[r*6+f];t[r*6+f]=t[c*6+f],t[c*6+f]=l}r++,c--}else return r}}function I(n,e){return e[n+15]===65535}function q(n,e){return e[n+6]}function $(n,e){return e[n+14]}function H(n){return n+8}function j(n,e){return e[n+6]}function Qe(n,e){return e[n+7]}let Oe,Ct,Jt,Ge;const Fn=Math.pow(2,32);function fe(n){return"count"in n?1:1+fe(n.left)+fe(n.right)}function En(n,e,t){return Oe=new Float32Array(t),Ct=new Uint32Array(t),Jt=new Uint16Array(t),Ge=new Uint8Array(t),pe(n,e)}function pe(n,e){const t=n/4,s=n/2,i="count"in e,a=e.boundingData;for(let r=0;r<6;r++)Oe[t+r]=a[r];if(i)if(e.buffer){const r=e.buffer;Ge.set(new Uint8Array(r),n);for(let c=n,o=n+r.byteLength;c<o;c+=Lt){const p=c/2;I(p,Jt)||(Ct[c/4+6]+=t)}return n+r.byteLength}else{const r=e.offset,c=e.count;return Ct[t+6]=r,Jt[s+14]=c,Jt[s+15]=Ot,n+Lt}else{const r=e.left,c=e.right,o=e.splitAxis;let p;if(p=pe(n+Lt,r),p/4>Fn)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ct[t+6]=p/4,p=pe(p,c),Ct[t+7]=o,p}}function Vn(n,e){const t=(n.index?n.index.count:n.attributes.position.count)/3,s=t>2**16,i=s?4:2,a=e?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),r=s?new Uint32Array(a):new Uint16Array(a);for(let c=0,o=r.length;c<o;c++)r[c]=c;return r}function Nn(n,e,t,s,i){const{maxDepth:a,verbose:r,maxLeafTris:c,strategy:o,onProgress:p,indirect:u}=i,f=n._indirectBuffer,l=n.geometry,y=l.index?l.index.array:null,A=u?Dn:Un,T=Tt(l),h=new Float32Array(6);let m=!1;const d=new se;return ne(e,t,s,d.boundingData,h),x(d,t,s,h),d;function w(g){p&&p(g/T)}function x(g,B,b,P=null,_=0){if(!m&&_>=a&&(m=!0,r&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),b<=c||_>=a)return w(B+b),g.offset=B,g.count=b,g;const M=zn(g.boundingData,P,e,B,b,o);if(M.axis===-1)return w(B+b),g.offset=B,g.count=b,g;const C=A(f,y,e,B,b,M);if(C===B||C===B+b)w(B+b),g.offset=B,g.count=b;else{g.splitAxis=M.axis;const S=new se,v=B,L=C-B;g.left=S,ne(e,v,L,S.boundingData,h),x(S,v,L,h,_+1);const U=new se,R=C,N=b-L;g.right=U,ne(e,R,N,U.boundingData,h),x(U,R,N,h,_+1)}return g}}function kn(n,e){const t=n.geometry;e.indirect&&(n._indirectBuffer=Vn(t,e.useSharedArrayBuffer),Mn(t,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||Sn(t,e);const s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Cn(t),a=e.indirect?Ke(t,e.range):Je(t,e.range);n._roots=a.map(r=>{const c=Nn(n,i,r.offset,r.count,e),o=fe(c),p=new s(Lt*o);return En(0,c,p),p})}class tt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let s=1/0,i=-1/0;for(let a=0,r=e.length;a<r;a++){const o=e[a][t];s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}setFromPoints(e,t){let s=1/0,i=-1/0;for(let a=0,r=t.length;a<r;a++){const c=t[a],o=e.dot(c);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}tt.prototype.setFromBox=(function(){const n=new z;return function(t,s){const i=s.min,a=s.max;let r=1/0,c=-1/0;for(let o=0;o<=1;o++)for(let p=0;p<=1;p++)for(let u=0;u<=1;u++){n.x=i.x*o+a.x*(1-o),n.y=i.y*p+a.y*(1-p),n.z=i.z*u+a.z*(1-u);const f=t.dot(n);r=Math.min(f,r),c=Math.max(f,c)}this.min=r,this.max=c}})();const In=(function(){const n=new z,e=new z,t=new z;return function(i,a,r){const c=i.start,o=n,p=a.start,u=e;t.subVectors(c,p),n.subVectors(i.end,i.start),e.subVectors(a.end,a.start);const f=t.dot(u),l=u.dot(o),y=u.dot(u),A=t.dot(o),h=o.dot(o)*y-l*l;let m,d;h!==0?m=(f*l-A*y)/h:m=0,d=(f+m*l)/y,r.x=m,r.y=d}})(),Te=(function(){const n=new At,e=new z,t=new z;return function(i,a,r,c){In(i,a,n);let o=n.x,p=n.y;if(o>=0&&o<=1&&p>=0&&p<=1){i.at(o,r),a.at(p,c);return}else if(o>=0&&o<=1){p<0?a.at(0,c):a.at(1,c),i.closestPointToPoint(c,!0,r);return}else if(p>=0&&p<=1){o<0?i.at(0,r):i.at(1,r),a.closestPointToPoint(r,!0,c);return}else{let u;o<0?u=i.start:u=i.end;let f;p<0?f=a.start:f=a.end;const l=e,y=t;if(i.closestPointToPoint(f,!0,e),a.closestPointToPoint(u,!0,t),l.distanceToSquared(f)<=y.distanceToSquared(u)){r.copy(l),c.copy(f);return}else{r.copy(u),c.copy(y);return}}}})(),qn=(function(){const n=new z,e=new z,t=new We,s=new G;return function(a,r){const{radius:c,center:o}=a,{a:p,b:u,c:f}=r;if(s.start=p,s.end=u,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c||(s.start=p,s.end=f,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c)||(s.start=u,s.end=f,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c))return!0;const T=r.getPlane(t);if(Math.abs(T.distanceToPoint(o))<=c){const m=T.projectPoint(o,e);if(r.containsPoint(m))return!0}return!1}})(),$n=1e-15;function ie(n){return Math.abs(n)<$n}class Z extends wt{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new z),this.satBounds=new Array(4).fill().map(()=>new tt),this.points=[this.a,this.b,this.c],this.sphere=new Ze,this.plane=new We,this.needsUpdate=!0}intersectsSphere(e){return qn(e,this)}update(){const e=this.a,t=this.b,s=this.c,i=this.points,a=this.satAxes,r=this.satBounds,c=a[0],o=r[0];this.getNormal(c),o.setFromPoints(c,i);const p=a[1],u=r[1];p.subVectors(e,t),u.setFromPoints(p,i);const f=a[2],l=r[2];f.subVectors(t,s),l.setFromPoints(f,i);const y=a[3],A=r[3];y.subVectors(s,e),A.setFromPoints(y,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,e),this.needsUpdate=!1}}Z.prototype.closestPointToSegment=(function(){const n=new z,e=new z,t=new G;return function(i,a=null,r=null){const{start:c,end:o}=i,p=this.points;let u,f=1/0;for(let l=0;l<3;l++){const y=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[y]),Te(t,i,n,e),u=n.distanceToSquared(e),u<f&&(f=u,a&&a.copy(n),r&&r.copy(e))}return this.closestPointToPoint(c,n),u=c.distanceToSquared(n),u<f&&(f=u,a&&a.copy(n),r&&r.copy(c)),this.closestPointToPoint(o,n),u=o.distanceToSquared(n),u<f&&(f=u,a&&a.copy(n),r&&r.copy(o)),Math.sqrt(f)}})();Z.prototype.intersectsTriangle=(function(){const n=new Z,e=new Array(3),t=new Array(3),s=new tt,i=new tt,a=new z,r=new z,c=new z,o=new z,p=new z,u=new G,f=new G,l=new G,y=new z;function A(T,h,m){const d=T.points;let w=0,x=-1;for(let g=0;g<3;g++){const{start:B,end:b}=u;B.copy(d[g]),b.copy(d[(g+1)%3]),u.delta(r);const P=ie(h.distanceToPoint(B));if(ie(h.normal.dot(r))&&P){m.copy(u),w=2;break}const _=h.intersectLine(u,y);if(!_&&P&&y.copy(B),(_||P)&&!ie(y.distanceTo(b))){if(w<=1)(w===1?m.start:m.end).copy(y),P&&(x=w);else if(w>=2){(x===1?m.start:m.end).copy(y),w=2;break}if(w++,w===2&&x===-1)break}}return w}return function(h,m=null,d=!1){this.needsUpdate&&this.update(),h.isExtendedTriangle?h.needsUpdate&&h.update():(n.copy(h),n.update(),h=n);const w=this.plane,x=h.plane;if(Math.abs(w.normal.dot(x.normal))>1-1e-10){const g=this.satBounds,B=this.satAxes;t[0]=h.a,t[1]=h.b,t[2]=h.c;for(let _=0;_<4;_++){const M=g[_],C=B[_];if(s.setFromPoints(C,t),M.isSeparated(s))return!1}const b=h.satBounds,P=h.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let _=0;_<4;_++){const M=b[_],C=P[_];if(s.setFromPoints(C,e),M.isSeparated(s))return!1}for(let _=0;_<4;_++){const M=B[_];for(let C=0;C<4;C++){const S=P[C];if(a.crossVectors(M,S),s.setFromPoints(a,e),i.setFromPoints(a,t),s.isSeparated(i))return!1}}return m&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}else{const g=A(this,x,f);if(g===1&&h.containsPoint(f.end))return m&&(m.start.copy(f.end),m.end.copy(f.end)),!0;if(g!==2)return!1;const B=A(h,w,l);if(B===1&&this.containsPoint(l.end))return m&&(m.start.copy(l.end),m.end.copy(l.end)),!0;if(B!==2)return!1;if(f.delta(c),l.delta(o),c.dot(o)<0){let v=l.start;l.start=l.end,l.end=v}const b=f.start.dot(c),P=f.end.dot(c),_=l.start.dot(c),M=l.end.dot(c),C=P<_,S=b<M;return b!==M&&_!==P&&C===S?!1:(m&&(p.subVectors(f.start,l.start),p.dot(c)>0?m.start.copy(f.start):m.start.copy(l.start),p.subVectors(f.end,l.end),p.dot(c)<0?m.end.copy(f.end):m.end.copy(l.end)),!0)}}})();Z.prototype.distanceToPoint=(function(){const n=new z;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}})();Z.prototype.distanceToTriangle=(function(){const n=new z,e=new z,t=["a","b","c"],s=new G,i=new G;return function(r,c=null,o=null){const p=c||o?s:null;if(this.intersectsTriangle(r,p))return(c||o)&&(c&&p.getCenter(c),o&&p.getCenter(o)),0;let u=1/0;for(let f=0;f<3;f++){let l;const y=t[f],A=r[y];this.closestPointToPoint(A,n),l=A.distanceToSquared(n),l<u&&(u=l,c&&c.copy(n),o&&o.copy(A));const T=this[y];r.closestPointToPoint(T,n),l=T.distanceToSquared(n),l<u&&(u=l,c&&c.copy(T),o&&o.copy(n))}for(let f=0;f<3;f++){const l=t[f],y=t[(f+1)%3];s.set(this[l],this[y]);for(let A=0;A<3;A++){const T=t[A],h=t[(A+1)%3];i.set(r[T],r[h]),Te(s,i,n,e);const m=n.distanceToSquared(e);m<u&&(u=m,c&&c.copy(n),o&&o.copy(e))}}return Math.sqrt(u)}})();class k{constructor(e,t,s){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new ot,this.invMatrix=new ot,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new tt),this.alignedSatBounds=new Array(3).fill().map(()=>new tt),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(e,t,s){this.min.copy(e),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}k.prototype.update=(function(){return function(){const e=this.matrix,t=this.min,s=this.max,i=this.points;for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*p|2*u|4*f,y=i[l];y.x=p?s.x:t.x,y.y=u?s.y:t.y,y.z=f?s.z:t.z,y.applyMatrix4(e)}const a=this.satBounds,r=this.satAxes,c=i[0];for(let p=0;p<3;p++){const u=r[p],f=a[p],l=1<<p,y=i[l];u.subVectors(c,y),f.setFromPoints(u,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();k.prototype.intersectsBox=(function(){const n=new tt;return function(t){this.needsUpdate&&this.update();const s=t.min,i=t.max,a=this.satBounds,r=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let o=0;o<3;o++){const p=r[o],u=a[o];if(n.setFromBox(p,t),u.isSeparated(n))return!1}return!0}})();k.prototype.intersectsTriangle=(function(){const n=new Z,e=new Array(3),t=new tt,s=new tt,i=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(n.copy(r),n.update(),r=n);const c=this.satBounds,o=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let l=0;l<3;l++){const y=c[l],A=o[l];if(t.setFromPoints(A,e),y.isSeparated(t))return!1}const p=r.satBounds,u=r.satAxes,f=this.points;for(let l=0;l<3;l++){const y=p[l],A=u[l];if(t.setFromPoints(A,f),y.isSeparated(t))return!1}for(let l=0;l<3;l++){const y=o[l];for(let A=0;A<4;A++){const T=u[A];if(i.crossVectors(y,T),t.setFromPoints(i,e),s.setFromPoints(i,f),t.isSeparated(s))return!1}}return!0}})();k.prototype.closestPointToPoint=(function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}})();k.prototype.distanceToPoint=(function(){const n=new z;return function(t){return this.closestPointToPoint(t,n),t.distanceTo(n)}})();k.prototype.distanceToBox=(function(){const n=["x","y","z"],e=new Array(12).fill().map(()=>new G),t=new Array(12).fill().map(()=>new G),s=new z,i=new z;return function(r,c=0,o=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||p)&&(r.getCenter(i),this.closestPointToPoint(i,s),r.closestPointToPoint(s,i),o&&o.copy(s),p&&p.copy(i)),0;const u=c*c,f=r.min,l=r.max,y=this.points;let A=1/0;for(let h=0;h<8;h++){const m=y[h];i.copy(m).clamp(f,l);const d=m.distanceToSquared(i);if(d<A&&(A=d,o&&o.copy(m),p&&p.copy(i),d<u))return Math.sqrt(d)}let T=0;for(let h=0;h<3;h++)for(let m=0;m<=1;m++)for(let d=0;d<=1;d++){const w=(h+1)%3,x=(h+2)%3,g=m<<w|d<<x,B=1<<h|m<<w|d<<x,b=y[g],P=y[B];e[T].set(b,P);const M=n[h],C=n[w],S=n[x],v=t[T],L=v.start,U=v.end;L[M]=f[M],L[C]=m?f[C]:l[C],L[S]=d?f[S]:l[C],U[M]=l[M],U[C]=m?f[C]:l[C],U[S]=d?f[S]:l[C],T++}for(let h=0;h<=1;h++)for(let m=0;m<=1;m++)for(let d=0;d<=1;d++){i.x=h?l.x:f.x,i.y=m?l.y:f.y,i.z=d?l.z:f.z,this.closestPointToPoint(i,s);const w=i.distanceToSquared(s);if(w<A&&(A=w,o&&o.copy(s),p&&p.copy(i),w<u))return Math.sqrt(w)}for(let h=0;h<12;h++){const m=e[h];for(let d=0;d<12;d++){const w=t[d];Te(m,w,s,i);const x=s.distanceToSquared(i);if(x<A&&(A=x,o&&o.copy(s),p&&p.copy(i),x<u))return Math.sqrt(x)}}return Math.sqrt(A)}})();class be{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class Hn extends be{constructor(){super(()=>new Z)}}const X=new Hn;class jn{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=s=>{t&&e.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const D=new jn;let rt,gt;const ft=[],Vt=new be(()=>new Q);function Xn(n,e,t,s,i,a){rt=Vt.getPrimitive(),gt=Vt.getPrimitive(),ft.push(rt,gt),D.setBuffer(n._roots[e]);const r=ye(0,n.geometry,t,s,i,a);D.clearBuffer(),Vt.releasePrimitive(rt),Vt.releasePrimitive(gt),ft.pop(),ft.pop();const c=ft.length;return c>0&&(gt=ft[c-1],rt=ft[c-2]),r}function ye(n,e,t,s,i=null,a=0,r=0){const{float32Array:c,uint16Array:o,uint32Array:p}=D;let u=n*2;if(I(u,o)){const l=q(n,p),y=$(u,o);return F(n,c,rt),s(l,y,!1,r,a+n,rt)}else{let M=function(S){const{uint16Array:v,uint32Array:L}=D;let U=S*2;for(;!I(U,v);)S=H(S),U=S*2;return q(S,L)},C=function(S){const{uint16Array:v,uint32Array:L}=D;let U=S*2;for(;!I(U,v);)S=j(S,L),U=S*2;return q(S,L)+$(U,v)};const l=H(n),y=j(n,p);let A=l,T=y,h,m,d,w;if(i&&(d=rt,w=gt,F(A,c,d),F(T,c,w),h=i(d),m=i(w),m<h)){A=y,T=l;const S=h;h=m,m=S,d=w}d||(d=rt,F(A,c,d));const x=I(A*2,o),g=t(d,x,h,r+1,a+A);let B;if(g===Le){const S=M(A),L=C(A)-S;B=s(S,L,!0,r+1,a+A,d)}else B=g&&ye(A,e,t,s,i,a,r+1);if(B)return!0;w=gt,F(T,c,w);const b=I(T*2,o),P=t(w,b,m,r+1,a+T);let _;if(P===Le){const S=M(T),L=C(T)-S;_=s(S,L,!0,r+1,a+T,w)}else _=P&&ye(T,e,t,s,i,a,r+1);return!!_}}const Bt=new z,re=new z;function Wn(n,e,t={},s=0,i=1/0){const a=s*s,r=i*i;let c=1/0,o=null;if(n.shapecast({boundsTraverseOrder:u=>(Bt.copy(e).clamp(u.min,u.max),Bt.distanceToSquared(e)),intersectsBounds:(u,f,l)=>l<c&&l<r,intersectsTriangle:(u,f)=>{u.closestPointToPoint(e,Bt);const l=e.distanceToSquared(Bt);return l<c&&(re.copy(Bt),c=l,o=f),l<a}}),c===1/0)return null;const p=Math.sqrt(c);return t.point?t.point.copy(re):t.point=re.clone(),t.distance=p,t.faceIndex=o,t}const Zn=parseInt(nn)>=169,at=new z,lt=new z,ut=new z,Nt=new At,kt=new At,It=new At,Fe=new z,Ee=new z,Ve=new z,vt=new z;function Yn(n,e,t,s,i,a,r,c){let o;if(a===tn?o=n.intersectTriangle(s,t,e,!0,i):o=n.intersectTriangle(e,t,s,a!==en,i),o===null)return null;const p=n.origin.distanceTo(i);return p<r||p>c?null:{distance:p,point:i.clone()}}function Kn(n,e,t,s,i,a,r,c,o,p,u){at.fromBufferAttribute(e,a),lt.fromBufferAttribute(e,r),ut.fromBufferAttribute(e,c);const f=Yn(n,at,lt,ut,vt,o,p,u);if(f){const l=new z;wt.getBarycoord(vt,at,lt,ut,l),s&&(Nt.fromBufferAttribute(s,a),kt.fromBufferAttribute(s,r),It.fromBufferAttribute(s,c),f.uv=wt.getInterpolation(vt,at,lt,ut,Nt,kt,It,new At)),i&&(Nt.fromBufferAttribute(i,a),kt.fromBufferAttribute(i,r),It.fromBufferAttribute(i,c),f.uv1=wt.getInterpolation(vt,at,lt,ut,Nt,kt,It,new At)),t&&(Fe.fromBufferAttribute(t,a),Ee.fromBufferAttribute(t,r),Ve.fromBufferAttribute(t,c),f.normal=wt.getInterpolation(vt,at,lt,ut,Fe,Ee,Ve,new z),f.normal.dot(n.direction)>0&&f.normal.multiplyScalar(-1));const y={a,b:r,c,normal:new z,materialIndex:0};wt.getNormal(at,lt,ut,y.normal),f.face=y,f.faceIndex=a,Zn&&(f.barycoord=l)}return f}function Gt(n,e,t,s,i,a,r){const c=s*3;let o=c+0,p=c+1,u=c+2;const f=n.index;n.index&&(o=f.getX(o),p=f.getX(p),u=f.getX(u));const{position:l,normal:y,uv:A,uv1:T}=n.attributes,h=Kn(t,l,y,A,T,o,p,u,e,a,r);return h?(h.faceIndex=s,i&&i.push(h),h):null}function E(n,e,t,s){const i=n.a,a=n.b,r=n.c;let c=e,o=e+1,p=e+2;t&&(c=t.getX(c),o=t.getX(o),p=t.getX(p)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),a.x=s.getX(o),a.y=s.getY(o),a.z=s.getZ(o),r.x=s.getX(p),r.y=s.getY(p),r.z=s.getZ(p)}function Jn(n,e,t,s,i,a,r,c){const{geometry:o,_indirectBuffer:p}=n;for(let u=s,f=s+i;u<f;u++)Gt(o,e,t,u,a,r,c)}function Qn(n,e,t,s,i,a,r){const{geometry:c,_indirectBuffer:o}=n;let p=1/0,u=null;for(let f=s,l=s+i;f<l;f++){let y;y=Gt(c,e,t,f,null,a,r),y&&y.distance<p&&(u=y,p=y.distance)}return u}function On(n,e,t,s,i,a,r){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let u=n,f=e+n;u<f;u++){let l;if(l=u,E(r,l*3,o,p),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}function Gn(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,c,o,p=0;const u=n._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],r=new Uint32Array(a),c=new Uint16Array(a),o=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,y,A=!1){const T=l*2;if(c[T+15]===Ot){const m=r[l+6],d=c[T+14];let w=1/0,x=1/0,g=1/0,B=-1/0,b=-1/0,P=-1/0;for(let _=3*m,M=3*(m+d);_<M;_++){let C=s[_];const S=i.getX(C),v=i.getY(C),L=i.getZ(C);S<w&&(w=S),S>B&&(B=S),v<x&&(x=v),v>b&&(b=v),L<g&&(g=L),L>P&&(P=L)}return o[l+0]!==w||o[l+1]!==x||o[l+2]!==g||o[l+3]!==B||o[l+4]!==b||o[l+5]!==P?(o[l+0]=w,o[l+1]=x,o[l+2]=g,o[l+3]=B,o[l+4]=b,o[l+5]=P,!0):!1}else{const m=l+8,d=r[l+6],w=m+y,x=d+y;let g=A,B=!1,b=!1;e?g||(B=e.has(w),b=e.has(x),g=!B&&!b):(B=!0,b=!0);const P=g||B,_=g||b;let M=!1;P&&(M=f(m,y,g));let C=!1;_&&(C=f(d,y,g));const S=M||C;if(S)for(let v=0;v<3;v++){const L=m+v,U=d+v,R=o[L],N=o[L+3],Y=o[U],K=o[U+3];o[l+v]=R<Y?R:Y,o[l+v+3]=N>K?N:K}return S}}}function ct(n,e,t,s,i){let a,r,c,o,p,u;const f=1/t.direction.x,l=1/t.direction.y,y=1/t.direction.z,A=t.origin.x,T=t.origin.y,h=t.origin.z;let m=e[n],d=e[n+3],w=e[n+1],x=e[n+3+1],g=e[n+2],B=e[n+3+2];return f>=0?(a=(m-A)*f,r=(d-A)*f):(a=(d-A)*f,r=(m-A)*f),l>=0?(c=(w-T)*l,o=(x-T)*l):(c=(x-T)*l,o=(w-T)*l),a>o||c>r||((c>a||isNaN(a))&&(a=c),(o<r||isNaN(r))&&(r=o),y>=0?(p=(g-h)*y,u=(B-h)*y):(p=(B-h)*y,u=(g-h)*y),a>u||p>r)?!1:((p>a||a!==a)&&(a=p),(u<r||r!==r)&&(r=u),a<=i&&r>=s)}function ts(n,e,t,s,i,a,r,c){const{geometry:o,_indirectBuffer:p}=n;for(let u=s,f=s+i;u<f;u++){let l=p?p[u]:u;Gt(o,e,t,l,a,r,c)}}function es(n,e,t,s,i,a,r){const{geometry:c,_indirectBuffer:o}=n;let p=1/0,u=null;for(let f=s,l=s+i;f<l;f++){let y;y=Gt(c,e,t,o?o[f]:f,null,a,r),y&&y.distance<p&&(u=y,p=y.distance)}return u}function ns(n,e,t,s,i,a,r){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let u=n,f=e+n;u<f;u++){let l;if(l=t.resolveTriangleIndex(u),E(r,l*3,o,p),r.needsUpdate=!0,s(r,l,i,a))return!0}return!1}function ss(n,e,t,s,i,a,r){D.setBuffer(n._roots[e]),de(0,n,t,s,i,a,r),D.clearBuffer()}function de(n,e,t,s,i,a,r){const{float32Array:c,uint16Array:o,uint32Array:p}=D,u=n*2;if(I(u,o)){const l=q(n,p),y=$(u,o);Jn(e,t,s,l,y,i,a,r)}else{const l=H(n);ct(l,c,s,a,r)&&de(l,e,t,s,i,a,r);const y=j(n,p);ct(y,c,s,a,r)&&de(y,e,t,s,i,a,r)}}const is=["x","y","z"];function rs(n,e,t,s,i,a){D.setBuffer(n._roots[e]);const r=me(0,n,t,s,i,a);return D.clearBuffer(),r}function me(n,e,t,s,i,a){const{float32Array:r,uint16Array:c,uint32Array:o}=D;let p=n*2;if(I(p,c)){const f=q(n,o),l=$(p,c);return Qn(e,t,s,f,l,i,a)}else{const f=Qe(n,o),l=is[f],A=s.direction[l]>=0;let T,h;A?(T=H(n),h=j(n,o)):(T=j(n,o),h=H(n));const d=ct(T,r,s,i,a)?me(T,e,t,s,i,a):null;if(d){const g=d.point[l];if(A?g<=r[h+f]:g>=r[h+f+3])return d}const x=ct(h,r,s,i,a)?me(h,e,t,s,i,a):null;return d&&x?d.distance<=x.distance?d:x:d||x||null}}const qt=new Q,pt=new Z,yt=new Z,Pt=new ot,Ne=new k,$t=new k;function os(n,e,t,s){D.setBuffer(n._roots[e]);const i=he(0,n,t,s);return D.clearBuffer(),i}function he(n,e,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:c}=D;let o=n*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),Ne.set(t.boundingBox.min,t.boundingBox.max,s),i=Ne),I(o,r)){const u=e.geometry,f=u.index,l=u.attributes.position,y=t.index,A=t.attributes.position,T=q(n,c),h=$(o,r);if(Pt.copy(s).invert(),t.boundsTree)return F(n,a,$t),$t.matrix.copy(Pt),$t.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:d=>$t.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let w=T*3,x=(h+T)*3;w<x;w+=3)if(E(yt,w,f,l),yt.needsUpdate=!0,d.intersectsTriangle(yt))return!0;return!1}});for(let m=T*3,d=(h+T)*3;m<d;m+=3){E(pt,m,f,l),pt.a.applyMatrix4(Pt),pt.b.applyMatrix4(Pt),pt.c.applyMatrix4(Pt),pt.needsUpdate=!0;for(let w=0,x=y.count;w<x;w+=3)if(E(yt,w,y,A),yt.needsUpdate=!0,pt.intersectsTriangle(yt))return!0}}else{const u=n+8,f=c[n+6];return F(u,a,qt),!!(i.intersectsBox(qt)&&he(u,e,t,s,i)||(F(f,a,qt),i.intersectsBox(qt)&&he(f,e,t,s,i)))}}const Ht=new ot,oe=new k,_t=new k,cs=new z,as=new z,ls=new z,us=new z;function fs(n,e,t,s={},i={},a=0,r=1/0){e.boundingBox||e.computeBoundingBox(),oe.set(e.boundingBox.min,e.boundingBox.max,t),oe.needsUpdate=!0;const c=n.geometry,o=c.attributes.position,p=c.index,u=e.attributes.position,f=e.index,l=X.getPrimitive(),y=X.getPrimitive();let A=cs,T=as,h=null,m=null;i&&(h=ls,m=us);let d=1/0,w=null,x=null;return Ht.copy(t).invert(),_t.matrix.copy(Ht),n.shapecast({boundsTraverseOrder:g=>oe.distanceToBox(g),intersectsBounds:(g,B,b)=>b<d&&b<r?(B&&(_t.min.copy(g.min),_t.max.copy(g.max),_t.needsUpdate=!0),!0):!1,intersectsRange:(g,B)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:P=>_t.distanceToBox(P),intersectsBounds:(P,_,M)=>M<d&&M<r,intersectsRange:(P,_)=>{for(let M=P,C=P+_;M<C;M++){E(y,3*M,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=g,v=g+B;S<v;S++){E(l,3*S,p,o),l.needsUpdate=!0;const L=l.distanceToTriangle(y,A,h);if(L<d&&(T.copy(A),m&&m.copy(h),d=L,w=S,x=M),L<a)return!0}}}});{const b=Tt(e);for(let P=0,_=b;P<_;P++){E(y,3*P,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=g,C=g+B;M<C;M++){E(l,3*M,p,o),l.needsUpdate=!0;const S=l.distanceToTriangle(y,A,h);if(S<d&&(T.copy(A),m&&m.copy(h),d=S,w=M,x=P),S<a)return!0}}}}}),X.releasePrimitive(l),X.releasePrimitive(y),d===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=d,s.faceIndex=w,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(Ht),T.applyMatrix4(Ht),i.distance=T.sub(i.point).length(),i.faceIndex=x),s)}function ps(n,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=n.geometry,s=t.index?t.index.array:null,i=t.attributes.position;let a,r,c,o,p=0;const u=n._roots;for(let l=0,y=u.length;l<y;l++)a=u[l],r=new Uint32Array(a),c=new Uint16Array(a),o=new Float32Array(a),f(0,p),p+=a.byteLength;function f(l,y,A=!1){const T=l*2;if(c[T+15]===Ot){const m=r[l+6],d=c[T+14];let w=1/0,x=1/0,g=1/0,B=-1/0,b=-1/0,P=-1/0;for(let _=m,M=m+d;_<M;_++){const C=3*n.resolveTriangleIndex(_);for(let S=0;S<3;S++){let v=C+S;v=s?s[v]:v;const L=i.getX(v),U=i.getY(v),R=i.getZ(v);L<w&&(w=L),L>B&&(B=L),U<x&&(x=U),U>b&&(b=U),R<g&&(g=R),R>P&&(P=R)}}return o[l+0]!==w||o[l+1]!==x||o[l+2]!==g||o[l+3]!==B||o[l+4]!==b||o[l+5]!==P?(o[l+0]=w,o[l+1]=x,o[l+2]=g,o[l+3]=B,o[l+4]=b,o[l+5]=P,!0):!1}else{const m=l+8,d=r[l+6],w=m+y,x=d+y;let g=A,B=!1,b=!1;e?g||(B=e.has(w),b=e.has(x),g=!B&&!b):(B=!0,b=!0);const P=g||B,_=g||b;let M=!1;P&&(M=f(m,y,g));let C=!1;_&&(C=f(d,y,g));const S=M||C;if(S)for(let v=0;v<3;v++){const L=m+v,U=d+v,R=o[L],N=o[L+3],Y=o[U],K=o[U+3];o[l+v]=R<Y?R:Y,o[l+v+3]=N>K?N:K}return S}}}function ys(n,e,t,s,i,a,r){D.setBuffer(n._roots[e]),xe(0,n,t,s,i,a,r),D.clearBuffer()}function xe(n,e,t,s,i,a,r){const{float32Array:c,uint16Array:o,uint32Array:p}=D,u=n*2;if(I(u,o)){const l=q(n,p),y=$(u,o);ts(e,t,s,l,y,i,a,r)}else{const l=H(n);ct(l,c,s,a,r)&&xe(l,e,t,s,i,a,r);const y=j(n,p);ct(y,c,s,a,r)&&xe(y,e,t,s,i,a,r)}}const ds=["x","y","z"];function ms(n,e,t,s,i,a){D.setBuffer(n._roots[e]);const r=we(0,n,t,s,i,a);return D.clearBuffer(),r}function we(n,e,t,s,i,a){const{float32Array:r,uint16Array:c,uint32Array:o}=D;let p=n*2;if(I(p,c)){const f=q(n,o),l=$(p,c);return es(e,t,s,f,l,i,a)}else{const f=Qe(n,o),l=ds[f],A=s.direction[l]>=0;let T,h;A?(T=H(n),h=j(n,o)):(T=j(n,o),h=H(n));const d=ct(T,r,s,i,a)?we(T,e,t,s,i,a):null;if(d){const g=d.point[l];if(A?g<=r[h+f]:g>=r[h+f+3])return d}const x=ct(h,r,s,i,a)?we(h,e,t,s,i,a):null;return d&&x?d.distance<=x.distance?d:x:d||x||null}}const jt=new Q,dt=new Z,mt=new Z,St=new ot,ke=new k,Xt=new k;function hs(n,e,t,s){D.setBuffer(n._roots[e]);const i=ge(0,n,t,s);return D.clearBuffer(),i}function ge(n,e,t,s,i=null){const{float32Array:a,uint16Array:r,uint32Array:c}=D;let o=n*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),ke.set(t.boundingBox.min,t.boundingBox.max,s),i=ke),I(o,r)){const u=e.geometry,f=u.index,l=u.attributes.position,y=t.index,A=t.attributes.position,T=q(n,c),h=$(o,r);if(St.copy(s).invert(),t.boundsTree)return F(n,a,Xt),Xt.matrix.copy(St),Xt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:d=>Xt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let w=T,x=h+T;w<x;w++)if(E(mt,3*e.resolveTriangleIndex(w),f,l),mt.needsUpdate=!0,d.intersectsTriangle(mt))return!0;return!1}});for(let m=T,d=h+T;m<d;m++){const w=e.resolveTriangleIndex(m);E(dt,3*w,f,l),dt.a.applyMatrix4(St),dt.b.applyMatrix4(St),dt.c.applyMatrix4(St),dt.needsUpdate=!0;for(let x=0,g=y.count;x<g;x+=3)if(E(mt,x,y,A),mt.needsUpdate=!0,dt.intersectsTriangle(mt))return!0}}else{const u=n+8,f=c[n+6];return F(u,a,jt),!!(i.intersectsBox(jt)&&ge(u,e,t,s,i)||(F(f,a,jt),i.intersectsBox(jt)&&ge(f,e,t,s,i)))}}const Wt=new ot,ce=new k,Mt=new k,xs=new z,ws=new z,gs=new z,As=new z;function Ts(n,e,t,s={},i={},a=0,r=1/0){e.boundingBox||e.computeBoundingBox(),ce.set(e.boundingBox.min,e.boundingBox.max,t),ce.needsUpdate=!0;const c=n.geometry,o=c.attributes.position,p=c.index,u=e.attributes.position,f=e.index,l=X.getPrimitive(),y=X.getPrimitive();let A=xs,T=ws,h=null,m=null;i&&(h=gs,m=As);let d=1/0,w=null,x=null;return Wt.copy(t).invert(),Mt.matrix.copy(Wt),n.shapecast({boundsTraverseOrder:g=>ce.distanceToBox(g),intersectsBounds:(g,B,b)=>b<d&&b<r?(B&&(Mt.min.copy(g.min),Mt.max.copy(g.max),Mt.needsUpdate=!0),!0):!1,intersectsRange:(g,B)=>{if(e.boundsTree){const b=e.boundsTree;return b.shapecast({boundsTraverseOrder:P=>Mt.distanceToBox(P),intersectsBounds:(P,_,M)=>M<d&&M<r,intersectsRange:(P,_)=>{for(let M=P,C=P+_;M<C;M++){const S=b.resolveTriangleIndex(M);E(y,3*S,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let v=g,L=g+B;v<L;v++){const U=n.resolveTriangleIndex(v);E(l,3*U,p,o),l.needsUpdate=!0;const R=l.distanceToTriangle(y,A,h);if(R<d&&(T.copy(A),m&&m.copy(h),d=R,w=v,x=M),R<a)return!0}}}})}else{const b=Tt(e);for(let P=0,_=b;P<_;P++){E(y,3*P,f,u),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=g,C=g+B;M<C;M++){const S=n.resolveTriangleIndex(M);E(l,3*S,p,o),l.needsUpdate=!0;const v=l.distanceToTriangle(y,A,h);if(v<d&&(T.copy(A),m&&m.copy(h),d=v,w=M,x=P),v<a)return!0}}}}}),X.releasePrimitive(l),X.releasePrimitive(y),d===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=d,s.faceIndex=w,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(Wt),T.applyMatrix4(Wt),i.distance=T.sub(i.point).length(),i.faceIndex=x),s)}function bs(){return typeof SharedArrayBuffer<"u"}const zt=new D.constructor,Qt=new D.constructor,it=new be(()=>new Q),ht=new Q,xt=new Q,ae=new Q,le=new Q;let ue=!1;function Bs(n,e,t,s){if(ue)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");ue=!0;const i=n._roots,a=e._roots;let r,c=0,o=0;const p=new ot().copy(t).invert();for(let u=0,f=i.length;u<f;u++){zt.setBuffer(i[u]),o=0;const l=it.getPrimitive();F(0,zt.float32Array,l),l.applyMatrix4(p);for(let y=0,A=a.length;y<A&&(Qt.setBuffer(a[y]),r=W(0,0,t,p,s,c,o,0,0,l),Qt.clearBuffer(),o+=a[y].length,!r);y++);if(it.releasePrimitive(l),zt.clearBuffer(),c+=i[u].length,r)break}return ue=!1,r}function W(n,e,t,s,i,a=0,r=0,c=0,o=0,p=null,u=!1){let f,l;u?(f=Qt,l=zt):(f=zt,l=Qt);const y=f.float32Array,A=f.uint32Array,T=f.uint16Array,h=l.float32Array,m=l.uint32Array,d=l.uint16Array,w=n*2,x=e*2,g=I(w,T),B=I(x,d);let b=!1;if(B&&g)u?b=i(q(e,m),$(e*2,d),q(n,A),$(n*2,T),o,r+e,c,a+n):b=i(q(n,A),$(n*2,T),q(e,m),$(e*2,d),c,a+n,o,r+e);else if(B){const P=it.getPrimitive();F(e,h,P),P.applyMatrix4(t);const _=H(n),M=j(n,A);F(_,y,ht),F(M,y,xt);const C=P.intersectsBox(ht),S=P.intersectsBox(xt);b=C&&W(e,_,s,t,i,r,a,o,c+1,P,!u)||S&&W(e,M,s,t,i,r,a,o,c+1,P,!u),it.releasePrimitive(P)}else{const P=H(e),_=j(e,m);F(P,h,ae),F(_,h,le);const M=p.intersectsBox(ae),C=p.intersectsBox(le);if(M&&C)b=W(n,P,t,s,i,a,r,c,o+1,p,u)||W(n,_,t,s,i,a,r,c,o+1,p,u);else if(M)if(g)b=W(n,P,t,s,i,a,r,c,o+1,p,u);else{const S=it.getPrimitive();S.copy(ae).applyMatrix4(t);const v=H(n),L=j(n,A);F(v,y,ht),F(L,y,xt);const U=S.intersectsBox(ht),R=S.intersectsBox(xt);b=U&&W(P,v,s,t,i,r,a,o,c+1,S,!u)||R&&W(P,L,s,t,i,r,a,o,c+1,S,!u),it.releasePrimitive(S)}else if(C)if(g)b=W(n,_,t,s,i,a,r,c,o+1,p,u);else{const S=it.getPrimitive();S.copy(le).applyMatrix4(t);const v=H(n),L=j(n,A);F(v,y,ht),F(L,y,xt);const U=S.intersectsBox(ht),R=S.intersectsBox(xt);b=U&&W(_,v,s,t,i,r,a,o,c+1,S,!u)||R&&W(_,L,s,t,i,r,a,o,c+1,S,!u),it.releasePrimitive(S)}}return b}const Zt=new k,Ie=new Q,vs={strategy:Ye,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Be{static serialize(e,t={}){t={cloneBuffers:!0,...t};const s=e.geometry,i=e._roots,a=e._indirectBuffer,r=s.getIndex();let c;return t.cloneBuffers?c={roots:i.map(o=>o.slice()),index:r?r.array.slice():null,indirectBuffer:a?a.slice():null}:c={roots:i,index:r?r.array:null,indirectBuffer:a},c}static deserialize(e,t,s={}){s={setIndex:!0,indirect:!!e.indirectBuffer,...s};const{index:i,roots:a,indirectBuffer:r}=e,c=new Be(t,{...s,[ee]:!0});if(c._roots=a,c._indirectBuffer=r||null,s.setIndex){const o=t.getIndex();if(o===null){const p=new Xe(e.index,1,!1);t.setIndex(p)}else o.array!==i&&(o.array.set(i),o.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...vs,[ee]:!1},t),t.useSharedArrayBuffer&&!bs())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[ee]||(kn(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new Q))),this.resolveTriangleIndex=t.indirect?s=>this._indirectBuffer[s]:s=>s}refit(e=null){return(this.indirect?ps:Gn)(this,e)}traverse(e,t=0){const s=this._roots[t],i=new Uint32Array(s),a=new Uint16Array(s);r(0);function r(c,o=0){const p=c*2,u=a[p+15]===Ot;if(u){const f=i[c+6],l=a[p+14];e(o,u,new Float32Array(s,c*4,6),f,l)}else{const f=c+Lt/4,l=i[c+6],y=i[c+7];e(o,u,new Float32Array(s,c*4,6),y)||(r(f,o+1),r(l,o+1))}}}raycast(e,t=_e,s=0,i=1/0){const a=this._roots,r=this.geometry,c=[],o=t.isMaterial,p=Array.isArray(t),u=r.groups,f=o?t.side:t,l=this.indirect?ys:ss;for(let y=0,A=a.length;y<A;y++){const T=p?t[u[y].materialIndex].side:f,h=c.length;if(l(this,y,T,e,c,s,i),p){const m=u[y].materialIndex;for(let d=h,w=c.length;d<w;d++)c[d].face.materialIndex=m}}return c}raycastFirst(e,t=_e,s=0,i=1/0){const a=this._roots,r=this.geometry,c=t.isMaterial,o=Array.isArray(t);let p=null;const u=r.groups,f=c?t.side:t,l=this.indirect?ms:rs;for(let y=0,A=a.length;y<A;y++){const T=o?t[u[y].materialIndex].side:f,h=l(this,y,T,e,s,i);h!=null&&(p==null||h.distance<p.distance)&&(p=h,o&&(h.face.materialIndex=u[y].materialIndex))}return p}intersectsGeometry(e,t){let s=!1;const i=this._roots,a=this.indirect?hs:os;for(let r=0,c=i.length;r<c&&(s=a(this,r,e,t),!s);r++);return s}shapecast(e){const t=X.getPrimitive(),s=this.indirect?ns:On;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:r,intersectsTriangle:c}=e;if(r&&c){const f=r;r=(l,y,A,T,h)=>f(l,y,A,T,h)?!0:s(l,y,this,c,A,T,t)}else r||(c?r=(f,l,y,A)=>s(f,l,this,c,y,A,t):r=(f,l,y)=>y);let o=!1,p=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const y=u[f];if(o=Xn(this,f,a,r,i,p),o)break;p+=y.byteLength}return X.releasePrimitive(t),o}bvhcast(e,t,s){let{intersectsRanges:i,intersectsTriangles:a}=s;const r=X.getPrimitive(),c=this.geometry.index,o=this.geometry.attributes.position,p=this.indirect?A=>{const T=this.resolveTriangleIndex(A);E(r,T*3,c,o)}:A=>{E(r,A*3,c,o)},u=X.getPrimitive(),f=e.geometry.index,l=e.geometry.attributes.position,y=e.indirect?A=>{const T=e.resolveTriangleIndex(A);E(u,T*3,f,l)}:A=>{E(u,A*3,f,l)};if(a){const A=(T,h,m,d,w,x,g,B)=>{for(let b=m,P=m+d;b<P;b++){y(b),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let _=T,M=T+h;_<M;_++)if(p(_),r.needsUpdate=!0,a(r,u,_,b,w,x,g,B))return!0}return!1};if(i){const T=i;i=function(h,m,d,w,x,g,B,b){return T(h,m,d,w,x,g,B,b)?!0:A(h,m,d,w,x,g,B,b)}}else i=A}return Bs(this,e,t,i)}intersectsBox(e,t){return Zt.set(e.min,e.max,t),Zt.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Zt.intersectsBox(s),intersectsTriangle:s=>Zt.intersectsTriangle(s)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,s={},i={},a=0,r=1/0){return(this.indirect?Ts:fs)(this,e,t,s,i,a,r)}closestPointToPoint(e,t={},s=0,i=1/0){return Wn(this,e,t,s,i)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(s=>{F(0,new Float32Array(s),Ie),e.union(Ie)}),e}}function qe(n,e,t){return n===null?null:(n.point.applyMatrix4(e.matrixWorld),n.distance=n.point.distanceTo(t.ray.origin),n.object=e,n)}const Yt=new rn,$e=new z,He=new ot,Ps=Ae.prototype.raycast,_s=sn.prototype.raycast,je=new z,V=new Ae,Kt=[];function Ss(n,e){this.isBatchedMesh?Ms.call(this,n,e):Cs.call(this,n,e)}function Ms(n,e){if(this.boundsTrees){const t=this.boundsTrees,s=this._drawInfo||this._instanceInfo,i=this._drawRanges||this._geometryInfo,a=this.matrixWorld;V.material=this.material,V.geometry=this.geometry;const r=V.geometry.boundsTree,c=V.geometry.drawRange;V.geometry.boundingSphere===null&&(V.geometry.boundingSphere=new Ze);for(let o=0,p=s.length;o<p;o++){if(!this.getVisibleAt(o))continue;const u=s[o].geometryIndex;if(V.geometry.boundsTree=t[u],this.getMatrixAt(o,V.matrixWorld).premultiply(a),!V.geometry.boundsTree){this.getBoundingBoxAt(u,V.geometry.boundingBox),this.getBoundingSphereAt(u,V.geometry.boundingSphere);const f=i[u];V.geometry.setDrawRange(f.start,f.count)}V.raycast(n,Kt);for(let f=0,l=Kt.length;f<l;f++){const y=Kt[f];y.object=this,y.batchId=o,e.push(y)}Kt.length=0}V.geometry.boundsTree=r,V.geometry.drawRange=c,V.material=null,V.geometry=null}else _s.call(this,n,e)}function Cs(n,e){if(this.geometry.boundsTree){if(this.material===void 0)return;He.copy(this.matrixWorld).invert(),Yt.copy(n.ray).applyMatrix4(He),je.setFromMatrixScale(this.matrixWorld),$e.copy(Yt.direction).multiply(je);const t=$e.length(),s=n.near/t,i=n.far/t,a=this.geometry.boundsTree;if(n.firstHitOnly===!0){const r=qe(a.raycastFirst(Yt,this.material,s,i),this,n);r&&e.push(r)}else{const r=a.raycast(Yt,this.material,s,i);for(let c=0,o=r.length;c<o;c++){const p=qe(r[c],this,n);p&&e.push(p)}}}else Ps.call(this,n,e)}function Ls(n={}){return this.boundsTree=new Be(this,n),this.boundsTree}function zs(){this.boundsTree=null}const Rs=["ar","ar-modes","environment-image","exposure","autoplay","orbit-sensitivity","pan-sensitivity","poster","shadow-intensity","skybox-image","src","zoom-sensitivity"],Us={class:"overlay-svg-wrapper"},Ds=["x1","x2","y1","y2"],Fs={key:0},Es=["height","width","x","y"],Vs=["x","y"],Ns=on({__name:"ModelViewerWrapper",props:{src:{}},setup(n,{expose:e}){cn.modelCacheSize=0,Se.prototype.computeBoundsTree=Ls,Se.prototype.disposeBoundsTree=zs,Ae.prototype.raycast=Ss;const t=n,s=J(null),i=J(null),a=J(null),r=J(null),c=J(null);(async()=>c.value=await an)();let o,p,u=t.src.toString(),f=!1;ln(()=>{s.value&&(f||(f=!0,s.value.addEventListener("before-render",()=>{s.value&&(i.value=s.value[un],a.value=s.value[fn],r.value=s.value[pn],o&&(i.value.setTarget(-o.x,-o.y,-o.z),i.value.jumpToGoal()),(async()=>{let v=0;for(;v++<25&&!(!p||!s.value?.getCameraOrbit()?.radius);){let L=p-s.value.getCameraOrbit().radius;if(Math.abs(L)<.001)break;s.value.zoom(-Math.sign(L)*(Math.pow(Math.abs(L)+1,.9)-1)),s.value.jumpCameraToGoal(),await s.value.updateComplete}u=t.src.toString()})())}),s.value.addEventListener("camera-change",l),s.value.addEventListener("progress",v=>h(v.detail.totalProgress)),yn(s.value)))});function l(){i.value&&t.src.toString()==u&&(o=i.value.target.position.clone(),p=s.value?.getCameraOrbit()?.radius);for(let v in x.value)_(v)}const y=J(null),A=J(null);let T=null;const h=v=>{!y.value||!A.value||(y.value.style.display="block",y.value.style.opacity="1",A.value.style.width=`${v*100}%`,T&&clearTimeout(T),T=setTimeout(()=>{y.value&&(y.value.style.opacity="0",setTimeout(()=>{y.value&&(y.value.style.display="none")},300))},1e3))},m=J(""),d=v=>{m.value="data:image/svg+xml;charset=utf-8;base64,"+btoa('<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg" fill="gray"><text x="50%" y="0%" dominant-baseline="middle" text-anchor="middle" font-size="48px">'+v+"</text></svg>")};d("Loading...");let w=1,x=J({});function g(v){return v.x+" "+v.y+" "+v.z}function B(v,L,U,R={"stroke-width":"2",stroke:"red"}){if(!i.value||!s.value?.shadowRoot)return null;let N=w++,Y="line"+N+"_start",K="line"+N+"_end";return i.value.addHotspot(new Dt({name:Y,position:g(v)})),i.value.addHotspot(new Dt({name:K,position:g(L)})),x.value[N]={startHotspot:s.value.shadowRoot.querySelector('slot[name="'+Y+'"]').parentElement,endHotspot:s.value.shadowRoot.querySelector('slot[name="'+K+'"]').parentElement,start2D:[-1e3,-1e3],end2D:[-1e3,-1e3],centerText:U,centerTextSize:[0,0],lineAttrs:R},i.value.queueRender(),requestIdleCallback(()=>_(N),{timeout:100}),N}function b(v){return!i.value||!(v in x.value)?!1:(i.value.removeHotspot(new Dt({name:"line"+v+"_start"})),x.value[v]?.startHotspot.parentElement?.remove(),i.value.removeHotspot(new Dt({name:"line"+v+"_end"})),x.value[v]?.endHotspot.parentElement?.remove(),delete x.value[v],i.value.queueRender(),!0)}let P=J(null);function _(v){if(!(v in x.value)||!s.value)return;let{x:L,y:U}=s.value.getBoundingClientRect(),{x:R,y:N}=x.value[v]?.startHotspot.getBoundingClientRect()??{x:0,y:0};x.value[v]&&(x.value[v].start2D=[R-L,N-U]);let{x:Y,y:K}=x.value[v]?.endHotspot.getBoundingClientRect()??{x:0,y:0};if(x.value[v]&&(x.value[v].end2D=[Y-L,K-U]),P.value&&x.value[v]?.centerText&&x.value[v]?.centerTextSize[0]===0){let ve=P.value.getElementsByClassName("line"+v+"_text")[0];if(ve){let Pe=ve.getBBox();x.value[v]&&(x.value[v].centerTextSize=[Pe.width,Pe.height])}}}function M(v){s.value?v(s.value):Me(()=>s.value,L=>{L&&v(L)})}function C(v){return Object.entries(v)}e({elem:s,onElemReady:M,scene:i,renderer:a,controls:r,addLine3D:B,removeLine3D:b,onProgress:h,setPosterText:d});let{disableTap:S}=dn("disableTap");return Me(S,v=>{s.value&&(s.value.disableTap=v)}),(v,L)=>(nt(),et(Ce,null,[c.value!=null?(nt(),et("model-viewer",{key:0,ref_key:"elem",ref:s,ar:c.value.arModes.length>0,"ar-modes":c.value.arModes,"environment-image":c.value.environment,exposure:c.value.exposure,autoplay:c.value.autoplay,"orbit-sensitivity":c.value.orbitSensitivity,"pan-sensitivity":c.value.panSensitivity,poster:m.value,"shadow-intensity":c.value.shadowIntensity,"skybox-image":c.value.skybox,src:t.src,"zoom-sensitivity":c.value.zoomSensitivity,alt:"The 3D model(s)","camera-controls":"","camera-orbit":"45deg 45deg auto","interaction-prompt":"none","max-camera-orbit":"Infinity 180deg auto","min-camera-orbit":"-Infinity 0deg 5%",style:{width:"100%",height:"100%"}},[mn(v.$slots,"default",{},void 0,!0),Ut("div",{ref_key:"progressBar",ref:y,slot:"progress-bar",class:"progress-bar"},[Ut("div",{ref_key:"updateBar",ref:A,class:"update-bar"},null,512)],512)],8,Rs)):Rt("",!0),Ut("div",Us,[(nt(),et("svg",{ref_key:"svg",ref:P,class:"overlay-svg",height:"100%",width:"100%",xmlns:"http://www.w3.org/2000/svg"},[(nt(!0),et(Ce,null,hn(C(An(x)),([U,R])=>(nt(),et("g",{key:U},[Ut("line",xn({x1:R.start2D[0],x2:R.end2D[0],y1:R.start2D[1],y2:R.end2D[1]},{ref_for:!0},R.lineAttrs),null,16,Ds),R.centerText!==void 0?(nt(),et("g",Fs,[R.centerText?(nt(),et("rect",{key:0,height:R.centerTextSize[1]+4,width:R.centerTextSize[0]+8,x:(R.start2D[0]+R.end2D[0])/2-R.centerTextSize[0]/2-4,y:(R.start2D[1]+R.end2D[1])/2-R.centerTextSize[1]/2-2,fill:"gray","fill-opacity":"0.75",rx:"4",ry:"4",stroke:"black"},null,8,Es)):Rt("",!0),R.centerText?(nt(),et("text",{key:1,class:wn("line"+U+"_text"),x:(R.start2D[0]+R.end2D[0])/2,y:(R.start2D[1]+R.end2D[1])/2,"dominant-baseline":"middle",fill:"black","font-size":"16","text-anchor":"middle"},gn(R.centerText),11,Vs)):Rt("",!0)])):Rt("",!0)]))),128))],512))])],64))}}),Is=Tn(Ns,[["__scopeId","data-v-fa462b40"]]);export{Is as default};
//# sourceMappingURL=ModelViewerWrapper-DeU4WF1h.js.map
