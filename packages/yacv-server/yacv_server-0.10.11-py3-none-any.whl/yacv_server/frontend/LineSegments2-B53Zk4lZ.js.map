{"version":3,"file":"LineSegments2-B53Zk4lZ.js","sources":["../../node_modules/three/examples/jsm/lines/LineSegments2.js"],"sourcesContent":["import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * A series of lines drawn between pairs of vertices.\n *\n * This adds functionality beyond {@link LineSegments}, like arbitrary line width and changing width\n * to be in world units. {@link Line2} extends this object, forming a polyline instead of individual\n * segments.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `lines/webgpu/LineSegments2.js`.\n *\n *  ```js\n * const geometry = new LineSegmentsGeometry();\n * geometry.setPositions( positions );\n * geometry.setColors( colors );\n *\n * const material = new LineMaterial( { linewidth: 5, vertexColors: true } };\n *\n * const lineSegments = new LineSegments2( geometry, material );\n * scene.add( lineSegments );\n * ```\n *\n * @augments Mesh\n * @three_import import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';\n */\nclass LineSegments2 extends Mesh {\n\n\t/**\n\t * Constructs a new wide line.\n\t *\n\t * @param {LineSegmentsGeometry} [geometry] - The line geometry.\n\t * @param {LineMaterial} [material] - The line material.\n\t */\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t/**\n\t * Computes an array of distance values which are necessary for rendering dashed lines.\n\t * For each vertex in the geometry, the method calculates the cumulative length from the\n\t * current point to the very beginning of the line.\n\t *\n\t * @return {LineSegments2} A reference to this instance.\n\t */\n\tcomputeLineDistances() {\n\n\t\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes intersection points between a casted ray and this instance.\n\t *\n\t * @param {Raycaster} raycaster - The raycaster.\n\t * @param {Array<Object>} intersects - The target array that holds the intersection points.\n\t */\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\n\t\tif ( uniforms && uniforms.resolution ) {\n\n\t\t\trenderer.getViewport( _viewport );\n\t\t\tthis.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n"],"names":["_viewport","Vector4","_start","Vector3","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_box","Box3","_sphere","Sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","raycastWorldUnits","lineSegments","intersects","matrixWorld","geometry","instanceStart","instanceEnd","segmentCount","i","l","pointOnLine","point","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","Mesh","LineSegmentsGeometry","material","LineMaterial","lineDistances","j","instanceDistanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","raycaster","worldUnits","threshold","sphereMargin","distanceToSphere","boxMargin","distanceToBox","renderer","uniforms"],"mappings":"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","x_google_ignoreList":[0]}