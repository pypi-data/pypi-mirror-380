from _typeshed import Incomplete
from collections.abc import Callable, Hashable, Iterable, Iterator
from pythonic_fp.iterables.merging import MergeEnum
from typing import Never, overload

__all__ = ['IList']

class IList[D](Hashable):
    __match_args__: Incomplete
    def __init__(self, *dss: Iterable[D]) -> None: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[D]: ...
    def __reversed__(self) -> Iterator[D]: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __getitem__(self, idx: int) -> D: ...
    @overload
    def __getitem__(self, idx: slice) -> IList[D]: ...
    def foldl[L](self, f: Callable[[L, D], L], /, start: L | None = None, default: L | None = None) -> L | None: ...
    def foldr[R](self, f: Callable[[D, R], R], /, start: R | None = None, default: R | None = None) -> R | None: ...
    def __add__(self, other: IList[D]) -> IList[D]: ...
    def __mul__(self, num: int) -> IList[D]: ...
    def __rmul__(self, num: int) -> IList[D]: ...
    def accummulate[L](self, f: Callable[[L, D], L], s: L | None = None, /) -> IList[L]: ...
    def map[U](self, f: Callable[[D], U], /) -> IList[U]: ...
    def bind[U](self, f: Callable[[D], IList[U]], merge_enum: MergeEnum = ..., yield_partials: bool = False) -> IList[U] | Never: ...
