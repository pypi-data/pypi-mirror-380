{"spec": "From a paragraph containing bullet-like lines prefixed by '-', '+', or '*' extract each trimmed bullet text in original order and return as a JSON array of strings.", "category": "parsing_text", "difficulty": "easy"}
{"spec": "Strip HTML tags while preserving meaningful whitespace, convert HTML entities to characters (e.g., &amp; -> &), collapse consecutive spaces/newlines to single spaces, and return cleaned plain text.", "category": "html_text_cleanup", "difficulty": "medium"}
{"spec": "Parse a block of multiple-choice options labeled inconsistently (e.g., 'A)', 'B.', 'C -', 'D:') and return a list of objects {\"label\": uppercase single letter, \"text\": trimmed option text} in appearance order.", "category": "option_block_parsing", "difficulty": "medium"}
{"spec": "Parse options from inline or mixed-format text like 'a) apple b) banana\\nc) cherry' and reliably split into [{label:'A',text:'apple'}, ...] handling missing separators and lowercase labels.", "category": "option_block_parsing", "difficulty": "hard"}
{"spec": "Given a chat transcript that ends with a marker such as 'Answer:' or 'Final answer:', extract and return the substring immediately following the last such marker trimmed of surrounding whitespace.", "category": "final_answer_extraction", "difficulty": "easy"}
{"spec": "From a reasoning trace that contains multiple 'Answer:' and 'Final Answer:' markers return only the final 'Final Answer:' content (case-insensitive), trimmed and without trailing punctuation.", "category": "final_answer_extraction", "difficulty": "medium"}
{"spec": "Normalize a CSV-like input that uses inconsistent delimiters and quoting (commas, semicolons, stray double quotes) into valid RFC4180 CSV with comma delimiters and properly quoted fields.", "category": "format_conversion", "difficulty": "medium"}
{"spec": "Transform free-form recipe ingredient lines (e.g., '1 1/2 cups sifted all-purpose flour') into JSON objects {quantity: number, unit: standardized_unit, ingredient: normalized_string} handling mixed fractions, approximations (e.g., 'about'), and common unit synonyms.", "category": "format_conversion", "difficulty": "hard"}
{"spec": "Find all Unicode emoji grapheme clusters in text (including skin-tone modifiers and ZWJ sequences) and return an array of objects with the emoji string and its start and end byte indices.", "category": "regex_hard", "difficulty": "hard"}
{"spec": "Extract domain names from a list of email addresses and URLs, excluding common mailbox subdomains like 'mail.' and return a unique sorted list of domains.", "category": "regex_hard", "difficulty": "medium"}
{"spec": "Normalize dates expressed in various formats (e.g., 'Jan 2nd, 2020', '02/01/20', '2020-01-02') into ISO 8601 (YYYY-MM-DD), resolving ambiguous numeric dates by assuming MM/DD/YY when ambiguous.", "category": "date_time_normalization", "difficulty": "medium"}
{"spec": "Given a reference date in ISO form, resolve relative date expressions such as 'next Friday', 'in 3 business days', 'last month', and return the resulting ISO date or date range when appropriate.", "category": "date_time_normalization", "difficulty": "hard"}
{"spec": "Convert localized numeric strings using commas or spaces as thousands separators and commas as decimals (e.g., '1.234,56', '1 234.56') into canonical dot-decimal numeric strings without grouping (e.g., '1234.56').", "category": "number_normalization", "difficulty": "easy"}
{"spec": "Parse unstructured application logs that use varying timestamp formats, levels (INFO/WARN/ERROR), thread ids, and inline key=value contexts and output structured JSON events with ISO timestamps, level, message, and a dictionary of extracted keys and numeric metrics.", "category": "log_parsing", "difficulty": "hard"}
{"spec": "Convert mixed-unit human height strings like '5 ft 7 in', '5'7\"', or '170 cm' into meters rounded to three decimal places and return the numeric string (e.g., '1.701').", "category": "unit_conversion", "difficulty": "medium"}
{"spec": "Parse complex scientific units in text (e.g., 'kg·m^2/s^3', 'J/(mol·K)') and, when a numeric value is present (e.g., '9.81 m/s^2'), convert that numeric value to a specified target unit preserving unit algebra or fail with an unconvertible error.", "category": "unit_conversion", "difficulty": "hard"}
{"spec": "From lines of 'Key: Value' or 'Key - Value' possibly containing duplicate keys, produce JSON where each key maps to an array of values in the original order, trimming whitespace.", "category": "key_value_extraction", "difficulty": "easy"}
{"spec": "Extract key-value pairs from free-form text where keys appear in brackets like '[Name] John Doe' or as 'Name=John', normalize keys to lowercase_with_underscores, and return a JSON object mapping keys to values.", "category": "key_value_extraction", "difficulty": "medium"}
{"spec": "Infer and extract key/value pairs from mixed YAML/INI-like blocks that may omit separators (e.g., 'timeout 30\\nuser: admin\\nlog_dir /var/log') and output a canonical JSON object with guessed value types (strings, numbers, booleans) when unambiguous.", "category": "key_value_extraction", "difficulty": "hard"}
{"spec": "Parse ASCII-art tables using '+', '-', and '|' borders into an array of rows where each row is an array of trimmed cell strings, preserving empty cells and original column order.", "category": "table_parsing", "difficulty": "medium"}
{"spec": "Parse a Markdown table that may contain escaped pipes, inline code with pipes, and multiline cells; return rows as arrays and represent internal newlines in cells as '\\n'.", "category": "table_parsing", "difficulty": "hard"}
{"spec": "Parse a URL and return its query parameters as a JSON object mapping each percent-decoded parameter name to an array of percent-decoded values in original order.", "category": "url_query_parsing", "difficulty": "medium"}
{"spec": "Extract all URLs from a text blob, canonicalize them by lowercasing the host, removing default ports, sorting query parameters alphabetically, and return a deduplicated list of normalized URLs.", "category": "url_query_parsing", "difficulty": "hard"}
{"spec": "Repair malformed JSON that may contain single quotes, trailing commas, unquoted keys, and C/JS-style comments and return a valid JSON string or an explicit error if ambiguous changes are required.", "category": "json_fixup", "difficulty": "hard"}
{"spec": "Convert plain text with section headings marked by '##', '###', or 'Section 1:' into a nested JSON outline where each node has 'title' and 'content' and child sections are nested under the nearest higher-level heading.", "category": "markdown_structuring", "difficulty": "medium"}
{"spec": "Extract all quoted substrings (both single and double quotes) preserving escaped quotes and return them as an array in original order.", "category": "parsing_text", "difficulty": "easy"}
{"spec": "Split text into sentences while preventing common English abbreviations (e.g., Mr., Dr., U.S.) from causing sentence breaks and return an array of trimmed sentences.", "category": "parsing_text", "difficulty": "medium"}
{"spec": "Parse an option block where lines start with labels like 'a)', '1.', 'A.' possibly with indented nested suboptions and output a nested JSON array of option objects {key, text, children}.", "category": "option_block_parsing", "difficulty": "medium"}
{"spec": "Given a free-form choices line mixing ranges and lists (e.g., 'Select: a-c, e, g-i'), expand ranges and commas into an explicit ordered list of option labels and validate labels against an allowed set if provided.", "category": "option_block_parsing", "difficulty": "hard"}
{"spec": "From text containing multiple 'Final Answer:' markers, return the text after the last 'Final Answer:' marker trimmed; return an empty string if none found.", "category": "final_answer_extraction", "difficulty": "easy"}
{"spec": "From a multi-turn assistant transcript, extract the last paragraph that is not prefixed by 'Thought:' or 'Reasoning:' and contains at least one sentence-ending punctuation, returning it as the final answer string.", "category": "final_answer_extraction", "difficulty": "medium"}
{"spec": "Convert CSV text to a compact JSON array of objects using the header row; handle quoted fields containing commas and return valid JSON text.", "category": "format_conversion", "difficulty": "easy"}
{"spec": "Convert a Markdown bullet list with nesting via spaces or tabs into a JSON nested array preserving order and item content; support '-' and '*' bullets and multiple nesting levels.", "category": "format_conversion", "difficulty": "medium"}
{"spec": "Convert a fixed-width column text table (no delimiters) into CSV by inferring column boundaries from the header line and aligning subsequent rows to those columns while trimming whitespace.", "category": "format_conversion", "difficulty": "hard"}
{"spec": "Extract balanced parentheses expressions including nested ones from text and return them as an array in order of appearance.", "category": "regex_hard", "difficulty": "hard"}
{"spec": "Validate and extract all IPv6 addresses (including compressed forms and IPv4-embedded) from text and return them as an array of matched strings.", "category": "regex_hard", "difficulty": "hard"}
{"spec": "Normalize dates in common formats (MM/DD/YYYY, DD-MM-YYYY, 'January 2, 2003', '2 Jan 2003') to ISO 8601 dates 'YYYY-MM-DD'; ignore time components and invalid dates.", "category": "date_time_normalization", "difficulty": "medium"}
{"spec": "Parse timestamps with textual time zones (e.g., '2021-07-04 5pm PST', '04 Jul 2021 17:00 UTC+2') and output ISO 8601 datetimes with numeric offset, using a standard mapping for timezone abbreviations.", "category": "date_time_normalization", "difficulty": "hard"}
{"spec": "Convert written English integers up to 'one million' (e.g., 'two thousand thirty-five', 'one hundred and five') into digits and return the numeric string.", "category": "number_normalization", "difficulty": "medium"}
{"spec": "Normalize numeric ranges and lists expressed in words or digits (e.g., 'one to three', '5-7', 'two, four and six') into a sorted unique JSON array of integers.", "category": "number_normalization", "difficulty": "hard"}
{"spec": "Find measurements with simple units in text (e.g., '3.5 kg', '12in', '100 cm') and replace each with its SI base unit equivalent (meters for length, kilograms for mass) rounded to two decimal places.", "category": "unit_conversion", "difficulty": "medium"}
{"spec": "Parse compound measurements like '5 ft 7 in' or '3 lb 4 oz' and convert each into a single metric value with unit (e.g., '1.70 m', '1.49 kg') with sensible rounding.", "category": "unit_conversion", "difficulty": "hard"}
{"spec": "Extract simple 'key: value' pairs from text where each pair is on its own line, trimming whitespace, and return a JSON object mapping keys to values.", "category": "key_value_extraction", "difficulty": "easy"}
{"spec": "From mixed inline and line-separated attribute text (e.g., 'Name=John; Age:30, Location- NYC') extract key-value pairs handling separators '=', ':', '-', ';' and ','; on duplicate keys keep the last value and return a JSON map.", "category": "key_value_extraction", "difficulty": "medium"}
{"spec": "Parse an ASCII/Markdown table with a header and separator line (e.g., pipes and '---') into a JSON array of row objects keyed by header names, trimming cell whitespace.", "category": "table_parsing", "difficulty": "medium"}
{"spec": "Parse irregular space-aligned text tables where rows may omit explicit separators by inferring column boundaries from the header and output CSV rows preserving empty cells.", "category": "table_parsing", "difficulty": "hard"}
{"spec": "Parse a URL query string into a JSON mapping where keys and values are percent-decoded; if a key appears multiple times return an array of values for that key.", "category": "url_query_parsing", "difficulty": "easy"}
{"spec": "Repair near-JSON text by removing trailing commas, converting single quotes to double quotes, stripping JS-style comments, and quoting unquoted object keys; return valid JSON or an error indicator if unrecoverable.", "category": "json_fixup", "difficulty": "medium"}
{"spec": "Extract Markdown headings up to level 3 and output a JSON table of contents array with objects {level, text, line} where line is the 1-based source line number of the heading.", "category": "markdown_structuring", "difficulty": "medium"}
{"spec": "Strip all HTML tags but preserve line breaks for block elements (p, div, br, li, h1-h6) and decode common HTML entities to plain characters.", "category": "html_text_cleanup", "difficulty": "easy"}
{"spec": "Parse a multiline Java stack trace into JSON with fields {exception: \"Class: message\", frames: [{class, method, file, line}], caused_by: nested} capturing nested 'Caused by' chains and frame order.", "category": "log_parsing", "difficulty": "hard"}
