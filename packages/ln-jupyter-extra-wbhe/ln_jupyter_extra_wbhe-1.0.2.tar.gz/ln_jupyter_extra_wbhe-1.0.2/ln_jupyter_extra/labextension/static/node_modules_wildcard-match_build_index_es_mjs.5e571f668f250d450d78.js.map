{"version":3,"file":"node_modules_wildcard-match_build_index_es_mjs.5e571f668f250d450d78.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,wDAAwD,kDAAkD;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;AACpC","sources":["webpack://ln-jupyter-extra/./node_modules/wildcard-match/build/index.es.mjs"],"sourcesContent":["/**\n * Escapes a character if it has a special meaning in regular expressions\n * and returns the character as is if it doesn't\n */\nfunction escapeRegExpChar(char) {\n    if (char === '-' ||\n        char === '^' ||\n        char === '$' ||\n        char === '+' ||\n        char === '.' ||\n        char === '(' ||\n        char === ')' ||\n        char === '|' ||\n        char === '[' ||\n        char === ']' ||\n        char === '{' ||\n        char === '}' ||\n        char === '*' ||\n        char === '?' ||\n        char === '\\\\') {\n        return \"\\\\\".concat(char);\n    }\n    else {\n        return char;\n    }\n}\n/**\n * Escapes all characters in a given string that have a special meaning in regular expressions\n */\nfunction escapeRegExpString(str) {\n    var result = '';\n    for (var i = 0; i < str.length; i++) {\n        result += escapeRegExpChar(str[i]);\n    }\n    return result;\n}\n/**\n * Transforms one or more glob patterns into a RegExp pattern\n */\nfunction transform(pattern, separator) {\n    if (separator === void 0) { separator = true; }\n    if (Array.isArray(pattern)) {\n        var regExpPatterns = pattern.map(function (p) { return \"^\".concat(transform(p, separator), \"$\"); });\n        return \"(?:\".concat(regExpPatterns.join('|'), \")\");\n    }\n    var separatorSplitter = '';\n    var separatorMatcher = '';\n    var wildcard = '.';\n    if (separator === true) {\n        separatorSplitter = '/';\n        separatorMatcher = '[/\\\\\\\\]';\n        wildcard = '[^/\\\\\\\\]';\n    }\n    else if (separator) {\n        separatorSplitter = separator;\n        separatorMatcher = escapeRegExpString(separatorSplitter);\n        if (separatorMatcher.length > 1) {\n            separatorMatcher = \"(?:\".concat(separatorMatcher, \")\");\n            wildcard = \"((?!\".concat(separatorMatcher, \").)\");\n        }\n        else {\n            wildcard = \"[^\".concat(separatorMatcher, \"]\");\n        }\n    }\n    var requiredSeparator = separator ? \"\".concat(separatorMatcher, \"+?\") : '';\n    var optionalSeparator = separator ? \"\".concat(separatorMatcher, \"*?\") : '';\n    var segments = separator ? pattern.split(separatorSplitter) : [pattern];\n    var result = '';\n    for (var s = 0; s < segments.length; s++) {\n        var segment = segments[s];\n        var nextSegment = segments[s + 1];\n        var currentSeparator = '';\n        if (!segment && s > 0) {\n            continue;\n        }\n        if (separator) {\n            if (s === segments.length - 1) {\n                currentSeparator = optionalSeparator;\n            }\n            else if (nextSegment !== '**') {\n                currentSeparator = requiredSeparator;\n            }\n            else {\n                currentSeparator = '';\n            }\n        }\n        if (separator && segment === '**') {\n            if (currentSeparator) {\n                result += s === 0 ? '' : currentSeparator;\n                result += \"(?:\".concat(wildcard, \"*?\").concat(currentSeparator, \")*?\");\n            }\n            continue;\n        }\n        for (var c = 0; c < segment.length; c++) {\n            var char = segment[c];\n            if (char === '\\\\') {\n                if (c < segment.length - 1) {\n                    result += escapeRegExpChar(segment[c + 1]);\n                    c++;\n                }\n            }\n            else if (char === '?') {\n                result += wildcard;\n            }\n            else if (char === '*') {\n                result += \"\".concat(wildcard, \"*?\");\n            }\n            else {\n                result += escapeRegExpChar(char);\n            }\n        }\n        result += currentSeparator;\n    }\n    return result;\n}\n\nfunction isMatch(regexp, sample) {\n    if (typeof sample !== 'string') {\n        throw new TypeError(\"Sample must be a string, but \".concat(typeof sample, \" given\"));\n    }\n    return regexp.test(sample);\n}\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns `true`\n * if the string matches the pattern(s).\n *\n * ```js\n * wildcardMatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = wildcardMatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction wildcardMatch(pattern, options) {\n    if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n        throw new TypeError(\"The first argument must be a single pattern string or an array of patterns, but \".concat(typeof pattern, \" given\"));\n    }\n    if (typeof options === 'string' || typeof options === 'boolean') {\n        options = { separator: options };\n    }\n    if (arguments.length === 2 &&\n        !(typeof options === 'undefined' ||\n            (typeof options === 'object' && options !== null && !Array.isArray(options)))) {\n        throw new TypeError(\"The second argument must be an options object or a string/boolean separator, but \".concat(typeof options, \" given\"));\n    }\n    options = options || {};\n    if (options.separator === '\\\\') {\n        throw new Error('\\\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead');\n    }\n    var regexpPattern = transform(pattern, options.separator);\n    var regexp = new RegExp(\"^\".concat(regexpPattern, \"$\"), options.flags);\n    var fn = isMatch.bind(null, regexp);\n    fn.options = options;\n    fn.pattern = pattern;\n    fn.regexp = regexp;\n    return fn;\n}\n\nexport { wildcardMatch as default };\n//# sourceMappingURL=index.es.mjs.map\n"],"names":[],"sourceRoot":""}