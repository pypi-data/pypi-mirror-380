<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>taulu.grid API documentation</title>
<meta name="description" content="Implements the grid finding algorithm, that is able to find the intersections of horizontal and vertical rules.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<link rel="icon" href="./logo.svg" type="image/svg+xml">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>taulu.grid</code></h1>
</header>
<section id="section-intro">
<p>Implements the grid finding algorithm, that is able to find the intersections of horizontal and vertical rules.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="taulu.grid.circular_median_angle"><code class="name flex">
<span>def <span class="ident">circular_median_angle</span></span>(<span>angles)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circular_median_angle(angles):
    &#34;&#34;&#34;Return the circular median of angles in radians.&#34;&#34;&#34;
    import math

    def circular_distance(a, b):
        diff = abs(a - b) % (2 * math.pi)
        return min(diff, 2 * math.pi - diff)

    angles = [angle % (2 * math.pi) for angle in angles]
    n = len(angles)

    best_median = None
    min_total_distance = float(&#34;inf&#34;)

    # Try each angle as a potential &#34;cut point&#34; for linearization
    for cut_point in angles:
        # Reorder angles relative to this cut point
        reordered = sorted(angles, key=lambda x: (x - cut_point) % (2 * math.pi))

        # Find median in this ordering
        if n % 2 == 1:
            candidate = reordered[n // 2]
        else:
            a1, a2 = reordered[n // 2 - 1], reordered[n // 2]
            # Take circular average of the two middle angles
            diff = (a2 - a1) % (2 * math.pi)
            if diff &gt; math.pi:
                diff = diff - 2 * math.pi
            candidate = (a1 + diff / 2) % (2 * math.pi)

        # Calculate total circular distance to all points
        total_distance = sum(circular_distance(candidate, angle) for angle in angles)

        if total_distance &lt; min_total_distance:
            min_total_distance = total_distance
            best_median = candidate

    return best_median</code></pre>
</details>
<div class="desc"><p>Return the circular median of angles in radians.</p></div>
</dd>
<dt id="taulu.grid.clamp"><code class="name flex">
<span>def <span class="ident">clamp</span></span>(<span>num: float | int, min_bound: float | int, max_bound: float | int) ‑> float | int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clamp(
    num: float | int, min_bound: float | int, max_bound: float | int
) -&gt; float | int:
    return max(min(num, max_bound), min_bound)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.median_slope"><code class="name flex">
<span>def <span class="ident">median_slope</span></span>(<span>lines: List[Tuple[Tuple[float, float], Tuple[float, float]]]) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def median_slope(lines: List[Tuple[PointFloat, PointFloat]]) -&gt; float:
    angles = []

    for (x1, y1), (x2, y2) in lines:
        dx = x2 - x1
        dy = y2 - y1
        angle = math.atan2(dy, dx)
        angles.append(angle)

    median_angle = circular_median_angle(angles)

    # Convert back to slope
    if math.isclose(math.cos(median_angle), 0.0, abs_tol=1e-9):
        return float(&#34;inf&#34;)  # Vertical
    else:
        return math.tan(median_angle)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.vector_average_slope"><code class="name flex">
<span>def <span class="ident">vector_average_slope</span></span>(<span>lines: List[Tuple[Tuple[float, float], Tuple[float, float]]]) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_average_slope(lines: List[Tuple[PointFloat, PointFloat]]) -&gt; float:
    sin_sum = 0
    cos_sum = 0
    for left, right in lines:
        dx = right[0] - left[0]
        dy = right[1] - left[1]
        angle = math.atan2(dy, dx)

        sin_sum += math.sin(angle)
        cos_sum += math.cos(angle)

    avg_angle = math.atan2(sin_sum, cos_sum)

    # Convert back to slope
    if math.isclose(math.cos(avg_angle), 0.0, abs_tol=1e-9):
        return float(&#34;inf&#34;)  # vertical line
    else:
        return math.tan(avg_angle)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="taulu.grid.GridDetector"><code class="flex name class">
<span>class <span class="ident">GridDetector</span></span>
<span>(</span><span>kernel_size: int = 21,<br>cross_width: int = 6,<br>cross_height: int | None = None,<br>morph_size: int | None = None,<br>sauvola_k: float = 0.04,<br>sauvola_window: int = 15,<br>scale: float = 1.0,<br>search_region: int = 40,<br>distance_penalty: float = 0.4,<br>min_rows: int = 5,<br>grow_threshold: float = 0.3,<br>look_distance: int = 4)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GridDetector:
    &#34;&#34;&#34;
    Implements a filters result in high activation where the image has an intersection of a vertical
    and horizontal rule, useful for finding the bounding boxes of cells.

    Also implements the search algorithm that uses the output of this filter to build a tabular structure of
    corner points (in row major order).
    &#34;&#34;&#34;

    def __init__(
        self,
        kernel_size: int = 21,
        cross_width: int = 6,
        cross_height: Optional[int] = None,
        morph_size: Optional[int] = None,
        sauvola_k: float = 0.04,
        sauvola_window: int = 15,
        scale: float = 1.0,
        search_region: int = 40,
        distance_penalty: float = 0.4,
        min_rows: int = 5,
        grow_threshold: float = 0.3,
        look_distance: int = 4,
    ):
        &#34;&#34;&#34;
        Args:
            kernel_size (int): the size of the cross kernel
                a larger kernel size often means that more penalty is applied, often leading
                to more sparse results
            cross_width (int): the width of one of the edges in the cross filter, should be
                roughly equal to the width of the rules in the image after morphology is applied
            cross_height (int | None): useful if the horizontal rules and vertical rules
                have different sizes
            morph_size (int | None): the size of the morphology operators that are applied before
                the cross kernel. &#39;bridges the gaps&#39; of broken-up lines
            sauvola_k (float): threshold parameter for sauvola thresholding
            sauvola_window (int): window_size parameter for sauvola thresholding
            scale (float): image scale factor to do calculations on (useful for increasing calculation speed mostly)
            search_region (int): area in which to search for a new max value in `find_nearest` etc.
            distance_penalty (float): how much the point finding algorithm penalizes points that are further in the region [0, 1]
            min_rows (int): minimum number of rows to find before stopping the table finding algorithm
            grow_threshold (float): the threshold for accepting a new point when growing the table
            look_distance (int): how many points away to look when calculating the median slope
        &#34;&#34;&#34;
        self._validate_parameters(
            kernel_size,
            cross_width,
            cross_height,
            morph_size,
            search_region,
            sauvola_k,
            sauvola_window,
            distance_penalty,
        )

        self._kernel_size = kernel_size
        self._cross_width = cross_width
        self._cross_height = cross_width if cross_height is None else cross_height
        self._morph_size = morph_size if morph_size is not None else cross_width
        self._search_region = search_region
        self._sauvola_k = sauvola_k
        self._sauvola_window = sauvola_window
        self._distance_penalty = distance_penalty
        self._scale = scale
        self._min_rows = min_rows
        self._grow_threshold = grow_threshold
        self._look_distance = look_distance

        self._cross_kernel = self._create_cross_kernel()

    def _validate_parameters(
        self,
        kernel_size: int,
        cross_width: int,
        cross_height: Optional[int],
        morph_size: Optional[int],
        search_region: int,
        sauvola_k: float,
        sauvola_window: int,
        distance_penalty: float,
    ) -&gt; None:
        &#34;&#34;&#34;Validate initialization parameters.&#34;&#34;&#34;
        if kernel_size % 2 == 0:
            raise ValueError(&#34;kernel_size must be odd&#34;)
        if (
            kernel_size &lt;= 0
            or cross_width &lt;= 0
            or search_region &lt;= 0
            or sauvola_window &lt;= 0
        ):
            raise ValueError(&#34;Size parameters must be positive&#34;)
        if cross_height is not None and cross_height &lt;= 0:
            raise ValueError(&#34;cross_height must be positive&#34;)
        if morph_size is not None and morph_size &lt;= 0:
            raise ValueError(&#34;morph_size must be positive&#34;)
        if not 0 &lt;= distance_penalty &lt;= 1:
            raise ValueError(&#34;distance_penalty must be in [0, 1]&#34;)
        if sauvola_k &lt;= 0:
            raise ValueError(&#34;sauvola_k must be positive&#34;)

    def _create_gaussian_weights(self, region_size: int) -&gt; NDArray:
        &#34;&#34;&#34;
        Create a 2D Gaussian weight mask.

        Args:
            shape (tuple[int, int]): Shape of the region (height, width)
            p (float): Minimum value at the edge = 1 - p

        Returns:
            NDArray: Gaussian weight mask
        &#34;&#34;&#34;
        if self._distance_penalty == 0:
            return np.ones((region_size, region_size), dtype=np.float32)

        y = np.linspace(-1, 1, region_size)
        x = np.linspace(-1, 1, region_size)
        xv, yv = np.meshgrid(x, y)
        dist_squared = xv**2 + yv**2

        # Prevent log(0) when distance_penalty is 1
        if self._distance_penalty &gt;= 0.999:
            sigma = 0.1  # Small sigma for very sharp peak
        else:
            sigma = np.sqrt(-1 / (2 * np.log(1 - self._distance_penalty)))

        weights = np.exp(-dist_squared / (2 * sigma**2))

        return weights.astype(np.float32)

    def _create_cross_kernel(self) -&gt; NDArray:
        kernel = np.zeros((self._kernel_size, self._kernel_size), dtype=np.uint8)
        center = self._kernel_size // 2

        # Create horizontal bar
        h_start = max(0, center - self._cross_height // 2)
        h_end = min(self._kernel_size, center + (self._cross_height + 1) // 2)
        kernel[h_start:h_end, :] = 255

        # Create vertical bar
        v_start = max(0, center - self._cross_width // 2)
        v_end = min(self._kernel_size, center + (self._cross_width + 1) // 2)
        kernel[:, v_start:v_end] = 255

        return kernel

    def _apply_morphology(self, binary: MatLike) -&gt; MatLike:
        # Define a horizontal kernel (adjust width as needed)
        kernel_hor = cv.getStructuringElement(cv.MORPH_RECT, (self._morph_size, 1))
        kernel_ver = cv.getStructuringElement(cv.MORPH_RECT, (1, self._morph_size))

        # Apply dilation
        dilated = cv.dilate(binary, kernel_hor, iterations=1)
        dilated = cv.dilate(dilated, kernel_ver, iterations=1)

        return dilated

    def _apply_cross_matching(self, img: MatLike) -&gt; MatLike:
        &#34;&#34;&#34;Apply cross kernel template matching.&#34;&#34;&#34;
        pad_y = self._cross_kernel.shape[0] // 2
        pad_x = self._cross_kernel.shape[1] // 2

        padded = cv.copyMakeBorder(
            img, pad_y, pad_y, pad_x, pad_x, borderType=cv.BORDER_CONSTANT, value=0
        )

        filtered = cv.matchTemplate(padded, self._cross_kernel, cv.TM_SQDIFF_NORMED)
        # Invert and normalize to 0-255 range
        filtered = cv.normalize(1.0 - filtered, None, 0, 255, cv.NORM_MINMAX)
        return filtered.astype(np.uint8)

    def apply(self, img: MatLike, visual: bool = False) -&gt; MatLike:
        &#34;&#34;&#34;
        Apply the grid detection filter to the input image.

        Args:
            img (MatLike): the input image
            visual (bool): whether to show intermediate steps

        Returns:
            MatLike: the filtered image, with high values (whiter pixels) at intersections of horizontal and vertical rules
        &#34;&#34;&#34;

        if img is None or img.size == 0:
            raise ValueError(&#34;Input image is empty or None&#34;)

        binary = imu.sauvola(img, k=self._sauvola_k, window_size=self._sauvola_window)

        if visual:
            imu.show(binary, title=&#34;thresholded&#34;)

        binary = self._apply_morphology(binary)

        if visual:
            imu.show(binary, title=&#34;dilated&#34;)

        filtered = self._apply_cross_matching(binary)

        return filtered

    @log_calls(level=logging.DEBUG, include_return=True)
    def find_nearest(
        self, filtered: MatLike, point: Point, region: Optional[int] = None
    ) -&gt; Tuple[Point, float]:
        &#34;&#34;&#34;
        Find the nearest &#39;corner match&#39; in the image, along with its score [0,1]

        Args:
            filtered (MatLike): the filtered image (obtained through `apply`)
            point (tuple[int, int]): the approximate target point (x, y)
            region (None | int): alternative value for search region,
                overwriting the `__init__` parameter `region`
        &#34;&#34;&#34;

        if filtered is None or filtered.size == 0:
            raise ValueError(&#34;Filtered image is empty or None&#34;)

        region_size = region if region is not None else self._search_region
        x, y = point

        # Calculate crop boundaries
        crop_x = max(0, x - region_size // 2)
        crop_y = max(0, y - region_size // 2)
        crop_width = min(region_size, filtered.shape[1] - crop_x)
        crop_height = min(region_size, filtered.shape[0] - crop_y)

        # Handle edge cases
        if crop_width &lt;= 0 or crop_height &lt;= 0:
            logger.warning(f&#34;Point {point} is outside image bounds&#34;)
            return point, 0.0

        cropped = filtered[crop_y : crop_y + crop_height, crop_x : crop_x + crop_width]

        if cropped.size == 0:
            return point, 0.0

        # Always apply Gaussian weighting by extending crop if needed
        if cropped.shape[0] == region_size and cropped.shape[1] == region_size:
            # Perfect size - apply weights directly
            weights = self._create_gaussian_weights(region_size)
            weighted = cropped.astype(np.float32) * weights
        else:
            # Extend crop to match region_size, apply weights, then restore
            extended = np.zeros((region_size, region_size), dtype=cropped.dtype)

            # Calculate offset to center the cropped region in extended array
            offset_y = (region_size - cropped.shape[0]) // 2
            offset_x = (region_size - cropped.shape[1]) // 2

            # Place cropped region in center of extended array
            extended[
                offset_y : offset_y + cropped.shape[0],
                offset_x : offset_x + cropped.shape[1],
            ] = cropped

            # Apply Gaussian weights to extended array
            weights = self._create_gaussian_weights(region_size)
            weighted_extended = extended.astype(np.float32) * weights

            # Extract the original region back out
            weighted = weighted_extended[
                offset_y : offset_y + cropped.shape[0],
                offset_x : offset_x + cropped.shape[1],
            ]

        best_idx = np.argmax(weighted)
        best_y, best_x = np.unravel_index(best_idx, cropped.shape)

        result_point = (
            int(crop_x + best_x),
            int(crop_y + best_y),
        )
        result_confidence = float(weighted[best_y, best_x]) / 255.0

        return result_point, result_confidence

    def find_table_points(
        self,
        img: MatLike | PathLike[str],
        left_top: Point,
        cell_widths: list[int],
        cell_heights: list[int] | int,
        visual: bool = False,
        window: str = WINDOW,
        goals_width: Optional[int] = None,
    ) -&gt; &#34;TableGrid&#34;:
        &#34;&#34;&#34;
        Parse the image to a `TableGrid` structure that holds all of the
        intersections between horizontal and vertical rules, starting near the `left_top` point

        Args:
            img (MatLike): the input image of a table
            left_top (tuple[int, int]): the starting point of the algorithm
            cell_widths (list[int]): the expected widths of the cells (based on a header template)
            cell_heights (list[int]): the expected height of the rows of data.
                The last value from this list is used until the image has no more vertical space.
            visual (bool): whether to show intermediate steps
            window (str): the name of the OpenCV window to use for visualization
            goals_width (int | None): the width of the goal region when searching for the next point.
                If None, defaults to 1.5 * search_region

        Returns:
            a TableGrid object
        &#34;&#34;&#34;

        if goals_width is None:
            goals_width = self._search_region * 3 // 2

        if not cell_widths:
            raise ValueError(&#34;cell_widths must contain at least one value&#34;)

        if not isinstance(img, np.ndarray):
            img = cv.imread(os.fspath(img))

        filtered = self.apply(img, visual)

        if visual:
            imu.show(filtered, window=window)

        if isinstance(cell_heights, int):
            cell_heights = [cell_heights]

        left_top, confidence = self.find_nearest(
            filtered, left_top, int(self._search_region * 3)
        )

        if confidence &lt; 0.1:
            logger.warning(
                f&#34;Low confidence for the starting point: {confidence} at {left_top}&#34;
            )

        # resize all parameters according to scale
        img = cv.resize(img, None, fx=self._scale, fy=self._scale)

        if visual:
            imu.push(img)

        filtered = cv.resize(filtered, None, fx=self._scale, fy=self._scale)
        cell_widths = [int(w * self._scale) for w in cell_widths]
        cell_heights = [int(h * self._scale) for h in cell_heights]
        left_top = (int(left_top[0] * self._scale), int(left_top[1] * self._scale))
        self._search_region = int(self._search_region * self._scale)

        img_gray = ensure_gray(img)
        filtered_gray = ensure_gray(filtered)

        table_grower = TableGrower(
            img_gray,
            filtered_gray,
            cell_widths,  # pyright: ignore
            cell_heights,  # pyright: ignore
            left_top,
            self._search_region,
            self._distance_penalty,
            self._look_distance,
            self._grow_threshold,
            self._min_rows,
        )

        def show_grower_progress(wait: bool = False):
            img_orig = np.copy(img)
            corners = table_grower.get_all_corners()
            for y in range(len(corners)):
                for x in range(len(corners[y])):
                    if corners[y][x] is not None:
                        img_orig = imu.draw_points(
                            img_orig,
                            [corners[y][x]],
                            color=(0, 0, 255),
                            thickness=30,
                        )

            edge = table_grower.get_edge_points()

            for point, score in edge:
                color = (100, int(clamp(score * 255, 0, 255)), 100)
                imu.draw_point(img_orig, point, color=color, thickness=20)

            imu.show(img_orig, wait=wait)

        if visual:
            threshold = self._grow_threshold
            look_distance = self._look_distance

            # python implementation of rust loops, for visualization purposes
            # note this is a LOT slower
            while table_grower.grow_point(img_gray, filtered_gray) is not None:
                show_grower_progress()

            show_grower_progress(True)

            original_threshold = threshold

            loops_without_change = 0

            while not table_grower.is_table_complete():
                loops_without_change += 1

                if loops_without_change &gt; 50:
                    break

                if table_grower.extrapolate_one(img_gray, filtered_gray) is not None:
                    show_grower_progress()

                    loops_without_change = 0

                    grown = False
                    while table_grower.grow_point(img_gray, filtered_gray) is not None:
                        show_grower_progress()
                        grown = True
                        threshold = min(0.1 + 0.9 * threshold, original_threshold)
                        table_grower.set_threshold(threshold)

                    if not grown:
                        threshold *= 0.9
                        table_grower.set_threshold(threshold)

                else:
                    threshold *= 0.9
                    table_grower.set_threshold(threshold)

                    if table_grower.grow_point(img_gray, filtered_gray) is not None:
                        show_grower_progress()
                        loops_without_change = 0

        else:
            table_grower.grow_table(img_gray, filtered_gray)

        table_grower.smooth_grid()
        corners = table_grower.get_all_corners()
        logger.info(
            f&#34;Table growth complete, found {len(corners)} rows and {len(corners[0])} columns&#34;
        )
        # rescale corners back to original size
        if self._scale != 1.0:
            for y in range(len(corners)):
                for x in range(len(corners[y])):
                    if corners[y][x] is not None:
                        corners[y][x] = (
                            int(corners[y][x][0] / self._scale),  # pyright:ignore
                            int(corners[y][x][1] / self._scale),  # pyright:ignore
                        )

        return TableGrid(corners)  # pyright: ignore

    @log_calls(level=logging.DEBUG, include_return=True)
    def _build_table_row(
        self,
        gray: MatLike,
        filtered: MatLike,
        start_point: Point,
        cell_widths: List[int],
        row_idx: int,
        goals_width: int,
        previous_row_points: Optional[List[Point]] = None,
        visual: bool = False,
    ) -&gt; List[Point]:
        &#34;&#34;&#34;Build a single row of table points.&#34;&#34;&#34;
        row = [start_point]
        current = start_point

        for col_idx, width in enumerate(cell_widths):
            next_point = self._find_next_column_point(
                gray,
                filtered,
                current,
                width,
                goals_width,
                visual,
                previous_row_points,
                col_idx,
            )
            if next_point is None:
                logger.warning(
                    f&#34;Could not find point for row {row_idx}, col {col_idx + 1}&#34;
                )
                return []  # Return empty list to signal failure
            row.append(next_point)
            current = next_point

        return row

    def _clamp_point_to_img(self, point: Point, img: MatLike) -&gt; Point:
        &#34;&#34;&#34;Clamp a point to be within the image bounds.&#34;&#34;&#34;
        x = max(0, min(point[0], img.shape[1] - 1))
        y = max(0, min(point[1], img.shape[0] - 1))
        return (x, y)

    @log_calls(level=logging.DEBUG, include_return=True)
    def _find_next_column_point(
        self,
        gray: MatLike,
        filtered: MatLike,
        current: Point,
        width: int,
        goals_width: int,
        visual: bool = False,
        previous_row_points: Optional[List[Point]] = None,
        current_col_idx: int = 0,
    ) -&gt; Optional[Point]:
        &#34;&#34;&#34;Find the next point in the current row.&#34;&#34;&#34;

        if previous_row_points is not None and current_col_idx + 1 &lt; len(
            previous_row_points
        ):
            # grow an astar path downwards from the previous row point that is
            # above and to the right of current
            # and ensure all points are within image bounds
            bottom_right = [
                self._clamp_point_to_img(
                    (
                        current[0] + width - goals_width // 2 + x,
                        current[1] + goals_width,
                    ),
                    gray,
                )
                for x in range(goals_width)
            ]
            goals = self._astar(
                gray, previous_row_points[current_col_idx + 1], bottom_right, &#34;down&#34;
            )

            if goals is None:
                logger.warning(
                    f&#34;A* failed to find path going downwards from previous row&#39;s point at idx {current_col_idx + 1}&#34;
                )
                return None
        else:
            goals = [
                self._clamp_point_to_img(
                    (current[0] + width, current[1] - goals_width // 2 + y), gray
                )
                for y in range(goals_width)
            ]

        path = self._astar(gray, current, goals, &#34;right&#34;)

        if path is None:
            logger.warning(
                f&#34;A* failed to find path going rightward from {current} to goals&#34;
            )
            return None

        next_point, _ = self.find_nearest(filtered, path[-1], self._search_region)

        # show the point and the search region on the image for debugging
        if visual:
            self._visualize_path_finding(
                goals + path,
                current,
                next_point,
                current,
                path[-1],
                self._search_region,
            )

        return next_point

    @log_calls(level=logging.DEBUG, include_return=True)
    def _find_next_row_start(
        self,
        gray: MatLike,
        filtered: MatLike,
        top_point: Point,
        row_idx: int,
        cell_heights: List[int],
        goals_width: int,
        visual: bool = False,
    ) -&gt; Optional[Point]:
        &#34;&#34;&#34;Find the starting point of the next row.&#34;&#34;&#34;
        if row_idx &lt; len(cell_heights):
            row_height = cell_heights[row_idx]
        else:
            row_height = cell_heights[-1]

        if top_point[1] + row_height &gt;= filtered.shape[0] - 10:  # Near bottom
            return None

        goals = [
            (top_point[0] - goals_width // 2 + x, top_point[1] + row_height)
            for x in range(goals_width)
        ]

        path = self._astar(gray, top_point, goals, &#34;down&#34;)
        if path is None:
            return None

        next_point, _ = self.find_nearest(
            filtered, path[-1], region=self._search_region * 3 // 2
        )

        if visual:
            self._visualize_path_finding(
                path, top_point, next_point, top_point, path[-1], self._search_region
            )

        return next_point

    def _visualize_grid(self, img: MatLike, points: List[List[Point]]) -&gt; None:
        &#34;&#34;&#34;Visualize the detected grid points.&#34;&#34;&#34;
        all_points = [point for row in points for point in row]
        drawn = imu.draw_points(img, all_points)
        imu.show(drawn, wait=True)

    def _visualize_path_finding(
        self,
        path: List[Point],
        current: Point,
        next_point: Point,
        previous_row_target: Optional[Point] = None,
        region_center: Optional[Point] = None,
        region_size: Optional[int] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Visualize the path finding process for debugging.&#34;&#34;&#34;
        global show_time

        screen = imu.pop()

        # if gray, convert to BGR
        if len(screen.shape) == 2 or screen.shape[2] == 1:
            debug_img = cv.cvtColor(screen, cv.COLOR_GRAY2BGR)
        else:
            debug_img = cast(MatLike, screen)

        debug_img = imu.draw_points(debug_img, path, color=(200, 200, 0), thickness=2)
        debug_img = imu.draw_points(
            debug_img, [current], color=(0, 255, 0), thickness=3
        )
        debug_img = imu.draw_points(
            debug_img, [next_point], color=(0, 0, 255), thickness=2
        )

        # Draw previous row target if available
        if previous_row_target is not None:
            debug_img = imu.draw_points(
                debug_img, [previous_row_target], color=(255, 0, 255), thickness=2
            )

        # Draw search region if available
        if region_center is not None and region_size is not None:
            top_left = (
                max(0, region_center[0] - region_size // 2),
                max(0, region_center[1] - region_size // 2),
            )
            bottom_right = (
                min(debug_img.shape[1], region_center[0] + region_size // 2),
                min(debug_img.shape[0], region_center[1] + region_size // 2),
            )
            cv.rectangle(
                debug_img,
                top_left,
                bottom_right,
                color=(255, 0, 0),
                thickness=2,
                lineType=cv.LINE_AA,
            )

        imu.push(debug_img)

        show_time += 1
        if show_time % 10 != 1:
            return

        imu.show(debug_img, title=&#34;Next column point&#34;, wait=False)
        # time.sleep(0.003)

    @log_calls(level=logging.DEBUG, include_return=True)
    def _astar(
        self,
        img: np.ndarray,
        start: tuple[int, int],
        goals: list[tuple[int, int]],
        direction: str,
    ) -&gt; Optional[List[Point]]:
        &#34;&#34;&#34;
        Find the best path between the start point and one of the goal points on the image
        &#34;&#34;&#34;

        if not goals:
            return None

        if self._scale != 1.0:
            img = cv.resize(img, None, fx=self._scale, fy=self._scale)
            start = (int(start[0] * self._scale), int(start[1] * self._scale))
            goals = [(int(g[0] * self._scale), int(g[1] * self._scale)) for g in goals]

        # calculate bounding box with margin
        all_points = goals + [start]
        xs = [p[0] for p in all_points]
        ys = [p[1] for p in all_points]

        margin = 30
        top_left = (max(0, min(xs) - margin), max(0, min(ys) - margin))
        bottom_right = (
            min(img.shape[1], max(xs) + margin),
            min(img.shape[0], max(ys) + margin),
        )

        # check bounds
        if (
            top_left[0] &gt;= bottom_right[0]
            or top_left[1] &gt;= bottom_right[1]
            or top_left[0] &gt;= img.shape[1]
            or top_left[1] &gt;= img.shape[0]
        ):
            return None

        # transform coordinates to cropped image
        start_local = (start[0] - top_left[0], start[1] - top_left[1])
        goals_local = [(g[0] - top_left[0], g[1] - top_left[1]) for g in goals]

        cropped = img[top_left[1] : bottom_right[1], top_left[0] : bottom_right[0]]

        if cropped.size == 0:
            return None

        path = rust_astar(cropped, start_local, goals_local, direction)

        if path is None:
            return None

        if self._scale != 1.0:
            path = [(int(p[0] / self._scale), int(p[1] / self._scale)) for p in path]
            top_left = (int(top_left[0] / self._scale), int(top_left[1] / self._scale))

        return [(p[0] + top_left[0], p[1] + top_left[1]) for p in path]</code></pre>
</details>
<div class="desc"><p>Implements a filters result in high activation where the image has an intersection of a vertical
and horizontal rule, useful for finding the bounding boxes of cells.</p>
<p>Also implements the search algorithm that uses the output of this filter to build a tabular structure of
corner points (in row major order).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kernel_size</code></strong> :&ensp;<code>int</code></dt>
<dd>the size of the cross kernel
a larger kernel size often means that more penalty is applied, often leading
to more sparse results</dd>
<dt><strong><code>cross_width</code></strong> :&ensp;<code>int</code></dt>
<dd>the width of one of the edges in the cross filter, should be
roughly equal to the width of the rules in the image after morphology is applied</dd>
<dt><strong><code>cross_height</code></strong> :&ensp;<code>int | None</code></dt>
<dd>useful if the horizontal rules and vertical rules
have different sizes</dd>
<dt><strong><code>morph_size</code></strong> :&ensp;<code>int | None</code></dt>
<dd>the size of the morphology operators that are applied before
the cross kernel. 'bridges the gaps' of broken-up lines</dd>
<dt><strong><code>sauvola_k</code></strong> :&ensp;<code>float</code></dt>
<dd>threshold parameter for sauvola thresholding</dd>
<dt><strong><code>sauvola_window</code></strong> :&ensp;<code>int</code></dt>
<dd>window_size parameter for sauvola thresholding</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code></dt>
<dd>image scale factor to do calculations on (useful for increasing calculation speed mostly)</dd>
<dt><strong><code>search_region</code></strong> :&ensp;<code>int</code></dt>
<dd>area in which to search for a new max value in <code>find_nearest</code> etc.</dd>
<dt><strong><code>distance_penalty</code></strong> :&ensp;<code>float</code></dt>
<dd>how much the point finding algorithm penalizes points that are further in the region [0, 1]</dd>
<dt><strong><code>min_rows</code></strong> :&ensp;<code>int</code></dt>
<dd>minimum number of rows to find before stopping the table finding algorithm</dd>
<dt><strong><code>grow_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>the threshold for accepting a new point when growing the table</dd>
<dt><strong><code>look_distance</code></strong> :&ensp;<code>int</code></dt>
<dd>how many points away to look when calculating the median slope</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="taulu.grid.GridDetector.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, img: cv2.Mat | numpy.ndarray, visual: bool = False) ‑> cv2.Mat | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, img: MatLike, visual: bool = False) -&gt; MatLike:
    &#34;&#34;&#34;
    Apply the grid detection filter to the input image.

    Args:
        img (MatLike): the input image
        visual (bool): whether to show intermediate steps

    Returns:
        MatLike: the filtered image, with high values (whiter pixels) at intersections of horizontal and vertical rules
    &#34;&#34;&#34;

    if img is None or img.size == 0:
        raise ValueError(&#34;Input image is empty or None&#34;)

    binary = imu.sauvola(img, k=self._sauvola_k, window_size=self._sauvola_window)

    if visual:
        imu.show(binary, title=&#34;thresholded&#34;)

    binary = self._apply_morphology(binary)

    if visual:
        imu.show(binary, title=&#34;dilated&#34;)

    filtered = self._apply_cross_matching(binary)

    return filtered</code></pre>
</details>
<div class="desc"><p>Apply the grid detection filter to the input image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>img</code></strong> :&ensp;<code>MatLike</code></dt>
<dd>the input image</dd>
<dt><strong><code>visual</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to show intermediate steps</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>MatLike</code></dt>
<dd>the filtered image, with high values (whiter pixels) at intersections of horizontal and vertical rules</dd>
</dl></div>
</dd>
<dt id="taulu.grid.GridDetector.find_nearest"><code class="name flex">
<span>def <span class="ident">find_nearest</span></span>(<span>self,<br>filtered: cv2.Mat | numpy.ndarray,<br>point: Tuple[int, int],<br>region: int | None = None) ‑> Tuple[Tuple[int, int], float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log_calls(level=logging.DEBUG, include_return=True)
def find_nearest(
    self, filtered: MatLike, point: Point, region: Optional[int] = None
) -&gt; Tuple[Point, float]:
    &#34;&#34;&#34;
    Find the nearest &#39;corner match&#39; in the image, along with its score [0,1]

    Args:
        filtered (MatLike): the filtered image (obtained through `apply`)
        point (tuple[int, int]): the approximate target point (x, y)
        region (None | int): alternative value for search region,
            overwriting the `__init__` parameter `region`
    &#34;&#34;&#34;

    if filtered is None or filtered.size == 0:
        raise ValueError(&#34;Filtered image is empty or None&#34;)

    region_size = region if region is not None else self._search_region
    x, y = point

    # Calculate crop boundaries
    crop_x = max(0, x - region_size // 2)
    crop_y = max(0, y - region_size // 2)
    crop_width = min(region_size, filtered.shape[1] - crop_x)
    crop_height = min(region_size, filtered.shape[0] - crop_y)

    # Handle edge cases
    if crop_width &lt;= 0 or crop_height &lt;= 0:
        logger.warning(f&#34;Point {point} is outside image bounds&#34;)
        return point, 0.0

    cropped = filtered[crop_y : crop_y + crop_height, crop_x : crop_x + crop_width]

    if cropped.size == 0:
        return point, 0.0

    # Always apply Gaussian weighting by extending crop if needed
    if cropped.shape[0] == region_size and cropped.shape[1] == region_size:
        # Perfect size - apply weights directly
        weights = self._create_gaussian_weights(region_size)
        weighted = cropped.astype(np.float32) * weights
    else:
        # Extend crop to match region_size, apply weights, then restore
        extended = np.zeros((region_size, region_size), dtype=cropped.dtype)

        # Calculate offset to center the cropped region in extended array
        offset_y = (region_size - cropped.shape[0]) // 2
        offset_x = (region_size - cropped.shape[1]) // 2

        # Place cropped region in center of extended array
        extended[
            offset_y : offset_y + cropped.shape[0],
            offset_x : offset_x + cropped.shape[1],
        ] = cropped

        # Apply Gaussian weights to extended array
        weights = self._create_gaussian_weights(region_size)
        weighted_extended = extended.astype(np.float32) * weights

        # Extract the original region back out
        weighted = weighted_extended[
            offset_y : offset_y + cropped.shape[0],
            offset_x : offset_x + cropped.shape[1],
        ]

    best_idx = np.argmax(weighted)
    best_y, best_x = np.unravel_index(best_idx, cropped.shape)

    result_point = (
        int(crop_x + best_x),
        int(crop_y + best_y),
    )
    result_confidence = float(weighted[best_y, best_x]) / 255.0

    return result_point, result_confidence</code></pre>
</details>
<div class="desc"><p>Find the nearest 'corner match' in the image, along with its score [0,1]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filtered</code></strong> :&ensp;<code>MatLike</code></dt>
<dd>the filtered image (obtained through <code>apply</code>)</dd>
<dt><strong><code>point</code></strong> :&ensp;<code>tuple[int, int]</code></dt>
<dd>the approximate target point (x, y)</dd>
<dt><strong><code>region</code></strong> :&ensp;<code>None | int</code></dt>
<dd>alternative value for search region,
overwriting the <code>__init__</code> parameter <code>region</code></dd>
</dl></div>
</dd>
<dt id="taulu.grid.GridDetector.find_table_points"><code class="name flex">
<span>def <span class="ident">find_table_points</span></span>(<span>self,<br>img: cv2.Mat | numpy.ndarray | os.PathLike[str],<br>left_top: Tuple[int, int],<br>cell_widths: list[int],<br>cell_heights: list[int] | int,<br>visual: bool = False,<br>window: str = 'taulu',<br>goals_width: int | None = None) ‑> <a title="taulu.grid.TableGrid" href="#taulu.grid.TableGrid">TableGrid</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_table_points(
    self,
    img: MatLike | PathLike[str],
    left_top: Point,
    cell_widths: list[int],
    cell_heights: list[int] | int,
    visual: bool = False,
    window: str = WINDOW,
    goals_width: Optional[int] = None,
) -&gt; &#34;TableGrid&#34;:
    &#34;&#34;&#34;
    Parse the image to a `TableGrid` structure that holds all of the
    intersections between horizontal and vertical rules, starting near the `left_top` point

    Args:
        img (MatLike): the input image of a table
        left_top (tuple[int, int]): the starting point of the algorithm
        cell_widths (list[int]): the expected widths of the cells (based on a header template)
        cell_heights (list[int]): the expected height of the rows of data.
            The last value from this list is used until the image has no more vertical space.
        visual (bool): whether to show intermediate steps
        window (str): the name of the OpenCV window to use for visualization
        goals_width (int | None): the width of the goal region when searching for the next point.
            If None, defaults to 1.5 * search_region

    Returns:
        a TableGrid object
    &#34;&#34;&#34;

    if goals_width is None:
        goals_width = self._search_region * 3 // 2

    if not cell_widths:
        raise ValueError(&#34;cell_widths must contain at least one value&#34;)

    if not isinstance(img, np.ndarray):
        img = cv.imread(os.fspath(img))

    filtered = self.apply(img, visual)

    if visual:
        imu.show(filtered, window=window)

    if isinstance(cell_heights, int):
        cell_heights = [cell_heights]

    left_top, confidence = self.find_nearest(
        filtered, left_top, int(self._search_region * 3)
    )

    if confidence &lt; 0.1:
        logger.warning(
            f&#34;Low confidence for the starting point: {confidence} at {left_top}&#34;
        )

    # resize all parameters according to scale
    img = cv.resize(img, None, fx=self._scale, fy=self._scale)

    if visual:
        imu.push(img)

    filtered = cv.resize(filtered, None, fx=self._scale, fy=self._scale)
    cell_widths = [int(w * self._scale) for w in cell_widths]
    cell_heights = [int(h * self._scale) for h in cell_heights]
    left_top = (int(left_top[0] * self._scale), int(left_top[1] * self._scale))
    self._search_region = int(self._search_region * self._scale)

    img_gray = ensure_gray(img)
    filtered_gray = ensure_gray(filtered)

    table_grower = TableGrower(
        img_gray,
        filtered_gray,
        cell_widths,  # pyright: ignore
        cell_heights,  # pyright: ignore
        left_top,
        self._search_region,
        self._distance_penalty,
        self._look_distance,
        self._grow_threshold,
        self._min_rows,
    )

    def show_grower_progress(wait: bool = False):
        img_orig = np.copy(img)
        corners = table_grower.get_all_corners()
        for y in range(len(corners)):
            for x in range(len(corners[y])):
                if corners[y][x] is not None:
                    img_orig = imu.draw_points(
                        img_orig,
                        [corners[y][x]],
                        color=(0, 0, 255),
                        thickness=30,
                    )

        edge = table_grower.get_edge_points()

        for point, score in edge:
            color = (100, int(clamp(score * 255, 0, 255)), 100)
            imu.draw_point(img_orig, point, color=color, thickness=20)

        imu.show(img_orig, wait=wait)

    if visual:
        threshold = self._grow_threshold
        look_distance = self._look_distance

        # python implementation of rust loops, for visualization purposes
        # note this is a LOT slower
        while table_grower.grow_point(img_gray, filtered_gray) is not None:
            show_grower_progress()

        show_grower_progress(True)

        original_threshold = threshold

        loops_without_change = 0

        while not table_grower.is_table_complete():
            loops_without_change += 1

            if loops_without_change &gt; 50:
                break

            if table_grower.extrapolate_one(img_gray, filtered_gray) is not None:
                show_grower_progress()

                loops_without_change = 0

                grown = False
                while table_grower.grow_point(img_gray, filtered_gray) is not None:
                    show_grower_progress()
                    grown = True
                    threshold = min(0.1 + 0.9 * threshold, original_threshold)
                    table_grower.set_threshold(threshold)

                if not grown:
                    threshold *= 0.9
                    table_grower.set_threshold(threshold)

            else:
                threshold *= 0.9
                table_grower.set_threshold(threshold)

                if table_grower.grow_point(img_gray, filtered_gray) is not None:
                    show_grower_progress()
                    loops_without_change = 0

    else:
        table_grower.grow_table(img_gray, filtered_gray)

    table_grower.smooth_grid()
    corners = table_grower.get_all_corners()
    logger.info(
        f&#34;Table growth complete, found {len(corners)} rows and {len(corners[0])} columns&#34;
    )
    # rescale corners back to original size
    if self._scale != 1.0:
        for y in range(len(corners)):
            for x in range(len(corners[y])):
                if corners[y][x] is not None:
                    corners[y][x] = (
                        int(corners[y][x][0] / self._scale),  # pyright:ignore
                        int(corners[y][x][1] / self._scale),  # pyright:ignore
                    )

    return TableGrid(corners)  # pyright: ignore</code></pre>
</details>
<div class="desc"><p>Parse the image to a <code><a title="taulu.grid.TableGrid" href="#taulu.grid.TableGrid">TableGrid</a></code> structure that holds all of the
intersections between horizontal and vertical rules, starting near the <code>left_top</code> point</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>img</code></strong> :&ensp;<code>MatLike</code></dt>
<dd>the input image of a table</dd>
<dt><strong><code>left_top</code></strong> :&ensp;<code>tuple[int, int]</code></dt>
<dd>the starting point of the algorithm</dd>
<dt><strong><code>cell_widths</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>the expected widths of the cells (based on a header template)</dd>
<dt><strong><code>cell_heights</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>the expected height of the rows of data.
The last value from this list is used until the image has no more vertical space.</dd>
<dt><strong><code>visual</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to show intermediate steps</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the OpenCV window to use for visualization</dd>
<dt><strong><code>goals_width</code></strong> :&ensp;<code>int | None</code></dt>
<dd>the width of the goal region when searching for the next point.
If None, defaults to 1.5 * search_region</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a TableGrid object</p></div>
</dd>
</dl>
</dd>
<dt id="taulu.grid.TableGrid"><code class="flex name class">
<span>class <span class="ident">TableGrid</span></span>
<span>(</span><span>points: list[list[typing.Tuple[int, int]]], right_offset: int | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableGrid(TableIndexer):
    &#34;&#34;&#34;
    A data class that allows segmenting the image into cells
    &#34;&#34;&#34;

    _right_offset: int | None = None

    def __init__(self, points: list[list[Point]], right_offset: Optional[int] = None):
        &#34;&#34;&#34;
        Args:
            points: a 2D list of intersections between hor. and vert. rules
        &#34;&#34;&#34;
        self._points = points
        self._right_offset = right_offset

    @property
    def points(self) -&gt; list[list[Point]]:
        return self._points

    def row(self, i: int) -&gt; list[Point]:
        assert 0 &lt;= i and i &lt; len(self._points)
        return self._points[i]

    @property
    def cols(self) -&gt; int:
        if self._right_offset is not None:
            return len(self.row(0)) - 2
        else:
            return len(self.row(0)) - 1

    @property
    def rows(self) -&gt; int:
        return len(self._points) - 1

    @staticmethod
    def from_split(
        split_grids: Split[&#34;TableGrid&#34;], offsets: Split[Point]
    ) -&gt; &#34;TableGrid&#34;:
        &#34;&#34;&#34;
        Convert two ``TableGrid`` objects into one, that is able to segment the original (non-cropped) image

        Args:
            split_grids (Split[TableGrid]): a Split of TableGrid objects of the left and right part of the table
            offsets (Split[tuple[int, int]]): a Split of the offsets in the image where the crop happened
        &#34;&#34;&#34;

        def offset_points(points, offset):
            return [
                [(p[0] + offset[0], p[1] + offset[1]) for p in row] for row in points
            ]

        split_points = split_grids.apply(
            lambda grid, offset: offset_points(grid.points, offset), offsets
        )

        points = []

        rows = min(split_grids.left.rows, split_grids.right.rows)

        for row in range(rows + 1):
            row_points = []

            row_points.extend(split_points.left[row])
            row_points.extend(split_points.right[row])

            points.append(row_points)

        table_grid = TableGrid(points, split_grids.left.cols)

        return table_grid

    def save(self, path: str | Path):
        with open(path, &#34;w&#34;) as f:
            json.dump({&#34;points&#34;: self.points, &#34;right_offset&#34;: self._right_offset}, f)

    @staticmethod
    def from_saved(path: str | Path) -&gt; &#34;TableGrid&#34;:
        with open(path, &#34;r&#34;) as f:
            points = json.load(f)
            right_offset = points.get(&#34;right_offset&#34;, None)
            points = [[(p[0], p[1]) for p in pointes] for pointes in points[&#34;points&#34;]]
            return TableGrid(points, right_offset)

    def add_left_col(self, width: int):
        for row in self._points:
            first = row[0]
            new_first = (first[0] - width, first[1])
            row.insert(0, new_first)

    def add_top_row(self, height: int):
        new_row = []
        for point in self._points[0]:
            new_row.append((point[0], point[1] - height))

        self.points.insert(0, new_row)

    def _surrounds(self, rect: list[Point], point: tuple[float, float]) -&gt; bool:
        &#34;&#34;&#34;point: x, y&#34;&#34;&#34;
        lt, rt, rb, lb = rect
        x, y = point

        top = _Rule(*lt, *rt)
        if top._y_at_x(x) &gt; y:
            return False

        right = _Rule(*rt, *rb)
        if right._x_at_y(y) &lt; x:
            return False

        bottom = _Rule(*lb, *rb)
        if bottom._y_at_x(x) &lt; y:
            return False

        left = _Rule(*lb, *lt)
        if left._x_at_y(y) &gt; x:
            return False

        return True

    def cell(self, point: tuple[float, float]) -&gt; tuple[int, int]:
        for r in range(len(self._points) - 1):
            offset = 0
            for c in range(len(self.row(0)) - 1):
                if self._right_offset is not None and c == self._right_offset:
                    offset = -1
                    continue

                if self._surrounds(
                    [
                        self._points[r][c],
                        self._points[r][c + 1],
                        self._points[r + 1][c + 1],
                        self._points[r + 1][c],
                    ],
                    point,
                ):
                    return (r, c + offset)

        return (-1, -1)

    def cell_polygon(self, cell: tuple[int, int]) -&gt; tuple[Point, Point, Point, Point]:
        r, c = cell

        self._check_row_idx(r)
        self._check_col_idx(c)

        if self._right_offset is not None and c &gt;= self._right_offset:
            c = c + 1

        return (
            self._points[r][c],
            self._points[r][c + 1],
            self._points[r + 1][c + 1],
            self._points[r + 1][c],
        )

    def region(
        self, start: tuple[int, int], end: tuple[int, int]
    ) -&gt; tuple[Point, Point, Point, Point]:
        r0, c0 = start
        r1, c1 = end

        self._check_row_idx(r0)
        self._check_row_idx(r1)
        self._check_col_idx(c0)
        self._check_col_idx(c1)

        if self._right_offset is not None and c0 &gt;= self._right_offset:
            c0 = c0 + 1

        if self._right_offset is not None and c1 &gt;= self._right_offset:
            c1 = c1 + 1

        lt = self._points[r0][c0]
        rt = self._points[r0][c1 + 1]
        rb = self._points[r1 + 1][c1 + 1]
        lb = self._points[r1 + 1][c0]

        return lt, rt, rb, lb

    def visualize_points(self, img: MatLike):
        &#34;&#34;&#34;
        Draw the detected table points on the image for visual verification
        &#34;&#34;&#34;
        import colorsys

        def clr(index, total_steps):
            hue = index / total_steps  # Normalized hue between 0 and 1
            r, g, b = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
            return int(r * 255), int(g * 255), int(b * 255)

        for i, row in enumerate(self._points):
            for p in row:
                cv.circle(img, p, 4, clr(i, len(self._points)), -1)

        imu.show(img)

    def text_regions(
        self, img: MatLike, row: int, margin_x: int = 10, margin_y: int = -3
    ) -&gt; list[tuple[tuple[int, int], tuple[int, int]]]:
        def vertical_rule_crop(row: int, col: int):
            self._check_col_idx(col)
            self._check_row_idx(row)

            if self._right_offset is not None and col &gt;= self._right_offset:
                col = col + 1

            top = self._points[row][col]
            bottom = self._points[row + 1][col]

            left = int(min(top[0], bottom[0]))
            right = int(max(top[0], bottom[0]))

            return img[
                int(top[1]) - margin_y : int(bottom[1]) + margin_y,
                left - margin_x : right + margin_x,
            ]

        result = []

        start = None
        for col in range(self.cols):
            crop = vertical_rule_crop(row, col)
            text_over_score = imu.text_presence_score(crop)
            text_over = text_over_score &gt; -0.10

            if not text_over:
                if start is not None:
                    result.append(((row, start), (row, col - 1)))
                start = col

        if start is not None:
            result.append(((row, start), (row, self.cols - 1)))

        return result

    def anneal(
        self, img: MatLike, look_distance_main: int = 3, look_distance_alt: int = 3
    ):
        # how far to look in the main direction of the line
        # that is currently being examined
        LOOK_MAIN = look_distance_main

        # how far to look in the perpendicular direction of the line
        # that is currently being examined
        LOOK_ALT = look_distance_alt

        def _left_at(col: int, offset: int = LOOK_ALT) -&gt; int:
            if self._right_offset is not None and col &gt; self._right_offset:
                return int(clamp(col - offset, self._right_offset + 1, self.cols + 1))
            else:
                return int(clamp(col - offset, 0, self.cols + 1))

        def _right_at(col: int, offset: int = LOOK_ALT) -&gt; int:
            if self._right_offset is not None and col &lt;= self._right_offset:
                return int(clamp(col + offset, 0, self._right_offset))
            else:
                return int(clamp(col + offset, 0, self.cols + 1))

        def _median_slope(index: Point) -&gt; Optional[float]:
            (r, c) = index

            left = _left_at(c)
            right = _right_at(c)

            if left == right:
                return None

            lines = []
            for row in range(r - LOOK_MAIN, r + LOOK_MAIN):
                if row &lt; 0 or row == r or row &gt;= len(self.points):
                    continue

                left_point = self.points[row][int(left)]
                right_point = self.points[row][int(right)]

                lines.append((left_point, right_point))

            return _core_median_slope(lines)

        new_points = []
        for row in self.points:
            new_points.append(row.copy())

        for row in range(len(self.points)):
            for col in range(len(self.points[0])):
                slope = _median_slope((row, col))

                if slope is None:
                    continue

                left = _left_at(col, 1)
                left_point = self.points[row][int(left)]

                right = _right_at(col, 1)
                right_point = self.points[row][int(right)]

                # img_ = np.copy(img)
                # # draw a line through the left point with that slope
                # cv.line(
                #     img_,
                #     (int(left_point[0]), int(left_point[1])),
                #     (
                #         int(right_point[0]),
                #         int(slope * (right_point[0] - left_point[0]) + left_point[1]),
                #     ),
                #     (0, 255, 0),
                #     3,
                #     cv.LINE_AA,
                # )
                # imu.show(img_)

                # extrapolate left point to this points x coordinate
                new_y = (
                    slope * (self.points[row][col][0] - left_point[0]) + left_point[1]
                )

                new_y = (
                    new_y / 2
                    + (
                        slope * (right_point[0] - self.points[row][col][0])
                        + right_point[1]
                    )
                    / 2
                )

                movement = new_y - self.points[row][col][1]

                new_points[row][col] = (
                    self.points[row][col][0],
                    self.points[row][col][1] + movement * 0.8,
                )

        self._points = new_points</code></pre>
</details>
<div class="desc"><p>A data class that allows segmenting the image into cells</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong></dt>
<dd>a 2D list of intersections between hor. and vert. rules</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="taulu.table_indexer.TableIndexer" href="table_indexer.html#taulu.table_indexer.TableIndexer">TableIndexer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="taulu.grid.TableGrid.from_saved"><code class="name flex">
<span>def <span class="ident">from_saved</span></span>(<span>path: str | pathlib.Path) ‑> <a title="taulu.grid.TableGrid" href="#taulu.grid.TableGrid">TableGrid</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_saved(path: str | Path) -&gt; &#34;TableGrid&#34;:
    with open(path, &#34;r&#34;) as f:
        points = json.load(f)
        right_offset = points.get(&#34;right_offset&#34;, None)
        points = [[(p[0], p[1]) for p in pointes] for pointes in points[&#34;points&#34;]]
        return TableGrid(points, right_offset)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.TableGrid.from_split"><code class="name flex">
<span>def <span class="ident">from_split</span></span>(<span>split_grids: <a title="taulu.split.Split" href="split.html#taulu.split.Split">Split</a>[ForwardRef('<a title="taulu.grid.TableGrid" href="#taulu.grid.TableGrid">TableGrid</a>')],<br>offsets: <a title="taulu.split.Split" href="split.html#taulu.split.Split">Split</a>[typing.Tuple[int, int]]) ‑> <a title="taulu.grid.TableGrid" href="#taulu.grid.TableGrid">TableGrid</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_split(
    split_grids: Split[&#34;TableGrid&#34;], offsets: Split[Point]
) -&gt; &#34;TableGrid&#34;:
    &#34;&#34;&#34;
    Convert two ``TableGrid`` objects into one, that is able to segment the original (non-cropped) image

    Args:
        split_grids (Split[TableGrid]): a Split of TableGrid objects of the left and right part of the table
        offsets (Split[tuple[int, int]]): a Split of the offsets in the image where the crop happened
    &#34;&#34;&#34;

    def offset_points(points, offset):
        return [
            [(p[0] + offset[0], p[1] + offset[1]) for p in row] for row in points
        ]

    split_points = split_grids.apply(
        lambda grid, offset: offset_points(grid.points, offset), offsets
    )

    points = []

    rows = min(split_grids.left.rows, split_grids.right.rows)

    for row in range(rows + 1):
        row_points = []

        row_points.extend(split_points.left[row])
        row_points.extend(split_points.right[row])

        points.append(row_points)

    table_grid = TableGrid(points, split_grids.left.cols)

    return table_grid</code></pre>
</details>
<div class="desc"><p>Convert two <code><a title="taulu.grid.TableGrid" href="#taulu.grid.TableGrid">TableGrid</a></code> objects into one, that is able to segment the original (non-cropped) image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>split_grids</code></strong> :&ensp;<code>Split[<a title="taulu.grid.TableGrid" href="#taulu.grid.TableGrid">TableGrid</a>]</code></dt>
<dd>a Split of TableGrid objects of the left and right part of the table</dd>
<dt><strong><code>offsets</code></strong> :&ensp;<code>Split[tuple[int, int]]</code></dt>
<dd>a Split of the offsets in the image where the crop happened</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="taulu.grid.TableGrid.cols"><code class="name">prop <span class="ident">cols</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cols(self) -&gt; int:
    if self._right_offset is not None:
        return len(self.row(0)) - 2
    else:
        return len(self.row(0)) - 1</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.TableGrid.points"><code class="name">prop <span class="ident">points</span> : list[list[typing.Tuple[int, int]]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self) -&gt; list[list[Point]]:
    return self._points</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.TableGrid.rows"><code class="name">prop <span class="ident">rows</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rows(self) -&gt; int:
    return len(self._points) - 1</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="taulu.grid.TableGrid.add_left_col"><code class="name flex">
<span>def <span class="ident">add_left_col</span></span>(<span>self, width: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_left_col(self, width: int):
    for row in self._points:
        first = row[0]
        new_first = (first[0] - width, first[1])
        row.insert(0, new_first)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.TableGrid.add_top_row"><code class="name flex">
<span>def <span class="ident">add_top_row</span></span>(<span>self, height: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_top_row(self, height: int):
    new_row = []
    for point in self._points[0]:
        new_row.append((point[0], point[1] - height))

    self.points.insert(0, new_row)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.TableGrid.anneal"><code class="name flex">
<span>def <span class="ident">anneal</span></span>(<span>self,<br>img: cv2.Mat | numpy.ndarray,<br>look_distance_main: int = 3,<br>look_distance_alt: int = 3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anneal(
    self, img: MatLike, look_distance_main: int = 3, look_distance_alt: int = 3
):
    # how far to look in the main direction of the line
    # that is currently being examined
    LOOK_MAIN = look_distance_main

    # how far to look in the perpendicular direction of the line
    # that is currently being examined
    LOOK_ALT = look_distance_alt

    def _left_at(col: int, offset: int = LOOK_ALT) -&gt; int:
        if self._right_offset is not None and col &gt; self._right_offset:
            return int(clamp(col - offset, self._right_offset + 1, self.cols + 1))
        else:
            return int(clamp(col - offset, 0, self.cols + 1))

    def _right_at(col: int, offset: int = LOOK_ALT) -&gt; int:
        if self._right_offset is not None and col &lt;= self._right_offset:
            return int(clamp(col + offset, 0, self._right_offset))
        else:
            return int(clamp(col + offset, 0, self.cols + 1))

    def _median_slope(index: Point) -&gt; Optional[float]:
        (r, c) = index

        left = _left_at(c)
        right = _right_at(c)

        if left == right:
            return None

        lines = []
        for row in range(r - LOOK_MAIN, r + LOOK_MAIN):
            if row &lt; 0 or row == r or row &gt;= len(self.points):
                continue

            left_point = self.points[row][int(left)]
            right_point = self.points[row][int(right)]

            lines.append((left_point, right_point))

        return _core_median_slope(lines)

    new_points = []
    for row in self.points:
        new_points.append(row.copy())

    for row in range(len(self.points)):
        for col in range(len(self.points[0])):
            slope = _median_slope((row, col))

            if slope is None:
                continue

            left = _left_at(col, 1)
            left_point = self.points[row][int(left)]

            right = _right_at(col, 1)
            right_point = self.points[row][int(right)]

            # img_ = np.copy(img)
            # # draw a line through the left point with that slope
            # cv.line(
            #     img_,
            #     (int(left_point[0]), int(left_point[1])),
            #     (
            #         int(right_point[0]),
            #         int(slope * (right_point[0] - left_point[0]) + left_point[1]),
            #     ),
            #     (0, 255, 0),
            #     3,
            #     cv.LINE_AA,
            # )
            # imu.show(img_)

            # extrapolate left point to this points x coordinate
            new_y = (
                slope * (self.points[row][col][0] - left_point[0]) + left_point[1]
            )

            new_y = (
                new_y / 2
                + (
                    slope * (right_point[0] - self.points[row][col][0])
                    + right_point[1]
                )
                / 2
            )

            movement = new_y - self.points[row][col][1]

            new_points[row][col] = (
                self.points[row][col][0],
                self.points[row][col][1] + movement * 0.8,
            )

    self._points = new_points</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.TableGrid.row"><code class="name flex">
<span>def <span class="ident">row</span></span>(<span>self, i: int) ‑> list[typing.Tuple[int, int]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def row(self, i: int) -&gt; list[Point]:
    assert 0 &lt;= i and i &lt; len(self._points)
    return self._points[i]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.TableGrid.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, path: str | pathlib.Path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, path: str | Path):
    with open(path, &#34;w&#34;) as f:
        json.dump({&#34;points&#34;: self.points, &#34;right_offset&#34;: self._right_offset}, f)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.grid.TableGrid.visualize_points"><code class="name flex">
<span>def <span class="ident">visualize_points</span></span>(<span>self, img: cv2.Mat | numpy.ndarray)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize_points(self, img: MatLike):
    &#34;&#34;&#34;
    Draw the detected table points on the image for visual verification
    &#34;&#34;&#34;
    import colorsys

    def clr(index, total_steps):
        hue = index / total_steps  # Normalized hue between 0 and 1
        r, g, b = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
        return int(r * 255), int(g * 255), int(b * 255)

    for i, row in enumerate(self._points):
        for p in row:
            cv.circle(img, p, 4, clr(i, len(self._points)), -1)

    imu.show(img)</code></pre>
</details>
<div class="desc"><p>Draw the detected table points on the image for visual verification</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="taulu.table_indexer.TableIndexer" href="table_indexer.html#taulu.table_indexer.TableIndexer">TableIndexer</a></b></code>:
<ul class="hlist">
<li><code><a title="taulu.table_indexer.TableIndexer.cell" href="table_indexer.html#taulu.table_indexer.TableIndexer.cell">cell</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.cell_polygon" href="table_indexer.html#taulu.table_indexer.TableIndexer.cell_polygon">cell_polygon</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.crop_region" href="table_indexer.html#taulu.table_indexer.TableIndexer.crop_region">crop_region</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.region" href="table_indexer.html#taulu.table_indexer.TableIndexer.region">region</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.text_regions" href="table_indexer.html#taulu.table_indexer.TableIndexer.text_regions">text_regions</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<svg class="typst-doc" viewBox="0 0 192.75590551181102 99.21259842519684" width="192.75590551181102pt" height="99.21259842519684pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:h5="http://www.w3.org/1999/xhtml">
<path class="typst-shape" fill="#ffffff" fill-rule="nonzero" d="M 0 0 L 0 99.2126 L 192.7559 99.2126 L 192.7559 0 Z "/>
<g>
<g transform="translate(11.338582677165354 11.338582677165354)">
<g class="typst-group">
<g>
<g transform="translate(25.511811023622048 0)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 70.86614 L 0 0 "/>
</g>
<g transform="translate(65.19685039370079 2.8346456692913287)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 70.86614 L 0 0 "/>
</g>
<g transform="translate(102.04724409448819 8.50393700787401)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 70.86614 L 0 0 "/>
</g>
<g transform="translate(124.72440944881892 5.66929133858267)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 70.86614 L 0 0 "/>
</g>
<g transform="translate(0 14.173228346456686)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 0 L 170.07874 5.6692915 "/>
</g>
<g transform="translate(0 65.19685039370079)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 2.8346457 L 170.07874 0 "/>
</g>
<g transform="translate(0 14.031496062992122)">
<path class="typst-shape" fill="none" d="M 0 0 L 162.49606 0 L 162.49606 50.31496 L 0 50.31496 L 0 0 Z "/>
</g>
<g transform="translate(-0.000000000000014322751209022492 14.031496062992119)">
<g class="typst-group">
<g>
<g transform="translate(0 0)">
<g class="typst-group">
<g>
<g transform="translate(0 49.46456692913386)">
<g class="typst-text" transform="scale(1, -1)">
<use xlink:href="#g60E63192F9394D36DD991E83B7DA70A9" x="0" fill="#000000" fill-rule="nonzero"/>
<use xlink:href="#g6ABAA43E743E3E202E556EE721D84EF1" x="24.874015748031496" fill="#000000" fill-rule="nonzero"/>
<use xlink:href="#gC261177E87EBA3F4BCD6813A7432AF7A" x="62.71653543307087" fill="#000000" fill-rule="nonzero"/>
<use xlink:href="#gCEC7CECAD513869F11E8D4B4B926CD3" x="102.96850393700787" fill="#000000" fill-rule="nonzero"/>
<use xlink:href="#gC261177E87EBA3F4BCD6813A7432AF7A" x="122.24409448818898" fill="#000000" fill-rule="nonzero"/>
</g>
</g>
</g>
</g>
</g>
</g>
</g>
</g>
<g transform="translate(24.661417322834644 66.89763779527559)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(64.34645669291339 66.33070866141732)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(101.1968503937008 65.48031496062991)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(123.8740157480315 65.19685039370079)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(24.661417322834644 14.173228346456686)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(64.34645669291339 15.307086614173222)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(101.1968503937008 16.724409448818893)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(123.8740157480315 17.574803149606296)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
</g>
</g>
</g>
</g>
<defs id="glyph">
<symbol id="g60E63192F9394D36DD991E83B7DA70A9" overflow="visible">
<path d="M 14.102363 0 Q 11.125985 0 9.602363 1.6653544 Q 8.07874 3.3307087 8.07874 6.0236225 L 8.07874 31.6063 L 2.0551183 31.6063 L 2.0551183 36.566933 L 5.456693 36.566933 Q 7.299213 36.566933 7.972441 37.311024 Q 8.64567 38.05512 8.64567 39.89764 L 8.64567 46.70079 L 13.748033 46.70079 L 13.748033 36.566933 L 21.755907 36.566933 L 21.755907 31.6063 L 13.748033 31.6063 L 13.748033 4.96063 L 21.188978 4.96063 L 21.188978 0 L 14.102363 0 Z "/>
</symbol>
<symbol id="g6ABAA43E743E3E202E556EE721D84EF1" overflow="visible">
<path d="M 32.598427 0 Q 29.40945 0 28.027561 1.7007875 Q 26.64567 3.401575 26.29134 5.9527564 L 25.93701 5.9527564 Q 24.732285 2.5511813 21.968506 0.8503938 Q 19.204725 -0.8503938 15.377954 -0.8503938 Q 9.56693 -0.8503938 6.3425198 2.1259844 Q 3.1181104 5.1023626 3.1181104 10.204725 Q 3.1181104 15.377954 6.909449 18.141733 Q 10.700788 20.905514 18.708662 20.905514 L 25.93701 20.905514 L 25.93701 24.519686 Q 25.93701 28.417324 23.811026 30.472443 Q 21.68504 32.52756 17.29134 32.52756 Q 13.96063 32.52756 11.728347 31.039371 Q 9.496063 29.551182 8.0078745 27.070868 L 4.6062994 30.259844 Q 6.0944886 33.23622 9.354331 35.326775 Q 12.614174 37.417324 17.574804 37.417324 Q 24.236221 37.417324 27.92126 34.157482 Q 31.6063 30.89764 31.6063 25.086615 L 31.6063 4.96063 L 35.787403 4.96063 L 35.787403 0 L 32.598427 0 Z M 16.299213 3.9685042 Q 18.425198 3.9685042 20.196852 4.464567 Q 21.968506 4.96063 23.244095 5.88189 Q 24.519686 6.80315 25.228348 8.0078745 Q 25.93701 9.212599 25.93701 10.629922 L 25.93701 16.653543 L 18.425198 16.653543 Q 13.535434 16.653543 11.30315 15.236221 Q 9.070867 13.818898 9.070867 11.125985 L 9.070867 9.637795 Q 9.070867 6.9448824 11.019686 5.456693 Q 12.968505 3.9685042 16.299213 3.9685042 Z "/>
</symbol>
<symbol id="gC261177E87EBA3F4BCD6813A7432AF7A" overflow="visible">
<path d="M 28.559057 5.9527564 L 28.275593 5.9527564 Q 27.708662 4.6771655 26.893702 3.4370081 Q 26.078741 2.1968505 24.874018 1.2401575 Q 23.669292 0.28346458 21.968506 -0.28346458 Q 20.267717 -0.8503938 18 -0.8503938 Q 12.330709 -0.8503938 9 2.7992127 Q 5.6692915 6.448819 5.6692915 13.110237 L 5.6692915 36.566933 L 11.338583 36.566933 L 11.338583 14.102363 Q 11.338583 4.251969 19.700788 4.251969 Q 21.401575 4.251969 22.996063 4.6771655 Q 24.590553 5.1023626 25.83071 5.9527564 Q 27.070868 6.80315 27.814962 8.114174 Q 28.559057 9.425198 28.559057 11.267717 L 28.559057 36.566933 L 34.228348 36.566933 L 34.228348 0 L 28.559057 0 L 28.559057 5.9527564 Z "/>
</symbol>
<symbol id="gCEC7CECAD513869F11E8D4B4B926CD3" overflow="visible">
<path d="M 12.047245 0 Q 9.070867 0 7.5472445 1.6653544 Q 6.0236225 3.3307087 6.0236225 5.88189 L 6.0236225 52.44095 L 11.692914 52.44095 L 11.692914 4.96063 L 17.078741 4.96063 L 17.078741 0 L 12.047245 0 Z "/>
</symbol>
</defs>
</svg>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="taulu" href="index.html">taulu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="taulu.grid.circular_median_angle" href="#taulu.grid.circular_median_angle">circular_median_angle</a></code></li>
<li><code><a title="taulu.grid.clamp" href="#taulu.grid.clamp">clamp</a></code></li>
<li><code><a title="taulu.grid.median_slope" href="#taulu.grid.median_slope">median_slope</a></code></li>
<li><code><a title="taulu.grid.vector_average_slope" href="#taulu.grid.vector_average_slope">vector_average_slope</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="taulu.grid.GridDetector" href="#taulu.grid.GridDetector">GridDetector</a></code></h4>
<ul class="">
<li><code><a title="taulu.grid.GridDetector.apply" href="#taulu.grid.GridDetector.apply">apply</a></code></li>
<li><code><a title="taulu.grid.GridDetector.find_nearest" href="#taulu.grid.GridDetector.find_nearest">find_nearest</a></code></li>
<li><code><a title="taulu.grid.GridDetector.find_table_points" href="#taulu.grid.GridDetector.find_table_points">find_table_points</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="taulu.grid.TableGrid" href="#taulu.grid.TableGrid">TableGrid</a></code></h4>
<ul class="two-column">
<li><code><a title="taulu.grid.TableGrid.add_left_col" href="#taulu.grid.TableGrid.add_left_col">add_left_col</a></code></li>
<li><code><a title="taulu.grid.TableGrid.add_top_row" href="#taulu.grid.TableGrid.add_top_row">add_top_row</a></code></li>
<li><code><a title="taulu.grid.TableGrid.anneal" href="#taulu.grid.TableGrid.anneal">anneal</a></code></li>
<li><code><a title="taulu.grid.TableGrid.cols" href="#taulu.grid.TableGrid.cols">cols</a></code></li>
<li><code><a title="taulu.grid.TableGrid.from_saved" href="#taulu.grid.TableGrid.from_saved">from_saved</a></code></li>
<li><code><a title="taulu.grid.TableGrid.from_split" href="#taulu.grid.TableGrid.from_split">from_split</a></code></li>
<li><code><a title="taulu.grid.TableGrid.points" href="#taulu.grid.TableGrid.points">points</a></code></li>
<li><code><a title="taulu.grid.TableGrid.row" href="#taulu.grid.TableGrid.row">row</a></code></li>
<li><code><a title="taulu.grid.TableGrid.rows" href="#taulu.grid.TableGrid.rows">rows</a></code></li>
<li><code><a title="taulu.grid.TableGrid.save" href="#taulu.grid.TableGrid.save">save</a></code></li>
<li><code><a title="taulu.grid.TableGrid.visualize_points" href="#taulu.grid.TableGrid.visualize_points">visualize_points</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
