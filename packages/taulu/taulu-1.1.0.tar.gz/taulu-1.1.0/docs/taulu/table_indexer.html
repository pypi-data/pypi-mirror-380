<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>taulu.table_indexer API documentation</title>
<meta name="description" content="Defines an abstract class TableIndexer, which provides methods for mapping pixel coordinates
in an image to table cell indices and for cropping images …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<link rel="icon" href="./logo.svg" type="image/svg+xml">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>taulu.table_indexer</code></h1>
</header>
<section id="section-intro">
<p>Defines an abstract class TableIndexer, which provides methods for mapping pixel coordinates
in an image to table cell indices and for cropping images to specific table cells or regions.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="taulu.table_indexer.TableIndexer"><code class="flex name class">
<span>class <span class="ident">TableIndexer</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableIndexer(ABC):
    &#34;&#34;&#34;
    Subclasses implement methods for going from a pixel in the input image to a table cell index,
    and cropping an image to the given table cell index.
    &#34;&#34;&#34;

    def __init__(self):
        self._col_offset = 0

    @property
    def col_offset(self) -&gt; int:
        return self._col_offset

    @col_offset.setter
    def col_offset(self, value: int):
        assert value &gt;= 0
        self._col_offset = value

    @property
    @abstractmethod
    def cols(self) -&gt; int:
        pass

    @property
    @abstractmethod
    def rows(self) -&gt; int:
        pass

    def cells(self) -&gt; Generator[tuple[int, int], None, None]:
        for row in range(self.rows):
            for col in range(self.cols):
                yield (row, col)

    def _check_row_idx(self, row: int):
        if row &lt; 0:
            raise TauluException(&#34;row number needs to be positive or zero&#34;)
        if row &gt;= self.rows:
            raise TauluException(f&#34;row number too high: {row} &gt;= {self.rows}&#34;)

    def _check_col_idx(self, col: int):
        if col &lt; 0:
            raise TauluException(&#34;col number needs to be positive or zero&#34;)
        if col &gt;= self.cols:
            raise TauluException(f&#34;col number too high: {col} &gt;= {self.cols}&#34;)

    @abstractmethod
    def cell(self, point: tuple[float, float]) -&gt; tuple[int, int]:
        &#34;&#34;&#34;
        Returns the coordinate (row, col) of the cell that contains the given position

        Args:
            point (tuple[float, float]): a location in the input image

        Returns:
            tuple[int, int]: the cell index (row, col) that contains the given point
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def cell_polygon(
        self, cell: tuple[int, int]
    ) -&gt; tuple[tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]:
        &#34;&#34;&#34;returns the polygon (used in e.g. opencv) that enscribes the cell at the given cell position&#34;&#34;&#34;
        pass

    def _highlight_cell(
        self,
        image: MatLike,
        cell: tuple[int, int],
        color: tuple[int, int, int] = (0, 0, 255),
        thickness: int = 2,
    ):
        polygon = self.cell_polygon(cell)
        points = np.int32(list(polygon))  # type:ignore
        cv.polylines(image, [points], True, color, thickness, cv.LINE_AA)  # type:ignore
        cv.putText(
            image,
            str(cell),
            (int(polygon[3][0] + 10), int(polygon[3][1] - 10)),
            cv.FONT_HERSHEY_PLAIN,
            2.0,
            (255, 255, 255),
            2,
        )

    def highlight_all_cells(
        self,
        image: MatLike,
        color: tuple[int, int, int] = (0, 0, 255),
        thickness: int = 1,
    ) -&gt; MatLike:
        img = np.copy(image)

        for cell in self.cells():
            self._highlight_cell(img, cell, color, thickness)

        return img

    def select_one_cell(
        self,
        image: MatLike,
        window: str = WINDOW,
        color: tuple[int, int, int] = (255, 0, 0),
        thickness: int = 2,
    ) -&gt; tuple[int, int] | None:
        clicked = None

        def click_event(event, x, y, flags, params):
            nonlocal clicked

            img = np.copy(image)
            _ = flags
            _ = params
            if event == cv.EVENT_LBUTTONDOWN:
                cell = self.cell((x, y))
                if cell[0] &gt;= 0:
                    clicked = cell
                else:
                    return
                self._highlight_cell(img, cell, color, thickness)
                cv.imshow(window, img)

        imu.show(image, click_event=click_event, title=&#34;select one cell&#34;, window=window)

        return clicked

    def show_cells(
        self, image: MatLike | os.PathLike[str] | str, window: str = WINDOW
    ) -&gt; list[tuple[int, int]]:
        if not isinstance(image, np.ndarray):
            image = cv.imread(os.fspath(image))

        img = np.copy(image)

        cells = []

        def click_event(event, x, y, flags, params):
            _ = flags
            _ = params
            if event == cv.EVENT_LBUTTONDOWN:
                cell = self.cell((x, y))
                if cell[0] &gt;= 0:
                    cells.append(cell)
                else:
                    return
                self._highlight_cell(img, cell)
                cv.imshow(window, img)

        imu.show(
            img,
            click_event=click_event,
            title=&#34;click to highlight cells&#34;,
            window=window,
        )

        return cells

    @abstractmethod
    def region(
        self,
        start: tuple[int, int],
        end: tuple[int, int],
    ) -&gt; tuple[Point, Point, Point, Point]:
        &#34;&#34;&#34;
        Get the bounding box for the rectangular region that goes from start to end

        Returns:
            4 points: lt, rt, rb, lb, in format (x, y)
        &#34;&#34;&#34;
        pass

    def crop_region(
        self,
        image: MatLike,
        start: tuple[int, int],
        end: tuple[int, int],
        margin: int = 0,
        margin_top: int | None = None,
        margin_bottom: int | None = None,
        margin_left: int | None = None,
        margin_right: int | None = None,
        margin_y: int | None = None,
        margin_x: int | None = None,
    ) -&gt; MatLike:
        &#34;&#34;&#34;Crop the input image to a rectangular region with the start and end cells as extremes&#34;&#34;&#34;

        region = self.region(start, end)

        lt, rt, rb, lb = _apply_margin(
            *region,
            margin=margin,
            margin_top=margin_top,
            margin_bottom=margin_bottom,
            margin_left=margin_left,
            margin_right=margin_right,
            margin_y=margin_y,
            margin_x=margin_x,
        )

        # apply margins according to priority:
        # margin_top &gt; margin_y &gt; margin (etc.)

        w = (rt[0] - lt[0] + rb[0] - lb[0]) / 2
        h = (rb[1] - rt[1] + lb[1] - lt[1]) / 2

        # crop by doing a perspective transform to the desired quad
        src_pts = np.array([lt, rt, rb, lb], dtype=&#34;float32&#34;)
        dst_pts = np.array([[0, 0], [w, 0], [w, h], [0, h]], dtype=&#34;float32&#34;)
        M = cv.getPerspectiveTransform(src_pts, dst_pts)
        warped = cv.warpPerspective(image, M, (int(w), int(h)))  # type:ignore

        return warped

    @abstractmethod
    def text_regions(
        self, img: MatLike, row: int, margin_x: int = 0, margin_y: int = 0
    ) -&gt; list[tuple[tuple[int, int], tuple[int, int]]]:
        &#34;&#34;&#34;
        Split the row into regions of continuous text

        Returns
            list[tuple[int, int]]: a list of spans (start col, end col)
        &#34;&#34;&#34;

        pass

    def crop_cell(self, image, cell: tuple[int, int], margin: int = 0) -&gt; MatLike:
        return self.crop_region(image, cell, cell, margin)</code></pre>
</details>
<div class="desc"><p>Subclasses implement methods for going from a pixel in the input image to a table cell index,
and cropping an image to the given table cell index.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="taulu.grid.TableGrid" href="grid.html#taulu.grid.TableGrid">TableGrid</a></li>
<li><a title="taulu.header_template.HeaderTemplate" href="header_template.html#taulu.header_template.HeaderTemplate">HeaderTemplate</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="taulu.table_indexer.TableIndexer.col_offset"><code class="name">prop <span class="ident">col_offset</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def col_offset(self) -&gt; int:
    return self._col_offset</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.cols"><code class="name">prop <span class="ident">cols</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def cols(self) -&gt; int:
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.rows"><code class="name">prop <span class="ident">rows</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@abstractmethod
def rows(self) -&gt; int:
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="taulu.table_indexer.TableIndexer.cell"><code class="name flex">
<span>def <span class="ident">cell</span></span>(<span>self, point: tuple[float, float]) ‑> tuple[int, int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def cell(self, point: tuple[float, float]) -&gt; tuple[int, int]:
    &#34;&#34;&#34;
    Returns the coordinate (row, col) of the cell that contains the given position

    Args:
        point (tuple[float, float]): a location in the input image

    Returns:
        tuple[int, int]: the cell index (row, col) that contains the given point
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Returns the coordinate (row, col) of the cell that contains the given position</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>tuple[float, float]</code></dt>
<dd>a location in the input image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[int, int]</code></dt>
<dd>the cell index (row, col) that contains the given point</dd>
</dl></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.cell_polygon"><code class="name flex">
<span>def <span class="ident">cell_polygon</span></span>(<span>self, cell: tuple[int, int]) ‑> tuple[tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def cell_polygon(
    self, cell: tuple[int, int]
) -&gt; tuple[tuple[int, int], tuple[int, int], tuple[int, int], tuple[int, int]]:
    &#34;&#34;&#34;returns the polygon (used in e.g. opencv) that enscribes the cell at the given cell position&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>returns the polygon (used in e.g. opencv) that enscribes the cell at the given cell position</p></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.cells"><code class="name flex">
<span>def <span class="ident">cells</span></span>(<span>self) ‑> Generator[tuple[int, int], None, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cells(self) -&gt; Generator[tuple[int, int], None, None]:
    for row in range(self.rows):
        for col in range(self.cols):
            yield (row, col)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.crop_cell"><code class="name flex">
<span>def <span class="ident">crop_cell</span></span>(<span>self, image, cell: tuple[int, int], margin: int = 0) ‑> cv2.Mat | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_cell(self, image, cell: tuple[int, int], margin: int = 0) -&gt; MatLike:
    return self.crop_region(image, cell, cell, margin)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.crop_region"><code class="name flex">
<span>def <span class="ident">crop_region</span></span>(<span>self,<br>image: cv2.Mat | numpy.ndarray,<br>start: tuple[int, int],<br>end: tuple[int, int],<br>margin: int = 0,<br>margin_top: int | None = None,<br>margin_bottom: int | None = None,<br>margin_left: int | None = None,<br>margin_right: int | None = None,<br>margin_y: int | None = None,<br>margin_x: int | None = None) ‑> cv2.Mat | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crop_region(
    self,
    image: MatLike,
    start: tuple[int, int],
    end: tuple[int, int],
    margin: int = 0,
    margin_top: int | None = None,
    margin_bottom: int | None = None,
    margin_left: int | None = None,
    margin_right: int | None = None,
    margin_y: int | None = None,
    margin_x: int | None = None,
) -&gt; MatLike:
    &#34;&#34;&#34;Crop the input image to a rectangular region with the start and end cells as extremes&#34;&#34;&#34;

    region = self.region(start, end)

    lt, rt, rb, lb = _apply_margin(
        *region,
        margin=margin,
        margin_top=margin_top,
        margin_bottom=margin_bottom,
        margin_left=margin_left,
        margin_right=margin_right,
        margin_y=margin_y,
        margin_x=margin_x,
    )

    # apply margins according to priority:
    # margin_top &gt; margin_y &gt; margin (etc.)

    w = (rt[0] - lt[0] + rb[0] - lb[0]) / 2
    h = (rb[1] - rt[1] + lb[1] - lt[1]) / 2

    # crop by doing a perspective transform to the desired quad
    src_pts = np.array([lt, rt, rb, lb], dtype=&#34;float32&#34;)
    dst_pts = np.array([[0, 0], [w, 0], [w, h], [0, h]], dtype=&#34;float32&#34;)
    M = cv.getPerspectiveTransform(src_pts, dst_pts)
    warped = cv.warpPerspective(image, M, (int(w), int(h)))  # type:ignore

    return warped</code></pre>
</details>
<div class="desc"><p>Crop the input image to a rectangular region with the start and end cells as extremes</p></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.highlight_all_cells"><code class="name flex">
<span>def <span class="ident">highlight_all_cells</span></span>(<span>self,<br>image: cv2.Mat | numpy.ndarray,<br>color: tuple[int, int, int] = (0, 0, 255),<br>thickness: int = 1) ‑> cv2.Mat | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def highlight_all_cells(
    self,
    image: MatLike,
    color: tuple[int, int, int] = (0, 0, 255),
    thickness: int = 1,
) -&gt; MatLike:
    img = np.copy(image)

    for cell in self.cells():
        self._highlight_cell(img, cell, color, thickness)

    return img</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.region"><code class="name flex">
<span>def <span class="ident">region</span></span>(<span>self, start: tuple[int, int], end: tuple[int, int]) ‑> tuple[typing.Tuple[int, int], typing.Tuple[int, int], typing.Tuple[int, int], typing.Tuple[int, int]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def region(
    self,
    start: tuple[int, int],
    end: tuple[int, int],
) -&gt; tuple[Point, Point, Point, Point]:
    &#34;&#34;&#34;
    Get the bounding box for the rectangular region that goes from start to end

    Returns:
        4 points: lt, rt, rb, lb, in format (x, y)
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Get the bounding box for the rectangular region that goes from start to end</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>4 points</code></dt>
<dd>lt, rt, rb, lb, in format (x, y)</dd>
</dl></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.select_one_cell"><code class="name flex">
<span>def <span class="ident">select_one_cell</span></span>(<span>self,<br>image: cv2.Mat | numpy.ndarray,<br>window: str = 'taulu',<br>color: tuple[int, int, int] = (255, 0, 0),<br>thickness: int = 2) ‑> tuple[int, int] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_one_cell(
    self,
    image: MatLike,
    window: str = WINDOW,
    color: tuple[int, int, int] = (255, 0, 0),
    thickness: int = 2,
) -&gt; tuple[int, int] | None:
    clicked = None

    def click_event(event, x, y, flags, params):
        nonlocal clicked

        img = np.copy(image)
        _ = flags
        _ = params
        if event == cv.EVENT_LBUTTONDOWN:
            cell = self.cell((x, y))
            if cell[0] &gt;= 0:
                clicked = cell
            else:
                return
            self._highlight_cell(img, cell, color, thickness)
            cv.imshow(window, img)

    imu.show(image, click_event=click_event, title=&#34;select one cell&#34;, window=window)

    return clicked</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.show_cells"><code class="name flex">
<span>def <span class="ident">show_cells</span></span>(<span>self,<br>image: cv2.Mat | numpy.ndarray | os.PathLike[str] | str,<br>window: str = 'taulu') ‑> list[tuple[int, int]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_cells(
    self, image: MatLike | os.PathLike[str] | str, window: str = WINDOW
) -&gt; list[tuple[int, int]]:
    if not isinstance(image, np.ndarray):
        image = cv.imread(os.fspath(image))

    img = np.copy(image)

    cells = []

    def click_event(event, x, y, flags, params):
        _ = flags
        _ = params
        if event == cv.EVENT_LBUTTONDOWN:
            cell = self.cell((x, y))
            if cell[0] &gt;= 0:
                cells.append(cell)
            else:
                return
            self._highlight_cell(img, cell)
            cv.imshow(window, img)

    imu.show(
        img,
        click_event=click_event,
        title=&#34;click to highlight cells&#34;,
        window=window,
    )

    return cells</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="taulu.table_indexer.TableIndexer.text_regions"><code class="name flex">
<span>def <span class="ident">text_regions</span></span>(<span>self, img: cv2.Mat | numpy.ndarray, row: int, margin_x: int = 0, margin_y: int = 0) ‑> list[tuple[tuple[int, int], tuple[int, int]]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def text_regions(
    self, img: MatLike, row: int, margin_x: int = 0, margin_y: int = 0
) -&gt; list[tuple[tuple[int, int], tuple[int, int]]]:
    &#34;&#34;&#34;
    Split the row into regions of continuous text

    Returns
        list[tuple[int, int]]: a list of spans (start col, end col)
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>Split the row into regions of continuous text</p>
<p>Returns
list[tuple[int, int]]: a list of spans (start col, end col)</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<svg class="typst-doc" viewBox="0 0 192.75590551181102 99.21259842519684" width="192.75590551181102pt" height="99.21259842519684pt" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:h5="http://www.w3.org/1999/xhtml">
<path class="typst-shape" fill="#ffffff" fill-rule="nonzero" d="M 0 0 L 0 99.2126 L 192.7559 99.2126 L 192.7559 0 Z "/>
<g>
<g transform="translate(11.338582677165354 11.338582677165354)">
<g class="typst-group">
<g>
<g transform="translate(25.511811023622048 0)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 70.86614 L 0 0 "/>
</g>
<g transform="translate(65.19685039370079 2.8346456692913287)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 70.86614 L 0 0 "/>
</g>
<g transform="translate(102.04724409448819 8.50393700787401)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 70.86614 L 0 0 "/>
</g>
<g transform="translate(124.72440944881892 5.66929133858267)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 70.86614 L 0 0 "/>
</g>
<g transform="translate(0 14.173228346456686)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 0 L 170.07874 5.6692915 "/>
</g>
<g transform="translate(0 65.19685039370079)">
<path class="typst-shape" fill="none" stroke="#000000" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0 2.8346457 L 170.07874 0 "/>
</g>
<g transform="translate(0 14.031496062992122)">
<path class="typst-shape" fill="none" d="M 0 0 L 162.49606 0 L 162.49606 50.31496 L 0 50.31496 L 0 0 Z "/>
</g>
<g transform="translate(-0.000000000000014322751209022492 14.031496062992119)">
<g class="typst-group">
<g>
<g transform="translate(0 0)">
<g class="typst-group">
<g>
<g transform="translate(0 49.46456692913386)">
<g class="typst-text" transform="scale(1, -1)">
<use xlink:href="#g60E63192F9394D36DD991E83B7DA70A9" x="0" fill="#000000" fill-rule="nonzero"/>
<use xlink:href="#g6ABAA43E743E3E202E556EE721D84EF1" x="24.874015748031496" fill="#000000" fill-rule="nonzero"/>
<use xlink:href="#gC261177E87EBA3F4BCD6813A7432AF7A" x="62.71653543307087" fill="#000000" fill-rule="nonzero"/>
<use xlink:href="#gCEC7CECAD513869F11E8D4B4B926CD3" x="102.96850393700787" fill="#000000" fill-rule="nonzero"/>
<use xlink:href="#gC261177E87EBA3F4BCD6813A7432AF7A" x="122.24409448818898" fill="#000000" fill-rule="nonzero"/>
</g>
</g>
</g>
</g>
</g>
</g>
</g>
</g>
<g transform="translate(24.661417322834644 66.89763779527559)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(64.34645669291339 66.33070866141732)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(101.1968503937008 65.48031496062991)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(123.8740157480315 65.19685039370079)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(24.661417322834644 14.173228346456686)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(64.34645669291339 15.307086614173222)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(101.1968503937008 16.724409448818893)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
<g transform="translate(123.8740157480315 17.574803149606296)">
<path class="typst-shape" fill="#ff4136" fill-rule="nonzero" stroke="#ff4136" stroke-width="1" stroke-linecap="butt" stroke-linejoin="miter" stroke-miterlimit="4" d="M 0.8503937 0 C 0.38116005 0 0 0.38116005 0 0.8503937 C 0 1.3196273 0.38116005 1.7007874 0.8503937 1.7007874 C 1.3196273 1.7007874 1.7007874 1.3196273 1.7007874 0.8503937 C 1.7007874 0.38116005 1.3196273 0 0.8503937 0 Z "/>
</g>
</g>
</g>
</g>
</g>
<defs id="glyph">
<symbol id="g60E63192F9394D36DD991E83B7DA70A9" overflow="visible">
<path d="M 14.102363 0 Q 11.125985 0 9.602363 1.6653544 Q 8.07874 3.3307087 8.07874 6.0236225 L 8.07874 31.6063 L 2.0551183 31.6063 L 2.0551183 36.566933 L 5.456693 36.566933 Q 7.299213 36.566933 7.972441 37.311024 Q 8.64567 38.05512 8.64567 39.89764 L 8.64567 46.70079 L 13.748033 46.70079 L 13.748033 36.566933 L 21.755907 36.566933 L 21.755907 31.6063 L 13.748033 31.6063 L 13.748033 4.96063 L 21.188978 4.96063 L 21.188978 0 L 14.102363 0 Z "/>
</symbol>
<symbol id="g6ABAA43E743E3E202E556EE721D84EF1" overflow="visible">
<path d="M 32.598427 0 Q 29.40945 0 28.027561 1.7007875 Q 26.64567 3.401575 26.29134 5.9527564 L 25.93701 5.9527564 Q 24.732285 2.5511813 21.968506 0.8503938 Q 19.204725 -0.8503938 15.377954 -0.8503938 Q 9.56693 -0.8503938 6.3425198 2.1259844 Q 3.1181104 5.1023626 3.1181104 10.204725 Q 3.1181104 15.377954 6.909449 18.141733 Q 10.700788 20.905514 18.708662 20.905514 L 25.93701 20.905514 L 25.93701 24.519686 Q 25.93701 28.417324 23.811026 30.472443 Q 21.68504 32.52756 17.29134 32.52756 Q 13.96063 32.52756 11.728347 31.039371 Q 9.496063 29.551182 8.0078745 27.070868 L 4.6062994 30.259844 Q 6.0944886 33.23622 9.354331 35.326775 Q 12.614174 37.417324 17.574804 37.417324 Q 24.236221 37.417324 27.92126 34.157482 Q 31.6063 30.89764 31.6063 25.086615 L 31.6063 4.96063 L 35.787403 4.96063 L 35.787403 0 L 32.598427 0 Z M 16.299213 3.9685042 Q 18.425198 3.9685042 20.196852 4.464567 Q 21.968506 4.96063 23.244095 5.88189 Q 24.519686 6.80315 25.228348 8.0078745 Q 25.93701 9.212599 25.93701 10.629922 L 25.93701 16.653543 L 18.425198 16.653543 Q 13.535434 16.653543 11.30315 15.236221 Q 9.070867 13.818898 9.070867 11.125985 L 9.070867 9.637795 Q 9.070867 6.9448824 11.019686 5.456693 Q 12.968505 3.9685042 16.299213 3.9685042 Z "/>
</symbol>
<symbol id="gC261177E87EBA3F4BCD6813A7432AF7A" overflow="visible">
<path d="M 28.559057 5.9527564 L 28.275593 5.9527564 Q 27.708662 4.6771655 26.893702 3.4370081 Q 26.078741 2.1968505 24.874018 1.2401575 Q 23.669292 0.28346458 21.968506 -0.28346458 Q 20.267717 -0.8503938 18 -0.8503938 Q 12.330709 -0.8503938 9 2.7992127 Q 5.6692915 6.448819 5.6692915 13.110237 L 5.6692915 36.566933 L 11.338583 36.566933 L 11.338583 14.102363 Q 11.338583 4.251969 19.700788 4.251969 Q 21.401575 4.251969 22.996063 4.6771655 Q 24.590553 5.1023626 25.83071 5.9527564 Q 27.070868 6.80315 27.814962 8.114174 Q 28.559057 9.425198 28.559057 11.267717 L 28.559057 36.566933 L 34.228348 36.566933 L 34.228348 0 L 28.559057 0 L 28.559057 5.9527564 Z "/>
</symbol>
<symbol id="gCEC7CECAD513869F11E8D4B4B926CD3" overflow="visible">
<path d="M 12.047245 0 Q 9.070867 0 7.5472445 1.6653544 Q 6.0236225 3.3307087 6.0236225 5.88189 L 6.0236225 52.44095 L 11.692914 52.44095 L 11.692914 4.96063 L 17.078741 4.96063 L 17.078741 0 L 12.047245 0 Z "/>
</symbol>
</defs>
</svg>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="taulu" href="index.html">taulu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="taulu.table_indexer.TableIndexer" href="#taulu.table_indexer.TableIndexer">TableIndexer</a></code></h4>
<ul class="two-column">
<li><code><a title="taulu.table_indexer.TableIndexer.cell" href="#taulu.table_indexer.TableIndexer.cell">cell</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.cell_polygon" href="#taulu.table_indexer.TableIndexer.cell_polygon">cell_polygon</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.cells" href="#taulu.table_indexer.TableIndexer.cells">cells</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.col_offset" href="#taulu.table_indexer.TableIndexer.col_offset">col_offset</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.cols" href="#taulu.table_indexer.TableIndexer.cols">cols</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.crop_cell" href="#taulu.table_indexer.TableIndexer.crop_cell">crop_cell</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.crop_region" href="#taulu.table_indexer.TableIndexer.crop_region">crop_region</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.highlight_all_cells" href="#taulu.table_indexer.TableIndexer.highlight_all_cells">highlight_all_cells</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.region" href="#taulu.table_indexer.TableIndexer.region">region</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.rows" href="#taulu.table_indexer.TableIndexer.rows">rows</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.select_one_cell" href="#taulu.table_indexer.TableIndexer.select_one_cell">select_one_cell</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.show_cells" href="#taulu.table_indexer.TableIndexer.show_cells">show_cells</a></code></li>
<li><code><a title="taulu.table_indexer.TableIndexer.text_regions" href="#taulu.table_indexer.TableIndexer.text_regions">text_regions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
