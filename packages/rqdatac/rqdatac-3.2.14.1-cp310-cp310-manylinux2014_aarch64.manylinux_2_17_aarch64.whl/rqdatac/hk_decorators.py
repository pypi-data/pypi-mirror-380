import warnings
import pandas as pd
import six
import inspect
from functools import wraps, lru_cache

import rqdatac

try:
    from collections.abc import Iterable
except ImportError:
    from collections import Iterable


def hk_to_unique_id(ids):
    from rqdatac.services.basic import hk_all_unique_id_to_order_book_id

    all_unique_ids = hk_all_unique_id_to_order_book_id()
    reverse_map = {}
    if isinstance(ids, six.string_types):
        if ids not in all_unique_ids:
            insts = rqdatac.instruments(ids, market="hk")
            if insts is not None:
                reverse_map[insts.unique_id] = insts.order_book_id
                return insts.unique_id, reverse_map
            else:
                return ids, reverse_map
        else:
            return ids, reverse_map
    elif isinstance(ids, Iterable):
        result = []
        for i in ids:
            if i not in all_unique_ids:
                insts = rqdatac.instruments(i, market="hk")
                if insts is not None:
                    reverse_map[insts.unique_id] = insts.order_book_id
                    result.append(insts.unique_id)
                else:
                    # We can almost make sure that the input id `i` is not valid
                    # but we still append it to result, because the upper level decorator
                    # should not eat any passing parameters.
                    result.append(i)
            else:
                result.append(i)
        return result, reverse_map
    else:
        raise ValueError("ids should be str or iterator")


def _convert_multi_index_dataframe(result, reverse_map):
    for level_index, level_name in enumerate(result.index.names):
        if level_name == "order_book_id":
            result.index = result.index.set_levels(
                [reverse_map.get(i, i) for i in result.index.levels[level_index]],
                level=level_index,
            )
            break
    return result


def _convert_dataframe(result, reverse_map):
    if result.empty:
        return result
    if "order_book_id" in result.columns:
        result["order_book_id"] = [
            reverse_map.get(i, i) for i in result["order_book_id"]
        ]
    elif result.index.name == "order_book_id":
        result.index = [reverse_map.get(i, i) for i in result.index]
        result.index.name = "order_book_id"
    elif isinstance(result.columns[0], str):  # check if columns are order_book_ids.
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            first_column = result.columns[0]
            first_column = reverse_map.get(first_column, first_column)
            insts = rqdatac.instruments(first_column, market="hk")
            if insts is not None:
                name = result.columns.name
                result.columns = [reverse_map.get(i, i) for i in result.columns]
                result.columns.name = name
    return result


def _convert_series(result, reverse_map):
    if result.index.name == "order_book_id":
        result.index = [reverse_map.get(i, i) for i in result.index]
        result.index.name = "order_book_id"
    return result


def mapping_back_to_order_book_id(result, reverse_map):
    """Converts order_book_id fields in `reuslt`.  The result are generated by rqdatac calls"""
    # the result of rqdatac call can be the following:
    # 1. DataFrame, which have `order_book_id` as index
    # 2. Series, which have `order_book_id` as index
    # 3. List of order_book_ids
    # 4. List of instruments
    # 5. something that doesn't include id info.
    if isinstance(result, (pd.DataFrame, pd.Series)) and isinstance(
        result.index, pd.MultiIndex
    ):
        return _convert_multi_index_dataframe(result, reverse_map)
    elif isinstance(result, pd.DataFrame):
        return _convert_dataframe(result, reverse_map)
    elif isinstance(result, pd.Series):
        return _convert_series(result, reverse_map)
    elif isinstance(result, list):
        return [reverse_map.get(i, i) for i in result]
    return result


@lru_cache(None)
def get_signature(func):
    wrapped_f = func
    while True:
        new_wrapped = getattr(wrapped_f, "__wrapped__", None)
        if new_wrapped is not None and new_wrapped != wrapped_f:
            wrapped_f = new_wrapped
        else:
            break
    return inspect.signature(func)


def support_hk_order_book_id(f):
    """main decorator to make rqdatac function supports hk order book id as input."""

    @wraps(f)
    def wrapped(*args, **kwargs):
        # get order_book_id argument
        sig = get_signature(f)
        call_info = sig.bind(*args, **kwargs)
        call_info.apply_defaults()
        # after `apply_defaults`, all arg information are available through `call_info.arguments`
        # as a dict.
        arguments: dict = call_info.arguments
        # if there is something in kwargs, should flatten it into arguments.
        if "kwargs" in arguments:
            for k, v in arguments.pop("kwargs").items():
                arguments[k] = v
        # A fast call if user doesn't call for `hk` data.
        if arguments.get("market", None) != "hk":
            return f(*args, **kwargs)

        reverse_map = {}
        for k in ("order_book_id", "order_book_ids", "indexes"):
            if k in arguments:
                arguments[k], reverse_map = hk_to_unique_id(arguments[k])
                break
        result = f(**arguments)
        if reverse_map and f.__name__ != "get_trading_hours":
            return mapping_back_to_order_book_id(result, reverse_map)
        else:
            return result

    return wrapped


def return_hk_order_book_ids(f):
    """main decorator to make rqdatac function supports hk order book id as input."""

    @wraps(f)
    def wrapped(*args, **kwargs):
        # get order_book_id argument
        sig = get_signature(f)
        call_info = sig.bind(*args, **kwargs)
        call_info.apply_defaults()
        # after `apply_defaults`, all arg information are available through `call_info.arguments`
        # as a dict.
        arguments: dict = call_info.arguments
        # if there is something in kwargs, should flatten it into arguments.
        if "kwargs" in arguments:
            for k, v in arguments.pop("kwargs").items():
                arguments[k] = v
        # A fast call if user doesn't call for special hk data
        if arguments.get("order_book_id", None) not in ("931573.INDX", "930930.INDX"):
            return f(*args, **kwargs)

        result = f(**arguments)
        from rqdatac.services.basic import hk_all_unique_id_to_order_book_id

        unique_id_to_order_book_id = hk_all_unique_id_to_order_book_id()
        if f.__name__ == "index_components":
            # 有start_date,end_date时, 返回dict
            if isinstance(result, dict):
                date, components = result.popitem()
                # index_components 要求 rice_create_tm 字段时, 里面的数据为 (order_book_id列表, rice_create_tm) 元组
                if isinstance(components, tuple):
                    real_components, rice_create_tm = components
                    final_result = {}
                    real_components = [
                        unique_id_to_order_book_id.get(item, item)
                        for item in real_components
                    ]
                    final_result[date] = (real_components, rice_create_tm)
                    for date, components in result.items():
                        real_components, rice_create_tm = components
                        real_components = [
                            unique_id_to_order_book_id.get(item, item)
                            for item in real_components
                        ]
                        final_result[date] = (real_components, rice_create_tm)
                    result = final_result
                else:  # 没有要求 rice_create_tm 字段, value 为一个单纯的 order_book_id 列表
                    for k in result:
                        result[k] = [
                            unique_id_to_order_book_id.get(item, item)
                            for item in result[k]
                        ]
                    components = [
                        unique_id_to_order_book_id.get(item, item)
                        for item in components
                    ]
                    result[date] = components
            elif isinstance(result, tuple):  # 单纯要求rice_create_tm字段时, 返回tuple
                real_components, rice_create_tm = result
                real_components = [
                    unique_id_to_order_book_id.get(item, item)
                    for item in real_components
                ]
                return (real_components, rice_create_tm)
            elif isinstance(result, list):  # 默认情况, 返回list
                return [unique_id_to_order_book_id.get(item, item) for item in result]
        elif f.__name__ == "index_weights":
            if isinstance(result, pd.Series):
                # 没有传start_date/end_date时, 返回Series
                result.index = result.index.map(
                    lambda one_id: unique_id_to_order_book_id.get(one_id, one_id)
                )
            else:
                # 有start_date/end_date时, 返回multi-level dataframe
                result.index = result.index.set_levels(
                    [
                        unique_id_to_order_book_id.get(i, i)
                        for i in result.index.levels[1]
                    ],
                    level="order_book_id",
                )
        return result

    return wrapped
