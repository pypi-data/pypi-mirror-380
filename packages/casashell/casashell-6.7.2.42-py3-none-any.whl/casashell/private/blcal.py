##################### generated by xml-casa (v2) from blcal.xml #####################
##################### 305b0cd5f4c91d6a5f3a5696419a82d5 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_blcal import blcal as _blcal_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _blcal:
    """
    blcal ---- Calculate a baseline-based calibration solution (gain or bandpass)

    
    This task determines a baseline by baseline gain (time) or bandpass
    (freq) for all baseline pairs in the data set. For the usual
    antenna-based calibration of interferometric data, this task gaincal
    is recommended, even with only one to three baselines.  For arrays
    with closure errors, use blcal.

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file
                Default: none
                
                   Example: vis='ngc5921.ms'
    caltable    Name of output gain calibration table
                Default: none
                
                   Example: caltable='ngc5921.gcal'
    field       Select field using field id(s) or field name(s)
                Default: '' (all fields)
                
                Use 'go listobs' to obtain the list id's or
                names. If field string is a non-negative integer,
                it is assumed a field index,  otherwise, it is
                assumed a field name.
                
                   Examples:
                   field='0~2'; field ids 0,1,2
                   field='0,4,5~7'; field ids 0,4,5,6,7
                   field='3C286,3C295'; field named 3C286 and
                   3C295
                   field = '3,4C\*'; field id 3, all names
                   starting with 4C
    spw         Select spectral window/channels
                Default: '' (all spectral windows and channels)
                
                   Examples:
                   spw='0~2,4'; spectral windows 0,1,2,4 (all
                   channels)
                   spw='<2';  spectral windows less than 2
                   (i.e. 0,1)
                   spw='0:5~61'; spw 0, channels 5 to 61,
                   INCLUSIVE
                   spw='\*:5~61'; all spw with channels 5 to 61
                   spw='0,10,3:3~45'; spw 0,10 all channels, spw
                   3, channels 3 to 45.
                   spw='0~2:2~6'; spw 0,1,2 with channels 2
                   through 6 in each.
                   spw='0:0~10;15~60'; spectral window 0 with
                   channels 0-10,15-60. (NOTE ';' to separate
                   channel selections)
                   spw='0:0~10^2,1:20~30^5'; spw 0, channels
                   0,2,4,6,8,10, spw 1, channels 20,25,30
    intent      Select observing intent
                Default: '' (no selection by intent)
                
                   Example: intent='\*BANDPASS\*'  (selects data
                   labelled with BANDPASS intent)
    selectdata  Other data selection parameters
                Default: True
                Options: True|False
    timerange   Select data based on time range
                Subparameter of selectdata=True
                Default = '' (all)
                
                   Examples:
                   timerange =
                   'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                   (Note: if YYYY/MM/DD is missing date defaults
                   to first day in data set.)
                   timerange='09:14:0~09:54:0' picks 40 min on
                   first day 
                   timerange= '25:00:00~27:30:00' picks 1 hr to 3
                   hr 30min on NEXT day
                   timerange='09:44:00' pick data within one
                   integration of time
                   timerange='>10:24:00' data after this time
    uvrange     Select data by baseline length.
                Default = '' (all)
                
                   Examples:
                   uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
                   uvrange='>4klambda';uvranges greater than 4 kilo-lambda
                   uvrange='0~1000km'; uvrange in kilometers
    antenna     Select data based on antenna/baseline
                                   Subparameter of selectdata=True
                                   Default: '' (all)
                
                                   If antenna string is a non-negative integer, it
                                   is assumed an antenna index, otherwise, it is
                                   assumed as an antenna name
                
                                       Examples: 
                                       antenna='5&6'; baseline between antenna
                                       index 5 and index 6.
                                       antenna='VA05&VA06'; baseline between VLA
                                       antenna 5 and 6.
                                       antenna='5&6;7&8'; baselines with
                                       indices 5-6 and 7-8
                                       antenna='5'; all baselines with antenna index
                                       5
                                       antenna='05'; all baselines with antenna
                                       number 05 (VLA old name)
                                       antenna='5,6,10'; all baselines with antennas
                                       5,6,10 index numbers
    scan        Scan number range
                Subparameter of selectdata=True
                Default: '' = all
    observation Select by observation ID(s)
                Subparameter of selectdata=True
                Default: '' = all
                
                    Example: observation='0~2,4'
    msselect    Optional complex data selection (ignore for now)
    solint      Solution interval
                Default: 'inf' (infinite, up to boundaries
                controlled by combine); 
                Options: 'inf' (~infinite), 'int' (per
                integration), any float or integer value with or
                without units
                
                   Examples: 
                   solint='1min'; solint='60s', solint=60 (i.e.,
                   1 minute); solint='0s'; solint=0; solint='int'
                   (i.e., per integration); solint-'-1s';
                   solint='inf' (i.e., ~infinite, up to
                   boundaries enforced by combine)
    combine     Data axes which to combine for solve
                Default: 'scan' (solutions will break at obs,
                field, and spw boundaries, but may extend over
                multiple scans [per obs, field, and spw] up to
                solint.)
                Options: '','obs','scan','spw',field', or any
                comma-separated combination in a single string
                
                   Example: combine='scan,spw' - Extend solutions
                   over scan boundaries (up to the solint), and
                   combine spws for solving
    freqdep     Solve for frequency dependent solutions
                Default: False (gain; True=bandpass)
                Options: False|True
    calmode     Type of solution" ('ap', 'p', 'a')
                Default: 'ap' (amp and phase)
                Options: 'p' (phase) ,'a' (amplitude), 'ap'
                (amplitude and phase)
                
                   Example: calmode='p'
    solnorm     Normalize average solution amplitudes to 1.0
                Default: False (no normalization)
                
                For freqdep=False, this is a global (per-spw)
                normalization of amplitudes (only). For
                freqdep=True, each baseline  solution spectrum is
                separately normalized by its (complex) mean.
    gaintable   Gain calibration table(s) to apply on the fly
                Default: '' (none)
                
                   Examples: 
                   gaintable='ngc5921.gcal'
                   gaintable=['ngc5921.ampcal','ngc5921.phcal']
    gainfield   Select a subset of calibrators from gaintable(s)
                Default: '' (all sources on the sky)
                
                'nearest' ==> nearest (on sky) available field in
                table otherwise, same syntax as field
                
                   Examples: 
                   gainfield='0~3'
                   gainfield=['0~3','4~6']
    interp      Interpolation parmameters (in time[,freq]) for each gaintable, as a list of strings.
                  Default: '' --> 'linear,linear' for all gaintable(s)
                  Options: Time: 'nearest', 'linear'
                           Freq: 'nearest', 'linear', 'cubic',
                           'spline'
                Specify a list of strings, aligned with the list of caltable specified
                in gaintable, that contain the required interpolation parameters
                for each caltable.
                
                - When frequency interpolation is relevant (B, Df,
                  Xf), separate time-dependent and freq-dependent
                  interp types with a comma (freq after the
                  comma). 
                - Specifications for frequency are ignored when the
                  calibration table has no channel-dependence. 
                - Time-dependent interp options ending in 'PD'
                  enable a "phase delay" correction per spw for
                  non-channel-dependent calibration types.
                - For multi-obsId datasets, 'perobs' can be
                  appended to the time-dependent interpolation
                  specification to enforce obsId boundaries when
                  interpolating in time. 
                - For multi-scan datasets, 'perscan' can be
                  appended to the time-dependent interpolation
                  specification to enforce scan boundaries when
                  interpolating in time. 
                - Freq-dependent interp options can have 'flag' appended
                  to enforce channel-dependent flagging, and/or 'rel' 
                  appended to invoke relative frequency interpolation
                
                     Examples: 
                     interp='nearest' (in time, freq-dep will be
                     linear, if relevant)
                     interp='linear,cubic'  (linear in time, cubic
                     in freq)
                     interp='linearperobs,splineflag' (linear in
                     time per obsId, spline in freq with
                     channelized flagging)
                     interp='nearest,linearflagrel' (nearest in
                     time, linear in freq with with channelized 
                     flagging and relative-frequency interpolation)
                     interp=',spline'  (spline in freq; linear in
                     time by default)
                     interp=['nearest,spline','linear']  (for
                     multiple gaintables)
    spwmap      Spectral window mappings to form for gaintable(s)
                default: [] (apply solutions from each calibration spw to
                the same MS spw only)
                Any available calibration spw can be mechanically mapped to any 
                 MS spw. 
                Examples:
                   spwmap=[0,0,1,1] means apply calibration 
                     from cal spw = 0 to MS spw 0,1 and cal spw 1 to MS spws 2,3.
                   spwmap=[[0,0,1,1],[0,1,0,1]] (use a list of lists for multiple
                     gaintables)
    parang      Apply parallactic angle correction
                Default: False
                
                If True, apply the parallactic angle correction
                (required for polarization calibration)

    --------- examples -----------------------------------------------------------

    
    
    For more information, see the task pages of blcal in CASA Docs:
    
    https://casa.nrao.edu/casadocs/


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Calculate a baseline-based calibration solution (gain or bandpass)"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'caltable': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'intent': {'type': 'cStr', 'coerce': _coerce.to_str}, 'selectdata': {'type': 'cBool'}, 'timerange': {'type': 'cStr', 'coerce': _coerce.to_str}, 'uvrange': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'antenna': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scan': {'type': 'cStr', 'coerce': _coerce.to_str}, 'observation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'msselect': {'type': 'cStr', 'coerce': _coerce.to_str}, 'solint': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'combine': {'type': 'cStr', 'coerce': _coerce.to_str}, 'freqdep': {'type': 'cBool'}, 'calmode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'a', 'p', 'ap' ]}, 'solnorm': {'type': 'cBool'}, 'gaintable': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'gainfield': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'interp': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'spwmap': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'parang': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 14 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __solint_dflt( self, glb ):
        return 'inf'

    def __solint( self, glb ):
        if 'solint' in glb: return glb['solint']
        return 'inf'

    def __parang_dflt( self, glb ):
        return False

    def __parang( self, glb ):
        if 'parang' in glb: return glb['parang']
        return False

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __spwmap_dflt( self, glb ):
        return [ ]

    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        return [ ]

    def __caltable_dflt( self, glb ):
        return ''

    def __caltable( self, glb ):
        if 'caltable' in glb: return glb['caltable']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __calmode_dflt( self, glb ):
        return 'ap'

    def __calmode( self, glb ):
        if 'calmode' in glb: return glb['calmode']
        return 'ap'

    def __solnorm_dflt( self, glb ):
        return False

    def __solnorm( self, glb ):
        if 'solnorm' in glb: return glb['solnorm']
        return False

    def __combine_dflt( self, glb ):
        return 'scan'

    def __combine( self, glb ):
        if 'combine' in glb: return glb['combine']
        return 'scan'

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __interp_dflt( self, glb ):
        return [  ]

    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        return [  ]

    def __freqdep_dflt( self, glb ):
        return False

    def __freqdep( self, glb ):
        if 'freqdep' in glb: return glb['freqdep']
        return False

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __gaintable_dflt( self, glb ):
        return [  ]

    def __gaintable( self, glb ):
        if 'gaintable' in glb: return glb['gaintable']
        return [  ]

    def __gainfield_dflt( self, glb ):
        return [  ]

    def __gainfield( self, glb ):
        if 'gainfield' in glb: return glb['gainfield']
        return [  ]



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __msselect_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __uvrange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        dflt = self.__uvrange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __msselect( self, glb ):
        if 'msselect' in glb: return glb['msselect']
        dflt = self.__msselect_dflt( glb )
        if dflt is not None: return dflt
        return ''

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __caltable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__caltable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of output gain calibration table'
        value = self.__caltable( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'caltable': value},{'caltable': self.__schema['caltable']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('caltable',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select field using field id(s) or field name(s)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select spectral window/channels'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select observing intent'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __selectdata_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__selectdata_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Other data selection parameters'
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('selectdata',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on time range'
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __uvrange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__uvrange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__uvrange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data by baseline length.'
             value = self.__uvrange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('uvrange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on antenna/baseline'
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'Scan number range'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = 'Select by observation ID(s)'
             value = self.__observation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __msselect_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__msselect_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__msselect_dflt( self.__globals_( ) ) is not None:
             description = 'Optional complex data selection (ignore for now)'
             value = self.__msselect( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'msselect': value},{'msselect': self.__schema['msselect']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('msselect',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __solint_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__solint_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'inf'
        description = 'Solution interval'
        value = self.__solint( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'solint': value},{'solint': self.__schema['solint']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('solint',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __combine_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__combine_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'scan'
        description = 'Data axes which to combine for solve (obs, scan, spw, and/or field)'
        value = self.__combine( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'combine': value},{'combine': self.__schema['combine']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('combine',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __freqdep_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__freqdep_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Solve for frequency dependent solutions'
        value = self.__freqdep( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'freqdep': value},{'freqdep': self.__schema['freqdep']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('freqdep',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __calmode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__calmode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'ap'
        description = 'Type of solution" (\'ap\', \'p\', \'a\')'
        value = self.__calmode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'calmode': value},{'calmode': self.__schema['calmode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('calmode',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __solnorm_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__solnorm_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Normalize average solution amplitudes to 1.0'
        value = self.__solnorm( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'solnorm': value},{'solnorm': self.__schema['solnorm']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('solnorm',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __gaintable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gaintable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Gain calibration table(s) to apply on the fly'
        value = self.__gaintable( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gaintable': value},{'gaintable': self.__schema['gaintable']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('gaintable',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __gainfield_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gainfield_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Select a subset of calibrators from gaintable(s)'
        value = self.__gainfield( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gainfield': value},{'gainfield': self.__schema['gainfield']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('gainfield',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __interp_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interp_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Interpolation parameters for each gaintable, as a list'
        value = self.__interp( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('interp',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spwmap_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spwmap_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ ]
        description = 'Spectral window mappings to form for gaintable(s)'
        value = self.__spwmap( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('spwmap',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __parang_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__parang_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Apply parallactic angle correction'
        value = self.__parang( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'parang': value},{'parang': self.__schema['parang']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('parang',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'gainfield' in glb: del glb['gainfield']
        if 'parang' in glb: del glb['parang']
        if 'field' in glb: del glb['field']
        if 'msselect' in glb: del glb['msselect']
        if 'intent' in glb: del glb['intent']
        if 'spwmap' in glb: del glb['spwmap']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'interp' in glb: del glb['interp']
        if 'freqdep' in glb: del glb['freqdep']
        if 'solnorm' in glb: del glb['solnorm']
        if 'calmode' in glb: del glb['calmode']
        if 'combine' in glb: del glb['combine']
        if 'uvrange' in glb: del glb['uvrange']
        if 'solint' in glb: del glb['solint']
        if 'caltable' in glb: del glb['caltable']
        if 'observation' in glb: del glb['observation']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']
        if 'gaintable' in glb: del glb['gaintable']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# blcal -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__caltable_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__intent_inp( )
        self.__selectdata_inp( )
        self.__timerange_inp( )
        self.__uvrange_inp( )
        self.__antenna_inp( )
        self.__scan_inp( )
        self.__observation_inp( )
        self.__msselect_inp( )
        self.__solint_inp( )
        self.__combine_inp( )
        self.__freqdep_inp( )
        self.__calmode_inp( )
        self.__solnorm_inp( )
        self.__gaintable_inp( )
        self.__gainfield_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )
        self.__parang_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "blcal.last" if os.path.isfile("blcal.last") else "blcal.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('blcal.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['msselect'] = self.__msselect( self.__globals_( ) )
        _invocation_parameters['solint'] = self.__solint( self.__globals_( ) )
        _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
        _invocation_parameters['freqdep'] = self.__freqdep( self.__globals_( ) )
        _invocation_parameters['calmode'] = self.__calmode( self.__globals_( ) )
        _invocation_parameters['solnorm'] = self.__solnorm( self.__globals_( ) )
        _invocation_parameters['gaintable'] = self.__gaintable( self.__globals_( ) )
        _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
        _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
        _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
        _invocation_parameters['parang'] = self.__parang( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#blcal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, caltable=None, field=None, spw=None, intent=None, selectdata=None, timerange=None, uvrange=None, antenna=None, scan=None, observation=None, msselect=None, solint=None, combine=None, freqdep=None, calmode=None, solnorm=None, gaintable=None, gainfield=None, interp=None, spwmap=None, parang=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('blcal.pre')
        _postfile = os.path.realpath('blcal.last')
        task_result = None
        _arguments = [vis,caltable,field,spw,intent,selectdata,timerange,uvrange,antenna,scan,observation,msselect,solint,combine,freqdep,calmode,solnorm,gaintable,gainfield,interp,spwmap,parang]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if caltable is not None: local_global['caltable'] = caltable
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if intent is not None: local_global['intent'] = intent
            if selectdata is not None: local_global['selectdata'] = selectdata
            if solint is not None: local_global['solint'] = solint
            if combine is not None: local_global['combine'] = combine
            if freqdep is not None: local_global['freqdep'] = freqdep
            if calmode is not None: local_global['calmode'] = calmode
            if solnorm is not None: local_global['solnorm'] = solnorm
            if gaintable is not None: local_global['gaintable'] = gaintable
            if gainfield is not None: local_global['gainfield'] = gainfield
            if interp is not None: local_global['interp'] = interp
            if spwmap is not None: local_global['spwmap'] = spwmap
            if parang is not None: local_global['parang'] = parang

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['caltable'] = self.__caltable( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['solint'] = self.__solint( local_global )
            _invocation_parameters['combine'] = self.__combine( local_global )
            _invocation_parameters['freqdep'] = self.__freqdep( local_global )
            _invocation_parameters['calmode'] = self.__calmode( local_global )
            _invocation_parameters['solnorm'] = self.__solnorm( local_global )
            _invocation_parameters['gaintable'] = self.__gaintable( local_global )
            _invocation_parameters['gainfield'] = self.__gainfield( local_global )
            _invocation_parameters['interp'] = self.__interp( local_global )
            _invocation_parameters['spwmap'] = self.__spwmap( local_global )
            _invocation_parameters['parang'] = self.__parang( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['uvrange'] = self.__uvrange( _invocation_parameters ) if uvrange is None else uvrange
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['msselect'] = self.__msselect( _invocation_parameters ) if msselect is None else msselect

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['msselect'] = self.__msselect( self.__globals_( ) )
            _invocation_parameters['solint'] = self.__solint( self.__globals_( ) )
            _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
            _invocation_parameters['freqdep'] = self.__freqdep( self.__globals_( ) )
            _invocation_parameters['calmode'] = self.__calmode( self.__globals_( ) )
            _invocation_parameters['solnorm'] = self.__solnorm( self.__globals_( ) )
            _invocation_parameters['gaintable'] = self.__gaintable( self.__globals_( ) )
            _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
            _invocation_parameters['parang'] = self.__parang( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#blcal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'blcal', [ 'vis=' + repr(_pc.document['vis']), 'caltable=' + repr(_pc.document['caltable']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'intent=' + repr(_pc.document['intent']), 'selectdata=' + repr(_pc.document['selectdata']), 'timerange=' + repr(_pc.document['timerange']), 'uvrange=' + repr(_pc.document['uvrange']), 'antenna=' + repr(_pc.document['antenna']), 'scan=' + repr(_pc.document['scan']), 'observation=' + repr(_pc.document['observation']), 'msselect=' + repr(_pc.document['msselect']), 'solint=' + repr(_pc.document['solint']), 'combine=' + repr(_pc.document['combine']), 'freqdep=' + repr(_pc.document['freqdep']), 'calmode=' + repr(_pc.document['calmode']), 'solnorm=' + repr(_pc.document['solnorm']), 'gaintable=' + repr(_pc.document['gaintable']), 'gainfield=' + repr(_pc.document['gainfield']), 'interp=' + repr(_pc.document['interp']), 'spwmap=' + repr(_pc.document['spwmap']), 'parang=' + repr(_pc.document['parang']) ] )
            task_result = _blcal_t( _pc.document['vis'],_pc.document['caltable'],_pc.document['field'],_pc.document['spw'],_pc.document['intent'],_pc.document['selectdata'],_pc.document['timerange'],_pc.document['uvrange'],_pc.document['antenna'],_pc.document['scan'],_pc.document['observation'],_pc.document['msselect'],_pc.document['solint'],_pc.document['combine'],_pc.document['freqdep'],_pc.document['calmode'],_pc.document['solnorm'],_pc.document['gaintable'],_pc.document['gainfield'],_pc.document['interp'],_pc.document['spwmap'],_pc.document['parang'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('blcal')
            casalog.post("Exception Reported: Error in blcal: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'blcal', task_result )

        #Added if _blcal_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

blcal = _blcal( )

