##################### generated by xml-casa (v2) from concat.xml ####################
##################### cb03f5d962db38b1742a644543cef968 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_concat import concat as _concat_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _concat:
    """
    concat ---- Concatenate several visibility data sets.

    
    The list of data sets given in the vis argument are chronologically
    concatenated into an output data set in concatvis, i.e. the data sets
    in vis are first ordered by the time of their earliest integration and
    then concatenated. If concatvis already exists (e.g., it is the same
    as the first input data set), then the other input data sets will be
    appended to the concatvis data set.There is no limit to the number of
    input data sets.
    
    If there are fields whose direction agrees within the direction will
    be the one from the chronologically first input MS. Spectral windows
    for each data set with the same chanelization, and within a specified
    frequency tolerance of another data set will be combined into one
    spectral window.
    
    If none of the input data sets have any scratch columns (model and
    corrected columns), none are created in the concatvis.  Otherwise
    these columns are created on output and initialized to their default
    value (1 in model column, data in corrected column) for those data
    with no input columns.
    
    Each appended dataset is assigned a new observation id (provided the
    entries in the observation table are indeed different).

    --------- parameter descriptions ---------------------------------------------

    vis                   Name of input visibility file
                          default: none
                          
                             Example:
                             vis='['src2.ms','ngc5921.ms','ngc315.ms']
    concatvis             Name of visibility file that will contain the
                          concatenated data
                          default: none
                          
                             Example: concatvis='outvis.ms'
                          
                          Note: if this file exits on disk then the input
                          files are added to this file.  Otherwise the new
                          file contains the concatenated data. Be careful
                          here when concatenating to an existing file.
    freqtol               Frequency shift tolerance for considering data as the
                          same spwid. The number of channels must also be the same.
                          Default: '' == 1 Hz
                          
                             Example: freqtol='10MHz' will not combine spwid
                             unless they are within 10 MHz.
                          
                          Note: This option is useful to combine spectral
                          windows with very slight frequency differences
                          caused by Doppler tracking, for example.
    dirtol                Direction shift tolerance for considering data as the
                          same field
                          Default: '' == 1 mas (milliarcsec)
                          
                             Example: dirtol='1arcsec' will not combine
                             data for a field unless their phase center
                             differ by less than 1 arcsec.  
                          
                          Note: If the field names are different in the
                          input data sets, the name in the output data set
                          will be the first relevant data set in the list.
    respectname           If true, fields with a different name are not merged even
                          if their direction agrees (within dirtol)
                          Default: False
    timesort              If true, sort by TIME in ascending order
                          Default: False (data in order as read in)
                          
                             Example: timesort=True
                          
                          Note: There is no constraint on data that is
                          simultaneously observed for more than one field;
                          for example multi-source correlation of VLBA
                          data.
    copypointing          Make a proper copy of the POINTING subtable 
                          Default:True (can be time consuming!)
                          
                          If False, the result is an empty POINTING table.
    visweightscale        List of the weight scaling factors to be applied to the
                          individual MSs
                                              Default: [] (empty list) - no scaling
                          
                                              The weights of the individual MSs will be scaled
                                              in the concatenated output MS by the factors in
                                              this list. SIGMA will be scaled by
                                              1/sqrt(factor). Useful for handling heterogeneous
                                              arrays. Use plotms to inspect the "Wt" column as
                                              a reference for determining the scaling factors.
                          
                                                 Example: [1.,3.,3.] - scale the weights of the
                                                 second and third MS by a factor 3 and the
                                                 SIGMA column of these MS by a factor
                                                 1/sqrt(3).
    forcesingleephemfield Make sure that there is only one joint ephemeris for every field in this list
                          Default: '' (standard treatment of all ephemeris
                          fields)
                          
                          By default, concat will only merge two ephemeris
                          fields if the first ephemeris covers the time
                          range of the second. Otherwise, two separate
                          fields with separate ephemerides are placed in
                          the output MS.
                          In order to override this behaviour and make
                          concat merge the non-overlapping or only
                          partially overlapping input ephemerides, the name
                          or id of the field in question needs to be placed
                          into the list in parameter
                          'forcesingleephemfield'.
                          
                          Example: ['Neptune'] - will make sure that there
                          is only one joint ephemeris for field Neptune in
                          the output MS

    --------- examples -----------------------------------------------------------

    
    
    For more information, see the task pages of concat in CASA Docs:
    
    https://casa.nrao.edu/casadocs/


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """Concatenate several visibility data sets."""

    __schema = {'vis': {'type': 'cReqPathVec', 'coerce': [_coerce.to_list,_coerce.expand_pathvec]}, 'concatvis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'freqtol': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'dirtol': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'respectname': {'type': 'cBool'}, 'timesort': {'type': 'cBool'}, 'copypointing': {'type': 'cBool'}, 'visweightscale': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'forcesingleephemfield': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 21 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __forcesingleephemfield_dflt( self, glb ):
        return ''

    def __forcesingleephemfield( self, glb ):
        if 'forcesingleephemfield' in glb: return glb['forcesingleephemfield']
        return ''

    def __dirtol_dflt( self, glb ):
        return ''

    def __dirtol( self, glb ):
        if 'dirtol' in glb: return glb['dirtol']
        return ''

    def __vis_dflt( self, glb ):
        return [  ]

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return [  ]

    def __respectname_dflt( self, glb ):
        return False

    def __respectname( self, glb ):
        if 'respectname' in glb: return glb['respectname']
        return False

    def __timesort_dflt( self, glb ):
        return False

    def __timesort( self, glb ):
        if 'timesort' in glb: return glb['timesort']
        return False

    def __visweightscale_dflt( self, glb ):
        return [  ]

    def __visweightscale( self, glb ):
        if 'visweightscale' in glb: return glb['visweightscale']
        return [  ]

    def __concatvis_dflt( self, glb ):
        return ''

    def __concatvis( self, glb ):
        if 'concatvis' in glb: return glb['concatvis']
        return ''

    def __copypointing_dflt( self, glb ):
        return True

    def __copypointing( self, glb ):
        if 'copypointing' in glb: return glb['copypointing']
        return True

    def __freqtol_dflt( self, glb ):
        return ''

    def __freqtol( self, glb ):
        if 'freqtol' in glb: return glb['freqtol']
        return ''



    #--------- return inp/go default --------------------------------------------------


    #--------- return subparam values -------------------------------------------------


    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __concatvis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__concatvis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of output visibility file'
        value = self.__concatvis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'concatvis': value},{'concatvis': self.__schema['concatvis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('concatvis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __freqtol_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__freqtol_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Frequency shift tolerance for considering data as the same spwid'
        value = self.__freqtol( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'freqtol': value},{'freqtol': self.__schema['freqtol']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('freqtol',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __dirtol_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__dirtol_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Direction shift tolerance for considering data as the same field'
        value = self.__dirtol( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'dirtol': value},{'dirtol': self.__schema['dirtol']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('dirtol',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __respectname_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__respectname_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'If true, fields with a different name are not merged even if their direction agrees'
        value = self.__respectname( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'respectname': value},{'respectname': self.__schema['respectname']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('respectname',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __timesort_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timesort_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'If true, sort by TIME in ascending order'
        value = self.__timesort( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timesort': value},{'timesort': self.__schema['timesort']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('timesort',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __copypointing_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__copypointing_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Copy all rows of the POINTING table.'
        value = self.__copypointing( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'copypointing': value},{'copypointing': self.__schema['copypointing']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('copypointing',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __visweightscale_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__visweightscale_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'List of the weight scaling factors to be applied to the individual MSs'
        value = self.__visweightscale( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'visweightscale': value},{'visweightscale': self.__schema['visweightscale']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('visweightscale',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __forcesingleephemfield_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__forcesingleephemfield_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Make sure that there is only one joint ephemeris for every field in this list'
        value = self.__forcesingleephemfield( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'forcesingleephemfield': value},{'forcesingleephemfield': self.__schema['forcesingleephemfield']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-21.21s = %s%-23s%s' % ('forcesingleephemfield',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'dirtol' in glb: del glb['dirtol']
        if 'concatvis' in glb: del glb['concatvis']
        if 'freqtol' in glb: del glb['freqtol']
        if 'vis' in glb: del glb['vis']
        if 'forcesingleephemfield' in glb: del glb['forcesingleephemfield']
        if 'visweightscale' in glb: del glb['visweightscale']
        if 'timesort' in glb: del glb['timesort']
        if 'respectname' in glb: del glb['respectname']
        if 'copypointing' in glb: del glb['copypointing']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# concat -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__concatvis_inp( )
        self.__freqtol_inp( )
        self.__dirtol_inp( )
        self.__respectname_inp( )
        self.__timesort_inp( )
        self.__copypointing_inp( )
        self.__visweightscale_inp( )
        self.__forcesingleephemfield_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "concat.last" if os.path.isfile("concat.last") else "concat.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('concat.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['concatvis'] = self.__concatvis( self.__globals_( ) )
        _invocation_parameters['freqtol'] = self.__freqtol( self.__globals_( ) )
        _invocation_parameters['dirtol'] = self.__dirtol( self.__globals_( ) )
        _invocation_parameters['respectname'] = self.__respectname( self.__globals_( ) )
        _invocation_parameters['timesort'] = self.__timesort( self.__globals_( ) )
        _invocation_parameters['copypointing'] = self.__copypointing( self.__globals_( ) )
        _invocation_parameters['visweightscale'] = self.__visweightscale( self.__globals_( ) )
        _invocation_parameters['forcesingleephemfield'] = self.__forcesingleephemfield( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-21s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#concat( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, concatvis=None, freqtol=None, dirtol=None, respectname=None, timesort=None, copypointing=None, visweightscale=None, forcesingleephemfield=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('concat.pre')
        _postfile = os.path.realpath('concat.last')
        task_result = None
        _arguments = [vis,concatvis,freqtol,dirtol,respectname,timesort,copypointing,visweightscale,forcesingleephemfield]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if concatvis is not None: local_global['concatvis'] = concatvis
            if freqtol is not None: local_global['freqtol'] = freqtol
            if dirtol is not None: local_global['dirtol'] = dirtol
            if respectname is not None: local_global['respectname'] = respectname
            if timesort is not None: local_global['timesort'] = timesort
            if copypointing is not None: local_global['copypointing'] = copypointing
            if visweightscale is not None: local_global['visweightscale'] = visweightscale
            if forcesingleephemfield is not None: local_global['forcesingleephemfield'] = forcesingleephemfield

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['concatvis'] = self.__concatvis( local_global )
            _invocation_parameters['freqtol'] = self.__freqtol( local_global )
            _invocation_parameters['dirtol'] = self.__dirtol( local_global )
            _invocation_parameters['respectname'] = self.__respectname( local_global )
            _invocation_parameters['timesort'] = self.__timesort( local_global )
            _invocation_parameters['copypointing'] = self.__copypointing( local_global )
            _invocation_parameters['visweightscale'] = self.__visweightscale( local_global )
            _invocation_parameters['forcesingleephemfield'] = self.__forcesingleephemfield( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['concatvis'] = self.__concatvis( self.__globals_( ) )
            _invocation_parameters['freqtol'] = self.__freqtol( self.__globals_( ) )
            _invocation_parameters['dirtol'] = self.__dirtol( self.__globals_( ) )
            _invocation_parameters['respectname'] = self.__respectname( self.__globals_( ) )
            _invocation_parameters['timesort'] = self.__timesort( self.__globals_( ) )
            _invocation_parameters['copypointing'] = self.__copypointing( self.__globals_( ) )
            _invocation_parameters['visweightscale'] = self.__visweightscale( self.__globals_( ) )
            _invocation_parameters['forcesingleephemfield'] = self.__forcesingleephemfield( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-21s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#concat( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'concat', [ 'vis=' + repr(_pc.document['vis']), 'concatvis=' + repr(_pc.document['concatvis']), 'freqtol=' + repr(_pc.document['freqtol']), 'dirtol=' + repr(_pc.document['dirtol']), 'respectname=' + repr(_pc.document['respectname']), 'timesort=' + repr(_pc.document['timesort']), 'copypointing=' + repr(_pc.document['copypointing']), 'visweightscale=' + repr(_pc.document['visweightscale']), 'forcesingleephemfield=' + repr(_pc.document['forcesingleephemfield']) ] )
            task_result = _concat_t( _pc.document['vis'],_pc.document['concatvis'],_pc.document['freqtol'],_pc.document['dirtol'],_pc.document['respectname'],_pc.document['timesort'],_pc.document['copypointing'],_pc.document['visweightscale'],_pc.document['forcesingleephemfield'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('concat')
            casalog.post("Exception Reported: Error in concat: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'concat', task_result )

        #Added if _concat_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

concat = _concat( )

