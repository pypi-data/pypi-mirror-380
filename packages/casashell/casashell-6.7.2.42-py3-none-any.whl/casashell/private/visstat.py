##################### generated by xml-casa (v2) from visstat.xml ###################
##################### c86ed6b951fe8f7d2801da8c7294893f ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_visstat import visstat as _visstat_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _visstat:
    """
    visstat ---- Calculates statistical information from a MeasurementSet

    --------- parameter descriptions ---------------------------------------------

    vis                   Name of MeasurementSet or Multi-MS
    axis                  Values on which to compute statistics
    datacolumn            Which data column to use (data, corrected, model, float_data)
    useflags              Take flagging into account?
    spw                   spectral-window/frequency/channel
    field                 Field names or field index numbers: \'\'==>all, field=\'0~2,3C286\'
    selectdata            More data selection parameters (antenna, timerange etc)
    antenna               antenna/baselines: \'\'==>all, antenna = \'3,VA04\'
    uvrange               uv range: \'\'==>all; uvrange = \'0~100klambda\', default units=meters
    timerange             time range: \'\'==>all, timerange=\'09:14:0~09:54:0\'
    correlation           Select data based on correlation
    scan                  scan numbers: \'\'==>all
    array                 (sub)array numbers: \'\'==>all
    observation           observation ID number(s): \'\' = all
    timeaverage           Average data in time.
    timebin               Bin width for time averaging.
    timespan              Span the timebin across scan, state or both.
    maxuvwdistance        Maximum separation of start-to-end baselines that can be included in an average. (meters)
    disableparallel       Hidden parameter for internal use only. Do not change it!
    ddistart              Hidden parameter for internal use only. Do not change it!
    taql                  Table query for nested selections
    monolithic_processing Hidden parameter for internal use only. Do not change it!
    intent                Select data by scan intent.
    reportingaxes         Which reporting axis to use (ddid, field, integration)
    doquantiles           If False, quantile-like statistics are not computed. These include the first and third quartiles, the median, and the median of the absolute deviation from the median.
    [1;42mRETURNS[1;m                  record

    --------- examples -----------------------------------------------------------

    
    
    This task returns statistical information about data in a MeasurementSet
    or Multi-MS.
    
    The following statistics are computed: mean value, sum of values, sum of
    squared values, median, median absolute deviation, first and third
    quartiles, minimum, maximum, variance, standard deviation, and root mean
    square.
    
    Statistics may be computed on any of the following values: flag, antenna1,
    antenna2, feed1, feed2, field_id, array_id, data_desc_id, flag_row,
    interval, scan_number, time, weight_spectrum, amplitude, phase, real,
    imaginary, and uvrange (for the 'axis' parameter value, 'amp' is treated
    as an alias for amplitude, as are 'imag' for imaginary, and 'scan' for
    scan_number.)
    
    The 'reportingaxes' argument is used to partition the sample set along an
    axis. For example, setting its value to 'ddid' will result in the
    statistics of the chosen sample values partitioned by unique values of the
    data description id. Thus setting 'axis' to 'amp' and 'reportingaxes' to
    'ddid' will report statistics of visibility amplitudes for each unique
    value of data description id in the MeasurementSet.
    
    Optionally, the statistical information can be computed based only
    on a given subset of the MeasurementSet.
    
    Note: If the MS consists of inhomogeneous data, for example several
    spectral windows each having a different number of channels, it may be
    necessary to use selection parameters to select a homogeneous subset of
    the MS, e.g. spw='2'.
    
    Keyword arguments:
    
    vis  --- Name of input MeasurementSet or Multi-MS
    default: '', example: vis='my.ms'
    
    axis -- Which data to analyze.
    
    default: 'amplitude'
    axis='phase'
    axis='imag'
    axis='scan_number'
    axis='flag'
    
    The phase of a complex number is in radians in the range [-pi; pi].
    
    
    datacolumn -- Which data column to use for complex data.
    default: 'data'
    datacolumn='data'
    datacolumn='corrected'
    datacolumn='model'
    datacolumn='float_data'
    
    useflags -- Take MS flags into account?
    default: True
    useflags=False
    useflags=True
    If useflags=False, flagged values are included in the statistics.
    If useflags=True, any flagged values are not used in the statistics.
    
    spw -- Select data based on spectral window and channels
    default: '' (all); example: spw='1'
    spw='<2' #spectral windows less than 2
    spw='>1' #spectral windows greater than 1
    spw='0:0~10' # first 10 channels from spw 0
    spw='0:0~5;56~60' # multiple separated channel chunks.
    
    field -- Select data based on field id(s) or name(s)
    default: '' (all); example: field='1'
    field='0~2' # field ids inclusive from 0 to 2
    field='3C*' # all field names starting with 3C
    
    selectdata -- Other data selection parameters
    default: True
    antenna -- Select data based on baseline
    default: '' (all); example: antenna='5&6' baseline 5-6
    antenna='5&6;7&8' #baseline 5-6 and 7-8
    antenna='5' # all baselines with antenna 5
    antenna='5,6' # all baselines with antennas 5 and 6
    correlation -- Correlation types
    default: '' (all);
    example: correlation='RR LL'
    uvrange -- Select data within uvrange (default units meters)
    default: '' (all); example:
    uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
    uvrange='>4klambda';uvranges greater than 4 kilo-lambda
    uvrange='0~1000km'; uvrange in kilometers
    timerange  -- Select data based on time range:
    default = '' (all); example,
    timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: YYYY/MM/DD can be dropped as needed:
    timerange='09:14:0~09:54:0' # this time range
    timerange='09:44:00' # data within one integration of time
    timerange='>10:24:00' # data after this time
    timerange='09:44:00+00:13:00' #data 13 minutes after time
    scan -- Select data based on scan number
    default: '' (all); example: scan='>3'
    array -- Selection based on the antenna array
    observation -- Selection by observation ID(s).
    default: '' (all); example: observation='1~3'
    
    
    
    
    --- Time averaging parameters ---
    timeaverage -- Average data in time. Flagged data will be included in the
    average calculation, unless the parameter useflags is set to True. In this
    case only partially flagged rows will be used in the average.
    default: False
    
    timebin -- Bin width for time averaging.
    default: '0s'
    
    timespan -- Let the timebin span across scan, state or both.
    State is equivalent to sub-scans. One scan may have several
    state ids. For ALMA MSs, the sub-scans are limited to about
    30s duration each. In these cases, the task will automatically
    add state to the timespan parameter. To see the number of states
    in an MS, use the msmd tool. See help msmd.
    
    default: '' (separate time bins by both of the above)
    options: 'scan', 'state', 'state,scan'
    
    examples:
    timespan = 'scan'; can be useful when the scan number
    goes up with each integration as in many WSRT MSs.
    timespan = ['scan', 'state']: disregard scan and state
    numbers when time averaging.
    timespan = 'state,scan'; same as above.
    
    maxuvwdistance -- Provide a maximum separation of start-to-end baselines
    that can be included in an average. (int)
    default: 0.0 (given in meters)
    
    
    
    
    
    
    
    


    """

    _info_group_ = """information"""
    _info_desc_ = """Calculates statistical information from a MeasurementSet"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'axis': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'data_desc_id', 'field_id', 'flag', 'imaginary', 'feed1', 'flag_row', 'interval', 'imag', 'phase', 'array_id', 'amp', 'real', 'antenna2', 'weight_spectrum', 'scan_number', 'amplitude', 'uvrange', 'antenna1', 'feed2', 'time', 'scan' ]}, 'datacolumn': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'data', 'corrected', 'model', 'float_data' ]}, 'useflags': {'type': 'cBool'}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'selectdata': {'type': 'cBool'}, 'antenna': {'type': 'cStr', 'coerce': _coerce.to_str}, 'uvrange': {'type': 'cStr', 'coerce': _coerce.to_str}, 'timerange': {'type': 'cStr', 'coerce': _coerce.to_str}, 'correlation': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scan': {'type': 'cStr', 'coerce': _coerce.to_str}, 'array': {'type': 'cStr', 'coerce': _coerce.to_str}, 'observation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'timeaverage': {'type': 'cBool'}, 'timebin': {'type': 'cStr', 'coerce': _coerce.to_str}, 'timespan': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'maxuvwdistance': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'disableparallel': {'type': 'cBool'}, 'ddistart': {'type': 'cInt'}, 'taql': {'type': 'cStr', 'coerce': _coerce.to_str}, 'monolithic_processing': {'type': 'cBool'}, 'intent': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'reportingaxes': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'ddid', 'field', 'integration' ]}, 'doquantiles': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 24 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __timeaverage_dflt( self, glb ):
        return False

    def __timeaverage( self, glb ):
        if 'timeaverage' in glb: return glb['timeaverage']
        return False

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __monolithic_processing_dflt( self, glb ):
        return False

    def __monolithic_processing( self, glb ):
        if 'monolithic_processing' in glb: return glb['monolithic_processing']
        return False

    def __doquantiles_dflt( self, glb ):
        return True

    def __doquantiles( self, glb ):
        if 'doquantiles' in glb: return glb['doquantiles']
        return True

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __disableparallel_dflt( self, glb ):
        return False

    def __disableparallel( self, glb ):
        if 'disableparallel' in glb: return glb['disableparallel']
        return False

    def __ddistart_dflt( self, glb ):
        return int(-1)

    def __ddistart( self, glb ):
        if 'ddistart' in glb: return glb['ddistart']
        return int(-1)

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __useflags_dflt( self, glb ):
        return True

    def __useflags( self, glb ):
        if 'useflags' in glb: return glb['useflags']
        return True

    def __axis_dflt( self, glb ):
        return 'amplitude'

    def __axis( self, glb ):
        if 'axis' in glb: return glb['axis']
        return 'amplitude'

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __taql_dflt( self, glb ):
        return ''

    def __taql( self, glb ):
        if 'taql' in glb: return glb['taql']
        return ''

    def __reportingaxes_dflt( self, glb ):
        return 'ddid'

    def __reportingaxes( self, glb ):
        if 'reportingaxes' in glb: return glb['reportingaxes']
        return 'ddid'



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __datacolumn_dflt( self, glb ):
        if self.__axis( glb ) == "amp": return "data"
        if self.__axis( glb ) == "amplitude": return "data"
        if self.__axis( glb ) == "phase": return "data"
        if self.__axis( glb ) == "real": return "data"
        if self.__axis( glb ) == "imag": return "data"
        if self.__axis( glb ) == "imaginary": return "data"
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timebin_dflt( self, glb ):
        if self.__timeaverage( glb ) == bool(True): return "0s"
        return None
    def __array_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __maxuvwdistance_dflt( self, glb ):
        if self.__timeaverage( glb ) == bool(True): return float(0.0)
        return None
    def __correlation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timespan_dflt( self, glb ):
        if self.__timeaverage( glb ) == bool(True): return ""
        return None
    def __uvrange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        dflt = self.__datacolumn_dflt( glb )
        if dflt is not None: return dflt
        return 'data'
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        dflt = self.__uvrange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __correlation( self, glb ):
        if 'correlation' in glb: return glb['correlation']
        dflt = self.__correlation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        dflt = self.__array_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __timebin( self, glb ):
        if 'timebin' in glb: return glb['timebin']
        dflt = self.__timebin_dflt( glb )
        if dflt is not None: return dflt
        return '0s'
    def __timespan( self, glb ):
        if 'timespan' in glb: return glb['timespan']
        dflt = self.__timespan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __maxuvwdistance( self, glb ):
        if 'maxuvwdistance' in glb: return glb['maxuvwdistance']
        dflt = self.__maxuvwdistance_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __disableparallel( self, glb ):
        if 'disableparallel' in glb: return glb['disableparallel']
        dflt = self.__disableparallel_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __ddistart( self, glb ):
        if 'ddistart' in glb: return glb['ddistart']
        dflt = self.__ddistart_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __taql( self, glb ):
        if 'taql' in glb: return glb['taql']
        dflt = self.__taql_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __monolithic_processing( self, glb ):
        if 'monolithic_processing' in glb: return glb['monolithic_processing']
        dflt = self.__monolithic_processing_dflt( glb )
        if dflt is not None: return dflt
        return False

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of MeasurementSet or Multi-MS'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __axis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__axis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'amplitude'
        description = 'Values on which to compute statistics'
        value = self.__axis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'axis': value},{'axis': self.__schema['axis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23s%s' % ('axis',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __datacolumn_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__datacolumn_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'data'
        if self.__datacolumn_dflt( self.__globals_( ) ) is not None:
             description = 'Which data column to use (data, corrected, model, float_data)'
             value = self.__datacolumn( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('datacolumn',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __useflags_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__useflags_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Take flagging into account?'
        value = self.__useflags( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'useflags': value},{'useflags': self.__schema['useflags']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('useflags',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'spectral-window/frequency/channel'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Field names or field index numbers: \'\'==>all, field=\'0~2,3C286\''
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __selectdata_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__selectdata_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'More data selection parameters (antenna, timerange etc)'
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23s%s' % ('selectdata',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = 'antenna/baselines: \'\'==>all, antenna = \'3,VA04\''
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __uvrange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__uvrange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__uvrange_dflt( self.__globals_( ) ) is not None:
             description = 'uv range: \'\'==>all; uvrange = \'0~100klambda\', default units=meters'
             value = self.__uvrange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('uvrange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'time range: \'\'==>all, timerange=\'09:14:0~09:54:0\''
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __correlation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__correlation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__correlation_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on correlation'
             value = self.__correlation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'correlation': value},{'correlation': self.__schema['correlation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('correlation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'scan numbers: \'\'==>all'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __array_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__array_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__array_dflt( self.__globals_( ) ) is not None:
             description = '(sub)array numbers: \'\'==>all'
             value = self.__array( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('array',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = 'observation ID number(s): \'\' = all'
             value = self.__observation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __timeaverage_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timeaverage_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Average data in time.'
        value = self.__timeaverage( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timeaverage': value},{'timeaverage': self.__schema['timeaverage']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23s%s' % ('timeaverage',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __timebin_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timebin_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return '0s'
        if self.__timebin_dflt( self.__globals_( ) ) is not None:
             description = 'Bin width for time averaging.'
             value = self.__timebin( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timebin': value},{'timebin': self.__schema['timebin']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('timebin',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __timespan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timespan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__timespan_dflt( self.__globals_( ) ) is not None:
             description = 'Span the timebin across scan, state or both.'
             value = self.__timespan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timespan': value},{'timespan': self.__schema['timespan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('timespan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __maxuvwdistance_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__maxuvwdistance_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__maxuvwdistance_dflt( self.__globals_( ) ) is not None:
             description = 'Maximum separation of start-to-end baselines that can be included in an average. (meters)'
             value = self.__maxuvwdistance( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'maxuvwdistance': value},{'maxuvwdistance': self.__schema['maxuvwdistance']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('maxuvwdistance',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __disableparallel_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__disableparallel_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__disableparallel_dflt( self.__globals_( ) ) is not None:
             description = 'Hidden parameter for internal use only. Do not change it!'
             value = self.__disableparallel( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'disableparallel': value},{'disableparallel': self.__schema['disableparallel']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('disableparallel',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __ddistart_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__ddistart_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__ddistart_dflt( self.__globals_( ) ) is not None:
             description = 'Hidden parameter for internal use only. Do not change it!'
             value = self.__ddistart( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'ddistart': value},{'ddistart': self.__schema['ddistart']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('ddistart',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __taql_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__taql_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__taql_dflt( self.__globals_( ) ) is not None:
             description = 'Table query for nested selections'
             value = self.__taql( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'taql': value},{'taql': self.__schema['taql']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('taql',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __monolithic_processing_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__monolithic_processing_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__monolithic_processing_dflt( self.__globals_( ) ) is not None:
             description = 'Hidden parameter for internal use only. Do not change it!'
             value = self.__monolithic_processing( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'monolithic_processing': value},{'monolithic_processing': self.__schema['monolithic_processing']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('monolithic_processing',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select data by scan intent.'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __reportingaxes_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__reportingaxes_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'ddid'
        description = 'Which reporting axis to use (ddid, field, integration)'
        value = self.__reportingaxes( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'reportingaxes': value},{'reportingaxes': self.__schema['reportingaxes']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('reportingaxes',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __doquantiles_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__doquantiles_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = ''
        value = self.__doquantiles( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'doquantiles': value},{'doquantiles': self.__schema['doquantiles']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('doquantiles',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'field' in glb: del glb['field']
        if 'monolithic_processing' in glb: del glb['monolithic_processing']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'intent' in glb: del glb['intent']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'disableparallel' in glb: del glb['disableparallel']
        if 'timeaverage' in glb: del glb['timeaverage']
        if 'timebin' in glb: del glb['timebin']
        if 'array' in glb: del glb['array']
        if 'ddistart' in glb: del glb['ddistart']
        if 'maxuvwdistance' in glb: del glb['maxuvwdistance']
        if 'correlation' in glb: del glb['correlation']
        if 'timespan' in glb: del glb['timespan']
        if 'uvrange' in glb: del glb['uvrange']
        if 'reportingaxes' in glb: del glb['reportingaxes']
        if 'axis' in glb: del glb['axis']
        if 'observation' in glb: del glb['observation']
        if 'doquantiles' in glb: del glb['doquantiles']
        if 'spw' in glb: del glb['spw']
        if 'taql' in glb: del glb['taql']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']
        if 'useflags' in glb: del glb['useflags']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# visstat -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__axis_inp( )
        self.__datacolumn_inp( )
        self.__useflags_inp( )
        self.__spw_inp( )
        self.__field_inp( )
        self.__selectdata_inp( )
        self.__antenna_inp( )
        self.__uvrange_inp( )
        self.__timerange_inp( )
        self.__correlation_inp( )
        self.__scan_inp( )
        self.__array_inp( )
        self.__observation_inp( )
        self.__timeaverage_inp( )
        self.__timebin_inp( )
        self.__timespan_inp( )
        self.__maxuvwdistance_inp( )
        self.__disableparallel_inp( )
        self.__ddistart_inp( )
        self.__taql_inp( )
        self.__monolithic_processing_inp( )
        self.__intent_inp( )
        self.__reportingaxes_inp( )
        self.__doquantiles_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "visstat.last" if os.path.isfile("visstat.last") else "visstat.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('visstat.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['axis'] = self.__axis( self.__globals_( ) )
        _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
        _invocation_parameters['useflags'] = self.__useflags( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['array'] = self.__array( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['timeaverage'] = self.__timeaverage( self.__globals_( ) )
        _invocation_parameters['timebin'] = self.__timebin( self.__globals_( ) )
        _invocation_parameters['timespan'] = self.__timespan( self.__globals_( ) )
        _invocation_parameters['maxuvwdistance'] = self.__maxuvwdistance( self.__globals_( ) )
        _invocation_parameters['disableparallel'] = self.__disableparallel( self.__globals_( ) )
        _invocation_parameters['ddistart'] = self.__ddistart( self.__globals_( ) )
        _invocation_parameters['taql'] = self.__taql( self.__globals_( ) )
        _invocation_parameters['monolithic_processing'] = self.__monolithic_processing( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['reportingaxes'] = self.__reportingaxes( self.__globals_( ) )
        _invocation_parameters['doquantiles'] = self.__doquantiles( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-21s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#visstat( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, axis=None, datacolumn=None, useflags=None, spw=None, field=None, selectdata=None, antenna=None, uvrange=None, timerange=None, correlation=None, scan=None, array=None, observation=None, timeaverage=None, timebin=None, timespan=None, maxuvwdistance=None, disableparallel=None, ddistart=None, taql=None, monolithic_processing=None, intent=None, reportingaxes=None, doquantiles=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('visstat.pre')
        _postfile = os.path.realpath('visstat.last')
        task_result = None
        _arguments = [vis,axis,datacolumn,useflags,spw,field,selectdata,antenna,uvrange,timerange,correlation,scan,array,observation,timeaverage,timebin,timespan,maxuvwdistance,disableparallel,ddistart,taql,monolithic_processing,intent,reportingaxes,doquantiles]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if axis is not None: local_global['axis'] = axis
            if useflags is not None: local_global['useflags'] = useflags
            if spw is not None: local_global['spw'] = spw
            if field is not None: local_global['field'] = field
            if selectdata is not None: local_global['selectdata'] = selectdata
            if timeaverage is not None: local_global['timeaverage'] = timeaverage
            if intent is not None: local_global['intent'] = intent
            if reportingaxes is not None: local_global['reportingaxes'] = reportingaxes
            if doquantiles is not None: local_global['doquantiles'] = doquantiles

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['axis'] = self.__axis( local_global )
            _invocation_parameters['useflags'] = self.__useflags( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['timeaverage'] = self.__timeaverage( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['reportingaxes'] = self.__reportingaxes( local_global )
            _invocation_parameters['doquantiles'] = self.__doquantiles( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['datacolumn'] = self.__datacolumn( _invocation_parameters ) if datacolumn is None else datacolumn
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['uvrange'] = self.__uvrange( _invocation_parameters ) if uvrange is None else uvrange
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['correlation'] = self.__correlation( _invocation_parameters ) if correlation is None else correlation
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['array'] = self.__array( _invocation_parameters ) if array is None else array
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['timebin'] = self.__timebin( _invocation_parameters ) if timebin is None else timebin
            _invocation_parameters['timespan'] = self.__timespan( _invocation_parameters ) if timespan is None else timespan
            _invocation_parameters['maxuvwdistance'] = self.__maxuvwdistance( _invocation_parameters ) if maxuvwdistance is None else maxuvwdistance
            _invocation_parameters['disableparallel'] = self.__disableparallel( _invocation_parameters ) if disableparallel is None else disableparallel
            _invocation_parameters['ddistart'] = self.__ddistart( _invocation_parameters ) if ddistart is None else ddistart
            _invocation_parameters['taql'] = self.__taql( _invocation_parameters ) if taql is None else taql
            _invocation_parameters['monolithic_processing'] = self.__monolithic_processing( _invocation_parameters ) if monolithic_processing is None else monolithic_processing

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['axis'] = self.__axis( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['useflags'] = self.__useflags( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['timeaverage'] = self.__timeaverage( self.__globals_( ) )
            _invocation_parameters['timebin'] = self.__timebin( self.__globals_( ) )
            _invocation_parameters['timespan'] = self.__timespan( self.__globals_( ) )
            _invocation_parameters['maxuvwdistance'] = self.__maxuvwdistance( self.__globals_( ) )
            _invocation_parameters['disableparallel'] = self.__disableparallel( self.__globals_( ) )
            _invocation_parameters['ddistart'] = self.__ddistart( self.__globals_( ) )
            _invocation_parameters['taql'] = self.__taql( self.__globals_( ) )
            _invocation_parameters['monolithic_processing'] = self.__monolithic_processing( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['reportingaxes'] = self.__reportingaxes( self.__globals_( ) )
            _invocation_parameters['doquantiles'] = self.__doquantiles( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-21s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#visstat( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'visstat', [ 'vis=' + repr(_pc.document['vis']), 'axis=' + repr(_pc.document['axis']), 'datacolumn=' + repr(_pc.document['datacolumn']), 'useflags=' + repr(_pc.document['useflags']), 'spw=' + repr(_pc.document['spw']), 'field=' + repr(_pc.document['field']), 'selectdata=' + repr(_pc.document['selectdata']), 'antenna=' + repr(_pc.document['antenna']), 'uvrange=' + repr(_pc.document['uvrange']), 'timerange=' + repr(_pc.document['timerange']), 'correlation=' + repr(_pc.document['correlation']), 'scan=' + repr(_pc.document['scan']), 'array=' + repr(_pc.document['array']), 'observation=' + repr(_pc.document['observation']), 'timeaverage=' + repr(_pc.document['timeaverage']), 'timebin=' + repr(_pc.document['timebin']), 'timespan=' + repr(_pc.document['timespan']), 'maxuvwdistance=' + repr(_pc.document['maxuvwdistance']), 'disableparallel=' + repr(_pc.document['disableparallel']), 'ddistart=' + repr(_pc.document['ddistart']), 'taql=' + repr(_pc.document['taql']), 'monolithic_processing=' + repr(_pc.document['monolithic_processing']), 'intent=' + repr(_pc.document['intent']), 'reportingaxes=' + repr(_pc.document['reportingaxes']), 'doquantiles=' + repr(_pc.document['doquantiles']) ] )
            task_result = _visstat_t( _pc.document['vis'],_pc.document['axis'],_pc.document['datacolumn'],_pc.document['useflags'],_pc.document['spw'],_pc.document['field'],_pc.document['selectdata'],_pc.document['antenna'],_pc.document['uvrange'],_pc.document['timerange'],_pc.document['correlation'],_pc.document['scan'],_pc.document['array'],_pc.document['observation'],_pc.document['timeaverage'],_pc.document['timebin'],_pc.document['timespan'],_pc.document['maxuvwdistance'],_pc.document['disableparallel'],_pc.document['ddistart'],_pc.document['taql'],_pc.document['monolithic_processing'],_pc.document['intent'],_pc.document['reportingaxes'],_pc.document['doquantiles'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('visstat')
            casalog.post("Exception Reported: Error in visstat: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'visstat', task_result )

        #Added if _visstat_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

visstat = _visstat( )

