##################### generated by xml-casa (v2) from polcal.xml ####################
##################### fc3d1d4a07231908b23e215ee75e4bbe ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_polcal import polcal as _polcal_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _polcal:
    """
    polcal ---- Determine instrumental polarization calibrations

    
    The complex instrumental polarization factors (D-terms) for each antenna/spwid
    are determined from the data for the specified calibrator sources. Previous
    calibrations can be applied on the fly.

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file
    caltable    Name of output gain calibration table
    field       Select field using field id(s) or field name(s)
    spw         Select spectral window/channels
    intent      Select observing intent
    selectdata  Other data selection parameters
    timerange   Select data based on time range
    uvrange     Select data within uvrange (default units meters)
    antenna     Select data based on antenna/baseline
    scan        Scan number range
    observation Select by observation ID(s)
    msselect    Optional complex data selection (ignore for now)
    solint      Solution interval
    combine     Data axes which to combine for solve (obs, scan, spw, and/or field)
    preavg      Pre-averaging interval (sec)
    refant      Reference antenna name(s)
    minblperant Minimum baselines _per antenna_ required for solve
    minsnr      Reject solutions below this SNR
    poltype     Type of instrumental polarization solution (see help)
    smodel      Point source Stokes parameters for source model.
    append      Append solutions to the (existing) table
    docallib    Use callib or traditional cal apply parameters
    callib      Cal Library filename
    gaintable   Gain calibration table(s) to apply
    gainfield   Select a subset of calibrators from gaintable(s)
    interp      Interpolation mode (in time) to use for each gaintable
    spwmap      Spectral window mappings to form for gaintable(s)
                Only used if callib=False
                default: [] (apply solutions from each calibration spw to
                the same MS spw only)
                Any available calibration spw can be mechanically mapped to any 
                 MS spw. 
                Examples:
                   spwmap=[0,0,1,1] means apply calibration 
                     from cal spw = 0 to MS spw 0,1 and cal spw 1 to MS spws 2,3.
                   spwmap=[[0,0,1,1],[0,1,0,1]] (use a list of lists for multiple
                     gaintables)

    --------- examples -----------------------------------------------------------

    
    
    The instrumental polarization factors (D-terms), the calibrator polarization,
    and the R-L polarization angle can be determined using polcal.  The solutions
    can be obtained for each antenna/spwid and even individual channels, if desired.
    Previous calibrations of the total intensity data should be applied on the fly
    when running polcal, since polcal uses the 'data' column, not the 'corrected'
    column.
    
    After calibrating the gain, bandpass, and (if relevant, for channelized data)
    cross-hand delay, the simplest way to calibrate the polarization data is:
    
    a) Run polcal with poltype = 'D+QU' on the main 'calibrator' source.  The D terms
    and polarization (QU) of the calibrator will be determined.  Relatively good
    parallactic angle coverage is needed.
    
    b) If there is little parallactic angle coverage, place the known polarization of
    the main calibrator (or 0) using setjy with the appropriate fluxdensity.  Then
    run polcal with poltype = 'D'.  Run plotcal with xaxis = 'real'; yaxis ='imag'
    to view solutions.  It is best to use an unpolarized calibrator in this
    instance; large systematic offsets from zero indicate significant source
    polarization that will bias the polarization calibration.  A mechanism
    to constrain this bias will be made available in the near future.
    
    c) To determine R-L polarization angle, use setjy to put the fluxdensity of the
    polarization calibrator [I,Q,U,0.0] in the model column.  For resolved sources
    put in values associated with an appropriate u-v range.  Polarized models are
    not yet available for the major polarization standard sources, so very
    resolved polarized sources should not be used.
    
    d) Run polcal with poltype = 'X' and include polarization standard.  Make sure to
    include all previous calibrations, especially the D results.  Run plotxy with
    correlation = 'RL LR' and make sure polarization angles are as expected.
    
    e) Run applycal with all calibration table, include the D and X tables.  Make sure
    that parang = T
    
    NOTE: For very high dynamic range, use poltype='Df' or 'Df+QU' to determine
    D terms for each channel.  Similarly, poltype='Xf' can
    be used to determine a channel-dependent R-L phase
    "bandpass".
    NOTE: Rather than use setjy in b and c above, the new smodel
    parameter may be used in polcal to specify a simple
    point source Stokes model.
    
    Keyword arguments:
    vis -- Name of input visibility file
    default: none; example: vis='ngc5921.ms'
    caltable -- Name of output gain calibration table
    default: none; example: caltable='ngc5921.dcal'
    
    --- Data Selection (see help par.selectdata for more detailed information)
    
    field -- Select field using field id(s) or field name(s).
    [run listobs to obtain the list id's or names]
    default: ''=all fields.
    Most likely, the main calibrator source should be picked.
    If field string is a non-negative integer, it is assumed a field index
    otherwise, it is assumed a field name
    field='0~2'; field ids 0,1,2
    field='0,4,5~7'; field ids 0,4,5,6,7
    field='3C286,3C295'; field named 3C286 adn 3C295
    field = '3,4C*'; field id 3, all names starting with 4C
    spw -- Select spectral window/channels
    type 'help par.selection' for more examples.
    spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
    spw='<2';  spectral windows less than 2 (i.e. 0,1)
    spw='0:5~61'; spw 0, channels 5 to 61, INCLUSIVE
    spw='*:5~61'; all spw with channels 5 to 62
    spw='0,10,3:3~45'; spw 0,10 all channels, spw 3, channels 3 to 45.
    spw='0~2:2~6'; spw 0,1,2 with channels 2 through 6 in each.
    spw='0:0~10;15~60'; spectral window 0 with channels 0-10,15-60
    NOTE ';' to separate channel selections
    spw='0:0~10^2,1:20~30^5'; spw 0, channels 0,2,4,6,8,10,
    spw 1, channels 20,25,30
    intent -- Select observing intent
    default: ''  (no selection by intent)
    intent='*BANDPASS*'  (selects data labelled with
    BANDPASS intent)
    selectdata -- Other data selection parameters
    default: True
    timerange  -- Select data based on time range:
    default = '' (all); examples,
    timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: if YYYY/MM/DD is missing dat defaults to first day in data set
    timerange='09:14:0~09:54:0' picks 40 min on first day
    timerange= '25:00:00~27:30:00' picks 1 hr to 3 hr 30min on next day
    timerange='09:44:00' data within one integration of time
    timerange='>10:24:00' data after this time
    uvrange -- Select data within uvrange (default units meters)
    default: '' (all); example:
    uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
    uvrange='>4klambda';uvranges greater than 4 kilo-lambda
    antenna -- Select data based on antenna/baseline
    default: '' (all)
    If antenna string is a non-negative integer, it is assumed an antenna index
    otherwise, it is assumed as an antenna name
    antenna='5&6'; baseline between antenna index 5 and index 6.
    antenna='VA05&VA06'; baseline between VLA antenna 5 and 6.
    antenna='5&6;7&8'; baseline 5-6 and 7-8
    antenna='5'; all baselines with antenna index 5
    antenna='05'; all baselines with antenna name 05, i.e. VLA ant 5
    antenna='5,6,10'; all baselines with antennas 5, 6 and 10
    scan -- Scan number range
    observation -- Observation ID(s).
    default: '' = all
    example: '0~2,4'
    msselect -- Optional complex data selection (ignore for now)
    
    --- Solution parameters
    poltype -- Type of instrumental polarization solution
    'D+QU' (or 'Df+QU')  solve also for apparent source polarization (channelized D)
    Need relatively good parallactic angle coverage for this
    'D' (or 'Df') solve only for instrumental polarization (channelized).  The
    I, Q, U flux density of the source can be placed in the model column using
    setjy.  Use for poor parallactic angle coverage.
    'X' (or 'Xf') = solve only for position angle correction (channelized).
    The source must have its I, Q, U flux density in the model column
    or specified in smodel.  If the source is resolved, use a limited
    uvrange that is appropriate.
    'D+X' (or 'Df+X') = solve also for position angle offset (channelized D) as
    well as the D-term.  Not normally done.
    default: 'D+QU'
    The solution used the traditional linear approximation.  Non-linearized options
    will be avaible soon.
    smodel -- Point source Stokes parameters for source model (experimental)
    default: [] (use MODEL_DATA column)
    examples: [1,0,0,0] (I=1, unpolarized)
    [5.2,0.2,0.3,0.0] (I=5.2, Q=0.2, U=0.3, V=0.0)
    solint --  Solution interval (units optional)
    default: 'inf' (~infinite, up to boundaries controlled by combine);
    Options: 'inf' (~infinite), 'int' (per integration), any float
    or integer value with or without units
    examples: solint='1min'; solint='60s', solint=60 --> 1 minute
    solint='0s'; solint=0; solint='int' --> per integration
    solint-'-1s'; solint='inf' --> ~infinite, up to boundaries
    enforced by combine
    combine -- Data axes to combine for solving
    default: 'obs,scan' --> solutions will break at field and spw
    boundaries but may extend over multiple obs and scans
    (per field and spw) up to solint.
    Options: '','obs','scan','spw',field', or any comma-separated
    combination in a single string
    example: combine='scan,spw' --> extend solutions over scan boundaries
    (up to the solint), and combine spws for solving
    preavg -- Pre-averaging interval (sec)
    default=300
    Interval to apply parallactic angle.
    refant -- Reference antenna name
    default: '' => refant = '0'
    example: refant='13' (antenna with index 13)
    refant='VA04' (VLA antenna #4)
    refant='EA02,EA23,EA13' (EVLA antenna EA02, use
    EA23 and EA13 as alternates if/when EA02
    drops out)
    Use 'go listobs' for antenna listing.
    USE SAME REFERENCE ANTENNA AS USED FOR I CALIBRATION.
    minblperant -- Minimum number of baselines required per antenna for each solve
    Antennas with fewer baaselines are excluded from solutions. Amplitude
    solutions with fewer than 4 baselines, and phase solutions with fewer
    than 3 baselines are only trivially constrained, and are no better
    than baseline-based solutions.
    default: 4
    example: minblperant=10  => Antennas participating on 10 or more
    baselines are included in the solve
    minsnr -- Reject solutions below this SNR
    default: 3.0
    append -- Append solutions to the (existing) table.  Appended solutions
    must be derived from the same MS as the existing
    caltable, and solution spws must have the same
    meta-info (according to spw selection and solint)
    or be non-overlapping.
    default: False; overwrite existing table or make new table
    
    --- Other calibrations to apply on the fly before determining polcal solution
    
    docallib -- Control means of specifying the caltables:
    default: False ==> Use gaintable,gainfield,interp,spwmap,calwt
    If True, specify a file containing cal library in callib
    callib -- If docallib=True, specify a file containing cal
    library directives
    
    gaintable -- Gain calibration table(s) to apply
    default: '' (none);  BUT I CALIBRATION TABLES SHOULD GENERALLY BE INCLUDED
    examples: gaintable='ngc5921.gcal'
    gaintable=['ngc5921.ampcal','ngc5921.phcal']
    gainfield -- Select a subset of calibrators from gaintable(s)
    default:'' ==> all sources in table;
    'nearest' ==> nearest (on sky) available field in table
    otherwise, same syntax as field
    example: gainfield='0~3'
    gainfield=['0~3','4~6'] means use field 0 through 3
    from first gain file, field 4 through 6 for second.
    interp -- Interpolation type (in time[,freq]) to use for each gaintable.
    When frequency interpolation is relevant (B, Df, Xf),
    separate time-dependent and freq-dependent interp
    types with a comma (freq _after_ the comma).
    Specifications for frequency are ignored when the
    calibration table has no channel-dependence.
    Time-dependent interp options ending in 'PD' enable a
    "phase delay" correction per spw for non-channel-dependent
    calibration types.
    For multi-obsId datasets, 'perobs' can be appended to
    the time-dependent interpolation specification to
    enforce obsId boundaries when interpolating in time.
    For multi-scan datasets, 'perscan' can be appended to
    the time-dependent interpolation specification to
    enforce scan boundaries when interpolating in time.
    default: '' --> 'linear,linear' for all gaintable(s)
    example: interp='nearest'   (in time, freq-dep will be
    linear, if relevant)
    interp='linear,cubic'  (linear in time, cubic
    in freq)
    interp='linearperobs,spline' (linear in time
    per obsId,
    spline in freq)
    interp=',spline'  (spline in freq; linear in
    time by default)
    interp=['nearest,spline','linear']  (for multiple gaintables)
    Options: Time: 'nearest', 'linear'
    Freq: 'nearest', 'linear', 'cubic', 'spline'
    spwmap -- Spectral windows combinations to form for gaintable(s)
    default: [] (apply solutions from each spw to that spw only)
    Example:  spwmap=[0,0,1,1] means apply the caltable solutions
    from spw = 0 to the spw 0,1 and spw 1 to spw 2,3.
    spwmap=[[0,0,1,1],[0,1,0,1]]


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Determine instrumental polarization calibrations"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'caltable': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'intent': {'type': 'cStr', 'coerce': _coerce.to_str}, 'selectdata': {'type': 'cBool'}, 'timerange': {'type': 'cStr', 'coerce': _coerce.to_str}, 'uvrange': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'antenna': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scan': {'type': 'cStr', 'coerce': _coerce.to_str}, 'observation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'msselect': {'type': 'cStr', 'coerce': _coerce.to_str}, 'solint': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'combine': {'type': 'cStr', 'coerce': _coerce.to_str}, 'preavg': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'refant': {'type': 'cStr', 'coerce': _coerce.to_str}, 'minblperant': {'type': 'cInt'}, 'minsnr': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'poltype': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'Dflls', 'D', 'Dlls', 'D+QU', 'D+X', 'PosAng', 'X', 'Dfgen', 'Dfgen+X', 'Df+X', 'Df', 'Dgen+X', 'Dgen+QU', 'Df+QU', 'Dgen', 'Xfparang+QU', 'Xf', 'Dfgen+QU', 'Xj', 'Xparang+QU' ]}, 'smodel': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'append': {'type': 'cBool'}, 'docallib': {'type': 'cBool'}, 'callib': {'type': 'cStr', 'coerce': _coerce.to_str}, 'gaintable': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'gainfield': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'interp': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'spwmap': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 14 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __solint_dflt( self, glb ):
        return 'inf'

    def __solint( self, glb ):
        if 'solint' in glb: return glb['solint']
        return 'inf'

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __caltable_dflt( self, glb ):
        return ''

    def __caltable( self, glb ):
        if 'caltable' in glb: return glb['caltable']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __preavg_dflt( self, glb ):
        return float(300.0)

    def __preavg( self, glb ):
        if 'preavg' in glb: return glb['preavg']
        return float(300.0)

    def __refant_dflt( self, glb ):
        return ''

    def __refant( self, glb ):
        if 'refant' in glb: return glb['refant']
        return ''

    def __smodel_dflt( self, glb ):
        return [  ]

    def __smodel( self, glb ):
        if 'smodel' in glb: return glb['smodel']
        return [  ]

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __minblperant_dflt( self, glb ):
        return int(4)

    def __minblperant( self, glb ):
        if 'minblperant' in glb: return glb['minblperant']
        return int(4)

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __minsnr_dflt( self, glb ):
        return float(3.0)

    def __minsnr( self, glb ):
        if 'minsnr' in glb: return glb['minsnr']
        return float(3.0)

    def __append_dflt( self, glb ):
        return False

    def __append( self, glb ):
        if 'append' in glb: return glb['append']
        return False

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __combine_dflt( self, glb ):
        return 'obs,scan'

    def __combine( self, glb ):
        if 'combine' in glb: return glb['combine']
        return 'obs,scan'

    def __docallib_dflt( self, glb ):
        return False

    def __docallib( self, glb ):
        if 'docallib' in glb: return glb['docallib']
        return False

    def __poltype_dflt( self, glb ):
        return 'D+QU'

    def __poltype( self, glb ):
        if 'poltype' in glb: return glb['poltype']
        return 'D+QU'



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __callib_dflt( self, glb ):
        if self.__docallib( glb ) == bool(True): return ""
        return None
    def __gainfield_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __msselect_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __spwmap_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __interp_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __uvrange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __gaintable_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None

    #--------- return subparam values -------------------------------------------------
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        dflt = self.__uvrange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __msselect( self, glb ):
        if 'msselect' in glb: return glb['msselect']
        dflt = self.__msselect_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __callib( self, glb ):
        if 'callib' in glb: return glb['callib']
        dflt = self.__callib_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __gaintable( self, glb ):
        if 'gaintable' in glb: return glb['gaintable']
        dflt = self.__gaintable_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __gainfield( self, glb ):
        if 'gainfield' in glb: return glb['gainfield']
        dflt = self.__gainfield_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        dflt = self.__interp_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        dflt = self.__spwmap_dflt( glb )
        if dflt is not None: return dflt
        return [ ]

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __caltable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__caltable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of output gain calibration table'
        value = self.__caltable( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'caltable': value},{'caltable': self.__schema['caltable']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('caltable',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select field using field id(s) or field name(s)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select spectral window/channels'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select observing intent'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __selectdata_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__selectdata_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Other data selection parameters'
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('selectdata',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on time range'
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __uvrange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__uvrange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__uvrange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data within uvrange (default units meters)'
             value = self.__uvrange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('uvrange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on antenna/baseline'
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'Scan number range'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = 'Select by observation ID(s)'
             value = self.__observation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __msselect_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__msselect_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__msselect_dflt( self.__globals_( ) ) is not None:
             description = 'Optional complex data selection (ignore for now)'
             value = self.__msselect( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'msselect': value},{'msselect': self.__schema['msselect']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('msselect',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __solint_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__solint_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'inf'
        description = 'Solution interval'
        value = self.__solint( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'solint': value},{'solint': self.__schema['solint']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('solint',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __combine_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__combine_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'obs,scan'
        description = 'Data axes which to combine for solve (obs, scan, spw, and/or field)'
        value = self.__combine( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'combine': value},{'combine': self.__schema['combine']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('combine',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __preavg_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__preavg_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(300.0)
        description = 'Pre-averaging interval (sec)'
        value = self.__preavg( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'preavg': value},{'preavg': self.__schema['preavg']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('preavg',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __refant_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__refant_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Reference antenna name(s)'
        value = self.__refant( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'refant': value},{'refant': self.__schema['refant']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('refant',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __minblperant_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minblperant_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(4)
        description = 'Minimum baselines _per antenna_ required for solve'
        value = self.__minblperant( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minblperant': value},{'minblperant': self.__schema['minblperant']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('minblperant',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __minsnr_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minsnr_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(3.0)
        description = 'Reject solutions below this SNR'
        value = self.__minsnr( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minsnr': value},{'minsnr': self.__schema['minsnr']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('minsnr',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __poltype_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__poltype_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'D+QU'
        description = 'Type of instrumental polarization solution (see help)'
        value = self.__poltype( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'poltype': value},{'poltype': self.__schema['poltype']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('poltype',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __smodel_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__smodel_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Point source Stokes parameters for source model.'
        value = self.__smodel( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'smodel': value},{'smodel': self.__schema['smodel']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('smodel',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __append_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__append_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Append solutions to the (existing) table'
        value = self.__append( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'append': value},{'append': self.__schema['append']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('append',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __docallib_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__docallib_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Use callib or traditional cal apply parameters'
        value = self.__docallib( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'docallib': value},{'docallib': self.__schema['docallib']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('docallib',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __callib_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__callib_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__callib_dflt( self.__globals_( ) ) is not None:
             description = 'Cal Library filename'
             value = self.__callib( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'callib': value},{'callib': self.__schema['callib']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('callib',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __gaintable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gaintable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__gaintable_dflt( self.__globals_( ) ) is not None:
             description = 'Gain calibration table(s) to apply'
             value = self.__gaintable( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gaintable': value},{'gaintable': self.__schema['gaintable']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('gaintable',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __gainfield_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gainfield_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__gainfield_dflt( self.__globals_( ) ) is not None:
             description = 'Select a subset of calibrators from gaintable(s)'
             value = self.__gainfield( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gainfield': value},{'gainfield': self.__schema['gainfield']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('gainfield',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __interp_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interp_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__interp_dflt( self.__globals_( ) ) is not None:
             description = 'Interpolation mode (in time) to use for each gaintable'
             value = self.__interp( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('interp',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __spwmap_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spwmap_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ ]
        if self.__spwmap_dflt( self.__globals_( ) ) is not None:
             description = 'Spectral window mappings to form for gaintable(s)'
             value = self.__spwmap( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('spwmap',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'callib' in glb: del glb['callib']
        if 'gainfield' in glb: del glb['gainfield']
        if 'poltype' in glb: del glb['poltype']
        if 'preavg' in glb: del glb['preavg']
        if 'field' in glb: del glb['field']
        if 'msselect' in glb: del glb['msselect']
        if 'intent' in glb: del glb['intent']
        if 'spwmap' in glb: del glb['spwmap']
        if 'refant' in glb: del glb['refant']
        if 'minsnr' in glb: del glb['minsnr']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'minblperant' in glb: del glb['minblperant']
        if 'interp' in glb: del glb['interp']
        if 'docallib' in glb: del glb['docallib']
        if 'combine' in glb: del glb['combine']
        if 'uvrange' in glb: del glb['uvrange']
        if 'solint' in glb: del glb['solint']
        if 'caltable' in glb: del glb['caltable']
        if 'observation' in glb: del glb['observation']
        if 'smodel' in glb: del glb['smodel']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']
        if 'gaintable' in glb: del glb['gaintable']
        if 'append' in glb: del glb['append']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# polcal -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__caltable_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__intent_inp( )
        self.__selectdata_inp( )
        self.__timerange_inp( )
        self.__uvrange_inp( )
        self.__antenna_inp( )
        self.__scan_inp( )
        self.__observation_inp( )
        self.__msselect_inp( )
        self.__solint_inp( )
        self.__combine_inp( )
        self.__preavg_inp( )
        self.__refant_inp( )
        self.__minblperant_inp( )
        self.__minsnr_inp( )
        self.__poltype_inp( )
        self.__smodel_inp( )
        self.__append_inp( )
        self.__docallib_inp( )
        self.__callib_inp( )
        self.__gaintable_inp( )
        self.__gainfield_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "polcal.last" if os.path.isfile("polcal.last") else "polcal.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('polcal.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['msselect'] = self.__msselect( self.__globals_( ) )
        _invocation_parameters['solint'] = self.__solint( self.__globals_( ) )
        _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
        _invocation_parameters['preavg'] = self.__preavg( self.__globals_( ) )
        _invocation_parameters['refant'] = self.__refant( self.__globals_( ) )
        _invocation_parameters['minblperant'] = self.__minblperant( self.__globals_( ) )
        _invocation_parameters['minsnr'] = self.__minsnr( self.__globals_( ) )
        _invocation_parameters['poltype'] = self.__poltype( self.__globals_( ) )
        _invocation_parameters['smodel'] = self.__smodel( self.__globals_( ) )
        _invocation_parameters['append'] = self.__append( self.__globals_( ) )
        _invocation_parameters['docallib'] = self.__docallib( self.__globals_( ) )
        _invocation_parameters['callib'] = self.__callib( self.__globals_( ) )
        _invocation_parameters['gaintable'] = self.__gaintable( self.__globals_( ) )
        _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
        _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
        _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#polcal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, caltable=None, field=None, spw=None, intent=None, selectdata=None, timerange=None, uvrange=None, antenna=None, scan=None, observation=None, msselect=None, solint=None, combine=None, preavg=None, refant=None, minblperant=None, minsnr=None, poltype=None, smodel=None, append=None, docallib=None, callib=None, gaintable=None, gainfield=None, interp=None, spwmap=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('polcal.pre')
        _postfile = os.path.realpath('polcal.last')
        task_result = None
        _arguments = [vis,caltable,field,spw,intent,selectdata,timerange,uvrange,antenna,scan,observation,msselect,solint,combine,preavg,refant,minblperant,minsnr,poltype,smodel,append,docallib,callib,gaintable,gainfield,interp,spwmap]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if caltable is not None: local_global['caltable'] = caltable
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if intent is not None: local_global['intent'] = intent
            if selectdata is not None: local_global['selectdata'] = selectdata
            if solint is not None: local_global['solint'] = solint
            if combine is not None: local_global['combine'] = combine
            if preavg is not None: local_global['preavg'] = preavg
            if refant is not None: local_global['refant'] = refant
            if minblperant is not None: local_global['minblperant'] = minblperant
            if minsnr is not None: local_global['minsnr'] = minsnr
            if poltype is not None: local_global['poltype'] = poltype
            if smodel is not None: local_global['smodel'] = smodel
            if append is not None: local_global['append'] = append
            if docallib is not None: local_global['docallib'] = docallib

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['caltable'] = self.__caltable( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['solint'] = self.__solint( local_global )
            _invocation_parameters['combine'] = self.__combine( local_global )
            _invocation_parameters['preavg'] = self.__preavg( local_global )
            _invocation_parameters['refant'] = self.__refant( local_global )
            _invocation_parameters['minblperant'] = self.__minblperant( local_global )
            _invocation_parameters['minsnr'] = self.__minsnr( local_global )
            _invocation_parameters['poltype'] = self.__poltype( local_global )
            _invocation_parameters['smodel'] = self.__smodel( local_global )
            _invocation_parameters['append'] = self.__append( local_global )
            _invocation_parameters['docallib'] = self.__docallib( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['uvrange'] = self.__uvrange( _invocation_parameters ) if uvrange is None else uvrange
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['msselect'] = self.__msselect( _invocation_parameters ) if msselect is None else msselect
            _invocation_parameters['callib'] = self.__callib( _invocation_parameters ) if callib is None else callib
            _invocation_parameters['gaintable'] = self.__gaintable( _invocation_parameters ) if gaintable is None else gaintable
            _invocation_parameters['gainfield'] = self.__gainfield( _invocation_parameters ) if gainfield is None else gainfield
            _invocation_parameters['interp'] = self.__interp( _invocation_parameters ) if interp is None else interp
            _invocation_parameters['spwmap'] = self.__spwmap( _invocation_parameters ) if spwmap is None else spwmap

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['msselect'] = self.__msselect( self.__globals_( ) )
            _invocation_parameters['solint'] = self.__solint( self.__globals_( ) )
            _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
            _invocation_parameters['preavg'] = self.__preavg( self.__globals_( ) )
            _invocation_parameters['refant'] = self.__refant( self.__globals_( ) )
            _invocation_parameters['minblperant'] = self.__minblperant( self.__globals_( ) )
            _invocation_parameters['minsnr'] = self.__minsnr( self.__globals_( ) )
            _invocation_parameters['poltype'] = self.__poltype( self.__globals_( ) )
            _invocation_parameters['smodel'] = self.__smodel( self.__globals_( ) )
            _invocation_parameters['append'] = self.__append( self.__globals_( ) )
            _invocation_parameters['docallib'] = self.__docallib( self.__globals_( ) )
            _invocation_parameters['callib'] = self.__callib( self.__globals_( ) )
            _invocation_parameters['gaintable'] = self.__gaintable( self.__globals_( ) )
            _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#polcal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'polcal', [ 'vis=' + repr(_pc.document['vis']), 'caltable=' + repr(_pc.document['caltable']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'intent=' + repr(_pc.document['intent']), 'selectdata=' + repr(_pc.document['selectdata']), 'timerange=' + repr(_pc.document['timerange']), 'uvrange=' + repr(_pc.document['uvrange']), 'antenna=' + repr(_pc.document['antenna']), 'scan=' + repr(_pc.document['scan']), 'observation=' + repr(_pc.document['observation']), 'msselect=' + repr(_pc.document['msselect']), 'solint=' + repr(_pc.document['solint']), 'combine=' + repr(_pc.document['combine']), 'preavg=' + repr(_pc.document['preavg']), 'refant=' + repr(_pc.document['refant']), 'minblperant=' + repr(_pc.document['minblperant']), 'minsnr=' + repr(_pc.document['minsnr']), 'poltype=' + repr(_pc.document['poltype']), 'smodel=' + repr(_pc.document['smodel']), 'append=' + repr(_pc.document['append']), 'docallib=' + repr(_pc.document['docallib']), 'callib=' + repr(_pc.document['callib']), 'gaintable=' + repr(_pc.document['gaintable']), 'gainfield=' + repr(_pc.document['gainfield']), 'interp=' + repr(_pc.document['interp']), 'spwmap=' + repr(_pc.document['spwmap']) ] )
            task_result = _polcal_t( _pc.document['vis'],_pc.document['caltable'],_pc.document['field'],_pc.document['spw'],_pc.document['intent'],_pc.document['selectdata'],_pc.document['timerange'],_pc.document['uvrange'],_pc.document['antenna'],_pc.document['scan'],_pc.document['observation'],_pc.document['msselect'],_pc.document['solint'],_pc.document['combine'],_pc.document['preavg'],_pc.document['refant'],_pc.document['minblperant'],_pc.document['minsnr'],_pc.document['poltype'],_pc.document['smodel'],_pc.document['append'],_pc.document['docallib'],_pc.document['callib'],_pc.document['gaintable'],_pc.document['gainfield'],_pc.document['interp'],_pc.document['spwmap'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('polcal')
            casalog.post("Exception Reported: Error in polcal: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'polcal', task_result )

        #Added if _polcal_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

polcal = _polcal( )

