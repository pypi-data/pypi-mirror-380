##################### generated by xml-casa (v2) from sdbaseline.xml ################
##################### 4530469d254eac6ebd5f62b408a92603 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_sdbaseline import sdbaseline as _sdbaseline_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _sdbaseline:
    """
    sdbaseline ---- Fit/subtract a spectral baseline

    
    Task sdbaseline fits and/or subtracts baseline from single-dish spectra.
    Given baseline parameters (baseline type, order, etc.), sdbaseline
    computes the best-fit baseline for each spectrum by least-square fitting
    method and, if you want, subtracts it. The best-fit baseline parameters
    (including baseline type, coefficients of basis functions, etc.) and
    other values such as residual rms can be saved in various formats
    including ascii text (in human-readable format or CSV format) or baseline
    table (a CASA table).
    Sdbaseline has another mode to 'apply' a baseline table to a MS data;
    for each spectrum in MS, the best-fit baseline is reproduced from the
    baseline parameters stored in the given baseline table and subtracted.
    Putting 'fit' and 'subtract' into separate processes can be useful for
    pipeline processing for huge dataset.
    

    --------- parameter descriptions ---------------------------------------------

    infile       name of input SD dataset
    datacolumn   name of data column to be used ["data", "float_data", or "corrected"]
    antenna      select data by antenna name or ID, e.g. "PM03"
    field        select data by field IDs and names, e.g. "3C2*" (""=all)
    spw          select data by IF IDs (spectral windows), e.g. "3,5,7" (""=all)
    timerange    select data by time range, e.g. "09:14:0~09:54:0" (""=all) (see examples in help)
    scan         select data by scan numbers, e.g. "21~23" (""=all)
    pol          select data by polarization IDs, e.g. "XX,YY" (""=all)
    intent       select data by observational intent, e.g. "*ON_SOURCE*" (""=all)
    reindex      Re-index indices in subtables based on data selection. Ignored when blmode='apply'.
    maskmode     mode of setting additional channel masks. "list" and "auto" are available now.
    thresh       S/N threshold for linefinder
    avg_limit    channel averaging for broad lines
    minwidth     the minimum channel width to detect as a line
    edge         channels to drop at beginning and end of spectrum
    blmode       baselining mode ["fit" or "apply"]
    dosubtract   subtract baseline from input data [True, False]
    blformat     format(s) of file(s) in which best-fit parameters are written ["text", "csv", "table" or ""]
    bloutput     name(s) of file(s) in which best-fit parameters are written
    bltable      name of baseline table to apply
    blfunc       baseline model function ["poly", "chebyshev", "cspline", "sinusoid", or "variable"(expert mode)]
    order        order of baseline model function
    npiece       number of element polynomials for cubic spline curve
    applyfft     automatically set wave numbers of sinusoids
    fftmethod    method for automatically set wave numbers of sinusoids
    fftthresh    threshold to select wave numbers of sinusoids
    addwn        additional wave numbers to use
    rejwn        wave numbers NOT to use
    clipthresh   clipping threshold for iterative fitting
    clipniter    maximum iteration number for iterative fitting
    blparam      text file that stores per spectrum fit parameters
    verbose      output fitting parameters to logger
    updateweight update WEIGHT column based on sigmavalue computed over unmasked range
    sigmavalue   value used for computing weight ["stddev" or "rms"]
    showprogress (NOT SUPPORTED YET) show progress status for large data
    minnrow      (NOT SUPPORTED YET) minimum number of input spectra to show progress status
    outfile      name of output file
    overwrite    overwrite the output file if already exists
    [1;42mRETURNS[1;m         void

    --------- examples -----------------------------------------------------------

    
    -----------------
    Keyword arguments
    -----------------
    infile -- name of input SD dataset
    datacolumn -- name of data column to be used
    options: 'data', 'float_data', or 'corrected'
    default: 'data'
    antenna -- select data by antenna name or ID
    default: '' (use all antennas)
    example: 'PM03'
    field -- select data by field IDs and names
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 0 or field named 3C273)
    this selection is in addition to the other selections to data
    spw -- select data by IF IDs (spectral windows)/channels
    default: '' (use all IFs and channels)
    example: spw='3,5,7' (IF IDs 3,5,7; all channels)
    spw='<2' (IF IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (IF IDs with the center frequencies in range 30-45GHz; all channels)
    spw='0:5~61' (IF ID 0; channels 5 to 61; all channels)
    spw='3:10~20;50~60' (select multiple channel ranges within IF ID 3)
    spw='3:10~20,4:0~30' (select different channel ranges for IF IDs 3 and 4)
    spw='1~4;6:15~48' (for channels 15 through 48 for IF IDs 1,2,3,4 and 6)
    this selection is in addition to the other selections to data
    timerange -- select data by time range
    default: '' (use all)
    example: timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: YYYY/MM/DD can be dropped as needed:
    timerange='09:14:00~09:54:00' # this time range
    timerange='09:44:00' # data within one integration of time
    timerange='>10:24:00' # data after this time
    timerange='09:44:00+00:13:00' #data 13 minutes after time
    this selection is in addition to the other selections to data
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    this selection is in addition to the other selections to data
    pol -- select data by polarization IDs
    default: '' (use all polarizations)
    example: pol='XX,YY' (polarizations XX and YY)
    this selection is in addition to the other selections to data
    intent -- select data by observational intent, also referred to as 'scan intent'
    default: '' (use all scan intents)
    example: intent='*ON_SOURCE*' (any valid scan-intent expression accepted by the MSSelection module can be specified)
    this selection is in addition to the other selections to data
    reindex -- Re-index indices in subtables based on data selection.
    Ignored when blmode='apply'.
    If True, DATA_DESCRIPTION, FEED, SPECTRAL_WINDOW, STATE, and SOURCE
    subtables are filtered  based on data selection and re-indexed in output MS.
    default: True
    maskmode -- mode of setting additional channel masks. When blmode='apply'
    and/or blfunc='variable', maskmode and its subparameters
    are ignored.
    options: 'list', 'auto'
    default: 'list'
    example: maskmode='list' uses channel masks specified with the
    spw parameter. Note that additional channel masks may
    be applied in case you turn on iterative sigma clipping
    by setting a positive number to the clipniter parameter,
    but linefinder doesn't run with this mode.
    maskmode='auto' runs linefinder to detect line regions
    to be excluded from fitting. this mode requires four
    expandable parameters: thresh, avg_limit, minwidth, and edge.
    NOTE maskmode='auto' is EXPERIMENTAL.
    USE WITH CARE! May need to tweak the expandable parameters.
    Note also that channel masks given with the spw parameters
    and additional masks set by iterative sigma clipping are
    effective; the actual channel mask will be a composite
    of these masks (i.e., linefinder + spw + sigma clipping).
    >>> maskmode expandable parameters
    thresh -- S/N threshold for linefinder. a single channel S/N ratio
    above which the channel is considered to be a detection.
    default: 5
    avg_limit -- channel averaging for broad lines. a number of
    consecutive channels not greater than this parameter
    can be averaged to search for broad lines.
    default: 4
    minwidth -- the minimum channel width to detect as a line.
    a line with number of consecutive channels less
    than this parameter will not be detected as a line.
    default: 4
    edge -- channels to drop at beginning and end of spectrum
    default: 0
    example: edge=[1000] drops 1000 channels at beginning AND end.
    edge=[1000,500] drops 1000 from beginning and 500
    from end.
    Note: For bad baselines threshold should be increased,
    and avg_limit decreased (r even switched off completely by
    setting this parameter to 1) to avoid detecting baseline
    undulations instead of real lines.
    blmode -- baselining mode.
    options: 'fit', 'apply'
    default: 'fit'
    example: blmode='fit' calculates the best-fit baseline based on
    given baseline type, then (if you set dosubtract=True)
    subtract it from each spectrum. The information about
    best-fit baselines (baseline type, order, coefficients,
    etc.) can be stored in various formats (cf. blformat).
    blmode='apply' reads a baseline table as well as input
    MS, reproduces the best-fit baseline via info written
    in the baseline table, then subtracts it from each
    spectrum.
    >>> blmode expandable parameters
    dosubtract -- execute baseline subtraction in addition to fitting.
    Note that MS is not output when dosubtract=False.
    Also, sdbaseline will abort when dosubtract=False
    and blformat=''.
    options: (bool) True, False
    default: True
    blformat -- format(s) of file(s) in which best-fit parameters are
    written.
    options: 'text', 'csv', 'table', and '' can be set for
    a single output. In case you want to output
    fitting results in multiple formats, a list
    containing the above keywords is accepted as well.
    default: 'text'
    example: (1) blformat='text' outputs an ascii text file
    with the best-fit baseline parameters written
    in human-readable format. It may be good to read,
    but you should mind it might be huge.
    (2) blformat='csv' outputs a CSV file. For example,
    output of csv with blfunc='poly' is as below:
    #scan, beam, spw, pol, MJD[s], fitrange (i.e. inverse mask), blfunc, order, fitting coefficients, rms, number of clipped channels
    4,0,17,0,4915973292.23,[[252;3828]],poly,1,767.647,-0.00956208,26.3036,0
    ... .
    (3) blformat='table' outputs a baseline table
    which can be used to apply afterwards.
    (4) blformat='' doesn't output any parameter file.
    (5) blformat=['csv','table'] outputs both a CSV
    file and a baseline table.
    (6) If one or more ''s appear in blformat, they
    are all ignored. For example, if blformat=['',
    'text',''] is given, only 'text' will be output.
    (7) Elements of blformat other than '' must not
    be duplicated. For example, blformat=['text','',
    'text'] is not accepted.
    bloutput -- name(s) of file(s) in which best-fit parameters are
    written. If bloutput is a null string '', name(s) of
    baseline parameter file(s) will be set as follows:
    <outfile>_blparam.txt for blformat='text',
    <outfile>_blparam.csv for blformat='csv', and
    <outfile>_blparam.bltable for blformat='table'.
    Otherwise, blformat and bloutput must have the same
    length, and one-to-one correspondence is assumed
    between them. If there are '' elements in bloutput,
    output file names will be set by following the above
    rules. If there are '' elements in blformat, the
    corresponding bloutput elements will be ignored.
    Also, non-'' bloutput elements correspoding to
    non-'' blformat elements must not be duplicated.
    default: ''
    example: (1) bloutput='' and blformat=['csv','table']:
    outputs a csv file '<outfile>_blparam.csv'
    and a baseline table '<outfile>_blparam.bltable'.
    (2) bloutput=['foo.csv',''] and blformat=['csv',
    'table']: outputs a csv file 'foo.csv' and a
    baseline table '<outfile>_blparam.bltable'.
    (3) bloutput=['foo.csv','bar.blt'] and blformat=
    ['csv','']: outputs a csv file 'foo.csv' only.
    (4) bloutput=['foo.csv','foo.csv','bar.blt'] and
    blformat=['csv','','table']: the second 'foo.csv'
    is ignored because it corresponds to the blformat
    element '', and thus outputs a csv file 'foo.csv'
    and a baseline table 'bar.blt'.
    (5) bloutput=['foo.csv','foo.csv','bar.blt'] and
    blformat=['csv','text','table']: will be error
    since 'foo.csv' is duplicated.
    (6) bloutput=['foo.csv','bar.blt'] and blformat=
    ['csv','','table']: will be error since bloutput
    and blformat have different lengths.
    bltable -- name of baseline table to apply
    default: ''
    blfunc -- baseline model function. In cases blmode='apply' or blparam is
    set, blfunc and its subparameters are ignored.
    options: 'poly', 'chebyshev', 'cspline', 'sinusoid' or 'variable'
    default: 'poly'
    example: blfunc='poly' uses a single polynomial line of
    any order which should be given as an expandable
    parameter 'order' to fit baseline.
    blfunc='chebyshev' uses Chebyshev polynomials.
    blfunc='cspline' uses a cubic spline function, a piecewise
    cubic polynomial having C2-continuity (i.e., the second
    derivative is continuous at the joining points).
    blfunc='sinusoid' uses a combination of sinusoidal curves.
    NOTE blfunc='variable' IS EXPERT MODE!!!
    >>> blfunc expandable parameters
    order -- order of baseline model function
    options: (int) (<0 turns off baseline fitting)
    default: 5
    example: typically in range 2-9 (higher values
    seem to be needed for GBT)
    npiece -- number of the element polynomials of cubic spline curve
    options: (int) (<0 turns off baseline fitting)
    default: 2
    applyfft -- automatically choose an appropriate set of sinusoidal
    wave numbers via FFT for each spectrum data.
    options: (bool) True, False
    default: True
    fftmethod -- method to be used when applyfft=True. Now only
    'fft' is available and it is the default.
    fftthresh -- threshold on Fourier-domain spectrum data to pick up
    appropriate wave numbers to be used for sinusoidal
    fitting. both (float) and (str) accepted.
    given a float value, the unit is set to sigma.
    for string values, allowed formats include:
    'xsigma' or 'x' (= above x-sigma level. e.g., '3sigma')
    or 'topx' (= the x strongest ones, e.g. 'top5').
    default is 3.0 (i.e., above 3sigma level).
    addwn -- additional wave number(s) of sinusoids to be used
    for fitting.
    (list) and (int) are accepted to specify every
    wave numbers. also (str) can be used in case
    you need to specify wave numbers in a certain range.
    default: [0] (i.e., constant is subtracted at least)
    example: 0
    [0,1,2]
    '0,1,2'
    'a-b' (= a, a+1, ..., b)
    'a~b' (= a, a+1, ..., b)
    '<a'  (= 0,1,...,a-2,a-1)
    '>=a' (= a, a+1, ... up to the maximum wave
    number corresponding to the Nyquist
    frequency for the case of FFT)
    rejwn -- wave number(s) of sinusoid NOT to be used for fitting.
    can be set just as addwn but has higher priority:
    wave numbers which are specified both in addwn
    and rejwn will NOT be used.
    note also that rejwn value takes precedence over those
    automatically selected by setting applyfft=True as well.
    default: []
    clipthresh -- clipping threshold for iterative fitting
    default: 3
    clipniter -- maximum iteration number for iterative fitting
    default: 0 (no iteration, i.e., no clipping)
    blparam -- the name of text file that stores per spectrum fit
    parameters. See below for details of format.
    verbose -- output fitting parameters to logger (ONLY available
    for blfunc='variable'. if False, the fitting parameters are
    not output to the CASA logger.
    options: (bool) True, False
    default: False
    updateweight -- update WEIGHT column of output MS based on sigmavalue
    computed over unmasked ranges of post-subtraction
    spectra for each row. Note that SIGMA_SPECTRUM and
    WEIGHT_SPECTRUM columns are removed if they exist.
    options: (bool) True, False
    default: False
    >>> updateweight expandable parameter
    sigmavalue -- value used to compute weight as 1/(sigmavalue)^2
    options: stddev, rms
    default: stddev
    showprogress -- (NOT SUPPORTED YET) show progress status for large data
    options: (bool) False (this capability is currently unavailable.)
    default: False
    >>> showprogress expandable parameter
    minnrow -- (NOT SUPPORTED YET) minimum number of input spectra to show progress status
    default: 1000
    outfile -- name of output file
    default: '' (<infile>_bs)
    overwrite -- overwrite the output files (outfile and bloutput) if they
    already exist
    options: (bool) True, False
    default: False
    NOTE this parameter is ignored when outform='ASCII'
    
    
    -----------
    DESCRIPTION
    -----------
    
    Task sdbaseline performs baseline fitting/subtraction for single-dish spectra.
    The fit parameters, terms and rms of baseline can be saved into an ascii file
    or baseline table. Subtracting baseline from data in input MS using existing
    baseline table is also possible.
    
    -----------------------
    BASELINE MODEL FUNCTION
    -----------------------
    The list of available model functions are shown above (see Keyword arguments
    section). In general 'cspline' or 'chebyshev' are recommended since they are
    more stable than others. 'poly' will work for lower order but will be unstable
    for higher order fitting. 'sinusoid' is kind of special mode that will be
    useful for the data that clearly shows standing wave in the spectral baseline.
    
    ----------------------------------
    SIGMA CLIPPING (ITERATIVE FITTING)
    ----------------------------------
    In general least square fitting is strongly affected by an extreme data
    so that the resulting fit makes worse. Sigma clipping is an iterative
    baseline fitting with data clipping based on a certain threshold. Threshold
    is set as a certain factor times rms of the resulting (baseline subtracted)
    spectra. If sigma clipping is on, baseline fit/removal is performed several
    times. After each baseline subtraction, the data whose absolute value is
    above threshold are detected and those data are excluded from the next round
    of fitting. By using sigma clipping, extreme data are excluded from the
    fit so that resulting fit is more robust.
    
    The user is able to control a multiplication factor using parameter
    clipthresh for clipping threshold based on rms. Actual threshold for sigma
    clipping will be (clipthresh) x (rms of spectra). Also, the user can specify
    number of maximum iteration to the parameter clipniter.
    
    In general, sigma clipping will lower the performance since it increases
    number of fits per spectra. However, it is strongly recommended to turn
    on sigma clipping unless you are sure that the data is free from any kind
    of extreme values that may affect the fit.
    
    
    ----------------------------------
    PER-SPECTRUM FIT PARAMETERS
    ----------------------------------
    Per-spectrum baseline fitting parameters can be applied when blfunc='variable'.
    
    The fitting parameters can be defined in a text file and specified in a
    parameter 'blparam'. Each line of the text file should store baseline fitting
    parameters for its corresponding spectrum in the input MS. It must be a
    comma-separated text and contain values in the following order:
    
    (1) 'row': row index
    (2) 'pol': polarization index in the specified row
    (3) 'mask': channel range(s) used for the fitting (see examples below).
    (4) 'clipniter': maximum number of times of iterative fitting (identical to
    the task parameter 'clipniter')
    (5) 'clipthresh': clipping threshold for iterative fitting (identical to
    the task parameter 'clipthresh')
    (6) 'use_linefinder': 'true' or 'false'. Note that linefinder does not run
    with per-spectrum fitting now even if setting 'true',
    due to a bug which will be fixed in the future
    (7) 'thresh': S/N threshold for linefinder (identical to the task parameter
    'thresh'). Blank is accepted when you don't use linefinder
    (8) 'left_edge': channels to drop at beginning of spectrum (identical to the
    first element of the task parameter 'edge')
    (9) 'right_edge': channels to drop at end of spectrum (identical to the
    second element of the task parameter 'edge')
    (10) 'avg_limit': channel averaging for broad lines (identical to the task
    parameter 'avg_limit')
    (11) 'blfunc': baseline model function (identical to the task parameter
    'blfunc')
    (12) 'order': order of polynomial function (identical to the task parameter
    'order'). Needed when (11) is 'poly' or 'chebyshev'. It will
    be ignored when other values are set for blfunc
    (13) 'npiece': number of the element polynomials of cubic spline curve.
    Needed when (11) is 'cspline' (identical to the task
    parameter 'npiece')
    (14) 'nwave': a list of sinusoidal wave numbers. Needed when (11) is
    'sinusoid' though, actually, sinusoidal fitting is yet to be
    available with per-spectrum fitting
    
    Note that the following task parameters will be ignored/overwritten when
    blfunc='variable' is specified (i.e., when per-spectrum fitting is executed):
    
    * for iterative clipping: clipniter, clipthresh
    * for linefinder: thresh, edge, avg_limit
    * for baseline model function: blfunc, order, npiece, applyfft,
    fftmethod, fftthresh, addwn, rejwn
    
    Note also that:
    
    (1) lines starting with '#' will be ignored and can be used as comments
    (2) for MS spectra which have no corresponding line in the text file,
    baseline fitting is not executed
    
    Examples of text file:
    
    (1) a simple one:
    
    0,0,,2,3,false,,,,,poly,5,,[]
    0,1,1500~7500,0,3.,false,0.,0,0,0,chebyshev,10,0,[]
    1,0,,4,2.5,true,5.,70,80,3,cspline,,6,[]
    1,1,0~4000;6000~8000,0,,false,,,,,sinusoid,,,[0,1,2,3,4,5,6,7]
    #2,0,,0,,false,,,,,poly,10,,[]
    
    (2) same setting as (1), but with detailed comments:
    
    # for row 0, pol 0: no channel mask,
    #                   iterative (twice at maximum) clipping at 3 sigma,
    #                   no linefinder,
    #                   fitting with polynomial of order 5
    0,0,,2,3,false,,,,,poly,5,,[]
    # for row 0, pol 1: use channel range 1500 to 7500,
    #                   no iterative clipping (clipniter=0),
    #                   no linefinder,
    #                   fitting with Chebyshev polynomial of order 10
    0,1,1500~7500,0,3.,false,0.,0,0,0,chebyshev,10,0,[]
    # for row 1, pol 0: no channel mask,
    #                   iterative (4 times at maximum) clipping at 2.5 sigma,
    #                   using linefinder (thresh: 5.0 sigma,
    #                                     left_edge: 70 channels,
    #                                     right_edge: 80 channels,
    #                                     avg_limit: 3),
    #                   fitting with cubic spline with 6 elements
    1,0,,4,2.5,true,5.,70,80,3,cspline,,6,[]
    # for row 1, pol 1: use channel ranges (0 to 4000) and (6000 to 8000),
    #                   no iterative clipping,
    #                   no linefinder,
    #                   fitting with sinusoids with wave numbers up to 7
    1,1,0~4000;6000~8000,0,,false,,,,,sinusoid,,,[0,1,2,3,4,5,6,7]
    # for row 2, pol 0: no baseline fitting as the line is commented out
    #2,0,,0,,false,,,,,poly,10,,[]
    
    
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """Fit/subtract a spectral baseline """

    __schema = {'infile': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'datacolumn': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'DATA', 'corrected', 'FLOAT_DATA', 'CORRECTED', 'float_data', 'data' ]}, 'antenna': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'timerange': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scan': {'type': 'cStr', 'coerce': _coerce.to_str}, 'pol': {'type': 'cStr', 'coerce': _coerce.to_str}, 'intent': {'type': 'cStr', 'coerce': _coerce.to_str}, 'reindex': {'type': 'cBool'}, 'maskmode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'list', 'auto', 'LIST', 'AUTO' ]}, 'thresh': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'avg_limit': {'type': 'cInt'}, 'minwidth': {'type': 'cInt'}, 'edge': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'blmode': {'type': 'cStr', 'coerce': _coerce.to_str}, 'dosubtract': {'type': 'cBool'}, 'blformat': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'bloutput': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'bltable': {'type': 'cStr', 'coerce': _coerce.to_str}, 'blfunc': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'variable', 'cspline', 'SINUSOID', 'CSPLINE', 'sinusoid', 'VARIABLE', 'POLY', 'poly', 'chebyshev', 'CHEBYSHEV' ]}, 'order': {'type': 'cInt'}, 'npiece': {'type': 'cInt'}, 'applyfft': {'type': 'cBool'}, 'fftmethod': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'fft', 'FFT' ]}, 'fftthresh': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'addwn': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'rejwn': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'clipthresh': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'clipniter': {'type': 'cInt'}, 'blparam': {'type': 'cStr', 'coerce': _coerce.to_str}, 'verbose': {'type': 'cBool'}, 'updateweight': {'type': 'cBool'}, 'sigmavalue': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'stddev', 'rms' ]}, 'showprogress': {'type': 'cBool'}, 'minnrow': {'type': 'cInt'}, 'outfile': {'type': 'cStr', 'coerce': _coerce.to_str}, 'overwrite': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 13 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __showprogress_dflt( self, glb ):
        return False

    def __showprogress( self, glb ):
        if 'showprogress' in glb: return glb['showprogress']
        return False

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __datacolumn_dflt( self, glb ):
        return 'data'

    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        return 'data'

    def __updateweight_dflt( self, glb ):
        return False

    def __updateweight( self, glb ):
        if 'updateweight' in glb: return glb['updateweight']
        return False

    def __blfunc_dflt( self, glb ):
        return 'poly'

    def __blfunc( self, glb ):
        if 'blfunc' in glb: return glb['blfunc']
        return 'poly'

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __maskmode_dflt( self, glb ):
        return 'list'

    def __maskmode( self, glb ):
        if 'maskmode' in glb: return glb['maskmode']
        return 'list'

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __timerange_dflt( self, glb ):
        return ''

    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        return ''

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __pol_dflt( self, glb ):
        return ''

    def __pol( self, glb ):
        if 'pol' in glb: return glb['pol']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __reindex_dflt( self, glb ):
        return True

    def __reindex( self, glb ):
        if 'reindex' in glb: return glb['reindex']
        return True

    def __infile_dflt( self, glb ):
        return ''

    def __infile( self, glb ):
        if 'infile' in glb: return glb['infile']
        return ''

    def __blmode_dflt( self, glb ):
        return 'fit'

    def __blmode( self, glb ):
        if 'blmode' in glb: return glb['blmode']
        return 'fit'

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __clipthresh_dflt( self, glb ):
        if self.__blfunc( glb ) == "poly": return float(3.0)
        if self.__blfunc( glb ) == "chebyshev": return float(3.0)
        if self.__blfunc( glb ) == "cspline": return float(3.0)
        if self.__blfunc( glb ) == "sinusoid": return float(3.0)
        return None
    def __sigmavalue_dflt( self, glb ):
        if self.__updateweight( glb ) == bool(True): return "stddev"
        return None
    def __rejwn_dflt( self, glb ):
        if self.__blfunc( glb ) == "sinusoid": return []
        return None
    def __thresh_dflt( self, glb ):
        if self.__maskmode( glb ) == "auto": return float(5.0)
        return None
    def __verbose_dflt( self, glb ):
        if self.__blfunc( glb ) == "variable": return bool(False)
        return None
    def __fftmethod_dflt( self, glb ):
        if self.__blfunc( glb ) == "sinusoid": return "fft"
        return None
    def __minwidth_dflt( self, glb ):
        if self.__maskmode( glb ) == "auto": return int(4)
        return None
    def __clipniter_dflt( self, glb ):
        if self.__blfunc( glb ) == "poly": return int(0)
        if self.__blfunc( glb ) == "chebyshev": return int(0)
        if self.__blfunc( glb ) == "cspline": return int(0)
        if self.__blfunc( glb ) == "sinusoid": return int(0)
        return None
    def __bltable_dflt( self, glb ):
        if self.__blmode( glb ) == "apply": return ""
        return None
    def __applyfft_dflt( self, glb ):
        if self.__blfunc( glb ) == "sinusoid": return bool(True)
        return None
    def __blformat_dflt( self, glb ):
        if self.__blmode( glb ) == "fit": return "text"
        return None
    def __dosubtract_dflt( self, glb ):
        if self.__blmode( glb ) == "fit": return bool(True)
        return None
    def __avg_limit_dflt( self, glb ):
        if self.__maskmode( glb ) == "auto": return int(4)
        return None
    def __order_dflt( self, glb ):
        if self.__blfunc( glb ) == "poly": return int(5)
        if self.__blfunc( glb ) == "chebyshev": return int(5)
        return None
    def __fftthresh_dflt( self, glb ):
        if self.__blfunc( glb ) == "sinusoid": return 3.0
        return None
    def __minnrow_dflt( self, glb ):
        if self.__showprogress( glb ) == bool(True): return int(1000)
        return None
    def __blparam_dflt( self, glb ):
        if self.__blfunc( glb ) == "variable": return ""
        return None
    def __addwn_dflt( self, glb ):
        if self.__blfunc( glb ) == "sinusoid": return [int(0)]
        return None
    def __edge_dflt( self, glb ):
        if self.__maskmode( glb ) == "auto": return [int(0),int(0)]
        return None
    def __bloutput_dflt( self, glb ):
        if self.__blmode( glb ) == "fit": return ""
        return None
    def __npiece_dflt( self, glb ):
        if self.__blfunc( glb ) == "cspline": return int(2)
        return None

    #--------- return subparam values -------------------------------------------------
    def __thresh( self, glb ):
        if 'thresh' in glb: return glb['thresh']
        dflt = self.__thresh_dflt( glb )
        if dflt is not None: return dflt
        return float(5.0)
    def __avg_limit( self, glb ):
        if 'avg_limit' in glb: return glb['avg_limit']
        dflt = self.__avg_limit_dflt( glb )
        if dflt is not None: return dflt
        return int(4)
    def __minwidth( self, glb ):
        if 'minwidth' in glb: return glb['minwidth']
        dflt = self.__minwidth_dflt( glb )
        if dflt is not None: return dflt
        return int(4)
    def __edge( self, glb ):
        if 'edge' in glb: return glb['edge']
        dflt = self.__edge_dflt( glb )
        if dflt is not None: return dflt
        return [ int(0),int(0) ]
    def __dosubtract( self, glb ):
        if 'dosubtract' in glb: return glb['dosubtract']
        dflt = self.__dosubtract_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __blformat( self, glb ):
        if 'blformat' in glb: return glb['blformat']
        dflt = self.__blformat_dflt( glb )
        if dflt is not None: return dflt
        return 'text'
    def __bloutput( self, glb ):
        if 'bloutput' in glb: return glb['bloutput']
        dflt = self.__bloutput_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __bltable( self, glb ):
        if 'bltable' in glb: return glb['bltable']
        dflt = self.__bltable_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __order( self, glb ):
        if 'order' in glb: return glb['order']
        dflt = self.__order_dflt( glb )
        if dflt is not None: return dflt
        return int(5)
    def __npiece( self, glb ):
        if 'npiece' in glb: return glb['npiece']
        dflt = self.__npiece_dflt( glb )
        if dflt is not None: return dflt
        return int(2)
    def __applyfft( self, glb ):
        if 'applyfft' in glb: return glb['applyfft']
        dflt = self.__applyfft_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __fftmethod( self, glb ):
        if 'fftmethod' in glb: return glb['fftmethod']
        dflt = self.__fftmethod_dflt( glb )
        if dflt is not None: return dflt
        return 'fft'
    def __fftthresh( self, glb ):
        if 'fftthresh' in glb: return glb['fftthresh']
        dflt = self.__fftthresh_dflt( glb )
        if dflt is not None: return dflt
        return float(3.0)
    def __addwn( self, glb ):
        if 'addwn' in glb: return glb['addwn']
        dflt = self.__addwn_dflt( glb )
        if dflt is not None: return dflt
        return [ int(0) ]
    def __rejwn( self, glb ):
        if 'rejwn' in glb: return glb['rejwn']
        dflt = self.__rejwn_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __clipthresh( self, glb ):
        if 'clipthresh' in glb: return glb['clipthresh']
        dflt = self.__clipthresh_dflt( glb )
        if dflt is not None: return dflt
        return float(3.0)
    def __clipniter( self, glb ):
        if 'clipniter' in glb: return glb['clipniter']
        dflt = self.__clipniter_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __blparam( self, glb ):
        if 'blparam' in glb: return glb['blparam']
        dflt = self.__blparam_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __verbose( self, glb ):
        if 'verbose' in glb: return glb['verbose']
        dflt = self.__verbose_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __sigmavalue( self, glb ):
        if 'sigmavalue' in glb: return glb['sigmavalue']
        dflt = self.__sigmavalue_dflt( glb )
        if dflt is not None: return dflt
        return 'stddev'
    def __minnrow( self, glb ):
        if 'minnrow' in glb: return glb['minnrow']
        dflt = self.__minnrow_dflt( glb )
        if dflt is not None: return dflt
        return int(1000)

    #--------- subparam inp output ----------------------------------------------------
    def __infile_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__infile_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'name of input SD dataset'
        value = self.__infile( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'infile': value},{'infile': self.__schema['infile']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('infile',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __datacolumn_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__datacolumn_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'data'
        description = 'name of data column to be used ["data", "float_data", or "corrected"]'
        value = self.__datacolumn( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('datacolumn',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by antenna name or ID, e.g. "PM03"'
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by field IDs and names, e.g. "3C2*" (""=all)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by IF IDs (spectral windows), e.g. "3,5,7" (""=all)'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by time range, e.g. "09:14:0~09:54:0" (""=all) (see examples in help)'
        value = self.__timerange( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by scan numbers, e.g. "21~23" (""=all)'
        value = self.__scan( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __pol_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__pol_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by polarization IDs, e.g. "XX,YY" (""=all)'
        value = self.__pol( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'pol': value},{'pol': self.__schema['pol']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('pol',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by observational intent, e.g. "*ON_SOURCE*" (""=all)'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __reindex_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__reindex_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Re-index indices in subtables based on data selection'
        value = self.__reindex( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'reindex': value},{'reindex': self.__schema['reindex']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('reindex',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __maskmode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__maskmode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'list'
        description = 'mode of setting additional channel masks ["list" or "auto"]'
        value = self.__maskmode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'maskmode': value},{'maskmode': self.__schema['maskmode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23s%s' % ('maskmode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __thresh_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__thresh_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(5.0)
        if self.__thresh_dflt( self.__globals_( ) ) is not None:
             description = 'S/N threshold for linefinder'
             value = self.__thresh( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'thresh': value},{'thresh': self.__schema['thresh']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('thresh',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __avg_limit_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__avg_limit_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(4)
        if self.__avg_limit_dflt( self.__globals_( ) ) is not None:
             description = 'channel averaging for broad lines'
             value = self.__avg_limit( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'avg_limit': value},{'avg_limit': self.__schema['avg_limit']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('avg_limit',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __minwidth_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minwidth_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(4)
        if self.__minwidth_dflt( self.__globals_( ) ) is not None:
             description = 'the minimum channel width to detect as a line'
             value = self.__minwidth( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minwidth': value},{'minwidth': self.__schema['minwidth']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('minwidth',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __edge_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__edge_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ int(0),int(0) ]
        if self.__edge_dflt( self.__globals_( ) ) is not None:
             description = 'channels to drop at beginning and end of spectrum'
             value = self.__edge( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'edge': value},{'edge': self.__schema['edge']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('edge',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __blmode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__blmode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'fit'
        description = 'baselining mode ["fit" or "apply"]'
        value = self.__blmode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'blmode': value},{'blmode': self.__schema['blmode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23s%s' % ('blmode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __dosubtract_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__dosubtract_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        if self.__dosubtract_dflt( self.__globals_( ) ) is not None:
             description = 'subtract baseline from input data [True, False]'
             value = self.__dosubtract( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'dosubtract': value},{'dosubtract': self.__schema['dosubtract']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('dosubtract',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __blformat_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__blformat_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'text'
        if self.__blformat_dflt( self.__globals_( ) ) is not None:
             description = 'format(s) of file(s) in which best-fit parameters are written'
             value = self.__blformat( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'blformat': value},{'blformat': self.__schema['blformat']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('blformat',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __bloutput_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__bloutput_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__bloutput_dflt( self.__globals_( ) ) is not None:
             description = 'name(s) of file(s) in which best-fit parameters are written'
             value = self.__bloutput( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'bloutput': value},{'bloutput': self.__schema['bloutput']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('bloutput',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __bltable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__bltable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__bltable_dflt( self.__globals_( ) ) is not None:
             description = 'name of baseline table to apply'
             value = self.__bltable( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'bltable': value},{'bltable': self.__schema['bltable']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('bltable',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __blfunc_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__blfunc_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'poly'
        description = 'baseline model function'
        value = self.__blfunc( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'blfunc': value},{'blfunc': self.__schema['blfunc']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23s%s' % ('blfunc',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __order_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__order_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(5)
        if self.__order_dflt( self.__globals_( ) ) is not None:
             description = 'order of baseline model function'
             value = self.__order( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'order': value},{'order': self.__schema['order']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('order',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __npiece_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__npiece_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(2)
        if self.__npiece_dflt( self.__globals_( ) ) is not None:
             description = 'number of element polynomials for cubic spline curve'
             value = self.__npiece( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'npiece': value},{'npiece': self.__schema['npiece']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('npiece',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __applyfft_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__applyfft_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        if self.__applyfft_dflt( self.__globals_( ) ) is not None:
             description = 'automatically set wave numbers of sinusoids'
             value = self.__applyfft( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'applyfft': value},{'applyfft': self.__schema['applyfft']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('applyfft',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __fftmethod_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fftmethod_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'fft'
        if self.__fftmethod_dflt( self.__globals_( ) ) is not None:
             description = 'method for automatically set wave numbers of sinusoids ["fft"]'
             value = self.__fftmethod( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fftmethod': value},{'fftmethod': self.__schema['fftmethod']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('fftmethod',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __fftthresh_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fftthresh_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(3.0)
        if self.__fftthresh_dflt( self.__globals_( ) ) is not None:
             description = 'threshold to select wave numbers of sinusoids'
             value = self.__fftthresh( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fftthresh': value},{'fftthresh': self.__schema['fftthresh']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('fftthresh',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __addwn_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__addwn_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ int(0) ]
        if self.__addwn_dflt( self.__globals_( ) ) is not None:
             description = 'additional wave numbers to use'
             value = self.__addwn( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'addwn': value},{'addwn': self.__schema['addwn']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('addwn',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __rejwn_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__rejwn_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__rejwn_dflt( self.__globals_( ) ) is not None:
             description = 'wave numbers NOT to use'
             value = self.__rejwn( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'rejwn': value},{'rejwn': self.__schema['rejwn']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('rejwn',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __clipthresh_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__clipthresh_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(3.0)
        if self.__clipthresh_dflt( self.__globals_( ) ) is not None:
             description = 'clipping threshold for iterative fitting'
             value = self.__clipthresh( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'clipthresh': value},{'clipthresh': self.__schema['clipthresh']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('clipthresh',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __clipniter_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__clipniter_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(0)
        if self.__clipniter_dflt( self.__globals_( ) ) is not None:
             description = 'maximum iteration number for iterative fitting'
             value = self.__clipniter( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'clipniter': value},{'clipniter': self.__schema['clipniter']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('clipniter',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __blparam_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__blparam_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__blparam_dflt( self.__globals_( ) ) is not None:
             description = 'text file that stores per spectrum fit parameters'
             value = self.__blparam( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'blparam': value},{'blparam': self.__schema['blparam']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('blparam',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __verbose_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__verbose_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__verbose_dflt( self.__globals_( ) ) is not None:
             description = 'output fitting parameters to logger [True, False]'
             value = self.__verbose( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'verbose': value},{'verbose': self.__schema['verbose']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('verbose',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __updateweight_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__updateweight_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'update WEIGHT column [True, False]'
        value = self.__updateweight( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'updateweight': value},{'updateweight': self.__schema['updateweight']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23s%s' % ('updateweight',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __sigmavalue_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__sigmavalue_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'stddev'
        if self.__sigmavalue_dflt( self.__globals_( ) ) is not None:
             description = 'value used for computing weight'
             value = self.__sigmavalue( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'sigmavalue': value},{'sigmavalue': self.__schema['sigmavalue']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('sigmavalue',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __showprogress_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__showprogress_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = '(NOT SUPPORTED YET) show progress status for large data [True, False] (NOT SUPPORTED YET)'
        value = self.__showprogress( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'showprogress': value},{'showprogress': self.__schema['showprogress']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23s%s' % ('showprogress',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __minnrow_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minnrow_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(1000)
        if self.__minnrow_dflt( self.__globals_( ) ) is not None:
             description = '(NOT SUPPORTED YET) minimum number of input spectra to show progress status'
             value = self.__minnrow( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minnrow': value},{'minnrow': self.__schema['minnrow']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('minnrow',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __outfile_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outfile_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'name of output file'
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('outfile',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __overwrite_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__overwrite_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'overwrite the output file if already exists [True, False]'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('overwrite',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'clipthresh' in glb: del glb['clipthresh']
        if 'infile' in glb: del glb['infile']
        if 'outfile' in glb: del glb['outfile']
        if 'sigmavalue' in glb: del glb['sigmavalue']
        if 'rejwn' in glb: del glb['rejwn']
        if 'field' in glb: del glb['field']
        if 'thresh' in glb: del glb['thresh']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'verbose' in glb: del glb['verbose']
        if 'intent' in glb: del glb['intent']
        if 'fftmethod' in glb: del glb['fftmethod']
        if 'maskmode' in glb: del glb['maskmode']
        if 'minwidth' in glb: del glb['minwidth']
        if 'clipniter' in glb: del glb['clipniter']
        if 'scan' in glb: del glb['scan']
        if 'bltable' in glb: del glb['bltable']
        if 'applyfft' in glb: del glb['applyfft']
        if 'blformat' in glb: del glb['blformat']
        if 'reindex' in glb: del glb['reindex']
        if 'dosubtract' in glb: del glb['dosubtract']
        if 'avg_limit' in glb: del glb['avg_limit']
        if 'order' in glb: del glb['order']
        if 'fftthresh' in glb: del glb['fftthresh']
        if 'minnrow' in glb: del glb['minnrow']
        if 'blparam' in glb: del glb['blparam']
        if 'addwn' in glb: del glb['addwn']
        if 'showprogress' in glb: del glb['showprogress']
        if 'edge' in glb: del glb['edge']
        if 'overwrite' in glb: del glb['overwrite']
        if 'pol' in glb: del glb['pol']
        if 'bloutput' in glb: del glb['bloutput']
        if 'blmode' in glb: del glb['blmode']
        if 'blfunc' in glb: del glb['blfunc']
        if 'spw' in glb: del glb['spw']
        if 'timerange' in glb: del glb['timerange']
        if 'updateweight' in glb: del glb['updateweight']
        if 'npiece' in glb: del glb['npiece']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# sdbaseline -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__infile_inp( )
        self.__datacolumn_inp( )
        self.__antenna_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__timerange_inp( )
        self.__scan_inp( )
        self.__pol_inp( )
        self.__intent_inp( )
        self.__reindex_inp( )
        self.__maskmode_inp( )
        self.__thresh_inp( )
        self.__avg_limit_inp( )
        self.__minwidth_inp( )
        self.__edge_inp( )
        self.__blmode_inp( )
        self.__dosubtract_inp( )
        self.__blformat_inp( )
        self.__bloutput_inp( )
        self.__bltable_inp( )
        self.__blfunc_inp( )
        self.__order_inp( )
        self.__npiece_inp( )
        self.__applyfft_inp( )
        self.__fftmethod_inp( )
        self.__fftthresh_inp( )
        self.__addwn_inp( )
        self.__rejwn_inp( )
        self.__clipthresh_inp( )
        self.__clipniter_inp( )
        self.__blparam_inp( )
        self.__verbose_inp( )
        self.__updateweight_inp( )
        self.__sigmavalue_inp( )
        self.__showprogress_inp( )
        self.__minnrow_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "sdbaseline.last" if os.path.isfile("sdbaseline.last") else "sdbaseline.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('sdbaseline.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['infile'] = self.__infile( self.__globals_( ) )
        _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['pol'] = self.__pol( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['reindex'] = self.__reindex( self.__globals_( ) )
        _invocation_parameters['maskmode'] = self.__maskmode( self.__globals_( ) )
        _invocation_parameters['thresh'] = self.__thresh( self.__globals_( ) )
        _invocation_parameters['avg_limit'] = self.__avg_limit( self.__globals_( ) )
        _invocation_parameters['minwidth'] = self.__minwidth( self.__globals_( ) )
        _invocation_parameters['edge'] = self.__edge( self.__globals_( ) )
        _invocation_parameters['blmode'] = self.__blmode( self.__globals_( ) )
        _invocation_parameters['dosubtract'] = self.__dosubtract( self.__globals_( ) )
        _invocation_parameters['blformat'] = self.__blformat( self.__globals_( ) )
        _invocation_parameters['bloutput'] = self.__bloutput( self.__globals_( ) )
        _invocation_parameters['bltable'] = self.__bltable( self.__globals_( ) )
        _invocation_parameters['blfunc'] = self.__blfunc( self.__globals_( ) )
        _invocation_parameters['order'] = self.__order( self.__globals_( ) )
        _invocation_parameters['npiece'] = self.__npiece( self.__globals_( ) )
        _invocation_parameters['applyfft'] = self.__applyfft( self.__globals_( ) )
        _invocation_parameters['fftmethod'] = self.__fftmethod( self.__globals_( ) )
        _invocation_parameters['fftthresh'] = self.__fftthresh( self.__globals_( ) )
        _invocation_parameters['addwn'] = self.__addwn( self.__globals_( ) )
        _invocation_parameters['rejwn'] = self.__rejwn( self.__globals_( ) )
        _invocation_parameters['clipthresh'] = self.__clipthresh( self.__globals_( ) )
        _invocation_parameters['clipniter'] = self.__clipniter( self.__globals_( ) )
        _invocation_parameters['blparam'] = self.__blparam( self.__globals_( ) )
        _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )
        _invocation_parameters['updateweight'] = self.__updateweight( self.__globals_( ) )
        _invocation_parameters['sigmavalue'] = self.__sigmavalue( self.__globals_( ) )
        _invocation_parameters['showprogress'] = self.__showprogress( self.__globals_( ) )
        _invocation_parameters['minnrow'] = self.__minnrow( self.__globals_( ) )
        _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
        _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-12s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdbaseline( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, infile=None, datacolumn=None, antenna=None, field=None, spw=None, timerange=None, scan=None, pol=None, intent=None, reindex=None, maskmode=None, thresh=None, avg_limit=None, minwidth=None, edge=None, blmode=None, dosubtract=None, blformat=None, bloutput=None, bltable=None, blfunc=None, order=None, npiece=None, applyfft=None, fftmethod=None, fftthresh=None, addwn=None, rejwn=None, clipthresh=None, clipniter=None, blparam=None, verbose=None, updateweight=None, sigmavalue=None, showprogress=None, minnrow=None, outfile=None, overwrite=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('sdbaseline.pre')
        _postfile = os.path.realpath('sdbaseline.last')
        task_result = None
        _arguments = [infile,datacolumn,antenna,field,spw,timerange,scan,pol,intent,reindex,maskmode,thresh,avg_limit,minwidth,edge,blmode,dosubtract,blformat,bloutput,bltable,blfunc,order,npiece,applyfft,fftmethod,fftthresh,addwn,rejwn,clipthresh,clipniter,blparam,verbose,updateweight,sigmavalue,showprogress,minnrow,outfile,overwrite]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infile is not None: local_global['infile'] = infile
            if datacolumn is not None: local_global['datacolumn'] = datacolumn
            if antenna is not None: local_global['antenna'] = antenna
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if timerange is not None: local_global['timerange'] = timerange
            if scan is not None: local_global['scan'] = scan
            if pol is not None: local_global['pol'] = pol
            if intent is not None: local_global['intent'] = intent
            if reindex is not None: local_global['reindex'] = reindex
            if maskmode is not None: local_global['maskmode'] = maskmode
            if blmode is not None: local_global['blmode'] = blmode
            if blfunc is not None: local_global['blfunc'] = blfunc
            if updateweight is not None: local_global['updateweight'] = updateweight
            if showprogress is not None: local_global['showprogress'] = showprogress
            if outfile is not None: local_global['outfile'] = outfile
            if overwrite is not None: local_global['overwrite'] = overwrite

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infile'] = self.__infile( local_global )
            _invocation_parameters['datacolumn'] = self.__datacolumn( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['timerange'] = self.__timerange( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['pol'] = self.__pol( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['reindex'] = self.__reindex( local_global )
            _invocation_parameters['maskmode'] = self.__maskmode( local_global )
            _invocation_parameters['blmode'] = self.__blmode( local_global )
            _invocation_parameters['blfunc'] = self.__blfunc( local_global )
            _invocation_parameters['updateweight'] = self.__updateweight( local_global )
            _invocation_parameters['showprogress'] = self.__showprogress( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['thresh'] = self.__thresh( _invocation_parameters ) if thresh is None else thresh
            _invocation_parameters['avg_limit'] = self.__avg_limit( _invocation_parameters ) if avg_limit is None else avg_limit
            _invocation_parameters['minwidth'] = self.__minwidth( _invocation_parameters ) if minwidth is None else minwidth
            _invocation_parameters['edge'] = self.__edge( _invocation_parameters ) if edge is None else edge
            _invocation_parameters['dosubtract'] = self.__dosubtract( _invocation_parameters ) if dosubtract is None else dosubtract
            _invocation_parameters['blformat'] = self.__blformat( _invocation_parameters ) if blformat is None else blformat
            _invocation_parameters['bloutput'] = self.__bloutput( _invocation_parameters ) if bloutput is None else bloutput
            _invocation_parameters['bltable'] = self.__bltable( _invocation_parameters ) if bltable is None else bltable
            _invocation_parameters['order'] = self.__order( _invocation_parameters ) if order is None else order
            _invocation_parameters['npiece'] = self.__npiece( _invocation_parameters ) if npiece is None else npiece
            _invocation_parameters['applyfft'] = self.__applyfft( _invocation_parameters ) if applyfft is None else applyfft
            _invocation_parameters['fftmethod'] = self.__fftmethod( _invocation_parameters ) if fftmethod is None else fftmethod
            _invocation_parameters['fftthresh'] = self.__fftthresh( _invocation_parameters ) if fftthresh is None else fftthresh
            _invocation_parameters['addwn'] = self.__addwn( _invocation_parameters ) if addwn is None else addwn
            _invocation_parameters['rejwn'] = self.__rejwn( _invocation_parameters ) if rejwn is None else rejwn
            _invocation_parameters['clipthresh'] = self.__clipthresh( _invocation_parameters ) if clipthresh is None else clipthresh
            _invocation_parameters['clipniter'] = self.__clipniter( _invocation_parameters ) if clipniter is None else clipniter
            _invocation_parameters['blparam'] = self.__blparam( _invocation_parameters ) if blparam is None else blparam
            _invocation_parameters['verbose'] = self.__verbose( _invocation_parameters ) if verbose is None else verbose
            _invocation_parameters['sigmavalue'] = self.__sigmavalue( _invocation_parameters ) if sigmavalue is None else sigmavalue
            _invocation_parameters['minnrow'] = self.__minnrow( _invocation_parameters ) if minnrow is None else minnrow

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infile'] = self.__infile( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['pol'] = self.__pol( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['reindex'] = self.__reindex( self.__globals_( ) )
            _invocation_parameters['maskmode'] = self.__maskmode( self.__globals_( ) )
            _invocation_parameters['thresh'] = self.__thresh( self.__globals_( ) )
            _invocation_parameters['avg_limit'] = self.__avg_limit( self.__globals_( ) )
            _invocation_parameters['minwidth'] = self.__minwidth( self.__globals_( ) )
            _invocation_parameters['edge'] = self.__edge( self.__globals_( ) )
            _invocation_parameters['blmode'] = self.__blmode( self.__globals_( ) )
            _invocation_parameters['dosubtract'] = self.__dosubtract( self.__globals_( ) )
            _invocation_parameters['blformat'] = self.__blformat( self.__globals_( ) )
            _invocation_parameters['bloutput'] = self.__bloutput( self.__globals_( ) )
            _invocation_parameters['bltable'] = self.__bltable( self.__globals_( ) )
            _invocation_parameters['blfunc'] = self.__blfunc( self.__globals_( ) )
            _invocation_parameters['order'] = self.__order( self.__globals_( ) )
            _invocation_parameters['npiece'] = self.__npiece( self.__globals_( ) )
            _invocation_parameters['applyfft'] = self.__applyfft( self.__globals_( ) )
            _invocation_parameters['fftmethod'] = self.__fftmethod( self.__globals_( ) )
            _invocation_parameters['fftthresh'] = self.__fftthresh( self.__globals_( ) )
            _invocation_parameters['addwn'] = self.__addwn( self.__globals_( ) )
            _invocation_parameters['rejwn'] = self.__rejwn( self.__globals_( ) )
            _invocation_parameters['clipthresh'] = self.__clipthresh( self.__globals_( ) )
            _invocation_parameters['clipniter'] = self.__clipniter( self.__globals_( ) )
            _invocation_parameters['blparam'] = self.__blparam( self.__globals_( ) )
            _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )
            _invocation_parameters['updateweight'] = self.__updateweight( self.__globals_( ) )
            _invocation_parameters['sigmavalue'] = self.__sigmavalue( self.__globals_( ) )
            _invocation_parameters['showprogress'] = self.__showprogress( self.__globals_( ) )
            _invocation_parameters['minnrow'] = self.__minnrow( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-12s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdbaseline( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'sdbaseline', [ 'infile=' + repr(_pc.document['infile']), 'datacolumn=' + repr(_pc.document['datacolumn']), 'antenna=' + repr(_pc.document['antenna']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'timerange=' + repr(_pc.document['timerange']), 'scan=' + repr(_pc.document['scan']), 'pol=' + repr(_pc.document['pol']), 'intent=' + repr(_pc.document['intent']), 'reindex=' + repr(_pc.document['reindex']), 'maskmode=' + repr(_pc.document['maskmode']), 'thresh=' + repr(_pc.document['thresh']), 'avg_limit=' + repr(_pc.document['avg_limit']), 'minwidth=' + repr(_pc.document['minwidth']), 'edge=' + repr(_pc.document['edge']), 'blmode=' + repr(_pc.document['blmode']), 'dosubtract=' + repr(_pc.document['dosubtract']), 'blformat=' + repr(_pc.document['blformat']), 'bloutput=' + repr(_pc.document['bloutput']), 'bltable=' + repr(_pc.document['bltable']), 'blfunc=' + repr(_pc.document['blfunc']), 'order=' + repr(_pc.document['order']), 'npiece=' + repr(_pc.document['npiece']), 'applyfft=' + repr(_pc.document['applyfft']), 'fftmethod=' + repr(_pc.document['fftmethod']), 'fftthresh=' + repr(_pc.document['fftthresh']), 'addwn=' + repr(_pc.document['addwn']), 'rejwn=' + repr(_pc.document['rejwn']), 'clipthresh=' + repr(_pc.document['clipthresh']), 'clipniter=' + repr(_pc.document['clipniter']), 'blparam=' + repr(_pc.document['blparam']), 'verbose=' + repr(_pc.document['verbose']), 'updateweight=' + repr(_pc.document['updateweight']), 'sigmavalue=' + repr(_pc.document['sigmavalue']), 'showprogress=' + repr(_pc.document['showprogress']), 'minnrow=' + repr(_pc.document['minnrow']), 'outfile=' + repr(_pc.document['outfile']), 'overwrite=' + repr(_pc.document['overwrite']) ] )
            task_result = _sdbaseline_t( _pc.document['infile'],_pc.document['datacolumn'],_pc.document['antenna'],_pc.document['field'],_pc.document['spw'],_pc.document['timerange'],_pc.document['scan'],_pc.document['pol'],_pc.document['intent'],_pc.document['reindex'],_pc.document['maskmode'],_pc.document['thresh'],_pc.document['avg_limit'],_pc.document['minwidth'],_pc.document['edge'],_pc.document['blmode'],_pc.document['dosubtract'],_pc.document['blformat'],_pc.document['bloutput'],_pc.document['bltable'],_pc.document['blfunc'],_pc.document['order'],_pc.document['npiece'],_pc.document['applyfft'],_pc.document['fftmethod'],_pc.document['fftthresh'],_pc.document['addwn'],_pc.document['rejwn'],_pc.document['clipthresh'],_pc.document['clipniter'],_pc.document['blparam'],_pc.document['verbose'],_pc.document['updateweight'],_pc.document['sigmavalue'],_pc.document['showprogress'],_pc.document['minnrow'],_pc.document['outfile'],_pc.document['overwrite'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('sdbaseline')
            casalog.post("Exception Reported: Error in sdbaseline: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'sdbaseline', task_result )

        #Added if _sdbaseline_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

sdbaseline = _sdbaseline( )

