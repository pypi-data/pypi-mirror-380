##################### generated by xml-casa (v2) from uvcontsub.xml #################
##################### 608b29d7e73cf5fff26de07ecd06eac3 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_uvcontsub import uvcontsub as _uvcontsub_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _uvcontsub:
    """
    uvcontsub ---- continuum subtraction in the uv domain

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file.
                Default: '', must be specified
                
                Example: vis='ngc5921.ms'
    outputvis   Name of output visibility file
                Default: '', must be specified
                
                Example: outputvis='ngc5921_contsub.ms'
                
                If an MS with the output name already exists, it
                will not be overwritten and the task stops with
                an error.
    field       Select field using field id(s) or field name(s)
                Default: '' (all fields)
                
                Use 'listobs' to obtain the list of id's or
                names. If field string is a non-negative integer,
                it is assumed a field index,  otherwise, it is
                assumed a field name.
                
                Examples:
                field='0~2'; field ids 0,1,2
                field='0,4,5~7'; field ids 0,4,5,6,7
                field='3C286,3C295'; field named 3C286 and
                      3C295
                field = '3,4C*'; field id 3, all names
                starting with 4C
    spw         Select spectral window/channels
                          Default: '' (meaning all spectral windows and channels)
                
                          Examples:
                          spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
                          spw='<2';  spectral windows less than 2 (i.e. 0,1)
                          spw='0:5~61'; spw 0, channels 5 to 61
                          spw='0,10,3:3~45'; spw 0,10 all channels, spw
                              3 - chans 3 to 45.
                          spw='0~2:2~6'; spw 0,1,2 with channels 2
                              through 6 in each.
                          spw = '*:3~64'  channels 3 through 64 for all sp id's
                          spw = ' :3~64' will NOT work.
    scan        Select scans by scan numbers
                Default: '' = all
                
                Examples:
                scan='3'
                scan='2~23'
                scan=''4,7,9,12'
    intent      Select observing intent
                Default: '' (no selection by intent)
                
                Example: intent='*BANDPASS*'  (selects data
                         labelled with BANDPASS intent)
    array       Select (sub)array(s) by array ID number
                Default: '' (all)
    observation Select by observation ID(s)
                Default: '' = all
                
                Example: observation='0~2,4'
    datacolumn  Which data column to use for processing
                (case-insensitive).
                Default: 'data'
                Options: 'data', 'model', 'corrected',
                'float_data', 'lag_data',
                
                Example: datacolumn='corrected'
    fitspec     Specification of fit, which can be general or
                specific for every field and SPW. The continuum will be fitted
                using a polynomial shape and using as input data points the
                channels given, which can be considered the line-free
                channels. fitspec can be a simple string or a dictionary. If
                it is a simple string, it gives an spw:channel specification in
                MSSelection syntax, and that same spw:channel specification is
                used for all fields. In that case, the polynomial order for
                all fields and SPWs is defined by the fitorder parameter.
                
                If it is a dictionary, its entries can define a different
                specification of fit order and channels for every field and
                for every SPW. The dictionary can have up to as many entries
                as fields are present in the MeasurementSet, and within each
                field entry, as many entries as SPWs are present. Each SPW
                entry specifies the polynomial order (in a 'fitorder' entry)
                and the line-free channels (in a 'chan' entry).
                
                If a field or SPW is not included, the default is assumed (all
                channels, and polynomial order given in the global fitorder
                parameter).
                
                   Default: '' (all channels for all SPWs for all fields)
                   Examples:
                   '17:100~500;600~910;1215~1678;1810~1903,19:7~100'
                   (The ranges of channels given for SPW 17 and 19
                    are used for all the fields present in the
                    MeasurementSet.)
                
                   Dictionary to use different channels and polynomial
                   orders for different fields and SPWs, assuming:
                        4 SPWs, with IDs 17, 19, 21, 23
                        6 fields, with IDs 0, 1, 4, 5, 6, 7
                   {'0': {'17,19,21,23': {'chan': '', 'fitorder': 1}},
                    '1': {'17': {'chan': '8~120', 'fitorder': 0},
                          '19': {'chan': '7~100', 'fitorder': 1},
                          '21': {'chan': '21:2~119', 'fitorder': 1},
                          '23': {'chan': '', 'fitorder': 0}},
                    '4,5,6': {'19': {'chan': '7~115', 'fitorder': 1},
                              '21': {'chan': '', 'fitorder': 1},
                              '23': {'chan': '', 'fitorder': 2}},
                    '7': 'NONE'}
                
                   (Field 0: fit all SPWs and channels (same as not giving it),
                    but using polynomial order 1 for all SPWs.
                    Field 1: fit only some channel ranges (all for SPW 23), with
                    different polynomial orders.
                    Fields 4,5,6: fit only some channel ranges in SPW 19, all
                    channels for SPWs 21 and 23, and don't fit SPWs 17),
                    also using different polynomial orders.
                    Field 7: do not subtract continuum)
                   (The dictionary fields 'chan' can be given in channel
                    numbers, as in the example above, or in frequencies, using
                    the MSSelection syntax)
                
                In the example, the empty string given for field 0 and all its
                SPWs means that all the channels are fitted (and subtracted)
                in all those SPWs. For the corner case where for a given field
                no channels should be fitted in any SPW, the field entry can
                be given as a string set to 'NONE'.
                
                This specification of SPWs and channels uses a syntax similar
                to the spw parameter. But in contrast to the spw parameter,
                the SPWs and channels given in fitspec are not used to select
                data but as a mask applied on the input data only for fitting
                purposes. The channels that are not included in the
                specification are masked out and not used as input by the
                polynomial fitting algorithm. This is different from the spw
                parameter, which selects the data that will be included in the
                output. All channels present in the output are
                continuum-subtracted, regardless of whether they were
                specified as inputs to the fitting in fitspec
    fitmethod   Choose fitting methods
                Default: 'gsl'
                Options: 'gsl', 'casacore'
                
                Example: fitmethod='gsl'
    fitorder    Polynomial order for the fits
                Default: 0
                
                Values of fitorder > 1 should be used with
                care. Higher order polynomials are more flexible,
                and may overfit and absorb line emission. They
                also tend to go wild at the edges of the range of
                channels used for fitting.
    writemodel  Write fitted model into the MODEL column of the
                output MeasurementSet.
                
                             Default: False
                             Options: True|False
                
                             By default the task creates an MS with the
                             continuum subtracted data in the DATA column. If
                             this option is enabled, the task will also write
                             the fitted model data into the MODEL column of the
                             output MS.

    --------- examples -----------------------------------------------------------

    
    For more information, see the task pages of uvcontsub in CASA Docs:
    https://casadocs.readthedocs.io
    


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """continuum subtraction in the uv domain"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outputvis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scan': {'type': 'cStr', 'coerce': _coerce.to_str}, 'intent': {'type': 'cStr', 'coerce': _coerce.to_str}, 'array': {'type': 'cStr', 'coerce': _coerce.to_str}, 'observation': {'type': 'cStr', 'coerce': _coerce.to_str}, 'datacolumn': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'DATA', 'model', 'corrected', 'LAG_DATA', 'lag_data', 'FLOAT_DATA', 'CORRECTED', 'float_data', 'MODEL', 'data' ]}, 'fitspec': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cDict'}]}, 'fitmethod': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'gsl', 'casacore', 'GSL', 'CASACORE' ]}, 'fitorder': {'type': 'cInt'}, 'writemodel': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 11 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __array_dflt( self, glb ):
        return ''

    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        return ''

    def __datacolumn_dflt( self, glb ):
        return 'data'

    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        return 'data'

    def __writemodel_dflt( self, glb ):
        return False

    def __writemodel( self, glb ):
        if 'writemodel' in glb: return glb['writemodel']
        return False

    def __observation_dflt( self, glb ):
        return ''

    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        return ''

    def __fitorder_dflt( self, glb ):
        return int(0)

    def __fitorder( self, glb ):
        if 'fitorder' in glb: return glb['fitorder']
        return int(0)

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __outputvis_dflt( self, glb ):
        return ''

    def __outputvis( self, glb ):
        if 'outputvis' in glb: return glb['outputvis']
        return ''

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __fitspec_dflt( self, glb ):
        return ''

    def __fitspec( self, glb ):
        if 'fitspec' in glb: return glb['fitspec']
        return ''

    def __fitmethod_dflt( self, glb ):
        return 'gsl'

    def __fitmethod( self, glb ):
        if 'fitmethod' in glb: return glb['fitmethod']
        return 'gsl'



    #--------- return inp/go default --------------------------------------------------


    #--------- return subparam values -------------------------------------------------


    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file (MeasurementSet)'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __outputvis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outputvis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of output MeasurementSet (visibility file)'
        value = self.__outputvis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outputvis': value},{'outputvis': self.__schema['outputvis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('outputvis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select field using field id(s) or field name(s)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select spectral window/channels'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select scans by scan numbers'
        value = self.__scan( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select observing intent'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __array_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__array_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select (sub)array(s) by array ID number'
        value = self.__array( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('array',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select by observation ID(s)'
        value = self.__observation( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __datacolumn_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__datacolumn_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'data'
        description = 'Which data column to process'
        value = self.__datacolumn( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('datacolumn',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __fitspec_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fitspec_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Specification of polynomial order and spectral window:channel for fitting'
        value = self.__fitspec( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fitspec': value},{'fitspec': self.__schema['fitspec']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('fitspec',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __fitmethod_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fitmethod_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'gsl'
        description = 'Choose fitting method'
        value = self.__fitmethod( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fitmethod': value},{'fitmethod': self.__schema['fitmethod']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('fitmethod',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __fitorder_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fitorder_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(0)
        description = 'Polynomial order for the fits'
        value = self.__fitorder( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fitorder': value},{'fitorder': self.__schema['fitorder']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('fitorder',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __writemodel_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__writemodel_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Write fitted model into the MODEL column of the output MS'
        value = self.__writemodel( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'writemodel': value},{'writemodel': self.__schema['writemodel']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-11.11s = %s%-23s%s' % ('writemodel',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'fitmethod' in glb: del glb['fitmethod']
        if 'field' in glb: del glb['field']
        if 'outputvis' in glb: del glb['outputvis']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'intent' in glb: del glb['intent']
        if 'writemodel' in glb: del glb['writemodel']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'fitspec' in glb: del glb['fitspec']
        if 'fitorder' in glb: del glb['fitorder']
        if 'array' in glb: del glb['array']
        if 'observation' in glb: del glb['observation']
        if 'spw' in glb: del glb['spw']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# uvcontsub -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__outputvis_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__array_inp( )
        self.__observation_inp( )
        self.__datacolumn_inp( )
        self.__fitspec_inp( )
        self.__fitmethod_inp( )
        self.__fitorder_inp( )
        self.__writemodel_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "uvcontsub.last" if os.path.isfile("uvcontsub.last") else "uvcontsub.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('uvcontsub.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['array'] = self.__array( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
        _invocation_parameters['fitspec'] = self.__fitspec( self.__globals_( ) )
        _invocation_parameters['fitmethod'] = self.__fitmethod( self.__globals_( ) )
        _invocation_parameters['fitorder'] = self.__fitorder( self.__globals_( ) )
        _invocation_parameters['writemodel'] = self.__writemodel( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#uvcontsub( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, outputvis=None, field=None, spw=None, scan=None, intent=None, array=None, observation=None, datacolumn=None, fitspec=None, fitmethod=None, fitorder=None, writemodel=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('uvcontsub.pre')
        _postfile = os.path.realpath('uvcontsub.last')
        task_result = None
        _arguments = [vis,outputvis,field,spw,scan,intent,array,observation,datacolumn,fitspec,fitmethod,fitorder,writemodel]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if outputvis is not None: local_global['outputvis'] = outputvis
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if scan is not None: local_global['scan'] = scan
            if intent is not None: local_global['intent'] = intent
            if array is not None: local_global['array'] = array
            if observation is not None: local_global['observation'] = observation
            if datacolumn is not None: local_global['datacolumn'] = datacolumn
            if fitspec is not None: local_global['fitspec'] = fitspec
            if fitmethod is not None: local_global['fitmethod'] = fitmethod
            if fitorder is not None: local_global['fitorder'] = fitorder
            if writemodel is not None: local_global['writemodel'] = writemodel

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['outputvis'] = self.__outputvis( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['array'] = self.__array( local_global )
            _invocation_parameters['observation'] = self.__observation( local_global )
            _invocation_parameters['datacolumn'] = self.__datacolumn( local_global )
            _invocation_parameters['fitspec'] = self.__fitspec( local_global )
            _invocation_parameters['fitmethod'] = self.__fitmethod( local_global )
            _invocation_parameters['fitorder'] = self.__fitorder( local_global )
            _invocation_parameters['writemodel'] = self.__writemodel( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['fitspec'] = self.__fitspec( self.__globals_( ) )
            _invocation_parameters['fitmethod'] = self.__fitmethod( self.__globals_( ) )
            _invocation_parameters['fitorder'] = self.__fitorder( self.__globals_( ) )
            _invocation_parameters['writemodel'] = self.__writemodel( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#uvcontsub( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'uvcontsub', [ 'vis=' + repr(_pc.document['vis']), 'outputvis=' + repr(_pc.document['outputvis']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'scan=' + repr(_pc.document['scan']), 'intent=' + repr(_pc.document['intent']), 'array=' + repr(_pc.document['array']), 'observation=' + repr(_pc.document['observation']), 'datacolumn=' + repr(_pc.document['datacolumn']), 'fitspec=' + repr(_pc.document['fitspec']), 'fitmethod=' + repr(_pc.document['fitmethod']), 'fitorder=' + repr(_pc.document['fitorder']), 'writemodel=' + repr(_pc.document['writemodel']) ] )
            task_result = _uvcontsub_t( _pc.document['vis'],_pc.document['outputvis'],_pc.document['field'],_pc.document['spw'],_pc.document['scan'],_pc.document['intent'],_pc.document['array'],_pc.document['observation'],_pc.document['datacolumn'],_pc.document['fitspec'],_pc.document['fitmethod'],_pc.document['fitorder'],_pc.document['writemodel'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('uvcontsub')
            casalog.post("Exception Reported: Error in uvcontsub: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'uvcontsub', task_result )

        #Added if _uvcontsub_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

uvcontsub = _uvcontsub( )

