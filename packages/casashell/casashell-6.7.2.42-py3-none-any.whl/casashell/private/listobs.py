##################### generated by xml-casa (v2) from listobs.xml ###################
##################### cc0cfcd467ffdd3243f66208fc9312dd ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_listobs import listobs as _listobs_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _listobs:
    """
    listobs ---- Get the summary of a MeasurementSet and list it in the logger or in a file

    
    List the summary information of a data set in the logger or in a file, based on
    a data selection. Only rows can be selected and printed. No in-row selection is
    possible (channel or correlation).
    
    Lists the following properties of a measurement set:
    scan list, field list, spectral window list with
    correlators, antenna locations, ms table information.
    

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file (MS)
    selectdata  Data selection parameters
    spw         Selection based on spectral-window/frequency/channel.
    field       Selection based on field names or field index numbers. Default is all.
    antenna     Selection based on antenna/baselines. Default is all.
    uvrange     Selection based on uv range. Default: entire range. Default units: meters.
    timerange   Selection based on time range. Default is entire range.
    correlation Selection based on correlation. Default is all.
    scan        Selection based on scan numbers. Default is all.
    intent      Selection based on observation intent. Default is all.
    feed        Selection based on multi-feed numbers: Not yet implemented
    array       Selection based on (sub)array numbers. Default is all.
    observation Selection based on observation ID. Default is all.
    verbose     Controls level of information detail reported. True reports more than False.
    listfile    Name of disk file to write output. Default is none (output is written to logger only).
    listunfl    List unflagged row counts? If true, it can have significant negative performance impact.
    cachesize   EXPERIMENTAL. Maximum size in megabytes of cache in which data structures can be held.
    overwrite   If True, tacitly overwrite listfile if it exists.
    [1;42mRETURNS[1;m        void

    --------- examples -----------------------------------------------------------

    
    
    List the summary information of a data set in the logger or in a file, based on
    a data selection. Only rows can be selected and printed. No in-row selection is
    possible (channel or correlation). Refer to the task listvis to list visibilites.
    
    Lists the following properties of a measurement set:
    scan list, field list, spectral window list with
    correlators, antenna locations, ms table information.
    
    Keyword arguments:
    vis -- Name of input visibility file
    default: none. example: vis='ngc5921.ms'
    
    selectdata -- Select a subset of data for flagging
    default: False
    options: True,False
    The summary listing will only apply to the specified selection.
    
    antenna -- Select data based on baseline
    default: '' (all); example: antenna='5&6' baseline 5-6
    antenna='5&6;7&8' #baseline 5-6 and 7-8
    antenna='5' # all cross-correlation baselines between antenna 5 and all other available
    antennas
    antenna='5,6' # all baselines with antennas 5 and 6
    antenna='1&&1' # only the auto-correlation baselines for antenna 1
    antenna='1&&*' # cross and auto-correlation baselines between antenna 1
    and all other available antennas
    antenna='1~7&&&' # only the auto-correlation baselines for antennas in range 1~7
    spw -- Select data based on spectral window and channels
    default: '' (all); example: spw='1'
    spw='<2' #spectral windows less than 2
    spw='>1' #spectral windows greater than 1
    correlation -- Correlation types
    default: '' (all);
    example: correlation='RR LL'
    field -- Select data based on field id(s) or name(s)
    default: '' (all); example: field='1'
    field='0~2' # field ids inclusive from 0 to 2
    field='3C*' # all field names starting with 3C
    uvrange -- Select data within uvrange (default units meters)
    default: '' (all); example:
    uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lamgda
    uvrange='>4klamda';uvranges greater than 4 kilo-lambda
    uvrange='0~1000km'; uvrange in kilometers
    timerange  -- Select data based on time range:
    default = '' (all); example,
    timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
    Note: YYYY/MM/DD can be dropped as needed:
    timerange='09:14:0~09:54:0' # this time range
    timerange='09:44:00' # data within one integration of time
    timerange='>10:24:00' # data after this time
    timerange='09:44:00+00:13:00' #data 13 minutes after time
    scan -- Select data based on scan number
    default: '' (all); example: scan='>3'
    intent -- Select data based on observation intent
    default: '' (all); example: intent='*CAL*,*BAND*'
    feed -- Selection based on the feed - NOT IMPLEMENTED YET
    array -- Selection based on the antenna array
    observation -- Selection based on the observation ID
    default: '' (all); example: observation='1' or observation=1
    
    
    verbose -- level of detail
    verbose=True: (default); scan and antenna lists
    verbose=False: less information
    
    listfile -- name of disk file to write output.
    default: None. Example: listfile='list.txt'
    
    listunfl -- List unflagged row counts? If true, it can have significant negative performance impact.
    
    cachesize -- maximum size of the memory cache in megabytes in which data structures can be
    stored. For very large datasets this can be increased for possibly better performance.
    THIS IS ONLY EXPERIEMENTAL FOR NOW, AND INCREASING THE VALUE OF THIS PARAMETER DOES NOT GUARANTEE INCREASED
    SPEED. DEPENDING ON ITS (LACK OF) USEFULNESS, IT MAY BE REMOVED IN THE FUTURE.
    
    
    The 'Int (s)' column is the average of the MS's INTERVAL column
    for each scan, so in a time-averaged MS 'Int' = 9.83s more likely
    means 5 10s integrations and 1 9s integration (timebin) than 6
    9.83s integrations.
    
    DESCRIPTION OF ALGORITHM TO CALCULATE THE NUMBER OF UNFLAGGED ROWS
    The number of unflagged rows are only computed if listunfl=True. Computing these quantity
    can have a negative performance impact, especially for large datasets.
    The number of unflagged rows (the nUnflRows columns in the scans and fields portions of the listing) is
    calculated by summing the fractional unflagged bandwidth for each row (and hence why the number of unflagged
    rows, in general, is not an integer). Thus a row which has half of its
    total bandwidth flagged contributes 0.5 rows to the unflagged row count. A row with 20 of 32 channels of
    homogeneous width contributes 20/32 = 0.625 rows to the unflagged row count. A row with a value of False
    in the FLAG_ROW column is not counted in the number of unflagged rows.
    


    """

    _info_group_ = """information"""
    _info_desc_ = """Get the summary of a MeasurementSet and list it in the logger or in a file"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'selectdata': {'type': 'cBool'}, 'spw': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'field': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'antenna': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'uvrange': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'correlation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'scan': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'intent': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'feed': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'array': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'observation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'verbose': {'type': 'cBool'}, 'listfile': {'type': 'cStr', 'coerce': _coerce.to_str}, 'listunfl': {'type': 'cBool'}, 'cachesize': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'overwrite': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 14 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __verbose_dflt( self, glb ):
        return True

    def __verbose( self, glb ):
        if 'verbose' in glb: return glb['verbose']
        return True

    def __listfile_dflt( self, glb ):
        return ''

    def __listfile( self, glb ):
        if 'listfile' in glb: return glb['listfile']
        return ''

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __cachesize_dflt( self, glb ):
        return float(50)

    def __cachesize( self, glb ):
        if 'cachesize' in glb: return glb['cachesize']
        return float(50)

    def __listunfl_dflt( self, glb ):
        return False

    def __listunfl( self, glb ):
        if 'listunfl' in glb: return glb['listunfl']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __field_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __intent_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __array_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __correlation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __feed_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __uvrange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __overwrite_dflt( self, glb ):
        if self.__listfile( glb ) != "": return bool(False)
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __spw_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        dflt = self.__spw_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        dflt = self.__field_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        dflt = self.__uvrange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __correlation( self, glb ):
        if 'correlation' in glb: return glb['correlation']
        dflt = self.__correlation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        dflt = self.__intent_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __feed( self, glb ):
        if 'feed' in glb: return glb['feed']
        dflt = self.__feed_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        dflt = self.__array_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        dflt = self.__overwrite_dflt( glb )
        if dflt is not None: return dflt
        return False

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file (MS)'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __selectdata_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__selectdata_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Data selection parameters'
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('selectdata',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__spw_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on spectral-window/frequency/channel.'
             value = self.__spw( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__field_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on field names or field index numbers. Default is all.'
             value = self.__field( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on antenna/baselines. Default is all.'
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __uvrange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__uvrange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__uvrange_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on uv range. Default: entire range. Default units: meters.'
             value = self.__uvrange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('uvrange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on time range. Default is entire range.'
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __correlation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__correlation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__correlation_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on correlation. Default is all.'
             value = self.__correlation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'correlation': value},{'correlation': self.__schema['correlation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('correlation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on scan numbers. Default is all.'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__intent_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on observation intent. Default is all.'
             value = self.__intent( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __feed_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__feed_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__feed_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on multi-feed numbers: Not yet implemented'
             value = self.__feed( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'feed': value},{'feed': self.__schema['feed']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('feed',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __array_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__array_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__array_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on (sub)array numbers. Default is all.'
             value = self.__array( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('array',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = 'Selection based on observation ID. Default is all.'
             value = self.__observation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __verbose_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__verbose_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Controls level of information detail reported. True reports more than False.'
        value = self.__verbose( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'verbose': value},{'verbose': self.__schema['verbose']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('verbose',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __listfile_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__listfile_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of disk file to write output. Default is none (output is written to logger only).'
        value = self.__listfile( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'listfile': value},{'listfile': self.__schema['listfile']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('listfile',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __listunfl_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__listunfl_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'List unflagged row counts? If true, it can have significant negative performance impact.'
        value = self.__listunfl( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'listunfl': value},{'listunfl': self.__schema['listunfl']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('listunfl',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __cachesize_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__cachesize_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(50)
        description = 'EXPERIMENTAL. Maximum size in megabytes of cache in which data structures can be held.'
        value = self.__cachesize( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'cachesize': value},{'cachesize': self.__schema['cachesize']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('cachesize',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __overwrite_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__overwrite_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__overwrite_dflt( self.__globals_( ) ) is not None:
             description = 'If True, tacitly overwrite listfile if it exists.'
             value = self.__overwrite( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('overwrite',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'field' in glb: del glb['field']
        if 'verbose' in glb: del glb['verbose']
        if 'intent' in glb: del glb['intent']
        if 'cachesize' in glb: del glb['cachesize']
        if 'listunfl' in glb: del glb['listunfl']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'array' in glb: del glb['array']
        if 'correlation' in glb: del glb['correlation']
        if 'feed' in glb: del glb['feed']
        if 'uvrange' in glb: del glb['uvrange']
        if 'listfile' in glb: del glb['listfile']
        if 'overwrite' in glb: del glb['overwrite']
        if 'observation' in glb: del glb['observation']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# listobs -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__selectdata_inp( )
        self.__spw_inp( )
        self.__field_inp( )
        self.__antenna_inp( )
        self.__uvrange_inp( )
        self.__timerange_inp( )
        self.__correlation_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__feed_inp( )
        self.__array_inp( )
        self.__observation_inp( )
        self.__verbose_inp( )
        self.__listfile_inp( )
        self.__listunfl_inp( )
        self.__cachesize_inp( )
        self.__overwrite_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "listobs.last" if os.path.isfile("listobs.last") else "listobs.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('listobs.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['feed'] = self.__feed( self.__globals_( ) )
        _invocation_parameters['array'] = self.__array( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )
        _invocation_parameters['listfile'] = self.__listfile( self.__globals_( ) )
        _invocation_parameters['listunfl'] = self.__listunfl( self.__globals_( ) )
        _invocation_parameters['cachesize'] = self.__cachesize( self.__globals_( ) )
        _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#listobs( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, selectdata=None, spw=None, field=None, antenna=None, uvrange=None, timerange=None, correlation=None, scan=None, intent=None, feed=None, array=None, observation=None, verbose=None, listfile=None, listunfl=None, cachesize=None, overwrite=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('listobs.pre')
        _postfile = os.path.realpath('listobs.last')
        task_result = None
        _arguments = [vis,selectdata,spw,field,antenna,uvrange,timerange,correlation,scan,intent,feed,array,observation,verbose,listfile,listunfl,cachesize,overwrite]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if selectdata is not None: local_global['selectdata'] = selectdata
            if verbose is not None: local_global['verbose'] = verbose
            if listfile is not None: local_global['listfile'] = listfile
            if listunfl is not None: local_global['listunfl'] = listunfl
            if cachesize is not None: local_global['cachesize'] = cachesize

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['verbose'] = self.__verbose( local_global )
            _invocation_parameters['listfile'] = self.__listfile( local_global )
            _invocation_parameters['listunfl'] = self.__listunfl( local_global )
            _invocation_parameters['cachesize'] = self.__cachesize( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['spw'] = self.__spw( _invocation_parameters ) if spw is None else spw
            _invocation_parameters['field'] = self.__field( _invocation_parameters ) if field is None else field
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['uvrange'] = self.__uvrange( _invocation_parameters ) if uvrange is None else uvrange
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['correlation'] = self.__correlation( _invocation_parameters ) if correlation is None else correlation
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['intent'] = self.__intent( _invocation_parameters ) if intent is None else intent
            _invocation_parameters['feed'] = self.__feed( _invocation_parameters ) if feed is None else feed
            _invocation_parameters['array'] = self.__array( _invocation_parameters ) if array is None else array
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['overwrite'] = self.__overwrite( _invocation_parameters ) if overwrite is None else overwrite

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['feed'] = self.__feed( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )
            _invocation_parameters['listfile'] = self.__listfile( self.__globals_( ) )
            _invocation_parameters['listunfl'] = self.__listunfl( self.__globals_( ) )
            _invocation_parameters['cachesize'] = self.__cachesize( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#listobs( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'listobs', [ 'vis=' + repr(_pc.document['vis']), 'selectdata=' + repr(_pc.document['selectdata']), 'spw=' + repr(_pc.document['spw']), 'field=' + repr(_pc.document['field']), 'antenna=' + repr(_pc.document['antenna']), 'uvrange=' + repr(_pc.document['uvrange']), 'timerange=' + repr(_pc.document['timerange']), 'correlation=' + repr(_pc.document['correlation']), 'scan=' + repr(_pc.document['scan']), 'intent=' + repr(_pc.document['intent']), 'feed=' + repr(_pc.document['feed']), 'array=' + repr(_pc.document['array']), 'observation=' + repr(_pc.document['observation']), 'verbose=' + repr(_pc.document['verbose']), 'listfile=' + repr(_pc.document['listfile']), 'listunfl=' + repr(_pc.document['listunfl']), 'cachesize=' + repr(_pc.document['cachesize']), 'overwrite=' + repr(_pc.document['overwrite']) ] )
            task_result = _listobs_t( _pc.document['vis'],_pc.document['selectdata'],_pc.document['spw'],_pc.document['field'],_pc.document['antenna'],_pc.document['uvrange'],_pc.document['timerange'],_pc.document['correlation'],_pc.document['scan'],_pc.document['intent'],_pc.document['feed'],_pc.document['array'],_pc.document['observation'],_pc.document['verbose'],_pc.document['listfile'],_pc.document['listunfl'],_pc.document['cachesize'],_pc.document['overwrite'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('listobs')
            casalog.post("Exception Reported: Error in listobs: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'listobs', task_result )

        #Added if _listobs_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

listobs = _listobs( )

