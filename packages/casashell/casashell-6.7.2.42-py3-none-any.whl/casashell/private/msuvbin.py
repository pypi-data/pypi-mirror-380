##################### generated by xml-casa (v2) from msuvbin.xml ###################
##################### 1b0767ff69d778776ecf7ddce14ced3c ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_msuvbin import msuvbin as _msuvbin_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _msuvbin:
    """
    msuvbin ---- grid the visibility data onto a defined uniform grid (in the form of an ms); multiple MS's can be done onto the same grid

    
    msuvbin is a uv gridding task. The use is for large volumes
    of data (from multiple epochs) that needs to be imaged into
    one image.  One way of proceeding is to image the epochs and
    average them after wards. Rather than doing this averaging
    the visibilities on a common uv grid has several convenience
    advantages like easily doing the proper weighted averaging and imaging.
    If an output grid already exists and a second ms is gridded on the grid
    then the output grid parameters is ignored but the existant grid is used.
    
    

    --------- parameter descriptions ---------------------------------------------

    vis         Name of input visibility file (MS)
                default: none;
    field       Field selection of input ms; use mssel syntax
    spw         Spw selection; mssel syntax
    taql        TaQl string for data selection; the advance user can do
                sophisticated data selection; see http://casacore.github.io/casacore-notes/199.html
    outputvis   name of output uvgrid; if it existant the data will be binned additively into
                that uvgrid (as long as the parameters match for the grid description). If the gridded ms
                exists
                and the gridding parameters do not match the ones with which the grid was made---
                msuvbin will exit with an exception
    phasecenter phase center of uv grid; if empty it will default
                the first field selected in the input ms
    imsize      Number of pixels
                example:
                
                imsize = [350,250]
                imsize = 500 is equivalent to [500,500]
                
                To take proper advantage of internal optimized FFT routines, the
                number of pixels must be even and factorizable by 2,3,5 only.
                To find the nearest optimal imsize to that desired by the user, please use the following tool method:
                
                from casatools import synthesisutils
                su = synthesisutils()
                su.getOptimumSize(345) 
                Output :  360
    cell        pixel cell size defined in sky dimension
                This should be in the units of sky angle. Usually you want to have a pixel size that
                is smaller than the maximum resolution that can be expected from the data.
    ncorr       number of correlations to store in grid
                if 1 is chosen and data have cross hands, then both XX and YY (or RR and LL)
                will be gridded on the same correlation plane (XX or RR as MS V2.0 does not support
                I as a correlation type).
                if 2 is chosen the parallel hands will be stored on independent grids for each frequency channel
                if 4 is chosen the all correlation type will be gridded independently.
    nchan       Nunmber of spectral channels in the output grid
    start       Frequency of first channel of grid. If left empty, it will try to use the
                	lowest frequency in the selected data
    width       Spectral channel width. If left empty the badwidth of the selected data will be divided by the nchan
                	selected to determine the width of an output channel. This happens only when not output grid already exists.
    wproject    Do wprojection correction while gridding. This should be used with care as it is known to have issues like perfomance
                	and for Cotton-Schwab style cleaning.
    memfrac     Limit fraction of RAM  available to use. Default is half.
    mode        when mode  will transfer back flag from grid to input ms
                For this to work both the original ms and the gridded ms has to exist and the flags will be
                transferred from the gridded ms back to original ms. This is provided as a utility to
                msuvbinflagger task.
    flagbackup  Backup flags before saving flags when using write_flags_back
    [1;42mRETURNS[1;m        void

    --------- examples -----------------------------------------------------------

    
    
    
    
    
    Keyword arguments:
    vis -- Name of input visibility file
    default: none; example: vis='ngc5921.ms'
    field -- Field name list
    default: '' ==> all
    field = '1328+307'  specifies source '1328+307'
    field = '4' specified field with index 4
    spw -- Spw selection
    default: spw = '' (all spw)
    spw='2'
    taql  --TaQl expression for data selection (see https://casacore.github.io/casacore-notes/199.html)
    default taql=''
    Example select all data where U > 1 m in the ms
    taql='UVW[0] > 1'
    outputvis -- name of output grid
    default: ''  The user has to give something here
    phasecenter -- phasecenter of the grid
    default= ''
    phasecenter='J2000 18h03m04 -20d00m45.1'
    imsize  -- number of pixels along the x and y axes of the grid
    default=100
    imsize=[1000, 1000]
    cell -- cellsize of the grid (given in sky units)
    default: '1arcsec'
    cell='0.1arcsec'
    ncorr -- number of correlation/polarization plane in uv grid (allowed 1, 2, 4)
    default: 1
    ncorr=4
    nchan -- number of spectral channel
    default: 1
    nchan=2000
    start -- frequency of the first channel
    default: '';  User has to give something useful here
    width -- spectral channel width
    default: ''
    wproject -- do wprojection correction while gridding
    default: False
    wproject=True
    memfrac -- control how much of computer's memory is available for  gridding
    default=0.5
    memfrac=0.9
    
    


    """

    _info_group_ = """manipulation, imaging"""
    _info_desc_ = """grid the visibility data onto a defined uniform grid (in the form of an ms); multiple MS\'s can be done onto the same grid"""

    __schema = {'vis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'taql': {'type': 'cStr', 'coerce': _coerce.to_str}, 'outputvis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'phasecenter': {'type': 'cStr', 'coerce': _coerce.to_str}, 'imsize': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'cell': {'type': 'cStr', 'coerce': _coerce.to_str}, 'ncorr': {'type': 'cInt', 'allowed': [ 1, 2, 4 ]}, 'nchan': {'type': 'cInt'}, 'start': {'type': 'cStr', 'coerce': _coerce.to_str}, 'width': {'type': 'cStr', 'coerce': _coerce.to_str}, 'wproject': {'type': 'cBool' # <allowed> IS NOT ALLOWED FOR A PARAMETER OF TYPE bool
}, 'memfrac': {'type': 'cFloat', 'coerce': _coerce.to_float, 'min': 0.01, 'max': 0.99}, 'mode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'bin', 'write_flags_back' ]}, 'flagbackup': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 13 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __phasecenter_dflt( self, glb ):
        return ''

    def __phasecenter( self, glb ):
        if 'phasecenter' in glb: return glb['phasecenter']
        return ''

    def __memfrac_dflt( self, glb ):
        return float(0.5)

    def __memfrac( self, glb ):
        if 'memfrac' in glb: return glb['memfrac']
        return float(0.5)

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __width_dflt( self, glb ):
        return ''

    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        return ''

    def __nchan_dflt( self, glb ):
        return int(1)

    def __nchan( self, glb ):
        if 'nchan' in glb: return glb['nchan']
        return int(1)

    def __wproject_dflt( self, glb ):
        return False

    def __wproject( self, glb ):
        if 'wproject' in glb: return glb['wproject']
        return False

    def __cell_dflt( self, glb ):
        return '1arcsec'

    def __cell( self, glb ):
        if 'cell' in glb: return glb['cell']
        return '1arcsec'

    def __outputvis_dflt( self, glb ):
        return ''

    def __outputvis( self, glb ):
        if 'outputvis' in glb: return glb['outputvis']
        return ''

    def __imsize_dflt( self, glb ):
        return [ int(100) ]

    def __imsize( self, glb ):
        if 'imsize' in glb: return glb['imsize']
        return [ int(100) ]

    def __ncorr_dflt( self, glb ):
        return int(1)

    def __ncorr( self, glb ):
        if 'ncorr' in glb: return glb['ncorr']
        return int(1)

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __mode_dflt( self, glb ):
        return 'bin'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'bin'

    def __taql_dflt( self, glb ):
        return ''

    def __taql( self, glb ):
        if 'taql' in glb: return glb['taql']
        return ''

    def __start_dflt( self, glb ):
        return ''

    def __start( self, glb ):
        if 'start' in glb: return glb['start']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __flagbackup_dflt( self, glb ):
        if self.__mode( glb ) == "write_flags_back": return bool(False)
        return None

    #--------- return subparam values -------------------------------------------------
    def __flagbackup( self, glb ):
        if 'flagbackup' in glb: return glb['flagbackup']
        dflt = self.__flagbackup_dflt( glb )
        if dflt is not None: return dflt
        return False

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'field(s) to select'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Spw selection'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __taql_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__taql_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'TaQl string for data selection'
        value = self.__taql( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'taql': value},{'taql': self.__schema['taql']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('taql',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __outputvis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outputvis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'name of output uvgrid'
        value = self.__outputvis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outputvis': value},{'outputvis': self.__schema['outputvis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('outputvis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __phasecenter_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__phasecenter_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'phase center of uv grid'
        value = self.__phasecenter( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'phasecenter': value},{'phasecenter': self.__schema['phasecenter']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('phasecenter',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __imsize_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__imsize_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ int(100) ]
        description = 'Number of pixels'
        value = self.__imsize( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'imsize': value},{'imsize': self.__schema['imsize']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('imsize',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __cell_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__cell_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return '1arcsec'
        description = 'pixel cell size defined in sky dimension'
        value = self.__cell( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'cell': value},{'cell': self.__schema['cell']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('cell',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __ncorr_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__ncorr_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(1)
        description = 'number of correlations to store in grid'
        value = self.__ncorr( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'ncorr': value},{'ncorr': self.__schema['ncorr']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('ncorr',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __nchan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__nchan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(1)
        description = 'Number of spectral channels in grid'
        value = self.__nchan( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'nchan': value},{'nchan': self.__schema['nchan']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('nchan',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __start_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__start_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Frequency of first spectral channel'
        value = self.__start( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'start': value},{'start': self.__schema['start']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('start',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __width_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__width_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'spectral channel width'
        value = self.__width( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('width',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __wproject_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__wproject_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Do wprojection correction while gridding'
        value = self.__wproject( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'wproject': value},{'wproject': self.__schema['wproject']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('wproject',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __memfrac_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__memfrac_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.5)
        description = 'Limit how much of memory to use'
        value = self.__memfrac( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'memfrac': value},{'memfrac': self.__schema['memfrac']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('memfrac',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __mode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__mode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'bin'
        description = 'when mode=  "write_flags_back"Operation mode (bin/write_back_flags)'
        value = self.__mode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23s%s' % ('mode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __flagbackup_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__flagbackup_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__flagbackup_dflt( self.__globals_( ) ) is not None:
             description = 'backup flags before saving flags when using write_flags_back'
             value = self.__flagbackup( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'flagbackup': value},{'flagbackup': self.__schema['flagbackup']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('flagbackup',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'memfrac' in glb: del glb['memfrac']
        if 'field' in glb: del glb['field']
        if 'outputvis' in glb: del glb['outputvis']
        if 'nchan' in glb: del glb['nchan']
        if 'ncorr' in glb: del glb['ncorr']
        if 'imsize' in glb: del glb['imsize']
        if 'vis' in glb: del glb['vis']
        if 'wproject' in glb: del glb['wproject']
        if 'mode' in glb: del glb['mode']
        if 'cell' in glb: del glb['cell']
        if 'phasecenter' in glb: del glb['phasecenter']
        if 'start' in glb: del glb['start']
        if 'width' in glb: del glb['width']
        if 'flagbackup' in glb: del glb['flagbackup']
        if 'spw' in glb: del glb['spw']
        if 'taql' in glb: del glb['taql']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# msuvbin -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__taql_inp( )
        self.__outputvis_inp( )
        self.__phasecenter_inp( )
        self.__imsize_inp( )
        self.__cell_inp( )
        self.__ncorr_inp( )
        self.__nchan_inp( )
        self.__start_inp( )
        self.__width_inp( )
        self.__wproject_inp( )
        self.__memfrac_inp( )
        self.__mode_inp( )
        self.__flagbackup_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "msuvbin.last" if os.path.isfile("msuvbin.last") else "msuvbin.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('msuvbin.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['taql'] = self.__taql( self.__globals_( ) )
        _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
        _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
        _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
        _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
        _invocation_parameters['ncorr'] = self.__ncorr( self.__globals_( ) )
        _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
        _invocation_parameters['start'] = self.__start( self.__globals_( ) )
        _invocation_parameters['width'] = self.__width( self.__globals_( ) )
        _invocation_parameters['wproject'] = self.__wproject( self.__globals_( ) )
        _invocation_parameters['memfrac'] = self.__memfrac( self.__globals_( ) )
        _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
        _invocation_parameters['flagbackup'] = self.__flagbackup( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#msuvbin( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, field=None, spw=None, taql=None, outputvis=None, phasecenter=None, imsize=None, cell=None, ncorr=None, nchan=None, start=None, width=None, wproject=None, memfrac=None, mode=None, flagbackup=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('msuvbin.pre')
        _postfile = os.path.realpath('msuvbin.last')
        task_result = None
        _arguments = [vis,field,spw,taql,outputvis,phasecenter,imsize,cell,ncorr,nchan,start,width,wproject,memfrac,mode,flagbackup]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if taql is not None: local_global['taql'] = taql
            if outputvis is not None: local_global['outputvis'] = outputvis
            if phasecenter is not None: local_global['phasecenter'] = phasecenter
            if imsize is not None: local_global['imsize'] = imsize
            if cell is not None: local_global['cell'] = cell
            if ncorr is not None: local_global['ncorr'] = ncorr
            if nchan is not None: local_global['nchan'] = nchan
            if start is not None: local_global['start'] = start
            if width is not None: local_global['width'] = width
            if wproject is not None: local_global['wproject'] = wproject
            if memfrac is not None: local_global['memfrac'] = memfrac
            if mode is not None: local_global['mode'] = mode

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['taql'] = self.__taql( local_global )
            _invocation_parameters['outputvis'] = self.__outputvis( local_global )
            _invocation_parameters['phasecenter'] = self.__phasecenter( local_global )
            _invocation_parameters['imsize'] = self.__imsize( local_global )
            _invocation_parameters['cell'] = self.__cell( local_global )
            _invocation_parameters['ncorr'] = self.__ncorr( local_global )
            _invocation_parameters['nchan'] = self.__nchan( local_global )
            _invocation_parameters['start'] = self.__start( local_global )
            _invocation_parameters['width'] = self.__width( local_global )
            _invocation_parameters['wproject'] = self.__wproject( local_global )
            _invocation_parameters['memfrac'] = self.__memfrac( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['flagbackup'] = self.__flagbackup( _invocation_parameters ) if flagbackup is None else flagbackup

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['taql'] = self.__taql( self.__globals_( ) )
            _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
            _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
            _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
            _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
            _invocation_parameters['ncorr'] = self.__ncorr( self.__globals_( ) )
            _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
            _invocation_parameters['start'] = self.__start( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['wproject'] = self.__wproject( self.__globals_( ) )
            _invocation_parameters['memfrac'] = self.__memfrac( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['flagbackup'] = self.__flagbackup( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#msuvbin( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'msuvbin', [ 'vis=' + repr(_pc.document['vis']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'taql=' + repr(_pc.document['taql']), 'outputvis=' + repr(_pc.document['outputvis']), 'phasecenter=' + repr(_pc.document['phasecenter']), 'imsize=' + repr(_pc.document['imsize']), 'cell=' + repr(_pc.document['cell']), 'ncorr=' + repr(_pc.document['ncorr']), 'nchan=' + repr(_pc.document['nchan']), 'start=' + repr(_pc.document['start']), 'width=' + repr(_pc.document['width']), 'wproject=' + repr(_pc.document['wproject']), 'memfrac=' + repr(_pc.document['memfrac']), 'mode=' + repr(_pc.document['mode']), 'flagbackup=' + repr(_pc.document['flagbackup']) ] )
            task_result = _msuvbin_t( _pc.document['vis'],_pc.document['field'],_pc.document['spw'],_pc.document['taql'],_pc.document['outputvis'],_pc.document['phasecenter'],_pc.document['imsize'],_pc.document['cell'],_pc.document['ncorr'],_pc.document['nchan'],_pc.document['start'],_pc.document['width'],_pc.document['wproject'],_pc.document['memfrac'],_pc.document['mode'],_pc.document['flagbackup'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('msuvbin')
            casalog.post("Exception Reported: Error in msuvbin: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'msuvbin', task_result )

        #Added if _msuvbin_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

msuvbin = _msuvbin( )

