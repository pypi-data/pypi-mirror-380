##################### generated by xml-casa (v2) from apparentsens.xml ##############
##################### 9d6c5795d9dfba6821c2263a4b3cb80f ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_apparentsens import apparentsens as _apparentsens_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _apparentsens:
    """
    apparentsens ---- Imaging sensitivity estimation

    Estimates the expected imaging sensitivity as a function of the
    visibility weights and imaging parameters.

    --------- parameter descriptions ---------------------------------------------

    vis         Name(s) of input visibility file(s)
                default: none;
                example: vis='ngc5921.ms'
                         vis=['ngc5921a.ms','ngc5921b.ms']; multiple MSes
    field       Select fields to image or mosaic.  Use field id(s) or name(s).
                   ['go listobs' to obtain the list id's or names]
                default: ''= all fields
                  If field string is a non-negative integer, it is assumed to
                  be a field index otherwise, it is assumed to be a
                  field name
                  field='0~2'; field ids 0,1,2
                  field='0,4,5~7'; field ids 0,4,5,6,7
                  field='3C286,3C295'; field named 3C286 and 3C295
                  field = '3,4C*'; field id 3, all names starting with 4C
                  For multiple MS input, a list of field strings can be used:
                  field = ['0~2','0~4']; field ids 0-2 for the first MS and 0-4
                          for the second
                  field = '0~2'; field ids 0-2 for all input MSes
    spw         Select spectral window/channels
                NOTE: channels de-selected here will contain all zeros if
                          selected by the parameter mode subparameters.
                default: ''=all spectral windows and channels
                  spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
                  spw='0:5~61'; spw 0, channels 5 to 61
                  spw='<2';   spectral windows less than 2 (i.e. 0,1)
                  spw='0,10,3:3~45'; spw 0,10 all channels, spw 3,
                                     channels 3 to 45.
                  spw='0~2:2~6'; spw 0,1,2 with channels 2 through 6 in each.
                  For multiple MS input, a list of spw strings can be used:
                  spw=['0','0~3']; spw ids 0 for the first MS and 0-3 for the second
                  spw='0~3' spw ids 0-3 for all input MS
                  spw='3:10~20;50~60' for multiple channel ranges within spw id 3
                  spw='3:10~20;50~60,4:0~30' for different channel ranges for spw ids 3 and 4
                  spw='0:0~10,1:20~30,2:1;2;3'; spw 0, channels 0-10,
                       spw 1, channels 20-30, and spw 2, channels, 1,2 and 3
                  spw='1~4;6:15~48' for channels 15 through 48 for spw ids 1,2,3,4 and 6
    intent      Scan Intent(s)
                
                default: '' (all)
                example: intent='TARGET_SOURCE'
                example: intent='TARGET_SOURCE1,TARGET_SOURCE2'
                example: intent='TARGET_POINTING*'
    selectdata  Enable data selection parameters.
    timerange   Range of time to select from data
                
                default: '' (all); examples,
                timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                Note: if YYYY/MM/DD is missing date defaults to first
                      day in data set
                timerange='09:14:0~09:54:0' picks 40 min on first day
                timerange='25:00:00~27:30:00' picks 1 hr to 3 hr
                          30min on NEXT day
                timerange='09:44:00' pick data within one integration
                          of time
                timerange='> 10:24:00' data after this time
                For multiple MS input, a list of timerange strings can be
                used:
                timerange=['09:14:0~09:54:0','> 10:24:00']
                timerange='09:14:0~09:54:0''; apply the same timerange for
                                              all input MSes
    uvrange     Select data within uvrange (default unit is meters)
                default: '' (all); example:
                uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
                uvrange='> 4klambda';uvranges greater than 4 kilo lambda
                For multiple MS input, a list of uvrange strings can be
                used:
                uvrange=['0~1000klambda','100~1000klamda']
                uvrange='0~1000klambda'; apply 0-1000 kilo-lambda for all
                                         input MSes
    antenna     Select data based on antenna/baseline
                
                default: '' (all)
                If antenna string is a non-negative integer, it is
                assumed to be an antenna index, otherwise, it is
                considered an antenna name.
                antenna='5\&6'; baseline between antenna index 5 and
                              index 6.
                antenna='VA05\&VA06'; baseline between VLA antenna 5
                                    and 6.
                antenna='5\&6;7\&8'; baselines 5-6 and 7-8
                antenna='5'; all baselines with antenna index 5
                antenna='05'; all baselines with antenna number 05
                             (VLA old name)
                antenna='5,6,9'; all baselines with antennas 5,6,9
                                index number
                For multiple MS input, a list of antenna strings can be
                used:
                antenna=['5','5\&6'];
                antenna='5'; antenna index 5 for all input MSes
                antenna='!DV14'; use all antennas except DV14
    scan        Scan number range
                
                default: '' (all)
                example: scan='1~5'
                For multiple MS input, a list of scan strings can be used:
                scan=['0~100','10~200']
                scan='0~100; scan ids 0-100 for all input MSes
    observation Observation ID range
                default: '' (all)
                example: observation='1~5'
    imsize      Number of pixels
                example :  imsize = [350,250]
                                  imsize = 500 is equivalent to [500,500]
                To take proper advantage of internal optimized FFT routines, the
                number of pixels must be even and factorizable by 2,3,5,7 only.
    cell        Cell size
                example: cell=['0.5arcsec,'0.5arcsec'] or
                cell=['1arcmin', '1arcmin']
                cell = '1arcsec' is equivalent to ['1arcsec','1arcsec']
    stokes      Stokes Planes to make (I only, for now)
                default='I'; example: stokes='IQUV';
                  Options: 'I','Q','U','V','IV','QU','IQ','UV','IQUV','RR','LL','XX','YY','RRLL','XXYY','pseudoI'
                
                              Note : Due to current internal code constraints, if any correlation pair
                                         is flagged, by default, no data for that row in the MS will be used.
                                         So, in an MS with XX,YY, if only YY is flagged, neither a
                                         Stokes I image nor an XX image can be made from those data points.
                                         In such a situation, please split out only the unflagged correlation into
                                         a separate MS.
                
                              Note : The 'pseudoI' option is a partial solution, allowing Stokes I imaging
                                     when either of the parallel-hand correlations are unflagged.
                
                              The remaining constraints shall be removed (where logical) in a future release.
    specmode    Spectral definition mode (mfs only, for now)
                
                mode='mfs' : Continuum imaging with only one output image channel.
                                      (mode='cont' can also be used here)
                
                mode='cube' : Spectral line imaging with one or more channels
                                        Parameters start, width,and nchan define the spectral
                                        coordinate system and can be specified either in terms
                                        of channel numbers, frequency or velocity in whatever
                                        spectral frame is specified in 'outframe'.
                                        All internal and output images are made with outframe as the
                                        base spectral frame. However imaging code internally uses the fixed
                                        spectral frame, LSRK for automatic internal software
                                        Doppler tracking so that a spectral line observed over an
                                        extended time range will line up appropriately.
                                        Therefore the output images have additional spectral frame conversion
                                        layer in LSRK on the top the base frame.
                
                
                                        (Note : Even if the input parameters are specified in a frame
                                                    other than LSRK, the viewer still displays spectral
                                                    axis in LSRK by default because of the conversion frame
                                                    layer mentioned above. The viewer can be used to relabel
                                                    the spectral axis in any desired frame - via the spectral
                                                    reference option under axis label properties in the
                                                    data display options window.)
                
                
                                        
                
                 mode='cubedata' : Spectral line imaging with one or more channels
                                                 There is no internal software Doppler tracking so
                                                 a spectral line observed over an extended time range
                                                 may be smeared out in frequency. There is strictly
                                                 no valid spectral frame with which to label the output
                                                 images, but they will list the frame defined in the MS.
    weighting   Weighting scheme (natural,uniform,briggs,superuniform,radial)
                
                        During gridding of the dirty or residual image, each visibility value is
                        multiplied by a weight before it is accumulated on the uv-grid.
                        The PSF's uv-grid is generated by gridding only the weights (weightgrid).
                
                        weighting='natural' : Gridding weights are identical to the data weights
                                                          from the MS. For visibilities with similar data weights,
                                                          the weightgrid will follow the sample density
                                                          pattern on the uv-plane. This weighting scheme
                                                          provides the maximum imaging sensitivity at the
                                                          expense of a possibly fat PSF with high sidelobes.
                                                          It is most appropriate for detection experiments
                                                          where sensitivity is most important.
                
                        weighting='uniform' : Gridding weights per visibility data point are the
                                                           original data weights divided by the total weight of
                                                           all data points that map to the same uv grid cell :
                                                           ' data_weight / total_wt_per_cell '.
                
                                                           The weightgrid is as close to flat as possible resulting
                                                           in a PSF with a narrow main lobe and suppressed
                                                           sidelobes. However, since heavily sampled areas of
                                                           the uv-plane get down-weighted, the imaging
                                                           sensitivity is not as high as with natural weighting.
                                                           It is most appropriate for imaging experiments where
                                                           a well behaved PSF can help the reconstruction.
                
                        weighting='briggs' :  Gridding weights per visibility data point are given by
                                                          'data_weight / ( A / total_wt_per_cell + B ) ' where
                                                          A and B vary according to the 'robust' parameter.
                
                                                          robust = -2.0 maps to A=1,B=0 or uniform weighting.
                                                          robust = +2.0 maps to natural weighting.
                                                          (robust=0.5 is equivalent to robust=0.0 in AIPS IMAGR.)
                
                                                          Robust/Briggs weighting generates a PSF that can
                                                          vary smoothly between 'natural' and 'uniform' and
                                                          allow customized trade-offs between PSF shape and
                                                          imaging sensitivity.
                
                        weighting='superuniform' : This is similar to uniform weighting except that
                                                                     the total_wt_per_cell is replaced by the
                                                                     total_wt_within_NxN_cells around the uv cell of
                                                                     interest.  ( N = subparameter 'npixels' )
                
                                                                    This method tends to give a PSF with inner
                                                                    sidelobes that are suppressed as in uniform
                                                                    weighting but with far-out sidelobes closer to
                                                                    natural weighting. The peak sensitivity is also
                                                                    closer to natural weighting.
                
                        weighting='radial' : Gridding weights are given by ' data_weight * uvdistance '
                
                                                       This method approximately minimizes rms sidelobes
                                                       for an east-west synthesis array.
                
                For more details on weighting please see Chapter3
                of Dan Briggs' thesis (http://www.aoc.nrao.edu/dissertations/dbriggs)
    robust      Robustness parameter for Briggs weighting.
                
                robust = -2.0 maps to uniform weighting.
                robust = +2.0 maps to natural weighting.
                (robust=0.5 is equivalent to robust=0.0 in AIPS IMAGR.)
    npixels     Number of pixels to determine uv-cell size for super-uniform weighting
                 (0 defaults to -/+ 3 pixels)
                
                npixels -- uv-box used for weight calculation
                               a box going from -npixel/2 to +npixel/2 on each side
                              around a point is used to calculate weight density.
                
                npixels=2 goes from -1 to +1 and covers 3 pixels on a side.
                
                npixels=0 implies a single pixel, which does not make sense for
                                superuniform weighting. Therefore, if npixels=0 it will
                                be forced to 6 (or a box of -3pixels to +3pixels) to cover
                                7 pixels on a side.
    uvtaper     uv-taper on outer baselines in uv-plane
                
                Apply a Gaussian taper in addition to the weighting scheme specified
                via the 'weighting' parameter. Higher spatial frequencies are weighted
                down relative to lower spatial frequencies to suppress artifacts
                arising from poorly sampled areas of the uv-plane. It is equivalent to
                smoothing the PSF obtained by other weighting schemes and can be
                specified either as a Gaussian in uv-space (eg. units of lambda)
                or as a Gaussian in the image domain (eg. angular units like arcsec).
                
                uvtaper = [bmaj, bmin, bpa]
                
                NOTE: the on-sky FWHM in arcsec is roughly  the uv taper/200 (klambda).
                default: uvtaper=[]; no Gaussian taper applied
                example: uvtaper=['5klambda']  circular taper
                             FWHM=5 kilo-lambda
                         uvtaper=['5klambda','3klambda','45.0deg']
                         uvtaper=['10arcsec'] on-sky FWHM 10 arcseconds
                         uvtaper=['300.0'] default units are lambda
                             in aperture plane
    [1;42mRETURNS[1;m        record

    --------- examples -----------------------------------------------------------

    
    
    TBD.
    
    


    """

    _info_group_ = """imaging"""
    _info_desc_ = """Imaging sensitivity estimation"""

    __schema = {'vis': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'field': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'spw': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'intent': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'selectdata': {'type': 'cBool'}, 'timerange': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'uvrange': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'antenna': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'scan': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'observation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'imsize': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'cell': {'anyof': [{'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'stokes': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'I', 'IQUV', 'UV', 'RRLL', 'IQ', 'V', 'pseudoI', 'QU', 'YY', 'RR', 'Q', 'U', 'IV', 'XX', 'XXYY', 'LL' ]}, 'specmode': {'type': 'cVariant', 'coerce': [_coerce.to_variant] # <allowed> IS NOT ALLOWED FOR A PARAMETER OF TYPE any
}, 'weighting': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'briggs', 'natural', 'radial', 'superuniform', 'uniform' ]}, 'robust': {'type': 'cFloat', 'coerce': _coerce.to_float, 'min': -2.0, 'max': 2.0}, 'npixels': {'type': 'cInt'}, 'uvtaper': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 14 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __cell_dflt( self, glb ):
        return [  ]

    def __cell( self, glb ):
        if 'cell' in glb: return glb['cell']
        return [  ]

    def __imsize_dflt( self, glb ):
        return [ int(100) ]

    def __imsize( self, glb ):
        if 'imsize' in glb: return glb['imsize']
        return [ int(100) ]

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __specmode_dflt( self, glb ):
        return 'mfs'

    def __specmode( self, glb ):
        if 'specmode' in glb: return glb['specmode']
        return 'mfs'

    def __stokes_dflt( self, glb ):
        return 'I'

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return 'I'

    def __weighting_dflt( self, glb ):
        return 'natural'

    def __weighting( self, glb ):
        if 'weighting' in glb: return glb['weighting']
        return 'natural'



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __field_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __intent_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __npixels_dflt( self, glb ):
        if self.__weighting( glb ) == "briggs": return int(0)
        return None
    def __uvtaper_dflt( self, glb ):
        if self.__weighting( glb ) == "natural": return []
        if self.__weighting( glb ) == "briggs": return []
        return None
    def __robust_dflt( self, glb ):
        if self.__weighting( glb ) == "briggs": return float(0.5)
        return None
    def __uvrange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __spw_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        dflt = self.__field_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        dflt = self.__spw_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        dflt = self.__intent_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        dflt = self.__uvrange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __robust( self, glb ):
        if 'robust' in glb: return glb['robust']
        dflt = self.__robust_dflt( glb )
        if dflt is not None: return dflt
        return float(0.5)
    def __npixels( self, glb ):
        if 'npixels' in glb: return glb['npixels']
        dflt = self.__npixels_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __uvtaper( self, glb ):
        if 'uvtaper' in glb: return glb['uvtaper']
        dflt = self.__uvtaper_dflt( glb )
        if dflt is not None: return dflt
        return [ '' ]

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file(s)'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__field_dflt( self.__globals_( ) ) is not None:
             description = 'field(s) to select'
             value = self.__field( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__spw_dflt( self.__globals_( ) ) is not None:
             description = 'spw(s)/channels to select'
             value = self.__spw( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__intent_dflt( self.__globals_( ) ) is not None:
             description = 'Scan Intent(s)'
             value = self.__intent( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __selectdata_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__selectdata_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Enable data selection parameters'
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('selectdata',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'Range of time to select from data'
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __uvrange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__uvrange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__uvrange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data within uvrange'
             value = self.__uvrange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('uvrange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on antenna/baseline'
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'Scan number range'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = 'Observation ID range'
             value = self.__observation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __imsize_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__imsize_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ int(100) ]
        description = 'Number of pixels'
        value = self.__imsize( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'imsize': value},{'imsize': self.__schema['imsize']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('imsize',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __cell_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__cell_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Cell size'
        value = self.__cell( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'cell': value},{'cell': self.__schema['cell']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('cell',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __stokes_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__stokes_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'I'
        description = 'Stokes Planes to make (I only, for now)'
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('stokes',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __specmode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__specmode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'mfs'
        description = 'Spectral definition mode (mfs only, for now)'
        value = self.__specmode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'specmode': value},{'specmode': self.__schema['specmode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('specmode',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __weighting_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__weighting_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'natural'
        description = 'Weighting scheme (natural,uniform,briggs)'
        value = self.__weighting( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'weighting': value},{'weighting': self.__schema['weighting']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('weighting',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __robust_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__robust_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.5)
        if self.__robust_dflt( self.__globals_( ) ) is not None:
             description = 'Robustness parameter'
             value = self.__robust( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'robust': value},{'robust': self.__schema['robust']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('robust',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __npixels_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__npixels_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(0)
        if self.__npixels_dflt( self.__globals_( ) ) is not None:
             description = 'Number of pixels to determine uv-cell size (0 : -/+ 3 pixels)'
             value = self.__npixels( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'npixels': value},{'npixels': self.__schema['npixels']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('npixels',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __uvtaper_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__uvtaper_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ '' ]
        if self.__uvtaper_dflt( self.__globals_( ) ) is not None:
             description = 'uv-taper on outer baselines in uv-plane'
             value = self.__uvtaper( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'uvtaper': value},{'uvtaper': self.__schema['uvtaper']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('uvtaper',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'stokes' in glb: del glb['stokes']
        if 'field' in glb: del glb['field']
        if 'weighting' in glb: del glb['weighting']
        if 'intent' in glb: del glb['intent']
        if 'imsize' in glb: del glb['imsize']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'specmode' in glb: del glb['specmode']
        if 'npixels' in glb: del glb['npixels']
        if 'uvtaper' in glb: del glb['uvtaper']
        if 'robust' in glb: del glb['robust']
        if 'cell' in glb: del glb['cell']
        if 'uvrange' in glb: del glb['uvrange']
        if 'observation' in glb: del glb['observation']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# apparentsens -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__intent_inp( )
        self.__selectdata_inp( )
        self.__timerange_inp( )
        self.__uvrange_inp( )
        self.__antenna_inp( )
        self.__scan_inp( )
        self.__observation_inp( )
        self.__imsize_inp( )
        self.__cell_inp( )
        self.__stokes_inp( )
        self.__specmode_inp( )
        self.__weighting_inp( )
        self.__robust_inp( )
        self.__npixels_inp( )
        self.__uvtaper_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "apparentsens.last" if os.path.isfile("apparentsens.last") else "apparentsens.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('apparentsens.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
        _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
        _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
        _invocation_parameters['specmode'] = self.__specmode( self.__globals_( ) )
        _invocation_parameters['weighting'] = self.__weighting( self.__globals_( ) )
        _invocation_parameters['robust'] = self.__robust( self.__globals_( ) )
        _invocation_parameters['npixels'] = self.__npixels( self.__globals_( ) )
        _invocation_parameters['uvtaper'] = self.__uvtaper( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#apparentsens( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, field=None, spw=None, intent=None, selectdata=None, timerange=None, uvrange=None, antenna=None, scan=None, observation=None, imsize=None, cell=None, stokes=None, specmode=None, weighting=None, robust=None, npixels=None, uvtaper=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('apparentsens.pre')
        _postfile = os.path.realpath('apparentsens.last')
        task_result = None
        _arguments = [vis,field,spw,intent,selectdata,timerange,uvrange,antenna,scan,observation,imsize,cell,stokes,specmode,weighting,robust,npixels,uvtaper]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if selectdata is not None: local_global['selectdata'] = selectdata
            if imsize is not None: local_global['imsize'] = imsize
            if cell is not None: local_global['cell'] = cell
            if stokes is not None: local_global['stokes'] = stokes
            if specmode is not None: local_global['specmode'] = specmode
            if weighting is not None: local_global['weighting'] = weighting

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['imsize'] = self.__imsize( local_global )
            _invocation_parameters['cell'] = self.__cell( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['specmode'] = self.__specmode( local_global )
            _invocation_parameters['weighting'] = self.__weighting( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['field'] = self.__field( _invocation_parameters ) if field is None else field
            _invocation_parameters['spw'] = self.__spw( _invocation_parameters ) if spw is None else spw
            _invocation_parameters['intent'] = self.__intent( _invocation_parameters ) if intent is None else intent
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['uvrange'] = self.__uvrange( _invocation_parameters ) if uvrange is None else uvrange
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['robust'] = self.__robust( _invocation_parameters ) if robust is None else robust
            _invocation_parameters['npixels'] = self.__npixels( _invocation_parameters ) if npixels is None else npixels
            _invocation_parameters['uvtaper'] = self.__uvtaper( _invocation_parameters ) if uvtaper is None else uvtaper

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
            _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['specmode'] = self.__specmode( self.__globals_( ) )
            _invocation_parameters['weighting'] = self.__weighting( self.__globals_( ) )
            _invocation_parameters['robust'] = self.__robust( self.__globals_( ) )
            _invocation_parameters['npixels'] = self.__npixels( self.__globals_( ) )
            _invocation_parameters['uvtaper'] = self.__uvtaper( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-11s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#apparentsens( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'apparentsens', [ 'vis=' + repr(_pc.document['vis']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'intent=' + repr(_pc.document['intent']), 'selectdata=' + repr(_pc.document['selectdata']), 'timerange=' + repr(_pc.document['timerange']), 'uvrange=' + repr(_pc.document['uvrange']), 'antenna=' + repr(_pc.document['antenna']), 'scan=' + repr(_pc.document['scan']), 'observation=' + repr(_pc.document['observation']), 'imsize=' + repr(_pc.document['imsize']), 'cell=' + repr(_pc.document['cell']), 'stokes=' + repr(_pc.document['stokes']), 'specmode=' + repr(_pc.document['specmode']), 'weighting=' + repr(_pc.document['weighting']), 'robust=' + repr(_pc.document['robust']), 'npixels=' + repr(_pc.document['npixels']), 'uvtaper=' + repr(_pc.document['uvtaper']) ] )
            task_result = _apparentsens_t( _pc.document['vis'],_pc.document['field'],_pc.document['spw'],_pc.document['intent'],_pc.document['selectdata'],_pc.document['timerange'],_pc.document['uvrange'],_pc.document['antenna'],_pc.document['scan'],_pc.document['observation'],_pc.document['imsize'],_pc.document['cell'],_pc.document['stokes'],_pc.document['specmode'],_pc.document['weighting'],_pc.document['robust'],_pc.document['npixels'],_pc.document['uvtaper'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('apparentsens')
            casalog.post("Exception Reported: Error in apparentsens: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'apparentsens', task_result )

        #Added if _apparentsens_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

apparentsens = _apparentsens( )

