##################### generated by xml-casa (v2) from tsdimaging.xml ################
##################### 713609c253d369e84269a826601df774 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_tsdimaging import tsdimaging as _tsdimaging_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _tsdimaging:
    """
    tsdimaging ---- SD task: imaging for total power and spectral data

    
    Task sdimaging creates an image from input single-dish data sets.
    The input can be either total power and spectral data.
    
    The coordinate of output image is defined by four axes, i.e., two
    spatial axes, frequency and polarization axes.n
    By default, spatial coordinate of image is defined so that the all
    pointing directions in POINTING tables of input data sets are covered
    with the cell size, 1/3 of FWHM of primary beam of antennas in the
    first MS. Therefore, it is often easiest to leave spatial definitions
    at the default values. It is also possible to define spatial axes of
    the image by specifying the image center direction (phasecenter),
    number of image pixel (imsize) and size of the pixel (cell).n
    The frequency coordinate of image is defined by three parameters,
    the number of channels (nchan), the channel id/frequency/velocity of
    the first channel (start), and channel width (width).There are three
    modes available to define unit of start and width, i.e., 'channel' (use
    channel indices), 'frequency' (use frequency unit, e.g., 'GHz'),
    and 'velocity' (use velocity unit, e.g., 'km/s'). By default, nchan,
    start, and width are defined so that all selected spectral windows are
    covered with the channel width equal to separation of first two
    channels selected.n
    Finally, polarizations of image is defined by stokes parameter or
    polarization. For example, stokes='XXYY' produces an image cube with
    each plane contains the image of one of the polarizations, while
    stokes='I' produces a 'total intensity' or Stokes I image.
    The stokes parameter has a special option, 'pseudoI'. The option is
    introduced to support imaging of partially flagged correlations.
    Main difference between 'I' and 'pseudoI' is that the former only takes
    into account the data whose correlations are all valid (this is the
    Stokes I in the strict sense) while the latter accumulates partially
    flagged data in addition. Note that the 'pseudoI' option is compatible
    with 'I' for sdimaging task.
    
    The task also supports various grid function (convolution kernel) to
    weight spectra as well as an option to remove the most extreme minimum
    and maximum (unweighted) values prior to computing the gridded pixel
    values. See description below for details of gridfunction available.
    
    

    --------- parameter descriptions ---------------------------------------------

    infiles        a list of names of input SD Measurementsets (only MS is allowed for this task)
    outfile        prefix of output images (.image, .weight)
    overwrite      overwrite the output file if already exists [True, False]
    field          select data by field IDs and names, e.g. \'3C2*\' (\'\'=all)
    spw            select data by IF IDs (spectral windows), e.g. \'3,5,7\' (\'\'=all)
    antenna        select data by antenna names or IDs, e.g, \'PM03\' (\'\' = all antennas)
    scan           select data by scan numbers, e.g. \'21~23\' (\'\'=all)
    intent         select data by observational intent, e.g. \'*ON_SOURCE*\' (\'\'=all)
    timerange      select data by range of time, e.g. 20:15:00~20:16:00 (\'\'=all)
    outframe       velocity frame of output image (''=current frame or LSRK for multiple-MS inputs)
    mode           spectral gridding type [\'channel\', \'frequency\', \'velocity\']
    nchan          number of channels (planes) in output image (-1=all)
    start          start of output spectral dimension, e.g. \'0\', \'110GHz\', \'-20km/s\'
    width          width of output spectral channels
    veltype        velocity definition
    specmode       Spectral definition mode (cube, cubedata, cubesource)
    interpolation  Spectral interpolation ["nearest", "linear", "cubic"]
                   Interpolation rules to use when binning data channels onto image channels and evaluating visibility values at the centers of image channels.
                   Note :
                   - "linear" and "cubic" interpolation requires data points on both sides of each image frequency. Errors are therefore possible at edge channels, or near flagged data channels. When image channel width is much larger than the data channel width there is nothing much to be gained using linear or cubic thus not worth the extra computation involved.
                   - If there are significant differences in the observation dates of the input MSes, "nearest" interpolation may cause some problems with frequency channel matching.
    pointingcolumn pointing data column to use
    convertfirst   Specify whether the direction of the specified pointing column must be converted to image"s reference frame prior to being interpolated at data-taking time, and when. "never": interpolate against the pointing column, then convert.  "always": interpolate against the beforehand converted pointing column. "auto": if there are less pointings than selected data rows convert first, else interpolate first
    projection     map projection type
    imsize         x and y image size in pixels, e.g., [64,64]. Single value: same for both spatial axes ([] = number of pixels to cover whole pointings in MSes)
    cell           x and y cell size, (e.g., [\'8arcsec\',\'8arcsec\']. default unit arcmin. ('' = 1/3 of FWHM of primary beam)
    phasecenter    image center direction: position or field index or ephemeris source info, e.g., \'J2000 17:30:15.0 -25.30.00.0\', \'MARS\'. (\'\' = the center of pointing directions in MSes)
    stokes         stokes parameters or polarization types to image, e.g. \'I\', \'XX\'
    gridfunction   gridding function for imaging (see description in help)
    convsupport    convolution support for gridding
    truncate       truncation radius for gridding
    gwidth         HWHM for gaussian
    jwidth         c-parameter for jinc function
    clipminmax     Clip minimum and maximum value from each pixel. Note the benefit of clipping is lost when the number of integrations contributing to each gridded pixel is small, or where the incidence of spurious datapoints is approximately or greater than the number of beams (in area) encompassed by expected image.
    minweight      Minimum weight ratio to the median of weight used in weight correction and weight beased masking
    brightnessunit Overwrite the brightness unit in image (\'\' = respect the unit in MS) [\'K\' or \'Jy/beam\'].
                   If no unit is provided, the task examines unit keywords ('UNIT' and 'QuantumUnits' in turn) of data columns.
                   Order of the examination is 'CORRECTED_DATA' - 'FLOAT_DATA' - 'DATA'. The order also represents the priority.
                   When unit string is found, it will be used as brightness unit.
    restfreq       rest frequency to assign to image, e.g., \'114.5GHz\'. When the default value \'\' is used, the task currently internally uses REST_FREQUENCY of SOURCE table or mean frequency of given spectral window as a default value.
    [1;42mRETURNS[1;m           void

    --------- examples -----------------------------------------------------------

    
    Keyword arguments:
    infiles -- a list of names of input SD Measurementsets
    example: 'm100.PM01.ms'
    ['m100.PM01.ms','m100.PM03.ms']; multiple MSes
    outfile -- prefix of output images
    Currently, four images are created by the task:
    .image -- target image
    .weight -- weight image
    .sumwt -- sumwt image
    .psf -- psf image (equivalent to weight image)
    .sumwt and .psf are kind of useless so far. image products
    will be improved later.
    default: ''
    example: 'mySDimage.im'
    overwrite -- overwrite the output file if already exists
    options: (bool) True,False
    default: False (do NOT overwrite)
    example: if True, existing file will be overwritten
    field -- select data by field IDs and names
    If field string is a non-negative integer, it is assumed to
    be a field index otherwise, it is assumed to be a
    field name
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 3 or filed named 3C273)
    For multiple MS input, a list of field strings can be used:
    field = ['0~2','0~4'] (field ids 0-2 for the first MS and 0-4
    for the second)
    field = '0~2' (field ids 0-2 for all input MSes)
    this selection is in addition to the other selections to data
    spw -- select data by spectral window IDs/channels
    NOTE: channels de-selected here will contain all zeros if
    selected by the parameter mode subparameters.
    default: '' (use all IFs and channels)
    example: spw='3,5,7' (IF IDs 3,5,7; all channels)
    spw='<2' (IF IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (IF IDs with the center frequencies in range 30-45GHz; all channels)
    spw='0:5~61' (IF ID 0; channels 5 to 61; all channels)
    spw='3:10~20;50~60' (select multiple channel ranges within IF ID 3)
    spw='3:10~20,4:0~30' (select different channel ranges for IF IDs 3 and 4)
    spw='1~4;6:15~48' (for channels 15 through 48 for IF IDs 1,2,3,4 and 6)
    For multiple MS input, a list of spw strings can be used:
    spw=['0','0~3'] (spw ids 0 for the first MS and 0-3 for the second)
    spw='0~3' (spw ids 0-3 for all input MSes)
    this selection is in addition to the other selections to data
    antenna -- select data by antenna names or IDs
    If antenna string is a non-negative integer, it is
    assumed to be an antenna index, otherwise, it is
    considered an antenna name.
    default: '' (all baselines, i.e. all antenna in case of auto data)
    example: antenna='PM03'
    For multiple MS input, a list of antenna strings can be used:
    antenna=['5','6'] (antenna id5 for the first MS and 6 for the second)
    antenna='5' (antenna index 5 for all input MSes)
    this selection is in addition to the other selections to data
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    For multiple MS input, a list of scan strings can be used:
    scan=['0~100','10~200'] (scan ids 0-100 for the first MS
    and 10-200 for the second)
    scan='0~100 (scan ids 0-100 for all input MSes)
    this selection is in addition to the other selections to data
    intent -- select data by observational intent, also referred to as 'scan intent'
    default: 'OBSERVE_TARGET#ON_SOURCE' (ALMA ON-source intent)
    example: intent='' (use all scan intents)
    intent='*ON_SOURCE*' (any valid scan-intent expression accepted by the MSSelection module can be specified)
    For multiple MS input, a list of scan-intent expressions can be used:
    intent=['ON_SOURCE','CALIBRATE_BANDPASS'] (scan intent ON_SOURCE for the first MS
    and CALIBRATE_BANDPASS for the second)
    this selection is in addition to the other selections to data
    mode -- spectral gridding type
    options: 'channel', 'velocity', 'frequency'
    default: 'channel'
    >>> mode expandable parameters
    nchan -- Total number of channels in the output image.
    default: -1; Automatically selects enough channels to cover
    data selected by 'spw' consistent with 'start' and 'width'.
    It is often easiest to leave nchan at the default value.
    example: nchan=100
    start -- First channel, velocity, or frequency.
    For mode='channel'; This selects the channel index number
    from the MS (0 based) that you want to correspond to the
    first channel of the output cube. The output cube will be
    in frequency space with the first channel having the
    frequency of the MS channel selected by start.  start=0
    refers to the first channel in the first selected spw, even
    if that channel is de-selected in the spw parameter.
    Channels de-selected by the spw parameter will be filled with
    zeros if included by the start parameter. For example,
    spw=3~8:3~100 and start=2 will produce a cube that starts on
    the third channel (recall 0 based) of spw index 3, and the
    first channel will be blank.
    default: '' (the first input channel of first input spw)
    example: start=100 (mode='channel')
    start='22.3GHz' (mode='frequency')
    start='5.0km/s' (mode='velocity')
    width -- Output channel width
    For mode='channel', default=1; width>1 indicates channel averaging
    example: width=4.
    For mode= 'velocity' or 'frequency', default=''; width of
    first input channel, or more precisely, the difference
    in frequencies between the first two selected channels.
    -- For example if channels 1 and 3 are selected with spw,
    then the default width will be the difference between their
    frequencies, and not the width of channel 1.
    -- Similarly, if the selected data has uneven channel-spacing,
    the default width will be picked from the first two selected
    channels. In this case, please specify the desired width.
    When specifying the width, one must give units
    examples: width='1.0km/s', or width='24.2kHz'.
    Setting width>0 gives channels of increasing frequency for
    mode='frequency', and increasing velocity for mode='velocity'.
    veltype -- Velocity definition
    Options: 'radio','optical','true','relativistic'
    default: 'radio'
    specmode -- Spectral definition mode (cube, cubedata, cubesource)
    default: 'cube'
    Options: 'cube', 'cubedata', 'cubesource'
    'cube' : Spectral line imaging with one or more channels
    Parameters start, width,and nchan define the spectral
    coordinate system and can be specified either in terms
    of channel numbers, frequency or velocity in whatever
    spectral frame is specified in 'outframe'.
    All internal and output images are made with outframe as the
    base spectral frame. However imaging code internally uses the fixed
    spectral frame, LSRK for automatic internal software
    Doppler tracking so that a spectral line observed over an
    extended time range will line up appropriately.
    Therefore the output images have additional spectral frame conversion
    layer in LSRK on the top the base frame.
    'cubedata' : Spectral line imaging with one or more channels
    There is no internal software Doppler tracking so
    a spectral line observed over an extended time range
    may be smeared out in frequency. There is strictly
    no valid spectral frame with which to label the output
    images, but they will list the frame defined in the MS
    'cubesource': Spectral line imaging while
    tracking moving source (near field or solar system
    objects). The velocity of the source is accounted
    and the frequency reported is in the source frame.
    As there is not SOURCE frame defined,
    the frame reported will be REST (as it may not be
    in the rest frame emission region may be
    moving w.r.t the systemic velocity frame)
    outframe -- velocity reference frame of output image
    Options: '','LSRK','LSRD','BARY','GEO','TOPO','GALACTO',
    'LGROUP','CMB'
    default: ''; same as input data or 'LSRK' for multiple-MS inputs
    example: frame='bary' for Barycentric frame
    gridfunction -- gridding function for imaging
    options: 'BOX' (Box-car), 'SF' (Spheroidal),
    'PB' (Primary-beam), 'GAUSS' (Gaussian),
    'GJINC' (Gaussian*Jinc)
    default: 'BOX'
    example: 'SF'
    >>> gridfunction expandable parameter:
    convsupport -- convolution support for 'SF'
    default: -1 (use default for each gridfunction)
    example: 3
    truncate -- truncattion radius of convolution kernel.
    effective only for 'GAUSS' and 'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    gwidth -- HWHM for gaussian. Effective only for
    'GAUSS' and 'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    jwidth -- Width of jinc function. Effective only for
    'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    imsize -- x and y image size in pixels, symmetric for single value
    default: [] (=cover all pointings in MS)
    example: imsize=200 (equivalent to [200,200])
    cell -- x and y cell size. default unit arcmin
    default: '' (= 1/3 of FWHM of primary beam)
    example: cell=['0.2arcmin, 0.2arcmin']
    cell='0.2arcmin' (equivalent to example above)
    phasecenter -- image center: direction measure, field ID, or
    ephemerides source information for moving source (solar system objects)
    default: '' (= the center of pointing directions in
    POINTING table of infiles)
    example: phasecenter=6 (field ID)
    phasecenter='J2000 13h44m00 -17d02m00'
    phasecenter='AZEL -123d48m29 15d41m41'
    phasecenter='MARS'
    phasecenter='myComet_ephem.tab'
    phasecenter='TRACKFIELD'
    
    If the phasecenter is the name known major solar system object
    ('MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS',
    'NEPTUNE', 'PLUTO', 'SUN', 'MOON') or is an ephemerides table
    then that source is tracked and the background sources get smeared.
    There is a special case, when phasecenter='TRACKFIELD', which
    will use the ephemerides or polynomial phasecenter in the FIELD
    table of the MS's as the source center to track.
    
    When moving source correction is applied, the source is fixed to
    the position at the beginning of on-source observations in the data.
    Direction reference frame of output image refers phasecenter ('J2000'
    if phasecenter is empty).
    
    Caution: in case of specifying ephemeris table name, its name or path
    must not start with known major solar system object listed
    above (case-insensitive), otherwise, CASA will use its
    internal ephemeris data for phasecenter instead. In such case
    you need to add './' at the beginning so that the specified
    table will be used. For example, if you wish to explicitly
    specify ephemeris table attached to the input MS 'SunObs.ms',
    set phasecenter like './SunObs.ms/FIELD/ephemtab_name.tab'.
    
    projection -- map projection type. See Calabretta & Greisen (2002) for detail.
    default: 'SIN'
    options: 'SIN', 'CAR', 'TAN', 'SFL'
    pointingcolumn -- pointing data column to use
    option: 'direction', 'target', 'pointing_offset', 'source_offset', encoder'
    default: 'direction'
    restfreq -- specify rest frequency to use for output image
    default: '' (refer input data)
    example: 1.0e11, '100GHz'
    stokes -- Stokes Planes to make
    default='I'; example: stokes='XXYY';
    options: 'I','Q','U','V','IV','QU','IQ','UV','IQUV','RR','LL','XX','YY','RRLL','XXYY','pseudoI'
    Note : The 'pseudoI' option is a partial solution, allowing Stokes I imaging
    when either of the parallel-hand correlations are unflagged.
    
    minweight -- Minimum weight ratio to the median of weight used in
    weight correction and weight based masking
    default: 0.1
    example: minweight = 0.
    brightnessunit -- Overwrite the brightness unit in image ['K' or 'Jy/beam'].
    If no unit is provided, the task examines unit keywords ('UNIT' and 'QuantumUnits' in turn) of data columns.
    Order of the examination is 'CORRECTED_DATA' - 'FLOAT_DATA' - 'DATA'. The order also represents the priority.
    When unit string is found, it will be used as brightness unit.
    default: '' (use the unit in MS)
    Options: '', 'K' (Kelvin), 'Jy/beam'
    clipminmax -- Clip minimum and maximum value from each pixel.
    Note the benefit of clipping is lost when the number of
    integrations contributing to each gridded pixel is small,
    or where the incidence of spurious datapoints is
    approximately or greater than the number of beams (in area)
    encompassed by expected image.
    default: False
    option: True, False
    interpolation -- Spectral interpolation.
    Interpolation rules to use when binning data channels onto image channels and
    evaluating visibility values at the centers of image channels.
    Note :
    - 'linear' and 'cubic' interpolation requires data points on both sides of each image frequency.
    Errors are therefore possible at edge channels, or near flagged data channels.
    When image channel width is much larger than the data channel width there is nothing much to be gained
    using linear or cubic thus not worth the extra computation involved.
    - If there are significant differences in observing dates of input MSes, some problems merely occur
    in frequency channel matching when 'nearest' interpolation.
    option: 'linear', 'nearest', 'cubic'
    default: 'linear'
    
    -----------------
    Gridding Kernel
    -----------------
    The parameter gridfunction sets gridding function (convolution kernel)
    for imaging. Currently, the task supports 'BOX' (Box-car), 'SF' (Prolate
    Spheroidal Wave Function), 'GAUSS' (Gaussian), 'GJINC' (Gaussian*Jinc),
    where Jinc(x) = J_1(pi*x/c)/(pi*x/c) with a first order Bessel function
    J_1, and 'PB' (Primary Beam). For 'PB', correct antenna informations
    should be included in input file.
    
    There are four subparameters for gridfunction: convsupport, truncate,
    gwidth, and jwidth. The convsupport is an integer specifying cut-off
    radius for 'SF' in units of pixel. By default (convsupport=-1),
    the cut-off radius is set to 3 pixels. The truncate is a cut-off
    radius for 'GAUSS' or 'GJINC'. It accepts integer, float, and
    string values of numeric plus unit. Allowed units are angular
    units such as 'deg', 'arcmin', 'arcsec', and 'pixel'. Default unit
    is 'pixel' so that string without unit or numerical values (integer
    or float) will be interpreted as radius in pixel. Default value
    for truncate, which is used when negative radius is set, is 3*HWHM
    for 'GAUSS' and radius at first null for 'GJINC'. The gwidth is
    the HWHM of gaussian for 'GAUSS' and 'GJINC'. Default value is
    sqrt(log(2)) pixel for 'GAUSS' and 2.52*sqrt(log(2)) pixel for
    'GJINC'. The jwidth specifies width of the jinc function (parameter
    'c' in the definition above). Default is 1.55 pixel. Both gwidth
    jwidth allows integer, float, or string of numeric plus unit.
    Default values for gwidth and jwidth are taken from Mangum et al.
    (2007). Formula for 'GAUSS' and 'GJINC' are taken from Table 1 in
    the paper, and are written as below using gwidth and jwidth:
    
    GAUSS: exp[-log(2)*(|r|/gwidth)**2]
    
    GJINC: J_1(pi*|r|/jwidth)/(pi*|r|/jwidth)
    * exp[-log(2)*(|r|/gwidth)^2]
    
    
    Reference: Mangum, et al. 2007, A&A, 474, 679-687
    
    --------------------
    Mask in Output Image
    --------------------
    The parameter minweight defines a threshold of weight values
    to mask. The pixels in outfile whose weight is smaller than
    minweight*median(weight) are masked out. The task also creates
    a weight image with the name outfile.weight.
    
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """SD task: imaging for total power and spectral data"""

    __schema = {'infiles': {'type': 'cReqPathVec', 'coerce': [_coerce.to_list,_coerce.expand_pathvec]}, 'outfile': {'type': 'cStr', 'coerce': _coerce.to_str}, 'overwrite': {'type': 'cBool'}, 'field': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'spw': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'antenna': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'scan': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'intent': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'type': 'cStr', 'coerce': _coerce.to_str}, 'outframe': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'LSRK', 'CMB', 'geo', 'bary', 'GALACTO', 'GEO', 'TOPO', 'LSRD', 'lsrk', 'topo', 'LGROUP', 'BARY', 'lsrd', 'cmb', 'galacto', 'lgroup', '' ]}, 'mode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'channel', 'frequency', 'velocity' ]}, 'nchan': {'type': 'cInt'}, 'start': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'width': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'veltype': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'OPTICAL', 'RELATIVISTIC', 'radio', 'true', 'optical', 'RADIO', 'TRUE', 'relativistic' ]}, 'specmode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'cube', 'cubedata', 'cubesource' ]}, 'interpolation': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'nearest', 'linear', 'cubic' ]}, 'pointingcolumn': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'TARGET', 'encoder', 'ENCODER', 'source_offset', 'pointing_offset', 'target', 'POINTING_OFFSET', 'DIRECTION', 'SOURCE_OFFSET', 'direction' ]}, 'convertfirst': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'never', 'auto', 'always' ]}, 'projection': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'sin', 'SIN', 'SFL', 'CAR', 'sfl', 'car', 'TAN', 'tan' ]}, 'imsize': {'anyof': [{'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'cell': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'phasecenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'stokes': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'I', 'IQUV', 'UV', 'RRLL', 'IQ', 'V', 'pseudoI', 'QU', 'YY', 'RR', 'Q', 'U', 'IV', 'XX', 'XXYY', 'LL' ]}, 'gridfunction': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'GJINC', 'pb', 'sf', 'GAUSS', 'PB', 'SF', 'gauss', 'BOX', 'box', 'gjinc' ]}, 'convsupport': {'type': 'cInt'}, 'truncate': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'gwidth': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'jwidth': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'clipminmax': {'type': 'cBool'}, 'minweight': {'type': 'cFloat', 'coerce': _coerce.to_float, 'min': 0}, 'brightnessunit': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ '', 'K', 'Jy/beam' ]}, 'restfreq': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 14 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __phasecenter_dflt( self, glb ):
        return ''

    def __phasecenter( self, glb ):
        if 'phasecenter' in glb: return glb['phasecenter']
        return ''

    def __projection_dflt( self, glb ):
        return 'SIN'

    def __projection( self, glb ):
        if 'projection' in glb: return glb['projection']
        return 'SIN'

    def __gridfunction_dflt( self, glb ):
        return 'BOX'

    def __gridfunction( self, glb ):
        if 'gridfunction' in glb: return glb['gridfunction']
        return 'BOX'

    def __clipminmax_dflt( self, glb ):
        return False

    def __clipminmax( self, glb ):
        if 'clipminmax' in glb: return glb['clipminmax']
        return False

    def __pointingcolumn_dflt( self, glb ):
        return 'direction'

    def __pointingcolumn( self, glb ):
        if 'pointingcolumn' in glb: return glb['pointingcolumn']
        return 'direction'

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __convertfirst_dflt( self, glb ):
        return 'never'

    def __convertfirst( self, glb ):
        if 'convertfirst' in glb: return glb['convertfirst']
        return 'never'

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __cell_dflt( self, glb ):
        return ''

    def __cell( self, glb ):
        if 'cell' in glb: return glb['cell']
        return ''

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __restfreq_dflt( self, glb ):
        return ''

    def __restfreq( self, glb ):
        if 'restfreq' in glb: return glb['restfreq']
        return ''

    def __interpolation_dflt( self, glb ):
        return 'linear'

    def __interpolation( self, glb ):
        if 'interpolation' in glb: return glb['interpolation']
        return 'linear'

    def __timerange_dflt( self, glb ):
        return ''

    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        return ''

    def __brightnessunit_dflt( self, glb ):
        return ''

    def __brightnessunit( self, glb ):
        if 'brightnessunit' in glb: return glb['brightnessunit']
        return ''

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __imsize_dflt( self, glb ):
        return [  ]

    def __imsize( self, glb ):
        if 'imsize' in glb: return glb['imsize']
        return [  ]

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __mode_dflt( self, glb ):
        return 'channel'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'channel'

    def __minweight_dflt( self, glb ):
        return float(0.1)

    def __minweight( self, glb ):
        if 'minweight' in glb: return glb['minweight']
        return float(0.1)

    def __specmode_dflt( self, glb ):
        return 'cube'

    def __specmode( self, glb ):
        if 'specmode' in glb: return glb['specmode']
        return 'cube'

    def __stokes_dflt( self, glb ):
        return 'I'

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return 'I'

    def __infiles_dflt( self, glb ):
        return [  ]

    def __infiles( self, glb ):
        if 'infiles' in glb: return glb['infiles']
        return [  ]

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False

    def __intent_dflt( self, glb ):
        return 'OBSERVE_TARGET#ON_SOURCE'

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return 'OBSERVE_TARGET#ON_SOURCE'



    #--------- return inp/go default --------------------------------------------------
    def __convsupport_dflt( self, glb ):
        if self.__gridfunction( glb ) == "SF": return int(-1)
        if self.__gridfunction( glb ) == "sf": return int(-1)
        return None
    def __nchan_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return int(-1)
        if self.__mode( glb ) == "frequency": return int(-1)
        if self.__mode( glb ) == "velocity": return int(-1)
        return None
    def __truncate_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GAUSS": return -1
        if self.__gridfunction( glb ) == "gauss": return -1
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __gwidth_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GAUSS": return -1
        if self.__gridfunction( glb ) == "gauss": return -1
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __veltype_dflt( self, glb ):
        if self.__mode( glb ) == "velocity": return "radio"
        return None
    def __outframe_dflt( self, glb ):
        if self.__specmode( glb ) == "cube": return ""
        return None
    def __jwidth_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __start_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return ""
        if self.__mode( glb ) == "frequency": return ""
        if self.__mode( glb ) == "velocity": return ""
        return None
    def __width_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return ""
        if self.__mode( glb ) == "frequency": return ""
        if self.__mode( glb ) == "velocity": return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __outframe( self, glb ):
        if 'outframe' in glb: return glb['outframe']
        dflt = self.__outframe_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __nchan( self, glb ):
        if 'nchan' in glb: return glb['nchan']
        dflt = self.__nchan_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __start( self, glb ):
        if 'start' in glb: return glb['start']
        dflt = self.__start_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        dflt = self.__width_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __veltype( self, glb ):
        if 'veltype' in glb: return glb['veltype']
        dflt = self.__veltype_dflt( glb )
        if dflt is not None: return dflt
        return 'radio'
    def __convsupport( self, glb ):
        if 'convsupport' in glb: return glb['convsupport']
        dflt = self.__convsupport_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __truncate( self, glb ):
        if 'truncate' in glb: return glb['truncate']
        dflt = self.__truncate_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __gwidth( self, glb ):
        if 'gwidth' in glb: return glb['gwidth']
        dflt = self.__gwidth_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __jwidth( self, glb ):
        if 'jwidth' in glb: return glb['jwidth']
        dflt = self.__jwidth_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)

    #--------- subparam inp output ----------------------------------------------------
    def __infiles_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__infiles_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'a list of names of input SD Measurementsets (only MS is allowed for this task)'
        value = self.__infiles( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'infiles': value},{'infiles': self.__schema['infiles']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('infiles',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __outfile_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outfile_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'prefix of output images (.image, .weight)'
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('outfile',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __overwrite_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__overwrite_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'overwrite the output file if already exists [True, False]'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('overwrite',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by field IDs and names, e.g. \'3C2*\' (\'\'=all)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by IF IDs (spectral windows), e.g. \'3,5,7\' (\'\'=all)'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by antenna names or IDs, e.g, \'PM03\' (\'\' = all antennas)'
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by scan numbers, e.g. \'21~23\' (\'\'=all)'
        value = self.__scan( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'OBSERVE_TARGET#ON_SOURCE'
        description = 'select data by observational intent, e.g. \'*ON_SOURCE*\' (\'\'=all)'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by range of time, e.g. 20:15:00~20:16:00 (\'\'=all)'
        value = self.__timerange( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __outframe_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outframe_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__outframe_dflt( self.__globals_( ) ) is not None:
             description = 'velocity frame of output image [\'lsrk\', \'lsrd\', \'bary\', \'geo\', \'topo\', \'galacto\', \'lgroup\', \'cmb\'] (\'\'=current frame or LSRK for multiple-MS inputs)'
             value = self.__outframe( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outframe': value},{'outframe': self.__schema['outframe']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('outframe',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __mode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__mode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'channel'
        description = 'spectral gridding type [\'channel\', \'frequency\', \'velocity\']'
        value = self.__mode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('mode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __nchan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__nchan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__nchan_dflt( self.__globals_( ) ) is not None:
             description = 'number of channels (planes) in output image (-1=all)'
             value = self.__nchan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'nchan': value},{'nchan': self.__schema['nchan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('nchan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __start_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__start_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(0)
        if self.__start_dflt( self.__globals_( ) ) is not None:
             description = 'start of output spectral dimension, e.g. \'0\', \'110GHz\', \'-20km/s\''
             value = self.__start( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'start': value},{'start': self.__schema['start']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('start',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __width_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__width_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(1)
        if self.__width_dflt( self.__globals_( ) ) is not None:
             description = 'width of output spectral channels'
             value = self.__width( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('width',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __veltype_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__veltype_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'radio'
        if self.__veltype_dflt( self.__globals_( ) ) is not None:
             description = 'velocity definition [\'radio\', \'optical\', \'true\' or \'relativistic\']'
             value = self.__veltype( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'veltype': value},{'veltype': self.__schema['veltype']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('veltype',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __specmode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__specmode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'cube'
        description = 'Spectral definition mode (cube, cubedata, cubesource)'
        value = self.__specmode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'specmode': value},{'specmode': self.__schema['specmode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('specmode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __interpolation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interpolation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'linear'
        description = 'Spectral interpolation ["nearest", "linear", "cubic"]'
        value = self.__interpolation( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interpolation': value},{'interpolation': self.__schema['interpolation']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('interpolation',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __pointingcolumn_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__pointingcolumn_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'direction'
        description = 'pointing data column to use [\'direction\', \'target\', \'pointing_offset\', \'source_offset\' or \'encoder\']'
        value = self.__pointingcolumn( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'pointingcolumn': value},{'pointingcolumn': self.__schema['pointingcolumn']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('pointingcolumn',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __convertfirst_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__convertfirst_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'never'
        description = 'pointing column: direction conversion-interpolation processing scheme to use ["never", "auto", "always"]'
        value = self.__convertfirst( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'convertfirst': value},{'convertfirst': self.__schema['convertfirst']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('convertfirst',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __projection_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__projection_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'SIN'
        description = 'map projection type'
        value = self.__projection( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'projection': value},{'projection': self.__schema['projection']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('projection',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __imsize_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__imsize_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'x and y image size in pixels, e.g., [64,64]. Single value: same for both spatial axes ([] = number of pixels to cover whole pointings in MSes)'
        value = self.__imsize( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'imsize': value},{'imsize': self.__schema['imsize']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('imsize',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __cell_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__cell_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'x and y cell size, (e.g., [\'8arcsec\',\'8arcsec\']. default unit arcmin. ('' = 1/3 of FWHM of primary beam)'
        value = self.__cell( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'cell': value},{'cell': self.__schema['cell']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('cell',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __phasecenter_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__phasecenter_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'image center direction: position or field index or ephemeris source info, e.g., \'J2000 17:30:15.0 -25.30.00.0\', \'MARS\'. (\'\' = the center of pointing directions in MSes)'
        value = self.__phasecenter( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'phasecenter': value},{'phasecenter': self.__schema['phasecenter']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('phasecenter',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __stokes_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__stokes_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'I'
        description = 'stokes parameters or polarization types to image, e.g. \'I\', \'XX\''
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('stokes',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __gridfunction_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gridfunction_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'BOX'
        description = 'gridding function for imaging [\'BOX\', \'SF\', \'PB\', \'GAUSS\' or \'GJINC\'] (see description in help)'
        value = self.__gridfunction( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gridfunction': value},{'gridfunction': self.__schema['gridfunction']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('gridfunction',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __convsupport_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__convsupport_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__convsupport_dflt( self.__globals_( ) ) is not None:
             description = 'convolution support for gridding'
             value = self.__convsupport( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'convsupport': value},{'convsupport': self.__schema['convsupport']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('convsupport',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __truncate_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__truncate_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__truncate_dflt( self.__globals_( ) ) is not None:
             description = 'truncation radius for gridding'
             value = self.__truncate( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'truncate': value},{'truncate': self.__schema['truncate']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('truncate',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __gwidth_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gwidth_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__gwidth_dflt( self.__globals_( ) ) is not None:
             description = 'HWHM for gaussian'
             value = self.__gwidth( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gwidth': value},{'gwidth': self.__schema['gwidth']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('gwidth',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __jwidth_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__jwidth_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__jwidth_dflt( self.__globals_( ) ) is not None:
             description = 'c-parameter for jinc function'
             value = self.__jwidth( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'jwidth': value},{'jwidth': self.__schema['jwidth']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('jwidth',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __clipminmax_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__clipminmax_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Clip minimum and maximum value from each pixel'
        value = self.__clipminmax( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'clipminmax': value},{'clipminmax': self.__schema['clipminmax']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('clipminmax',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __minweight_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minweight_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.1)
        description = 'Minimum weight ratio to use'
        value = self.__minweight( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minweight': value},{'minweight': self.__schema['minweight']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('minweight',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __brightnessunit_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__brightnessunit_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Overwrite the brightness unit in image (\'\' = respect the unit in MS) [\'K\' or \'Jy/beam\']'
        value = self.__brightnessunit( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'brightnessunit': value},{'brightnessunit': self.__schema['brightnessunit']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('brightnessunit',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __restfreq_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__restfreq_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'rest frequency to assign to image, e.g., \'114.5GHz\'. When the default value \'\' is used, the task currently internally uses REST_FREQUENCY of SOURCE table or mean frequency of given spectral window as a default value.'
        value = self.__restfreq( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'restfreq': value},{'restfreq': self.__schema['restfreq']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('restfreq',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'brightnessunit' in glb: del glb['brightnessunit']
        if 'stokes' in glb: del glb['stokes']
        if 'outfile' in glb: del glb['outfile']
        if 'field' in glb: del glb['field']
        if 'convsupport' in glb: del glb['convsupport']
        if 'projection' in glb: del glb['projection']
        if 'intent' in glb: del glb['intent']
        if 'interpolation' in glb: del glb['interpolation']
        if 'nchan' in glb: del glb['nchan']
        if 'convertfirst' in glb: del glb['convertfirst']
        if 'pointingcolumn' in glb: del glb['pointingcolumn']
        if 'truncate' in glb: del glb['truncate']
        if 'imsize' in glb: del glb['imsize']
        if 'scan' in glb: del glb['scan']
        if 'specmode' in glb: del glb['specmode']
        if 'gwidth' in glb: del glb['gwidth']
        if 'restfreq' in glb: del glb['restfreq']
        if 'clipminmax' in glb: del glb['clipminmax']
        if 'veltype' in glb: del glb['veltype']
        if 'outframe' in glb: del glb['outframe']
        if 'mode' in glb: del glb['mode']
        if 'cell' in glb: del glb['cell']
        if 'phasecenter' in glb: del glb['phasecenter']
        if 'overwrite' in glb: del glb['overwrite']
        if 'minweight' in glb: del glb['minweight']
        if 'jwidth' in glb: del glb['jwidth']
        if 'start' in glb: del glb['start']
        if 'gridfunction' in glb: del glb['gridfunction']
        if 'width' in glb: del glb['width']
        if 'spw' in glb: del glb['spw']
        if 'timerange' in glb: del glb['timerange']
        if 'infiles' in glb: del glb['infiles']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# tsdimaging -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__infiles_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__antenna_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__timerange_inp( )
        self.__outframe_inp( )
        self.__mode_inp( )
        self.__nchan_inp( )
        self.__start_inp( )
        self.__width_inp( )
        self.__veltype_inp( )
        self.__specmode_inp( )
        self.__interpolation_inp( )
        self.__pointingcolumn_inp( )
        self.__convertfirst_inp( )
        self.__projection_inp( )
        self.__imsize_inp( )
        self.__cell_inp( )
        self.__phasecenter_inp( )
        self.__stokes_inp( )
        self.__gridfunction_inp( )
        self.__convsupport_inp( )
        self.__truncate_inp( )
        self.__gwidth_inp( )
        self.__jwidth_inp( )
        self.__clipminmax_inp( )
        self.__minweight_inp( )
        self.__brightnessunit_inp( )
        self.__restfreq_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "tsdimaging.last" if os.path.isfile("tsdimaging.last") else "tsdimaging.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('tsdimaging.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['infiles'] = self.__infiles( self.__globals_( ) )
        _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
        _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
        _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
        _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
        _invocation_parameters['start'] = self.__start( self.__globals_( ) )
        _invocation_parameters['width'] = self.__width( self.__globals_( ) )
        _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
        _invocation_parameters['specmode'] = self.__specmode( self.__globals_( ) )
        _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
        _invocation_parameters['pointingcolumn'] = self.__pointingcolumn( self.__globals_( ) )
        _invocation_parameters['convertfirst'] = self.__convertfirst( self.__globals_( ) )
        _invocation_parameters['projection'] = self.__projection( self.__globals_( ) )
        _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
        _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
        _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
        _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
        _invocation_parameters['gridfunction'] = self.__gridfunction( self.__globals_( ) )
        _invocation_parameters['convsupport'] = self.__convsupport( self.__globals_( ) )
        _invocation_parameters['truncate'] = self.__truncate( self.__globals_( ) )
        _invocation_parameters['gwidth'] = self.__gwidth( self.__globals_( ) )
        _invocation_parameters['jwidth'] = self.__jwidth( self.__globals_( ) )
        _invocation_parameters['clipminmax'] = self.__clipminmax( self.__globals_( ) )
        _invocation_parameters['minweight'] = self.__minweight( self.__globals_( ) )
        _invocation_parameters['brightnessunit'] = self.__brightnessunit( self.__globals_( ) )
        _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-14s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#tsdimaging( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, infiles=None, outfile=None, overwrite=None, field=None, spw=None, antenna=None, scan=None, intent=None, timerange=None, outframe=None, mode=None, nchan=None, start=None, width=None, veltype=None, specmode=None, interpolation=None, pointingcolumn=None, convertfirst=None, projection=None, imsize=None, cell=None, phasecenter=None, stokes=None, gridfunction=None, convsupport=None, truncate=None, gwidth=None, jwidth=None, clipminmax=None, minweight=None, brightnessunit=None, restfreq=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('tsdimaging.pre')
        _postfile = os.path.realpath('tsdimaging.last')
        task_result = None
        _arguments = [infiles,outfile,overwrite,field,spw,antenna,scan,intent,timerange,outframe,mode,nchan,start,width,veltype,specmode,interpolation,pointingcolumn,convertfirst,projection,imsize,cell,phasecenter,stokes,gridfunction,convsupport,truncate,gwidth,jwidth,clipminmax,minweight,brightnessunit,restfreq]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infiles is not None: local_global['infiles'] = infiles
            if outfile is not None: local_global['outfile'] = outfile
            if overwrite is not None: local_global['overwrite'] = overwrite
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if antenna is not None: local_global['antenna'] = antenna
            if scan is not None: local_global['scan'] = scan
            if intent is not None: local_global['intent'] = intent
            if timerange is not None: local_global['timerange'] = timerange
            if mode is not None: local_global['mode'] = mode
            if specmode is not None: local_global['specmode'] = specmode
            if interpolation is not None: local_global['interpolation'] = interpolation
            if pointingcolumn is not None: local_global['pointingcolumn'] = pointingcolumn
            if convertfirst is not None: local_global['convertfirst'] = convertfirst
            if projection is not None: local_global['projection'] = projection
            if imsize is not None: local_global['imsize'] = imsize
            if cell is not None: local_global['cell'] = cell
            if phasecenter is not None: local_global['phasecenter'] = phasecenter
            if stokes is not None: local_global['stokes'] = stokes
            if gridfunction is not None: local_global['gridfunction'] = gridfunction
            if clipminmax is not None: local_global['clipminmax'] = clipminmax
            if minweight is not None: local_global['minweight'] = minweight
            if brightnessunit is not None: local_global['brightnessunit'] = brightnessunit
            if restfreq is not None: local_global['restfreq'] = restfreq

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infiles'] = self.__infiles( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['timerange'] = self.__timerange( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['specmode'] = self.__specmode( local_global )
            _invocation_parameters['interpolation'] = self.__interpolation( local_global )
            _invocation_parameters['pointingcolumn'] = self.__pointingcolumn( local_global )
            _invocation_parameters['convertfirst'] = self.__convertfirst( local_global )
            _invocation_parameters['projection'] = self.__projection( local_global )
            _invocation_parameters['imsize'] = self.__imsize( local_global )
            _invocation_parameters['cell'] = self.__cell( local_global )
            _invocation_parameters['phasecenter'] = self.__phasecenter( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['gridfunction'] = self.__gridfunction( local_global )
            _invocation_parameters['clipminmax'] = self.__clipminmax( local_global )
            _invocation_parameters['minweight'] = self.__minweight( local_global )
            _invocation_parameters['brightnessunit'] = self.__brightnessunit( local_global )
            _invocation_parameters['restfreq'] = self.__restfreq( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['outframe'] = self.__outframe( _invocation_parameters ) if outframe is None else outframe
            _invocation_parameters['nchan'] = self.__nchan( _invocation_parameters ) if nchan is None else nchan
            _invocation_parameters['start'] = self.__start( _invocation_parameters ) if start is None else start
            _invocation_parameters['width'] = self.__width( _invocation_parameters ) if width is None else width
            _invocation_parameters['veltype'] = self.__veltype( _invocation_parameters ) if veltype is None else veltype
            _invocation_parameters['convsupport'] = self.__convsupport( _invocation_parameters ) if convsupport is None else convsupport
            _invocation_parameters['truncate'] = self.__truncate( _invocation_parameters ) if truncate is None else truncate
            _invocation_parameters['gwidth'] = self.__gwidth( _invocation_parameters ) if gwidth is None else gwidth
            _invocation_parameters['jwidth'] = self.__jwidth( _invocation_parameters ) if jwidth is None else jwidth

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infiles'] = self.__infiles( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
            _invocation_parameters['start'] = self.__start( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
            _invocation_parameters['specmode'] = self.__specmode( self.__globals_( ) )
            _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
            _invocation_parameters['pointingcolumn'] = self.__pointingcolumn( self.__globals_( ) )
            _invocation_parameters['convertfirst'] = self.__convertfirst( self.__globals_( ) )
            _invocation_parameters['projection'] = self.__projection( self.__globals_( ) )
            _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
            _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
            _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['gridfunction'] = self.__gridfunction( self.__globals_( ) )
            _invocation_parameters['convsupport'] = self.__convsupport( self.__globals_( ) )
            _invocation_parameters['truncate'] = self.__truncate( self.__globals_( ) )
            _invocation_parameters['gwidth'] = self.__gwidth( self.__globals_( ) )
            _invocation_parameters['jwidth'] = self.__jwidth( self.__globals_( ) )
            _invocation_parameters['clipminmax'] = self.__clipminmax( self.__globals_( ) )
            _invocation_parameters['minweight'] = self.__minweight( self.__globals_( ) )
            _invocation_parameters['brightnessunit'] = self.__brightnessunit( self.__globals_( ) )
            _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-14s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#tsdimaging( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'tsdimaging', [ 'infiles=' + repr(_pc.document['infiles']), 'outfile=' + repr(_pc.document['outfile']), 'overwrite=' + repr(_pc.document['overwrite']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'antenna=' + repr(_pc.document['antenna']), 'scan=' + repr(_pc.document['scan']), 'intent=' + repr(_pc.document['intent']), 'timerange=' + repr(_pc.document['timerange']), 'outframe=' + repr(_pc.document['outframe']), 'mode=' + repr(_pc.document['mode']), 'nchan=' + repr(_pc.document['nchan']), 'start=' + repr(_pc.document['start']), 'width=' + repr(_pc.document['width']), 'veltype=' + repr(_pc.document['veltype']), 'specmode=' + repr(_pc.document['specmode']), 'interpolation=' + repr(_pc.document['interpolation']), 'pointingcolumn=' + repr(_pc.document['pointingcolumn']), 'convertfirst=' + repr(_pc.document['convertfirst']), 'projection=' + repr(_pc.document['projection']), 'imsize=' + repr(_pc.document['imsize']), 'cell=' + repr(_pc.document['cell']), 'phasecenter=' + repr(_pc.document['phasecenter']), 'stokes=' + repr(_pc.document['stokes']), 'gridfunction=' + repr(_pc.document['gridfunction']), 'convsupport=' + repr(_pc.document['convsupport']), 'truncate=' + repr(_pc.document['truncate']), 'gwidth=' + repr(_pc.document['gwidth']), 'jwidth=' + repr(_pc.document['jwidth']), 'clipminmax=' + repr(_pc.document['clipminmax']), 'minweight=' + repr(_pc.document['minweight']), 'brightnessunit=' + repr(_pc.document['brightnessunit']), 'restfreq=' + repr(_pc.document['restfreq']) ] )
            task_result = _tsdimaging_t( _pc.document['infiles'],_pc.document['outfile'],_pc.document['overwrite'],_pc.document['field'],_pc.document['spw'],_pc.document['antenna'],_pc.document['scan'],_pc.document['intent'],_pc.document['timerange'],_pc.document['outframe'],_pc.document['mode'],_pc.document['nchan'],_pc.document['start'],_pc.document['width'],_pc.document['veltype'],_pc.document['specmode'],_pc.document['interpolation'],_pc.document['pointingcolumn'],_pc.document['convertfirst'],_pc.document['projection'],_pc.document['imsize'],_pc.document['cell'],_pc.document['phasecenter'],_pc.document['stokes'],_pc.document['gridfunction'],_pc.document['convsupport'],_pc.document['truncate'],_pc.document['gwidth'],_pc.document['jwidth'],_pc.document['clipminmax'],_pc.document['minweight'],_pc.document['brightnessunit'],_pc.document['restfreq'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('tsdimaging')
            casalog.post("Exception Reported: Error in tsdimaging: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'tsdimaging', task_result )

        #Added if _tsdimaging_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

tsdimaging = _tsdimaging( )

