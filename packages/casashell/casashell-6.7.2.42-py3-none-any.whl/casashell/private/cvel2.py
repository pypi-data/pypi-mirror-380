##################### generated by xml-casa (v2) from cvel2.xml #####################
##################### b0b759de57aa7d74a7bbb529a642b212 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_cvel2 import cvel2 as _cvel2_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _cvel2:
    """
    cvel2 ---- Regrid an MS or MMS to a new spectral window, channel structure or frame

    
    The intent of cvel2 is to transform channel labels and the
    visibilities to a spectral reference frame which is appropriate for
    the science analysis, e.g. from TOPO to LSRK to correct for Doppler
    shifts throughout the time of the observation. Naturally, this will
    change the shape of the spectral feature to some extent. According to
    the Nyquist theorem you should oversample a spectrum with twice the
    numbers of channels to retain the shape. Based on some tests, however,
    we recommend to observe with at least 3-4 times the number of channels
    for each significant spectral feature (like 3-4 times the
    linewidth). This will minimize regridding artifacts in cvel2.
    
    If cvel2 has already established the grid that is desired for the
    imaging, tclean should be run with exactly the same frequency/velocity
    parameters as used in cvel2 in order to avoid additional regridding in
    clean.
    
    Hanning smoothing is optionally offered in cvel2, but tests have shown
    that already the regridding process itself, if it involved a
    transformation from TOPO to a non-terrestrial reference frame, implies
    some smoothing (due to channel interpolation) such that Hanning
    smoothing may not be necessary.
    
    This version of cvel2 also supports Multi-MS input, in which case it
    will create an output Multi-MS too.
    
    NOTE:
    The parameter passall is not supported in cvel2. The user may
    achieve the same results of passall=True by splitting out the data
    that will not be regridded with cvel2 and concatenate regridded
    and non-regridded sets at the end. In the case of Multi-MS input,
    the user should use virtualconcat to achieve a concatenated MMS.

    --------- parameter descriptions ---------------------------------------------

    vis           Name of input visibility file
                  Default: none
                  
                     Example: vis='ngc5921.ms'
    outputvis     Name of output visibility file or Multi-MS
                  Default: none
                  
                     Example: vis='ngc5921_out.ms'
    keepmms       If the input is a Multi-MS the output will also be a
                  Multi-MS.
                  Default: True
                  
                  By default it will create a Multi-MS when the
                  input is a Multi-MS. The output Multi-MS will
                  have the same partition axis of the input
                  MMS. See 'help partition' for more information on
                  the MMS format.
                  
                  NOTE: It is not possible to combine the spws if
                  the input MMS was partitioned with
                  separationaxis='spw'. In this case, the task will
                  abort with an error.
    passall       HIDDEN parameter. Pass through (write to output MS) non-selected data with no change
    field         Select field using field id(s) or field name(s)
                  Default: '' (all fields)
                  
                  Use 'go listobs' to obtain the list id's or
                  names. If field string is a non-negative integer,
                  it is assumed a field index,  otherwise, it is
                  assumed a field name.
                  
                     Examples:
                     field='0~2'; field ids 0,1,2
                     field='0,4,5~7'; field ids 0,4,5,6,7
                     field='3C286,3C295'; field named 3C286 and
                     3C295
                     field = '3,4C*'; field id 3, all names
                     starting with 4C
    spw           Select spectral window/channels
                            Default: ''=all spectral windows and channels
                  
                               Examples:
                               spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
                               spw='<2';  spectral windows less than 2 (i.e. 0,1)
                               spw='0:5~61'; spw 0, channels 5 to 61
                               spw='0,10,3:3~45'; spw 0,10 all channels, spw
                               3 - chans 3 to 45.
                               spw='0~2:2~6'; spw 0,1,2 with channels 2
                               through 6 in each.
                               spw = '\*:3~64'  channels 3 through 64 for all sp id's
                               spw = ' :3~64' will NOT work.
                  
                            NOTE: mstransform does not support multiple
                            channel ranges per spectral window.
    scan          Scan number range
                  Subparameter of selectdata=True
                  default: '' = all
    antenna       Select data based on antenna/baseline
                                     Subparameter of selectdata=True
                                     default: '' (all)
                  
                                     If antenna string is a non-negative integer, it
                                     is assumed an antenna index, otherwise, it is
                                     assumed as an antenna name
                  
                                         Examples: 
                                         antenna='5&6'; baseline between antenna
                                         index 5 and index 6.
                                         antenna='VA05&VA06'; baseline between VLA
                                         antenna 5 and 6.
                                         antenna='5&6;7&8'; baselines with
                                         indices 5-6 and 7-8
                                         antenna='5'; all baselines with antenna index
                                         5
                                         antenna='05'; all baselines with antenna
                                         number 05 (VLA old name)
                                         antenna='5,6,10'; all baselines with antennas
                                         5,6,10 index numbers
                                         antenna='!ea03,ea12,ea17': all baselines
                                         except those that include EVLA antennas ea03,
                                         ea12, or ea17.
    correlation   Select data based on correlation
                  Default: '' (all)
                  
                     Example: correlation='XX,YY'.
    timerange     Select data based on time range
                  Subparameter of selectdata=True
                  Default = '' (all)
                  
                     Examples:
                     timerange =
                     'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                     (Note: if YYYY/MM/DD is missing date defaults
                     to first day in data set.)
                     timerange='09:14:0~09:54:0' picks 40 min on
                     first day 
                     timerange= '25:00:00~27:30:00' picks 1 hr to 3
                     hr 30min on NEXT day
                     timerange='09:44:00' pick data within one
                     integration of time
                     timerange='>10:24:00' data after this time
    intent        Select observing intent
                  Default: '' (no selection by intent)
                  
                     Example: intent='*BANDPASS*'  (selects data
                     labelled with BANDPASS intent)
    array         Select (sub)array(s) by array ID number.
                  Default = '' (all)
    uvrange       Select data by baseline length.
    observation   Select by observation ID(s)
                  Subparameter of selectdata=True
                  Default: '' = all
                  
                      Example: observation='0~2,4'
    feed          Multi-feed numbers: Not yet implemented.
    datacolumn    Which data column(s) to process.
    mode          Regridding mode (channel/velocity/frequency/channel_b).
                    Default: 'channel'
                    Options: 'channel', 'velocity', 'frequency',
                    'channel_b'
                  
                  * mode = 'channel'; Use with nchan, start, width to
                    specify output spw. Produces equidistant grid
                    based on first selected channel.
                  * mode = 'velocity', means channels are specified
                    in velocity.
                  * mode = 'frequency', means channels are specified
                    in frequency.
                  * mode = 'channel_b', alternative 'channel'
                    mode. Does not force an equidistant grid. Faster.
                  
                       Examples: 
                       spw = '0,1'; mode = 'channel' will produce a
                       single spw containing all channels in spw 0
                       and 1
                       spw='0:5~28^2'; mode = 'channel' will produce
                       a single spw made with channels
                       (5,7,9,...,25,27)
                       spw = '0'; mode = 'channel': nchan=3; start=5;
                       width=4 will produce an spw with 3 output
                       channels
                       - new channel 1 contains data from channels
                       (5+6+7+8)
                       - new channel 2 contains data from channels
                       (9+10+11+12)
                       - new channel 3 contains data from channels
                       (13+14+15+16)
                       spw = '0:0~63^3'; mode='channel'; nchan=21;
                       start = 0; width = 1 will produce an spw with
                       21 channels
                       - new channel 1 contains data from channel 0
                       - new channel 2 contains data from channel 2
                       - new channel 21 contains data from channel 61
                       spw = '0:0~40^2'; mode = 'channel'; nchan = 3;
                       start = 5; width = 4 will produce an spw with
                       three output channels
                       - new channel 1 contains channels (5,7)
                       - new channel 2 contains channels (13,15)
                       - new channel 3 contains channels (21,23)
    nchan         Number of channels in the output spw (-1=all). 
                  Subparameter of
                  mode='channel|velocity|frequency|channel_b'                
                  Default: -1 = all channels
                  
                  Used for regridding, together with 'start' and
                  'width'.
                  
                     Example: nchan=3
    start         Start or end input channel (zero-based), depending on the sign of the width parameter 
                  Subparameter of
                  mode='channel|velocity|frequency|channel_b'                
                  
                  Used for regridding, together with 'width' and
                  'nchan'. It can be in different units, depending
                  on the regridding mode: 
                  - first input channel (mode='channel'), 
                  - first velocity (mode='velocity'), or 
                  - first frequency (mode='frequency'). 
                  
                     Example values: '5', '0.0km/s', '1.4GHz', for
                     channel, velocity, and frequency modes,
                     respectively.
    width         Channel width of the output visibilities. 
                  Subparameter of
                  mode='channel|velocity|frequency|channel_b'                
                  
                  Used for regridding, together with 'start', and
                  'nchan'. It can be in different units, depending
                  on the regridding mode: number of input channels
                  (mode='channel'), velocity (mode='velocity'), or
                  frequency (mode='frequency'. 
                  
                     Example values: '2', '1.0km/s', '1.0kHz', for
                     channel, velocity, and frequency modes,
                     respectively.
                  
                  Note: the sign indicates whether the start
                  parameter is lower(+) or upper(-) end of the
                  range.
    interpolation Spectral interpolation method
                  Subparameter of
                  mode='channel|velocity|frequency|channel_b'
                  Default = 'linear'
                  Options: linear, nearest, cubic, spline, fftshift
    phasecenter   Phase center direction to be used for the spectral
                  coordinate transformation.
                  Default: '' (first selected field)
                  Options: FIELD_ID (int) or center coordinate measure (str).
                  
                  Phase direction measure  or fieldid. To be used
                  in mosaics to indicate the center direction to be
                  used in the spectral coordinate transformation.
                  
                     Examples: 
                     phasecenter=6
                     phasecenter='J2000 19h30m00 -40d00m00'
    restfreq      Rest frequency to use for output visibilities.
                  Default='' 
                  
                  Occasionally it is necessary to set this (for
                  example some VLA spectral line data).  For
                  example for NH_3 (1,1) put
                  restfreq='23.694496GHz'
    outframe      Output reference frame (not case-sensitive).
                  Default: '' (keep original reference frame)
                  Options: LSRK, LSRD, BARY, GALACTO, LGROUP, CMB,
                  GEO, TOPO, or SOURCE 
                  
                  SOURCE is meant for solar system work and
                  corresponds to GEO + radial velocity correction
                  for ephemeris objects.
                  
                     Example: outframe='BARY'
    veltype       Definition of velocity (in mode)
                  Default = 'radio'
    hanning       Hanning smooth data to remove Gibbs ringing.
                  Default: False
                  Options: False|True
    [1;42mRETURNS[1;m          void

    --------- examples -----------------------------------------------------------

    
    
    For more information, see the task pages of cvel2 in CASA Docs:
    
    https://casa.nrao.edu/casadocs/


    """

    _info_group_ = """manipulation"""
    _info_desc_ = """Regrid an MS or MMS to a new spectral window, channel structure or frame"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'outputvis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'keepmms': {'type': 'cBool'}, 'passall': {'type': 'cBool'}, 'field': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'spw': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'scan': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'antenna': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'correlation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'timerange': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'intent': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'array': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'uvrange': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'observation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'feed': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'datacolumn': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'DATA', 'model', 'corrected', 'LAG_DATA', 'lag_data', 'FLOAT_DATA,DATA', 'FLOAT_DATA', 'CORRECTED', 'lag_data,data', 'float_data', 'float_data,data', 'DATA,MODEL,CORRECTED', 'ALL', 'MODEL', 'all', 'data,model,corrected', 'LAG_DATA,DATA', 'data' ]}, 'mode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'channel', 'velocity', 'frequency', 'channel_b' ]}, 'nchan': {'type': 'cInt'}, 'start': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'width': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'interpolation': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'nearest', 'linear', 'spline', 'fftshift', 'cubic' ]}, 'phasecenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'restfreq': {'type': 'cStr', 'coerce': _coerce.to_str}, 'outframe': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'SOURCE', 'LSRK', 'CMB', 'geo', 'source', 'bary', 'GALACTO', 'GEO', 'TOPO', 'LSRD', 'lsrk', 'topo', 'LGROUP', 'BARY', 'lsrd', 'cmb', 'galacto', 'lgroup', '' ]}, 'veltype': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'optical', 'radio', 'OPTICAL', 'RADIO' ]}, 'hanning': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 16 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __feed_dflt( self, glb ):
        return ''

    def __feed( self, glb ):
        if 'feed' in glb: return glb['feed']
        return ''

    def __phasecenter_dflt( self, glb ):
        return ''

    def __phasecenter( self, glb ):
        if 'phasecenter' in glb: return glb['phasecenter']
        return ''

    def __keepmms_dflt( self, glb ):
        return True

    def __keepmms( self, glb ):
        if 'keepmms' in glb: return glb['keepmms']
        return True

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __correlation_dflt( self, glb ):
        return ''

    def __correlation( self, glb ):
        if 'correlation' in glb: return glb['correlation']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __array_dflt( self, glb ):
        return ''

    def __array( self, glb ):
        if 'array' in glb: return glb['array']
        return ''

    def __outframe_dflt( self, glb ):
        return ''

    def __outframe( self, glb ):
        if 'outframe' in glb: return glb['outframe']
        return ''

    def __observation_dflt( self, glb ):
        return ''

    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        return ''

    def __veltype_dflt( self, glb ):
        return 'radio'

    def __veltype( self, glb ):
        if 'veltype' in glb: return glb['veltype']
        return 'radio'

    def __hanning_dflt( self, glb ):
        return False

    def __hanning( self, glb ):
        if 'hanning' in glb: return glb['hanning']
        return False

    def __datacolumn_dflt( self, glb ):
        return 'all'

    def __datacolumn( self, glb ):
        if 'datacolumn' in glb: return glb['datacolumn']
        return 'all'

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __outputvis_dflt( self, glb ):
        return ''

    def __outputvis( self, glb ):
        if 'outputvis' in glb: return glb['outputvis']
        return ''

    def __restfreq_dflt( self, glb ):
        return ''

    def __restfreq( self, glb ):
        if 'restfreq' in glb: return glb['restfreq']
        return ''

    def __uvrange_dflt( self, glb ):
        return ''

    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        return ''

    def __timerange_dflt( self, glb ):
        return ''

    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        return ''

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __mode_dflt( self, glb ):
        return 'channel'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'channel'

    def __passall_dflt( self, glb ):
        return False

    def __passall( self, glb ):
        if 'passall' in glb: return glb['passall']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __nchan_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return int(-1)
        if self.__mode( glb ) == "channel_b": return int(-1)
        if self.__mode( glb ) == "velocity": return int(-1)
        if self.__mode( glb ) == "frequency": return int(-1)
        return None
    def __start_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return 0
        if self.__mode( glb ) == "channel_b": return 0
        if self.__mode( glb ) == "velocity": return ""
        if self.__mode( glb ) == "frequency": return ""
        return None
    def __width_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return 1
        if self.__mode( glb ) == "channel_b": return 1
        if self.__mode( glb ) == "velocity": return ""
        if self.__mode( glb ) == "frequency": return ""
        return None
    def __interpolation_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return "linear"
        if self.__mode( glb ) == "channel_b": return "linear"
        if self.__mode( glb ) == "velocity": return "linear"
        if self.__mode( glb ) == "frequency": return "linear"
        return None

    #--------- return subparam values -------------------------------------------------
    def __passall( self, glb ):
        if 'passall' in glb: return glb['passall']
        dflt = self.__passall_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __nchan( self, glb ):
        if 'nchan' in glb: return glb['nchan']
        dflt = self.__nchan_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __start( self, glb ):
        if 'start' in glb: return glb['start']
        dflt = self.__start_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        dflt = self.__width_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __interpolation( self, glb ):
        if 'interpolation' in glb: return glb['interpolation']
        dflt = self.__interpolation_dflt( glb )
        if dflt is not None: return dflt
        return 'linear'

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __outputvis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outputvis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of output visibility file'
        value = self.__outputvis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outputvis': value},{'outputvis': self.__schema['outputvis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('outputvis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __keepmms_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__keepmms_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Create a Multi-MS as the output if the input is a Multi-MS'
        value = self.__keepmms( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'keepmms': value},{'keepmms': self.__schema['keepmms']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('keepmms',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __passall_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__passall_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__passall_dflt( self.__globals_( ) ) is not None:
             description = 'Hidden parameter'
             value = self.__passall( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'passall': value},{'passall': self.__schema['passall']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('passall',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select field using field id(s) or field name(s)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select spectral window/channels'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Scan number range'
        value = self.__scan( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select data based on antenna/baseline'
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __correlation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__correlation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select data based on correlation'
        value = self.__correlation( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'correlation': value},{'correlation': self.__schema['correlation']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('correlation',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select data based on time range'
        value = self.__timerange( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select observing intent'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __array_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__array_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select (sub)array(s) by array ID number.'
        value = self.__array( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'array': value},{'array': self.__schema['array']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('array',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __uvrange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__uvrange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select data by baseline length.'
        value = self.__uvrange( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('uvrange',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select by observation ID(s)'
        value = self.__observation( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __feed_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__feed_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Multi-feed numbers: Not yet implemented.'
        value = self.__feed( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'feed': value},{'feed': self.__schema['feed']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('feed',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __datacolumn_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__datacolumn_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'all'
        description = 'Data column(s) to process.'
        value = self.__datacolumn( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'datacolumn': value},{'datacolumn': self.__schema['datacolumn']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('datacolumn',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __mode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__mode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'channel'
        description = 'Regridding mode (channel/velocity/frequency/channel_b).'
        value = self.__mode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-16.16s =\x1B[0m %s%-23s%s' % ('mode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __nchan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__nchan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__nchan_dflt( self.__globals_( ) ) is not None:
             description = 'Number of channels in the output spw'
             value = self.__nchan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'nchan': value},{'nchan': self.__schema['nchan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('nchan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __start_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__start_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(0)
        if self.__start_dflt( self.__globals_( ) ) is not None:
             description = 'First input channel to use'
             value = self.__start( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'start': value},{'start': self.__schema['start']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('start',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __width_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__width_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(1)
        if self.__width_dflt( self.__globals_( ) ) is not None:
             description = 'Channel width of the output visibilities.'
             value = self.__width( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('width',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __interpolation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interpolation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'linear'
        if self.__interpolation_dflt( self.__globals_( ) ) is not None:
             description = 'Spectral interpolation method'
             value = self.__interpolation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interpolation': value},{'interpolation': self.__schema['interpolation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('interpolation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __phasecenter_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__phasecenter_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Phase center direction to be used for the spectral coordinate transformation: direction measure or field index'
        value = self.__phasecenter( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'phasecenter': value},{'phasecenter': self.__schema['phasecenter']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('phasecenter',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __restfreq_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__restfreq_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Rest frequency to use for output.'
        value = self.__restfreq( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'restfreq': value},{'restfreq': self.__schema['restfreq']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('restfreq',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __outframe_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outframe_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Output reference frame.'
        value = self.__outframe( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outframe': value},{'outframe': self.__schema['outframe']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('outframe',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __veltype_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__veltype_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'radio'
        description = 'Velocity definition.'
        value = self.__veltype( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'veltype': value},{'veltype': self.__schema['veltype']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('veltype',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __hanning_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__hanning_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Hanning smooth data to remove Gibbs ringing.'
        value = self.__hanning( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'hanning': value},{'hanning': self.__schema['hanning']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('hanning',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'keepmms' in glb: del glb['keepmms']
        if 'passall' in glb: del glb['passall']
        if 'field' in glb: del glb['field']
        if 'outputvis' in glb: del glb['outputvis']
        if 'datacolumn' in glb: del glb['datacolumn']
        if 'intent' in glb: del glb['intent']
        if 'interpolation' in glb: del glb['interpolation']
        if 'nchan' in glb: del glb['nchan']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'array' in glb: del glb['array']
        if 'restfreq' in glb: del glb['restfreq']
        if 'correlation' in glb: del glb['correlation']
        if 'feed' in glb: del glb['feed']
        if 'veltype' in glb: del glb['veltype']
        if 'outframe' in glb: del glb['outframe']
        if 'mode' in glb: del glb['mode']
        if 'uvrange' in glb: del glb['uvrange']
        if 'phasecenter' in glb: del glb['phasecenter']
        if 'start' in glb: del glb['start']
        if 'observation' in glb: del glb['observation']
        if 'hanning' in glb: del glb['hanning']
        if 'width' in glb: del glb['width']
        if 'spw' in glb: del glb['spw']
        if 'timerange' in glb: del glb['timerange']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# cvel2 -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__outputvis_inp( )
        self.__keepmms_inp( )
        self.__passall_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__scan_inp( )
        self.__antenna_inp( )
        self.__correlation_inp( )
        self.__timerange_inp( )
        self.__intent_inp( )
        self.__array_inp( )
        self.__uvrange_inp( )
        self.__observation_inp( )
        self.__feed_inp( )
        self.__datacolumn_inp( )
        self.__mode_inp( )
        self.__nchan_inp( )
        self.__start_inp( )
        self.__width_inp( )
        self.__interpolation_inp( )
        self.__phasecenter_inp( )
        self.__restfreq_inp( )
        self.__outframe_inp( )
        self.__veltype_inp( )
        self.__hanning_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "cvel2.last" if os.path.isfile("cvel2.last") else "cvel2.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('cvel2.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
        _invocation_parameters['keepmms'] = self.__keepmms( self.__globals_( ) )
        _invocation_parameters['passall'] = self.__passall( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['array'] = self.__array( self.__globals_( ) )
        _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['feed'] = self.__feed( self.__globals_( ) )
        _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
        _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
        _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
        _invocation_parameters['start'] = self.__start( self.__globals_( ) )
        _invocation_parameters['width'] = self.__width( self.__globals_( ) )
        _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
        _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
        _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )
        _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
        _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
        _invocation_parameters['hanning'] = self.__hanning( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-13s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#cvel2( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, outputvis=None, keepmms=None, passall=None, field=None, spw=None, scan=None, antenna=None, correlation=None, timerange=None, intent=None, array=None, uvrange=None, observation=None, feed=None, datacolumn=None, mode=None, nchan=None, start=None, width=None, interpolation=None, phasecenter=None, restfreq=None, outframe=None, veltype=None, hanning=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('cvel2.pre')
        _postfile = os.path.realpath('cvel2.last')
        task_result = None
        _arguments = [vis,outputvis,keepmms,passall,field,spw,scan,antenna,correlation,timerange,intent,array,uvrange,observation,feed,datacolumn,mode,nchan,start,width,interpolation,phasecenter,restfreq,outframe,veltype,hanning]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if outputvis is not None: local_global['outputvis'] = outputvis
            if keepmms is not None: local_global['keepmms'] = keepmms
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if scan is not None: local_global['scan'] = scan
            if antenna is not None: local_global['antenna'] = antenna
            if correlation is not None: local_global['correlation'] = correlation
            if timerange is not None: local_global['timerange'] = timerange
            if intent is not None: local_global['intent'] = intent
            if array is not None: local_global['array'] = array
            if uvrange is not None: local_global['uvrange'] = uvrange
            if observation is not None: local_global['observation'] = observation
            if feed is not None: local_global['feed'] = feed
            if datacolumn is not None: local_global['datacolumn'] = datacolumn
            if mode is not None: local_global['mode'] = mode
            if phasecenter is not None: local_global['phasecenter'] = phasecenter
            if restfreq is not None: local_global['restfreq'] = restfreq
            if outframe is not None: local_global['outframe'] = outframe
            if veltype is not None: local_global['veltype'] = veltype
            if hanning is not None: local_global['hanning'] = hanning

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['outputvis'] = self.__outputvis( local_global )
            _invocation_parameters['keepmms'] = self.__keepmms( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['correlation'] = self.__correlation( local_global )
            _invocation_parameters['timerange'] = self.__timerange( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['array'] = self.__array( local_global )
            _invocation_parameters['uvrange'] = self.__uvrange( local_global )
            _invocation_parameters['observation'] = self.__observation( local_global )
            _invocation_parameters['feed'] = self.__feed( local_global )
            _invocation_parameters['datacolumn'] = self.__datacolumn( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['phasecenter'] = self.__phasecenter( local_global )
            _invocation_parameters['restfreq'] = self.__restfreq( local_global )
            _invocation_parameters['outframe'] = self.__outframe( local_global )
            _invocation_parameters['veltype'] = self.__veltype( local_global )
            _invocation_parameters['hanning'] = self.__hanning( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['passall'] = self.__passall( _invocation_parameters ) if passall is None else passall
            _invocation_parameters['nchan'] = self.__nchan( _invocation_parameters ) if nchan is None else nchan
            _invocation_parameters['start'] = self.__start( _invocation_parameters ) if start is None else start
            _invocation_parameters['width'] = self.__width( _invocation_parameters ) if width is None else width
            _invocation_parameters['interpolation'] = self.__interpolation( _invocation_parameters ) if interpolation is None else interpolation

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['outputvis'] = self.__outputvis( self.__globals_( ) )
            _invocation_parameters['keepmms'] = self.__keepmms( self.__globals_( ) )
            _invocation_parameters['passall'] = self.__passall( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['correlation'] = self.__correlation( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['array'] = self.__array( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['feed'] = self.__feed( self.__globals_( ) )
            _invocation_parameters['datacolumn'] = self.__datacolumn( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
            _invocation_parameters['start'] = self.__start( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
            _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
            _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )
            _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
            _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
            _invocation_parameters['hanning'] = self.__hanning( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-13s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#cvel2( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'cvel2', [ 'vis=' + repr(_pc.document['vis']), 'outputvis=' + repr(_pc.document['outputvis']), 'keepmms=' + repr(_pc.document['keepmms']), 'passall=' + repr(_pc.document['passall']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'scan=' + repr(_pc.document['scan']), 'antenna=' + repr(_pc.document['antenna']), 'correlation=' + repr(_pc.document['correlation']), 'timerange=' + repr(_pc.document['timerange']), 'intent=' + repr(_pc.document['intent']), 'array=' + repr(_pc.document['array']), 'uvrange=' + repr(_pc.document['uvrange']), 'observation=' + repr(_pc.document['observation']), 'feed=' + repr(_pc.document['feed']), 'datacolumn=' + repr(_pc.document['datacolumn']), 'mode=' + repr(_pc.document['mode']), 'nchan=' + repr(_pc.document['nchan']), 'start=' + repr(_pc.document['start']), 'width=' + repr(_pc.document['width']), 'interpolation=' + repr(_pc.document['interpolation']), 'phasecenter=' + repr(_pc.document['phasecenter']), 'restfreq=' + repr(_pc.document['restfreq']), 'outframe=' + repr(_pc.document['outframe']), 'veltype=' + repr(_pc.document['veltype']), 'hanning=' + repr(_pc.document['hanning']) ] )
            task_result = _cvel2_t( _pc.document['vis'],_pc.document['outputvis'],_pc.document['keepmms'],_pc.document['passall'],_pc.document['field'],_pc.document['spw'],_pc.document['scan'],_pc.document['antenna'],_pc.document['correlation'],_pc.document['timerange'],_pc.document['intent'],_pc.document['array'],_pc.document['uvrange'],_pc.document['observation'],_pc.document['feed'],_pc.document['datacolumn'],_pc.document['mode'],_pc.document['nchan'],_pc.document['start'],_pc.document['width'],_pc.document['interpolation'],_pc.document['phasecenter'],_pc.document['restfreq'],_pc.document['outframe'],_pc.document['veltype'],_pc.document['hanning'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('cvel2')
            casalog.post("Exception Reported: Error in cvel2: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'cvel2', task_result )

        #Added if _cvel2_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

cvel2 = _cvel2( )

