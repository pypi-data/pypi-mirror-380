##################### generated by xml-casa (v2) from sdimaging.xml #################
##################### 3d5990fa46eb0dfcb908de9e27518a5f ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_sdimaging import sdimaging as _sdimaging_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _sdimaging:
    """
    sdimaging ---- SD task: imaging for total power and spectral data

    
    Task sdimaging creates an image from input single-dish data sets.
    The input can be either total power and spectral data.
    
    The coordinate of output image is defined by four axes, i.e., two
    spatial axes, frequency and polarization axes.n
    By default, spatial coordinate of image is defined so that the all
    pointing directions in POINTING tables of input data sets are covered
    with the cell size, 1/3 of FWHM of primary beam of antennas in the
    first MS. Therefore, it is often easiest to leave spatial definitions
    at the default values. It is also possible to define spatial axes of
    the image by specifying the image center direction (phasecenter),
    number of image pixel (imsize) and size of the pixel (cell).n
    The frequency coordinate of image is defined by three parameters,
    the number of channels (nchan), the channel id/frequency/velocity of
    the first channel (start), and channel width (width).There are three
    modes available to define unit of start and width, i.e., 'channel' (use
    channel indices), 'frequency' (use frequency unit, e.g., 'GHz'),
    and 'velocity' (use velocity unit, e.g., 'km/s'). By default, nchan,
    start, and width are defined so that all selected spectral windows are
    covered with the channel width equal to separation of first two
    channels selected.n
    Finally, polarizations of image is defined by stokes parameter or
    polarization. For example, stokes='XXYY' produces an image cube with
    each plane contains the image of one of the polarizations, while
    stokes='I' produces a 'total intensity' or Stokes I image.n
    
    The task also supports various grid function (convolution kernel) to
    weight spectra as well as an option to remove the most extreme minimum
    and maximum (unweighted) values prior to computing the gridded pixel
    values. See description below for details of gridfunction available.
    
    

    --------- parameter descriptions ---------------------------------------------

    infiles        a list of names of input SD Measurementsets (only MS is allowed for this task)
    outfile        name of output image
    overwrite      overwrite the output file if already exists [True, False]
    field          select data by field IDs and names, e.g. "3C2*" (""=all)
    spw            select data by IF IDs (spectral windows), e.g. "3,5,7" (""=all)
    antenna        select data by antenna names or IDs, e.g, "PM03" ("" = all antennas)
    scan           select data by scan numbers, e.g. "21~23" (""=all)
    intent         select data by observational intent, e.g. "*ON_SOURCE*" (""=all)
    mode           spectral gridding type
    nchan          number of channels (planes) in output image (-1=all)
    start          start of output spectral dimension, e.g. "0", "110GHz", "-20km/s"
    width          width of output spectral channels
    veltype        velocity definition
    outframe       velocity frame of output image (""=current frame or LSRK for multiple-MS inputs)
    gridfunction   gridding function for imaging (see description in help)
    convsupport    convolution support for gridding
    truncate       truncation radius for gridding
    gwidth         HWHM for gaussian
    jwidth         c-parameter for jinc function
    imsize         x and y image size in pixels, e.g., [64,64]. Single value: same for both spatial axes ([] = number of pixels to cover whole pointings in MSes)
    cell           x and y cell size, (e.g., ["8arcsec","8arcsec"]. default unit arcmin. ("" = 1/3 of FWHM of primary beam)
    phasecenter    image center direction: position or field index, e.g., "J2000 17:30:15.0 -25.30.00.0". ("" = the center of pointing directions in MSes)
    projection     map projection type
    ephemsrcname   ephemeris source name, e.g. "MARS"
    pointingcolumn pointing data column to use
    restfreq       rest frequency to assign to image, e.g., "114.5GHz"
    stokes         stokes parameters or polarization types to image, e.g. "I", "XX"
    minweight      Minimum weight ratio to the median of weight used in weight correction and weight beased masking
    brightnessunit Overwrite the brightness unit in image (\'\' = respect the unit in MS) [\'K\' or \'Jy/beam\']
    clipminmax     Clip minimum and maximum value from each pixel. Note the benefit of clipping is lost when the number of integrations contributing to each gridded pixel is small, or where the incidence of spurious datapoints is approximately or greater than the number of beams (in area) encompassed by expected image.
    enablecache    Cache spectra pixels coordinates computed while creating the normal image, and re-use them when creating the weight image.
    convertfirst   Specify whether the direction of the specified pointing column must be converted to image"s reference frame prior to being interpolated at data-taking time, and when. "never": interpolate against the pointing column, then convert.  "always": interpolate against the beforehand converted pointing column. "auto": if there are less pointings than selected data rows convert first, else interpolate first
    interpolation  Spectral interpolation ["nearest", "linear", "cubic"]
                   Interpolation rules to use when binning data channels onto image channels and evaluating visibility values at the centers of image channels.
                   Note :
                   - "linear" and "cubic" interpolation requires data points on both sides of each image frequency. Errors are therefore possible at edge channels, or near flagged data channels. When image channel width is much larger than the data channel width there is nothing much to be gained using linear or cubic thus not worth the extra computation involved.
                   - If there are significant differences in the observation dates of the input MSes, "nearest" interpolation may cause some problems with frequency channel matching.
    [1;42mRETURNS[1;m           void

    --------- examples -----------------------------------------------------------

    
    Keyword arguments:
    infiles -- a list of names of input SD Measurementsets
    example: 'm100.PM01.ms'
    ['m100.PM01.ms','m100.PM03.ms']; multiple MSes
    outfile -- name of output image
    default: ''
    example: 'mySDimage.im'
    overwrite -- overwrite the output file if already exists
    options: (bool) True,False
    default: False (do NOT overwrite)
    example: if True, existing file will be overwritten
    field -- select data by field IDs and names
    If field string is a non-negative integer, it is assumed to
    be a field index otherwise, it is assumed to be a
    field name
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 3 or filed named 3C273)
    For multiple MS input, a list of field strings can be used:
    field = ['0~2','0~4'] (field ids 0-2 for the first MS and 0-4
    for the second)
    field = '0~2' (field ids 0-2 for all input MSes)
    this selection is in addition to the other selections to data
    spw -- select data by spectral window IDs/channels
    NOTE: channels de-selected here will contain all zeros if
    selected by the parameter mode subparameters.
    default: '' (use all IFs and channels)
    example: spw='3,5,7' (IF IDs 3,5,7; all channels)
    spw='<2' (IF IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (IF IDs with the center frequencies in range 30-45GHz; all channels)
    spw='0:5~61' (IF ID 0; channels 5 to 61; all channels)
    spw='3:10~20;50~60' (select multiple channel ranges within IF ID 3)
    spw='3:10~20,4:0~30' (select different channel ranges for IF IDs 3 and 4)
    spw='1~4;6:15~48' (for channels 15 through 48 for IF IDs 1,2,3,4 and 6)
    For multiple MS input, a list of spw strings can be used:
    spw=['0','0~3'] (spw ids 0 for the first MS and 0-3 for the second)
    spw='0~3' (spw ids 0-3 for all input MSes)
    this selection is in addition to the other selections to data
    antenna -- select data by antenna names or IDs
    If antenna string is a non-negative integer, it is
    assumed to be an antenna index, otherwise, it is
    considered an antenna name.
    default: '' (all baselines, i.e. all antenna in case of auto data)
    example: antenna='PM03'
    For multiple MS input, a list of antenna strings can be used:
    antenna=['5','6'] (antenna id5 for the first MS and 6 for the second)
    antenna='5' (antenna index 5 for all input MSes)
    this selection is in addition to the other selections to data
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    For multiple MS input, a list of scan strings can be used:
    scan=['0~100','10~200'] (scan ids 0-100 for the first MS
    and 10-200 for the second)
    scan='0~100 (scan ids 0-100 for all input MSes)
    this selection is in addition to the other selections to data
    intent -- select data by observational intent, also referred to as 'scan intent'
    default: 'OBSERVE_TARGET#ON_SOURCE' (ALMA ON-source intent)
    example: intent='' (use all scan intents)
    intent='*ON_SOURCE*' (any valid scan-intent expression accepted by the MSSelection module can be specified)
    For multiple MS input, a list of scan-intent expressions can be used:
    intent=['ON_SOURCE','CALIBRATE_BANDPASS'] (scan intent ON_SOURCE for the first MS
    and CALIBRATE_BANDPASS for the second)
    this selection is in addition to the other selections to data
    mode -- spectral gridding type
    options: 'channel', 'velocity', 'frequency'
    default: 'channel'
    >>> mode expandable parameters
    nchan -- Total number of channels in the output image.
    default: -1; Automatically selects enough channels to cover
    data selected by 'spw' consistent with 'start' and 'width'.
    It is often easiest to leave nchan at the default value.
    example: nchan=100
    start -- First channel, velocity, or frequency.
    For mode='channel'; This selects the channel index number
    from the MS (0 based) that you want to correspond to the
    first channel of the output cube. The output cube will be
    in frequency space with the first channel having the
    frequency of the MS channel selected by start.  start=0
    refers to the first channel in the first selected spw, even
    if that channel is de-selected in the spw parameter.
    Channels de-selected by the spw parameter will be filled with
    zeros if included by the start parameter. For example,
    spw=3~8:3~100 and start=2 will produce a cube that starts on
    the third channel (recall 0 based) of spw index 3, and the
    first channel will be blank.
    default: '' (the first input channel of first input spw)
    example: start=100 (mode='channel')
    start='22.3GHz' (mode='frequency')
    start='5.0km/s' (mode='velocity')
    width -- Output channel width
    For mode='channel', default=1; width>1 indicates channel averaging
    example: width=4.
    For mode= 'velocity' or 'frequency', default=''; width of
    first input channel, or more precisely, the difference
    in frequencies between the first two selected channels.
    -- For example if channels 1 and 3 are selected with spw,
    then the default width will be the difference between their
    frequencies, and not the width of channel 1.
    -- Similarly, if the selected data has uneven channel-spacing,
    the default width will be picked from the first two selected
    channels. In this case, please specify the desired width.
    When specifying the width, one must give units
    examples: width='1.0km/s', or width='24.2kHz'.
    Setting width>0 gives channels of increasing frequency for
    mode='frequency', and increasing velocity for mode='velocity'.
    veltype -- Velocity definition
    Options: 'radio','optical','true','relativistic'
    default: 'radio'
    outframe -- velocity reference frame of output image
    Options: '','LSRK','LSRD','BARY','GEO','TOPO','GALACTO',
    'LGROUP','CMB'
    default: ''; same as input data or 'LSRK' for multiple-MS inputs
    example: frame='bary' for Barycentric frame
    gridfunction -- gridding function for imaging
    options: 'BOX' (Box-car), 'SF' (Spheroidal),
    'PB' (Primary-beam), 'GAUSS' (Gaussian),
    'GJINC' (Gaussian*Jinc)
    default: 'BOX'
    example: 'SF'
    >>> gridfunction expandable parameter:
    convsupport -- convolution support for 'SF'
    default: -1 (use default for each gridfunction)
    example: 3
    truncate -- truncattion radius of convolution kernel.
    effective only for 'GAUSS' and 'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    gwidth -- HWHM for gaussian. Effective only for
    'GAUSS' and 'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    jwidth -- Width of jinc function. Effective only for
    'GJINC'.
    default: '-1' (use default for each gridfunction)
    example: 3, '20arcsec', '3pixel'
    imsize -- x and y image size in pixels, symmetric for single value
    default: [] (=cover all pointings in MS)
    example: imsize=200 (equivalent to [200,200])
    cell -- x and y cell size. default unit arcmin
    default: '' (= 1/3 of FWHM of primary beam)
    example: cell=['0.2arcmin, 0.2arcmin']
    cell='0.2arcmin' (equivalent to example above)
    phasecenter -- image phase center: direction measure or field ID
    default: '' (= the center of pointing directions in
    POINTING table of infiles)
    example: 6 (field id), 'J2000 13h44m00 -17d02m00',
    'AZEL -123d48m29 15d41m41'
    projection -- map projection type. See Calabretta & Greisen (2002) for detail.
    default: 'SIN'
    options: 'SIN', 'CAR', 'TAN', 'SFL'
    ephemsrcname -- ephemeris source name for moving source (solar sytem objects)
    default: '' (none)
    If specified source name matches one of the solar system
    objects known by CASA (see examples below), the task realigns
    the data by correcting spatial shifts of the source during
    observation, so that the source appears to be fixed in the
    image. If specified name doesn't match, the task will fail.
    When moving source correction is applied, the source is fixed
    to the position at the beginning of the on-source observation
    in the data. Direction reference frame of output image refers
    phasecenter (it is 'J2000' if phasecenter is empty). Note that
    moving source correction is not applied unless the user
    explicitly set ephemsrcname even if target field is one of
    the solar system objects known by CASA. Note also that setting
    'pointing_offset' or 'source_offset' to directioncolumn
    disables moving source correction so that these values should
    not be used when the user wants to activate moving source
    correction.
    examples: 'MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN',
    'URANUS', 'NEPTUNE', 'PLUTO', 'SUN', 'MOON'
    pointingcolumn -- pointing data column to use
    option: 'direction', 'target', 'pointing_offset', 'source_offset', encoder'
    default: 'direction'
    restfreq -- specify rest frequency to use for output image
    default: '' (refer input data)
    example: 1.0e11, '100GHz'
    stokes -- stokes parameters or polarization types to image
    default: '' (use all polarizations)
    example: 'XX'
    minweight -- Minimum weight ratio to the median of weight used in
    weight correction and weight based masking
    default: 0.1
    example: minweight = 0.
    brightnessunit -- Overwrite the brightness unit in image.
    default: '' (use the unit in MS)
    Options: '', 'K' (Kelvin), 'Jy/beam'
    clipminmax -- Clip minimum and maximum value from each pixel.
    Note the benefit of clipping is lost when the number of
    integrations contributing to each gridded pixel is small,
    or where the incidence of spurious datapoints is
    approximately or greater than the number of beams (in area)
    encompassed by expected image.
    default: False
    option: True, False
    interpolation -- Spectral interpolation.
    Interpolation rules to use when binning data channels onto image channels and
    evaluating visibility values at the centers of image channels.
    Note :
    - 'linear' and 'cubic' interpolation requires data points on both sides of each image frequency.
    Errors are therefore possible at edge channels, or near flagged data channels.
    When image channel width is much larger than the data channel width there is nothing much to be gained
    using linear or cubic thus not worth the extra computation involved.
    - If there are significant differences in observing dates of input MSes, some problems merely occur
    in frequency channel matching when 'nearest' interpolation.
    option: 'linear', 'nearest', 'cubic'
    default: 'linear'
    -----------------
    Gridding Kernel
    -----------------
    The parameter gridfunction sets gridding function (convolution kernel)
    for imaging. Currently, the task supports 'BOX' (Box-car), 'SF' (Prolate
    Spheroidal Wave Function), 'GAUSS' (Gaussian), 'GJINC' (Gaussian*Jinc),
    where Jinc(x) = J_1(pi*x/c)/(pi*x/c) with a first order Bessel function
    J_1, and 'PB' (Primary Beam). For 'PB', correct antenna informations
    should be included in input file.
    
    There are four subparameters for gridfunction: convsupport, truncate,
    gwidth, and jwidth. The convsupport is an integer specifying cut-off
    radius for 'SF' in units of pixel. By default (convsupport=-1),
    the cut-off radius is set to 3 pixels. The truncate is a cut-off
    radius for 'GAUSS' or 'GJINC'. It accepts integer, float, and
    string values of numeric plus unit. Allowed units are angular
    units such as 'deg', 'arcmin', 'arcsec', and 'pixel'. Default unit
    is 'pixel' so that string without unit or numerical values (integer
    or float) will be interpreted as radius in pixel. Default value
    for truncate, which is used when negative radius is set, is 3*HWHM
    for 'GAUSS' and radius at first null for 'GJINC'. The gwidth is
    the HWHM of gaussian for 'GAUSS' and 'GJINC'. Default value is
    sqrt(log(2)) pixel for 'GAUSS' and 2.52*sqrt(log(2)) pixel for
    'GJINC'. The jwidth specifies width of the jinc function (parameter
    'c' in the definition above). Default is 1.55 pixel. Both gwidth
    jwidth allows integer, float, or string of numeric plus unit.
    Default values for gwidth and jwidth are taken from Mangum et al.
    (2007). Formula for 'GAUSS' and 'GJINC' are taken from Table 1 in
    the paper, and are written as below using gwidth and jwidth:
    
    GAUSS: exp[-log(2)*(|r|/gwidth)**2]
    
    GJINC: J_1(pi*|r|/jwidth)/(pi*|r|/jwidth)
    * exp[-log(2)*(|r|/gwidth)^2]
    
    
    Reference: Mangum, et al. 2007, A&A, 474, 679-687
    
    --------------------
    Mask in Output Image
    --------------------
    The parameter minweight defines a threshold of weight values
    to mask. The pixels in outfile whose weight is smaller than
    minweight*median(weight) are masked out. The task also creates
    a weight image with the name outfile.weight.
    
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """SD task: imaging for total power and spectral data"""

    __schema = {'infiles': {'type': 'cReqPathVec', 'coerce': [_coerce.to_list,_coerce.expand_pathvec]}, 'outfile': {'type': 'cStr', 'coerce': _coerce.to_str}, 'overwrite': {'type': 'cBool'}, 'field': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'spw': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'antenna': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'scan': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'intent': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'mode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'channel', 'frequency', 'velocity' ]}, 'nchan': {'type': 'cInt'}, 'start': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'width': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'veltype': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'OPTICAL', 'RELATIVISTIC', 'radio', 'true', 'optical', 'RADIO', 'TRUE', 'relativistic' ]}, 'outframe': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'LSRK', 'CMB', 'geo', 'bary', 'GALACTO', 'GEO', 'TOPO', 'LSRD', 'lsrk', 'topo', 'LGROUP', 'BARY', 'lsrd', 'cmb', 'galacto', 'lgroup', '' ]}, 'gridfunction': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'GJINC', 'pb', 'sf', 'GAUSS', 'PB', 'SF', 'gauss', 'BOX', 'box', 'gjinc' ]}, 'convsupport': {'type': 'cInt'}, 'truncate': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'gwidth': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'jwidth': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'imsize': {'anyof': [{'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'cell': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'phasecenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'projection': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'sin', 'SIN', 'SFL', 'CAR', 'sfl', 'car', 'TAN', 'tan' ]}, 'ephemsrcname': {'type': 'cStr', 'coerce': _coerce.to_str}, 'pointingcolumn': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'TARGET', 'encoder', 'ENCODER', 'source_offset', 'pointing_offset', 'target', 'POINTING_OFFSET', 'DIRECTION', 'SOURCE_OFFSET', 'direction' ]}, 'restfreq': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cFloat', 'coerce': _coerce.to_float}]}, 'stokes': {'type': 'cStr', 'coerce': _coerce.to_str}, 'minweight': {'type': 'cFloat', 'coerce': _coerce.to_float, 'min': 0}, 'brightnessunit': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ '', 'K', 'Jy/beam' ]}, 'clipminmax': {'type': 'cBool'}, 'enablecache': {'type': 'cBool'}, 'convertfirst': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'never', 'auto', 'always' ]}, 'interpolation': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'nearest', 'linear', 'cubic' ]}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 14 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __phasecenter_dflt( self, glb ):
        return ''

    def __phasecenter( self, glb ):
        if 'phasecenter' in glb: return glb['phasecenter']
        return ''

    def __projection_dflt( self, glb ):
        return 'SIN'

    def __projection( self, glb ):
        if 'projection' in glb: return glb['projection']
        return 'SIN'

    def __gridfunction_dflt( self, glb ):
        return 'BOX'

    def __gridfunction( self, glb ):
        if 'gridfunction' in glb: return glb['gridfunction']
        return 'BOX'

    def __clipminmax_dflt( self, glb ):
        return False

    def __clipminmax( self, glb ):
        if 'clipminmax' in glb: return glb['clipminmax']
        return False

    def __enablecache_dflt( self, glb ):
        return True

    def __enablecache( self, glb ):
        if 'enablecache' in glb: return glb['enablecache']
        return True

    def __pointingcolumn_dflt( self, glb ):
        return 'direction'

    def __pointingcolumn( self, glb ):
        if 'pointingcolumn' in glb: return glb['pointingcolumn']
        return 'direction'

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __outframe_dflt( self, glb ):
        return ''

    def __outframe( self, glb ):
        if 'outframe' in glb: return glb['outframe']
        return ''

    def __convertfirst_dflt( self, glb ):
        return 'never'

    def __convertfirst( self, glb ):
        if 'convertfirst' in glb: return glb['convertfirst']
        return 'never'

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __cell_dflt( self, glb ):
        return ''

    def __cell( self, glb ):
        if 'cell' in glb: return glb['cell']
        return ''

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __restfreq_dflt( self, glb ):
        return ''

    def __restfreq( self, glb ):
        if 'restfreq' in glb: return glb['restfreq']
        return ''

    def __interpolation_dflt( self, glb ):
        return 'linear'

    def __interpolation( self, glb ):
        if 'interpolation' in glb: return glb['interpolation']
        return 'linear'

    def __brightnessunit_dflt( self, glb ):
        return ''

    def __brightnessunit( self, glb ):
        if 'brightnessunit' in glb: return glb['brightnessunit']
        return ''

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __imsize_dflt( self, glb ):
        return [  ]

    def __imsize( self, glb ):
        if 'imsize' in glb: return glb['imsize']
        return [  ]

    def __ephemsrcname_dflt( self, glb ):
        return ''

    def __ephemsrcname( self, glb ):
        if 'ephemsrcname' in glb: return glb['ephemsrcname']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __stokes_dflt( self, glb ):
        return ''

    def __stokes( self, glb ):
        if 'stokes' in glb: return glb['stokes']
        return ''

    def __mode_dflt( self, glb ):
        return 'channel'

    def __mode( self, glb ):
        if 'mode' in glb: return glb['mode']
        return 'channel'

    def __minweight_dflt( self, glb ):
        return float(0.1)

    def __minweight( self, glb ):
        if 'minweight' in glb: return glb['minweight']
        return float(0.1)

    def __infiles_dflt( self, glb ):
        return [  ]

    def __infiles( self, glb ):
        if 'infiles' in glb: return glb['infiles']
        return [  ]

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False

    def __intent_dflt( self, glb ):
        return 'OBSERVE_TARGET#ON_SOURCE'

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return 'OBSERVE_TARGET#ON_SOURCE'



    #--------- return inp/go default --------------------------------------------------
    def __convsupport_dflt( self, glb ):
        if self.__gridfunction( glb ) == "SF": return int(-1)
        if self.__gridfunction( glb ) == "sf": return int(-1)
        return None
    def __nchan_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return int(-1)
        if self.__mode( glb ) == "frequency": return int(-1)
        if self.__mode( glb ) == "velocity": return int(-1)
        return None
    def __truncate_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GAUSS": return -1
        if self.__gridfunction( glb ) == "gauss": return -1
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __gwidth_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GAUSS": return -1
        if self.__gridfunction( glb ) == "gauss": return -1
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __veltype_dflt( self, glb ):
        if self.__mode( glb ) == "velocity": return "radio"
        return None
    def __jwidth_dflt( self, glb ):
        if self.__gridfunction( glb ) == "GJINC": return -1
        if self.__gridfunction( glb ) == "gjinc": return -1
        return None
    def __start_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return ""
        if self.__mode( glb ) == "frequency": return ""
        if self.__mode( glb ) == "velocity": return ""
        return None
    def __width_dflt( self, glb ):
        if self.__mode( glb ) == "channel": return ""
        if self.__mode( glb ) == "frequency": return ""
        if self.__mode( glb ) == "velocity": return ""
        return None

    #--------- return subparam values -------------------------------------------------
    def __nchan( self, glb ):
        if 'nchan' in glb: return glb['nchan']
        dflt = self.__nchan_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __start( self, glb ):
        if 'start' in glb: return glb['start']
        dflt = self.__start_dflt( glb )
        if dflt is not None: return dflt
        return int(0)
    def __width( self, glb ):
        if 'width' in glb: return glb['width']
        dflt = self.__width_dflt( glb )
        if dflt is not None: return dflt
        return int(1)
    def __veltype( self, glb ):
        if 'veltype' in glb: return glb['veltype']
        dflt = self.__veltype_dflt( glb )
        if dflt is not None: return dflt
        return 'radio'
    def __convsupport( self, glb ):
        if 'convsupport' in glb: return glb['convsupport']
        dflt = self.__convsupport_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __truncate( self, glb ):
        if 'truncate' in glb: return glb['truncate']
        dflt = self.__truncate_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __gwidth( self, glb ):
        if 'gwidth' in glb: return glb['gwidth']
        dflt = self.__gwidth_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __jwidth( self, glb ):
        if 'jwidth' in glb: return glb['jwidth']
        dflt = self.__jwidth_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)

    #--------- subparam inp output ----------------------------------------------------
    def __infiles_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__infiles_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'a list of names of input SD Measurementsets (only MS is allowed for this task)'
        value = self.__infiles( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'infiles': value},{'infiles': self.__schema['infiles']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('infiles',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __outfile_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outfile_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'name of output image'
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('outfile',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __overwrite_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__overwrite_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'overwrite the output file if already exists [True, False]'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('overwrite',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by field IDs and names, e.g. "3C2*" (""=all)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by IF IDs (spectral windows), e.g. "3,5,7" (""=all)'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by antenna names or IDs, e.g, "PM03" ("" = all antennas)'
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by scan numbers, e.g. "21~23" (""=all)'
        value = self.__scan( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'OBSERVE_TARGET#ON_SOURCE'
        description = 'select data by observational intent, e.g. "*ON_SOURCE*" (""=all)'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __mode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__mode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'channel'
        description = 'spectral gridding type ["channel", "frequency", "velocity"]'
        value = self.__mode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'mode': value},{'mode': self.__schema['mode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('mode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __nchan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__nchan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__nchan_dflt( self.__globals_( ) ) is not None:
             description = 'number of channels (planes) in output image (-1=all)'
             value = self.__nchan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'nchan': value},{'nchan': self.__schema['nchan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('nchan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __start_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__start_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(0)
        if self.__start_dflt( self.__globals_( ) ) is not None:
             description = 'start of output spectral dimension, e.g. "0", "110GHz", "-20km/s"'
             value = self.__start( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'start': value},{'start': self.__schema['start']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('start',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __width_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__width_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(1)
        if self.__width_dflt( self.__globals_( ) ) is not None:
             description = 'width of output spectral channels'
             value = self.__width( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'width': value},{'width': self.__schema['width']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('width',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __veltype_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__veltype_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'radio'
        if self.__veltype_dflt( self.__globals_( ) ) is not None:
             description = 'velocity definition ["radio", "optical", "true" or "relativistic"]'
             value = self.__veltype( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'veltype': value},{'veltype': self.__schema['veltype']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('veltype',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __outframe_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outframe_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'velocity frame of output image ["lsrk", "lsrd", "bary", "geo", "topo", "galacto", "lgroup", "cmb"] (""=current frame or LSRK for multiple-MS inputs)'
        value = self.__outframe( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outframe': value},{'outframe': self.__schema['outframe']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('outframe',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __gridfunction_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gridfunction_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'BOX'
        description = 'gridding function for imaging ["BOX", "SF", "PB", "GAUSS" or "GJINC"] (see description in help)'
        value = self.__gridfunction( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gridfunction': value},{'gridfunction': self.__schema['gridfunction']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('gridfunction',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __convsupport_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__convsupport_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__convsupport_dflt( self.__globals_( ) ) is not None:
             description = 'convolution support for gridding'
             value = self.__convsupport( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'convsupport': value},{'convsupport': self.__schema['convsupport']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('convsupport',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __truncate_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__truncate_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__truncate_dflt( self.__globals_( ) ) is not None:
             description = 'truncation radius for gridding'
             value = self.__truncate( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'truncate': value},{'truncate': self.__schema['truncate']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('truncate',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __gwidth_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gwidth_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__gwidth_dflt( self.__globals_( ) ) is not None:
             description = 'HWHM for gaussian'
             value = self.__gwidth( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gwidth': value},{'gwidth': self.__schema['gwidth']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('gwidth',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __jwidth_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__jwidth_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__jwidth_dflt( self.__globals_( ) ) is not None:
             description = 'c-parameter for jinc function'
             value = self.__jwidth( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'jwidth': value},{'jwidth': self.__schema['jwidth']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('jwidth',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __imsize_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__imsize_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'x and y image size in pixels, e.g., [64,64]. Single value: same for both spatial axes ([] = number of pixels to cover whole pointings in MSes)'
        value = self.__imsize( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'imsize': value},{'imsize': self.__schema['imsize']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('imsize',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __cell_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__cell_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'x and y cell size, (e.g., ["8arcsec","8arcsec"]. default unit arcmin. ("" = 1/3 of FWHM of primary beam)'
        value = self.__cell( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'cell': value},{'cell': self.__schema['cell']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('cell',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __phasecenter_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__phasecenter_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'image center direction: position or field index, e.g., "J2000 17:30:15.0 -25.30.00.0". ("" = the center of pointing directions in MSes)'
        value = self.__phasecenter( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'phasecenter': value},{'phasecenter': self.__schema['phasecenter']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('phasecenter',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __projection_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__projection_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'SIN'
        description = 'map projection type'
        value = self.__projection( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'projection': value},{'projection': self.__schema['projection']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('projection',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __ephemsrcname_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__ephemsrcname_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'ephemeris source name, e.g. "MARS"'
        value = self.__ephemsrcname( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'ephemsrcname': value},{'ephemsrcname': self.__schema['ephemsrcname']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('ephemsrcname',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __pointingcolumn_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__pointingcolumn_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'direction'
        description = 'pointing data column to use ["direction", "target", "pointing_offset", "source_offset" or "encoder"]'
        value = self.__pointingcolumn( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'pointingcolumn': value},{'pointingcolumn': self.__schema['pointingcolumn']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('pointingcolumn',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __restfreq_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__restfreq_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'rest frequency to assign to image, e.g., "114.5GHz"'
        value = self.__restfreq( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'restfreq': value},{'restfreq': self.__schema['restfreq']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('restfreq',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __stokes_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__stokes_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'stokes parameters or polarization types to image, e.g. "I", "XX"'
        value = self.__stokes( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'stokes': value},{'stokes': self.__schema['stokes']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('stokes',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __minweight_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minweight_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.1)
        description = 'Minimum weight ratio to use'
        value = self.__minweight( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minweight': value},{'minweight': self.__schema['minweight']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('minweight',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __brightnessunit_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__brightnessunit_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Overwrite the brightness unit in image (\'\' = respect the unit in MS) [\'K\' or \'Jy/beam\']'
        value = self.__brightnessunit( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'brightnessunit': value},{'brightnessunit': self.__schema['brightnessunit']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('brightnessunit',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __clipminmax_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__clipminmax_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Clip minimum and maximum value from each pixel'
        value = self.__clipminmax( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'clipminmax': value},{'clipminmax': self.__schema['clipminmax']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('clipminmax',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __enablecache_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__enablecache_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Cache spectra pixels coordinates computed while creating the normal image, and re-use them when creating the weight image.'
        value = self.__enablecache( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'enablecache': value},{'enablecache': self.__schema['enablecache']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('enablecache',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __convertfirst_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__convertfirst_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'never'
        description = 'pointing column: direction conversion-interpolation processing scheme to use ["never", "auto", "always"]'
        value = self.__convertfirst( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'convertfirst': value},{'convertfirst': self.__schema['convertfirst']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('convertfirst',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __interpolation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interpolation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'linear'
        description = 'Spectral interpolation ["nearest", "linear", "cubic"]'
        value = self.__interpolation( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interpolation': value},{'interpolation': self.__schema['interpolation']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('interpolation',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'brightnessunit' in glb: del glb['brightnessunit']
        if 'stokes' in glb: del glb['stokes']
        if 'outfile' in glb: del glb['outfile']
        if 'field' in glb: del glb['field']
        if 'convsupport' in glb: del glb['convsupport']
        if 'projection' in glb: del glb['projection']
        if 'intent' in glb: del glb['intent']
        if 'interpolation' in glb: del glb['interpolation']
        if 'nchan' in glb: del glb['nchan']
        if 'convertfirst' in glb: del glb['convertfirst']
        if 'pointingcolumn' in glb: del glb['pointingcolumn']
        if 'truncate' in glb: del glb['truncate']
        if 'imsize' in glb: del glb['imsize']
        if 'scan' in glb: del glb['scan']
        if 'enablecache' in glb: del glb['enablecache']
        if 'gwidth' in glb: del glb['gwidth']
        if 'restfreq' in glb: del glb['restfreq']
        if 'clipminmax' in glb: del glb['clipminmax']
        if 'veltype' in glb: del glb['veltype']
        if 'outframe' in glb: del glb['outframe']
        if 'mode' in glb: del glb['mode']
        if 'cell' in glb: del glb['cell']
        if 'phasecenter' in glb: del glb['phasecenter']
        if 'overwrite' in glb: del glb['overwrite']
        if 'minweight' in glb: del glb['minweight']
        if 'ephemsrcname' in glb: del glb['ephemsrcname']
        if 'jwidth' in glb: del glb['jwidth']
        if 'start' in glb: del glb['start']
        if 'gridfunction' in glb: del glb['gridfunction']
        if 'width' in glb: del glb['width']
        if 'spw' in glb: del glb['spw']
        if 'infiles' in glb: del glb['infiles']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# sdimaging -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__infiles_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__antenna_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__mode_inp( )
        self.__nchan_inp( )
        self.__start_inp( )
        self.__width_inp( )
        self.__veltype_inp( )
        self.__outframe_inp( )
        self.__gridfunction_inp( )
        self.__convsupport_inp( )
        self.__truncate_inp( )
        self.__gwidth_inp( )
        self.__jwidth_inp( )
        self.__imsize_inp( )
        self.__cell_inp( )
        self.__phasecenter_inp( )
        self.__projection_inp( )
        self.__ephemsrcname_inp( )
        self.__pointingcolumn_inp( )
        self.__restfreq_inp( )
        self.__stokes_inp( )
        self.__minweight_inp( )
        self.__brightnessunit_inp( )
        self.__clipminmax_inp( )
        self.__enablecache_inp( )
        self.__convertfirst_inp( )
        self.__interpolation_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "sdimaging.last" if os.path.isfile("sdimaging.last") else "sdimaging.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('sdimaging.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['infiles'] = self.__infiles( self.__globals_( ) )
        _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
        _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
        _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
        _invocation_parameters['start'] = self.__start( self.__globals_( ) )
        _invocation_parameters['width'] = self.__width( self.__globals_( ) )
        _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
        _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
        _invocation_parameters['gridfunction'] = self.__gridfunction( self.__globals_( ) )
        _invocation_parameters['convsupport'] = self.__convsupport( self.__globals_( ) )
        _invocation_parameters['truncate'] = self.__truncate( self.__globals_( ) )
        _invocation_parameters['gwidth'] = self.__gwidth( self.__globals_( ) )
        _invocation_parameters['jwidth'] = self.__jwidth( self.__globals_( ) )
        _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
        _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
        _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
        _invocation_parameters['projection'] = self.__projection( self.__globals_( ) )
        _invocation_parameters['ephemsrcname'] = self.__ephemsrcname( self.__globals_( ) )
        _invocation_parameters['pointingcolumn'] = self.__pointingcolumn( self.__globals_( ) )
        _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )
        _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
        _invocation_parameters['minweight'] = self.__minweight( self.__globals_( ) )
        _invocation_parameters['brightnessunit'] = self.__brightnessunit( self.__globals_( ) )
        _invocation_parameters['clipminmax'] = self.__clipminmax( self.__globals_( ) )
        _invocation_parameters['enablecache'] = self.__enablecache( self.__globals_( ) )
        _invocation_parameters['convertfirst'] = self.__convertfirst( self.__globals_( ) )
        _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-14s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdimaging( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, infiles=None, outfile=None, overwrite=None, field=None, spw=None, antenna=None, scan=None, intent=None, mode=None, nchan=None, start=None, width=None, veltype=None, outframe=None, gridfunction=None, convsupport=None, truncate=None, gwidth=None, jwidth=None, imsize=None, cell=None, phasecenter=None, projection=None, ephemsrcname=None, pointingcolumn=None, restfreq=None, stokes=None, minweight=None, brightnessunit=None, clipminmax=None, enablecache=None, convertfirst=None, interpolation=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('sdimaging.pre')
        _postfile = os.path.realpath('sdimaging.last')
        task_result = None
        _arguments = [infiles,outfile,overwrite,field,spw,antenna,scan,intent,mode,nchan,start,width,veltype,outframe,gridfunction,convsupport,truncate,gwidth,jwidth,imsize,cell,phasecenter,projection,ephemsrcname,pointingcolumn,restfreq,stokes,minweight,brightnessunit,clipminmax,enablecache,convertfirst,interpolation]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infiles is not None: local_global['infiles'] = infiles
            if outfile is not None: local_global['outfile'] = outfile
            if overwrite is not None: local_global['overwrite'] = overwrite
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if antenna is not None: local_global['antenna'] = antenna
            if scan is not None: local_global['scan'] = scan
            if intent is not None: local_global['intent'] = intent
            if mode is not None: local_global['mode'] = mode
            if outframe is not None: local_global['outframe'] = outframe
            if gridfunction is not None: local_global['gridfunction'] = gridfunction
            if imsize is not None: local_global['imsize'] = imsize
            if cell is not None: local_global['cell'] = cell
            if phasecenter is not None: local_global['phasecenter'] = phasecenter
            if projection is not None: local_global['projection'] = projection
            if ephemsrcname is not None: local_global['ephemsrcname'] = ephemsrcname
            if pointingcolumn is not None: local_global['pointingcolumn'] = pointingcolumn
            if restfreq is not None: local_global['restfreq'] = restfreq
            if stokes is not None: local_global['stokes'] = stokes
            if minweight is not None: local_global['minweight'] = minweight
            if brightnessunit is not None: local_global['brightnessunit'] = brightnessunit
            if clipminmax is not None: local_global['clipminmax'] = clipminmax
            if enablecache is not None: local_global['enablecache'] = enablecache
            if convertfirst is not None: local_global['convertfirst'] = convertfirst
            if interpolation is not None: local_global['interpolation'] = interpolation

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infiles'] = self.__infiles( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['mode'] = self.__mode( local_global )
            _invocation_parameters['outframe'] = self.__outframe( local_global )
            _invocation_parameters['gridfunction'] = self.__gridfunction( local_global )
            _invocation_parameters['imsize'] = self.__imsize( local_global )
            _invocation_parameters['cell'] = self.__cell( local_global )
            _invocation_parameters['phasecenter'] = self.__phasecenter( local_global )
            _invocation_parameters['projection'] = self.__projection( local_global )
            _invocation_parameters['ephemsrcname'] = self.__ephemsrcname( local_global )
            _invocation_parameters['pointingcolumn'] = self.__pointingcolumn( local_global )
            _invocation_parameters['restfreq'] = self.__restfreq( local_global )
            _invocation_parameters['stokes'] = self.__stokes( local_global )
            _invocation_parameters['minweight'] = self.__minweight( local_global )
            _invocation_parameters['brightnessunit'] = self.__brightnessunit( local_global )
            _invocation_parameters['clipminmax'] = self.__clipminmax( local_global )
            _invocation_parameters['enablecache'] = self.__enablecache( local_global )
            _invocation_parameters['convertfirst'] = self.__convertfirst( local_global )
            _invocation_parameters['interpolation'] = self.__interpolation( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['nchan'] = self.__nchan( _invocation_parameters ) if nchan is None else nchan
            _invocation_parameters['start'] = self.__start( _invocation_parameters ) if start is None else start
            _invocation_parameters['width'] = self.__width( _invocation_parameters ) if width is None else width
            _invocation_parameters['veltype'] = self.__veltype( _invocation_parameters ) if veltype is None else veltype
            _invocation_parameters['convsupport'] = self.__convsupport( _invocation_parameters ) if convsupport is None else convsupport
            _invocation_parameters['truncate'] = self.__truncate( _invocation_parameters ) if truncate is None else truncate
            _invocation_parameters['gwidth'] = self.__gwidth( _invocation_parameters ) if gwidth is None else gwidth
            _invocation_parameters['jwidth'] = self.__jwidth( _invocation_parameters ) if jwidth is None else jwidth

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infiles'] = self.__infiles( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['mode'] = self.__mode( self.__globals_( ) )
            _invocation_parameters['nchan'] = self.__nchan( self.__globals_( ) )
            _invocation_parameters['start'] = self.__start( self.__globals_( ) )
            _invocation_parameters['width'] = self.__width( self.__globals_( ) )
            _invocation_parameters['veltype'] = self.__veltype( self.__globals_( ) )
            _invocation_parameters['outframe'] = self.__outframe( self.__globals_( ) )
            _invocation_parameters['gridfunction'] = self.__gridfunction( self.__globals_( ) )
            _invocation_parameters['convsupport'] = self.__convsupport( self.__globals_( ) )
            _invocation_parameters['truncate'] = self.__truncate( self.__globals_( ) )
            _invocation_parameters['gwidth'] = self.__gwidth( self.__globals_( ) )
            _invocation_parameters['jwidth'] = self.__jwidth( self.__globals_( ) )
            _invocation_parameters['imsize'] = self.__imsize( self.__globals_( ) )
            _invocation_parameters['cell'] = self.__cell( self.__globals_( ) )
            _invocation_parameters['phasecenter'] = self.__phasecenter( self.__globals_( ) )
            _invocation_parameters['projection'] = self.__projection( self.__globals_( ) )
            _invocation_parameters['ephemsrcname'] = self.__ephemsrcname( self.__globals_( ) )
            _invocation_parameters['pointingcolumn'] = self.__pointingcolumn( self.__globals_( ) )
            _invocation_parameters['restfreq'] = self.__restfreq( self.__globals_( ) )
            _invocation_parameters['stokes'] = self.__stokes( self.__globals_( ) )
            _invocation_parameters['minweight'] = self.__minweight( self.__globals_( ) )
            _invocation_parameters['brightnessunit'] = self.__brightnessunit( self.__globals_( ) )
            _invocation_parameters['clipminmax'] = self.__clipminmax( self.__globals_( ) )
            _invocation_parameters['enablecache'] = self.__enablecache( self.__globals_( ) )
            _invocation_parameters['convertfirst'] = self.__convertfirst( self.__globals_( ) )
            _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-14s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdimaging( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'sdimaging', [ 'infiles=' + repr(_pc.document['infiles']), 'outfile=' + repr(_pc.document['outfile']), 'overwrite=' + repr(_pc.document['overwrite']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'antenna=' + repr(_pc.document['antenna']), 'scan=' + repr(_pc.document['scan']), 'intent=' + repr(_pc.document['intent']), 'mode=' + repr(_pc.document['mode']), 'nchan=' + repr(_pc.document['nchan']), 'start=' + repr(_pc.document['start']), 'width=' + repr(_pc.document['width']), 'veltype=' + repr(_pc.document['veltype']), 'outframe=' + repr(_pc.document['outframe']), 'gridfunction=' + repr(_pc.document['gridfunction']), 'convsupport=' + repr(_pc.document['convsupport']), 'truncate=' + repr(_pc.document['truncate']), 'gwidth=' + repr(_pc.document['gwidth']), 'jwidth=' + repr(_pc.document['jwidth']), 'imsize=' + repr(_pc.document['imsize']), 'cell=' + repr(_pc.document['cell']), 'phasecenter=' + repr(_pc.document['phasecenter']), 'projection=' + repr(_pc.document['projection']), 'ephemsrcname=' + repr(_pc.document['ephemsrcname']), 'pointingcolumn=' + repr(_pc.document['pointingcolumn']), 'restfreq=' + repr(_pc.document['restfreq']), 'stokes=' + repr(_pc.document['stokes']), 'minweight=' + repr(_pc.document['minweight']), 'brightnessunit=' + repr(_pc.document['brightnessunit']), 'clipminmax=' + repr(_pc.document['clipminmax']), 'enablecache=' + repr(_pc.document['enablecache']), 'convertfirst=' + repr(_pc.document['convertfirst']), 'interpolation=' + repr(_pc.document['interpolation']) ] )
            task_result = _sdimaging_t( _pc.document['infiles'],_pc.document['outfile'],_pc.document['overwrite'],_pc.document['field'],_pc.document['spw'],_pc.document['antenna'],_pc.document['scan'],_pc.document['intent'],_pc.document['mode'],_pc.document['nchan'],_pc.document['start'],_pc.document['width'],_pc.document['veltype'],_pc.document['outframe'],_pc.document['gridfunction'],_pc.document['convsupport'],_pc.document['truncate'],_pc.document['gwidth'],_pc.document['jwidth'],_pc.document['imsize'],_pc.document['cell'],_pc.document['phasecenter'],_pc.document['projection'],_pc.document['ephemsrcname'],_pc.document['pointingcolumn'],_pc.document['restfreq'],_pc.document['stokes'],_pc.document['minweight'],_pc.document['brightnessunit'],_pc.document['clipminmax'],_pc.document['enablecache'],_pc.document['convertfirst'],_pc.document['interpolation'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('sdimaging')
            casalog.post("Exception Reported: Error in sdimaging: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'sdimaging', task_result )

        #Added if _sdimaging_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

sdimaging = _sdimaging( )

