##################### generated by xml-casa (v2) from fringefit.xml #################
##################### ecd6425606a9aacdde09aa33346a9406 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_fringefit import fringefit as _fringefit_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _fringefit:
    """
    fringefit ---- Fringe fit delay and rates

    
    Phase offsets, groups delays and delay rates are calculated with
    respect to a specified referance antenna by a two-dimensional FFT and
    subsequent least-squares optimisation.
    
    Previous calibrations should be applied on the fly.

    --------- parameter descriptions ---------------------------------------------

    vis          Name of input visibility file
    caltable     Name of output gain calibration table
    field        Select field using field id(s) or field name(s)
    spw          Select spectral window/channels
    intent       Select observing intent
    selectdata   Other data selection parameters
    timerange    Select data based on time range
    uvrange      Select data by baseline length.
                 Default = '' (all)
                 
                    Examples:
                    uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
                    uvrange='>4klambda';uvranges greater than 4 kilo-lambda
                    uvrange='0~1000km'; uvrange in kilometers
    antenna      Select data based on antenna/baseline
    scan         Scan number range
    observation  Select by observation ID(s)
    msselect     Optional complex data selection (ignore for now)
    solint       Solution interval: egs. \'inf\', \'60s\' (see help)
    combine      Data axes which to combine for solve (obs, scan, spw, and/or field)
    refant       Reference antenna name(s)
    minsnr       Reject solutions below this signal-to-noise ratio (at the FFT stage)
    zerorates    Zero delay-rates in solution table
                 
                     Write a solution table with delay-rates zeroed, for the case of
                 "manual phase calibration", so that the calibration table can be
                 applied to the full dataset without the extrapolation of a non-zero delay-rate term
                 affecting the data
    globalsolve  Refine estimates of delay and rate with global least-squares solver
    niter        Maximum number of iterations for least-squares solver
    delaywindow  Constrain FFT delay search to a window specified as a two-element list with units of nanoseconds
                 Default: [None, None]
                 Examples: [-10, 10]
    ratewindow   Constrain FFT rate search to a window specified as a two-element list with units of seconds per second
                 Default: [None, None]
                 Examples: [-1e-13, 1e-13]
    append       Append solutions to the (existing) table
                 Default: False (overwrite existing table or make
                 new table)
                 
                 Appended solutions must be derived from the same
                 MS as the existing caltable, and solution spws
                 must have the same meta-info (according to spw
                 selection and solint) or be non-overlapping.
    corrdepflags Respect correlation-dependent flags:
                      If False (default), if any correlation is flagged,
                        treat all correlations in the visibility vector as flagged
                        when solving (per channel, per baseline).
                      If True, use unflagged correlations in a visibility vector,
                 	 even if one or more other correlations are flagged.
                             
                     Default: False (treat correlation vectors with one or more
                       correlations flagged as entirely flagged)
                 
                       Traditionally, CASA has observed a strict interpretation of 
                       correlation-dependent flags: if one or more correlations 
                       (for any baseline and channel) is flagged, then all available 
                       correlations for the same baseline and channel are 
                       treated as flagged.  However, it is desirable in some 
                       circumstances to relax this stricture, e.g., to preserve use
                       of data from antennas with only one good polarization (e.g., one polarization
                       is bad or entirely absent).  Solutions for the bad or missing polarization 
                       will be rendered as flagged.
    corrcomb     Combine correlations (use with corrdepflags=True):
                 If corrcomb="stokes", the parallel-hand correlations (if both
                   are unflagged) will be combined formally (unweighted) to form Stokes I,
                   with a net weight properly propagated from the correlatio
                   weights.
                 If corrcomb="parallel", the parallel-hand correlations (if
                   either unflagged) will be combined with a weighted average,
                   thereby optimizing net sensitivity for unpolarized sources.
                   If either parallel-hand correlation is flagged, its weight in
                   this average will be zero.  This mode permits combining
                   correlations without flagging single-pol antennas completely.
                 If corrcomb="none" (default), correlations will not be combined.
    docallib     Control means of specifying the caltables
                 Default: False (Use gaintable, gainfield, interp,
                 spwmap, calwt)
                 Options: False|True
                 
                 If True, specify a file containing cal library in
                 callib
    callib       Specify a file containing cal library directives
                 Subparameter of docallib=True
    gaintable    Gain calibration table(s) to apply on the fly
                 Default: '' (none)
                 Subparameter of docallib=False
                 Examples: 
                 gaintable='ngc5921.gcal'
                 gaintable=['ngc5921.ampcal','ngc5921.phcal']
    gainfield    Select a subset of calibrators from gaintable(s)
                 Default: '' (all sources on the sky)
                 
                 'nearest' ==> nearest (on sky) available field in
                 table otherwise, same syntax as field
                 
                 Examples: 
                 gainfield='0~2,5' means use fields 0,1,2,5
                 from gaintable
                 gainfield=['0~3','4~6'] means use field 0
                 through 3
    interp       Interpolation parameters (in time[,freq]) for each gaintable, as a list of strings.
                 Default: '' --> 'linear,linear' for all gaintable(s)
                 Options: Time: 'nearest', 'linear'
                 Freq: 'nearest', 'linear', 'cubic',
                 'spline'
                 Specify a list of strings, aligned with the list of caltable specified
                 in gaintable, that contain the required interpolation parameters
                 for each caltable.
                 * When frequency interpolation is relevant (B, Df,
                 Xf), separate time-dependent and freq-dependent
                 interp types with a comma (freq after the
                 comma). 
                 * Specifications for frequency are ignored when the
                 calibration table has no channel-dependence. 
                 * Time-dependent interp options ending in 'PD'
                 enable a "phase delay" correction per spw for
                 non-channel-dependent calibration types.
                 * For multi-obsId datasets, 'perobs' can be
                 appended to the time-dependent interpolation
                 specification to enforce obsId boundaries when
                 interpolating in time. 
                 * For multi-scan datasets, 'perscan' can be
                 appended to the time-dependent interpolation
                 specification to enforce scan boundaries when
                 interpolating in time. 
                 * Freq-dependent interp options can have 'flag' appended
                 to enforce channel-dependent flagging, and/or 'rel' 
                 appended to invoke relative frequency interpolation
                 
                 Examples: 
                 interp='nearest' (in time, freq-dep will be
                 linear, if relevant)
                 interp='linear,cubic'  (linear in time, cubic
                 in freq)
                 interp='linearperobs,splineflag' (linear in
                 time per obsId, spline in freq with
                 channelized flagging)
                 interp='nearest,linearflagrel' (nearest in
                 time, linear in freq with with channelized 
                 flagging and relative-frequency interpolation)
                 interp=',spline'  (spline in freq; linear in
                 time by default)
                 interp=['nearest,spline','linear']  (for
                 multiple gaintables)
    spwmap       Spectral window mappings to form for gaintable(s)
                 Only used if callib=False
                 default: [] (apply solutions from each calibration spw to
                 the same MS spw only)
                 Any available calibration spw can be mechanically mapped to any 
                  MS spw. 
                 Examples:
                    spwmap=[0,0,1,1] means apply calibration 
                      from cal spw = 0 to MS spw 0,1 and cal spw 1 to MS spws 2,3.
                    spwmap=[[0,0,1,1],[0,1,0,1]] (use a list of lists for multiple
                      gaintables)
    paramactive  Control which parameters are solved for; a vector of (exactly) three booleans for delay, delay-rate and dispersive delay (in that order)
    concatspws   For combine='spw', the multi-band FFT solution can be
                 done in two different ways.  For concatspws=True (the default), spws are
                 combined onto a wider frequency grid.  For concatspws=False, each
                 spw is separated FFT'd, and the results are combined using the
                 shift theorem; this mode is experimental.
    parang       Apply parallactic angle correction on the fly.

    --------- examples -----------------------------------------------------------

    
    For more information, see the task pages for fringefit in CASA Docs:
    
    https://casa.nrao.edu/casadocs/


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Fringe fit delay and rates"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'caltable': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'intent': {'type': 'cStr', 'coerce': _coerce.to_str}, 'selectdata': {'type': 'cBool'}, 'timerange': {'type': 'cStr', 'coerce': _coerce.to_str}, 'uvrange': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'antenna': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scan': {'type': 'cStr', 'coerce': _coerce.to_str}, 'observation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'msselect': {'type': 'cStr', 'coerce': _coerce.to_str}, 'solint': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'combine': {'type': 'cStr', 'coerce': _coerce.to_str}, 'refant': {'type': 'cStr', 'coerce': _coerce.to_str}, 'minsnr': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'zerorates': {'type': 'cBool'}, 'globalsolve': {'type': 'cBool'}, 'niter': {'type': 'cInt'}, 'delaywindow': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'ratewindow': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'append': {'type': 'cBool'}, 'corrdepflags': {'type': 'cBool'}, 'corrcomb': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'none', 'stokes', 'parallel' ]}, 'docallib': {'type': 'cBool'}, 'callib': {'type': 'cStr', 'coerce': _coerce.to_str}, 'gaintable': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'gainfield': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'interp': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'spwmap': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'paramactive': {'type': 'cBoolVec', 'coerce': [_coerce.to_list,_coerce.to_boolvec]}, 'concatspws': {'type': 'cBool'}, 'parang': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 14 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __solint_dflt( self, glb ):
        return 'inf'

    def __solint( self, glb ):
        if 'solint' in glb: return glb['solint']
        return 'inf'

    def __parang_dflt( self, glb ):
        return False

    def __parang( self, glb ):
        if 'parang' in glb: return glb['parang']
        return False

    def __combine_dflt( self, glb ):
        return ''

    def __combine( self, glb ):
        if 'combine' in glb: return glb['combine']
        return ''

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __caltable_dflt( self, glb ):
        return ''

    def __caltable( self, glb ):
        if 'caltable' in glb: return glb['caltable']
        return ''

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __ratewindow_dflt( self, glb ):
        return [  ]

    def __ratewindow( self, glb ):
        if 'ratewindow' in glb: return glb['ratewindow']
        return [  ]

    def __zerorates_dflt( self, glb ):
        return False

    def __zerorates( self, glb ):
        if 'zerorates' in glb: return glb['zerorates']
        return False

    def __globalsolve_dflt( self, glb ):
        return True

    def __globalsolve( self, glb ):
        if 'globalsolve' in glb: return glb['globalsolve']
        return True

    def __refant_dflt( self, glb ):
        return ''

    def __refant( self, glb ):
        if 'refant' in glb: return glb['refant']
        return ''

    def __uvrange_dflt( self, glb ):
        return ''

    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        return ''

    def __selectdata_dflt( self, glb ):
        return True

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return True

    def __delaywindow_dflt( self, glb ):
        return [  ]

    def __delaywindow( self, glb ):
        if 'delaywindow' in glb: return glb['delaywindow']
        return [  ]

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __minsnr_dflt( self, glb ):
        return float(3.0)

    def __minsnr( self, glb ):
        if 'minsnr' in glb: return glb['minsnr']
        return float(3.0)

    def __append_dflt( self, glb ):
        return False

    def __append( self, glb ):
        if 'append' in glb: return glb['append']
        return False

    def __niter_dflt( self, glb ):
        return int(100)

    def __niter( self, glb ):
        if 'niter' in glb: return glb['niter']
        return int(100)

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __corrcomb_dflt( self, glb ):
        return 'none'

    def __corrcomb( self, glb ):
        if 'corrcomb' in glb: return glb['corrcomb']
        return 'none'

    def __paramactive_dflt( self, glb ):
        return [  ]

    def __paramactive( self, glb ):
        if 'paramactive' in glb: return glb['paramactive']
        return [  ]

    def __docallib_dflt( self, glb ):
        return False

    def __docallib( self, glb ):
        if 'docallib' in glb: return glb['docallib']
        return False

    def __concatspws_dflt( self, glb ):
        return True

    def __concatspws( self, glb ):
        if 'concatspws' in glb: return glb['concatspws']
        return True

    def __corrdepflags_dflt( self, glb ):
        return False

    def __corrdepflags( self, glb ):
        if 'corrdepflags' in glb: return glb['corrdepflags']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __antenna_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __callib_dflt( self, glb ):
        if self.__docallib( glb ) == bool(True): return ""
        return None
    def __gainfield_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __msselect_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __spwmap_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __interp_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __gaintable_dflt( self, glb ):
        if self.__docallib( glb ) == bool(False): return []
        return None

    #--------- return subparam values -------------------------------------------------
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __uvrange( self, glb ):
        if 'uvrange' in glb: return glb['uvrange']
        dflt = self.__uvrange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        dflt = self.__antenna_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __msselect( self, glb ):
        if 'msselect' in glb: return glb['msselect']
        dflt = self.__msselect_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __callib( self, glb ):
        if 'callib' in glb: return glb['callib']
        dflt = self.__callib_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __gaintable( self, glb ):
        if 'gaintable' in glb: return glb['gaintable']
        dflt = self.__gaintable_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __gainfield( self, glb ):
        if 'gainfield' in glb: return glb['gainfield']
        dflt = self.__gainfield_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        dflt = self.__interp_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        dflt = self.__spwmap_dflt( glb )
        if dflt is not None: return dflt
        return [ ]

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __caltable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__caltable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of output gain calibration table'
        value = self.__caltable( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'caltable': value},{'caltable': self.__schema['caltable']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('caltable',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select field using field id(s) or field name(s)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select spectral window/channels'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select observing intent'
        value = self.__intent( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __selectdata_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__selectdata_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Other data selection parameters'
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('selectdata',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on time range'
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __uvrange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__uvrange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__uvrange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data by baseline length.'
             value = self.__uvrange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'uvrange': value},{'uvrange': self.__schema['uvrange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('uvrange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__antenna_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on antenna/baseline'
             value = self.__antenna( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'Scan number range'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = 'Select by observation ID(s)'
             value = self.__observation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __msselect_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__msselect_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__msselect_dflt( self.__globals_( ) ) is not None:
             description = 'Optional complex data selection (ignore for now)'
             value = self.__msselect( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'msselect': value},{'msselect': self.__schema['msselect']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('msselect',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __solint_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__solint_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'inf'
        description = 'Solution interval: egs. \'inf\', \'60s\' (see help)'
        value = self.__solint( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'solint': value},{'solint': self.__schema['solint']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('solint',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __combine_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__combine_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Data axes which to combine for solve (obs, scan, spw, and/or field)'
        value = self.__combine( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'combine': value},{'combine': self.__schema['combine']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('combine',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __refant_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__refant_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Reference antenna name(s)'
        value = self.__refant( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'refant': value},{'refant': self.__schema['refant']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('refant',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __minsnr_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minsnr_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(3.0)
        description = 'Reject solutions below this signal-to-noise ratio (at the FFT stage)'
        value = self.__minsnr( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minsnr': value},{'minsnr': self.__schema['minsnr']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('minsnr',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __zerorates_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__zerorates_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Zero delay-rates in solution table'
        value = self.__zerorates( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'zerorates': value},{'zerorates': self.__schema['zerorates']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('zerorates',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __globalsolve_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__globalsolve_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Refine estimates of delay and rate with global least-squares solver'
        value = self.__globalsolve( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'globalsolve': value},{'globalsolve': self.__schema['globalsolve']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('globalsolve',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __niter_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__niter_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(100)
        description = 'Maximum number of iterations for least-squares solver'
        value = self.__niter( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'niter': value},{'niter': self.__schema['niter']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('niter',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __delaywindow_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__delaywindow_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Constrain FFT delay search to a window'
        value = self.__delaywindow( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'delaywindow': value},{'delaywindow': self.__schema['delaywindow']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('delaywindow',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __ratewindow_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__ratewindow_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Constrain FFT rate search to a window'
        value = self.__ratewindow( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'ratewindow': value},{'ratewindow': self.__schema['ratewindow']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('ratewindow',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __append_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__append_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Append solutions to the (existing) table'
        value = self.__append( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'append': value},{'append': self.__schema['append']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('append',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __corrdepflags_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__corrdepflags_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Respect correlation-dependent flags'
        value = self.__corrdepflags( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'corrdepflags': value},{'corrdepflags': self.__schema['corrdepflags']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('corrdepflags',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __corrcomb_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__corrcomb_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'none'
        description = 'Combine correlations'
        value = self.__corrcomb( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'corrcomb': value},{'corrcomb': self.__schema['corrcomb']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('corrcomb',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __docallib_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__docallib_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Use callib or traditional cal apply parameters'
        value = self.__docallib( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'docallib': value},{'docallib': self.__schema['docallib']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-14.14s =\x1B[0m %s%-23s%s' % ('docallib',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __callib_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__callib_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__callib_dflt( self.__globals_( ) ) is not None:
             description = 'Cal Library filename'
             value = self.__callib( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'callib': value},{'callib': self.__schema['callib']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('callib',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __gaintable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gaintable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__gaintable_dflt( self.__globals_( ) ) is not None:
             description = 'Gain calibration table(s) to apply on the fly'
             value = self.__gaintable( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gaintable': value},{'gaintable': self.__schema['gaintable']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('gaintable',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __gainfield_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gainfield_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__gainfield_dflt( self.__globals_( ) ) is not None:
             description = 'Select a subset of calibrators from gaintable(s)'
             value = self.__gainfield( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gainfield': value},{'gainfield': self.__schema['gainfield']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('gainfield',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __interp_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interp_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__interp_dflt( self.__globals_( ) ) is not None:
             description = 'Temporal interpolation for each gaintable (''=linear)'
             value = self.__interp( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('interp',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __spwmap_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spwmap_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ ]
        if self.__spwmap_dflt( self.__globals_( ) ) is not None:
             description = 'Spectral window mappings to form for gaintable(s)'
             value = self.__spwmap( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-11.11s =\x1B[0m %s%-23s%s' % ('spwmap',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __paramactive_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__paramactive_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Control which parameters are solved for'
        value = self.__paramactive( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'paramactive': value},{'paramactive': self.__schema['paramactive']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('paramactive',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __concatspws_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__concatspws_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Choose between multi-band FFT strategies'
        value = self.__concatspws( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'concatspws': value},{'concatspws': self.__schema['concatspws']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('concatspws',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __parang_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__parang_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Apply parallactic angle correction on the fly'
        value = self.__parang( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'parang': value},{'parang': self.__schema['parang']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-14.14s = %s%-23s%s' % ('parang',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'callib' in glb: del glb['callib']
        if 'gainfield' in glb: del glb['gainfield']
        if 'ratewindow' in glb: del glb['ratewindow']
        if 'concatspws' in glb: del glb['concatspws']
        if 'paramactive' in glb: del glb['paramactive']
        if 'zerorates' in glb: del glb['zerorates']
        if 'corrcomb' in glb: del glb['corrcomb']
        if 'parang' in glb: del glb['parang']
        if 'field' in glb: del glb['field']
        if 'globalsolve' in glb: del glb['globalsolve']
        if 'msselect' in glb: del glb['msselect']
        if 'intent' in glb: del glb['intent']
        if 'spwmap' in glb: del glb['spwmap']
        if 'refant' in glb: del glb['refant']
        if 'minsnr' in glb: del glb['minsnr']
        if 'corrdepflags' in glb: del glb['corrdepflags']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'interp' in glb: del glb['interp']
        if 'delaywindow' in glb: del glb['delaywindow']
        if 'docallib' in glb: del glb['docallib']
        if 'combine' in glb: del glb['combine']
        if 'niter' in glb: del glb['niter']
        if 'uvrange' in glb: del glb['uvrange']
        if 'solint' in glb: del glb['solint']
        if 'caltable' in glb: del glb['caltable']
        if 'observation' in glb: del glb['observation']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']
        if 'gaintable' in glb: del glb['gaintable']
        if 'append' in glb: del glb['append']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# fringefit -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__caltable_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__intent_inp( )
        self.__selectdata_inp( )
        self.__timerange_inp( )
        self.__uvrange_inp( )
        self.__antenna_inp( )
        self.__scan_inp( )
        self.__observation_inp( )
        self.__msselect_inp( )
        self.__solint_inp( )
        self.__combine_inp( )
        self.__refant_inp( )
        self.__minsnr_inp( )
        self.__zerorates_inp( )
        self.__globalsolve_inp( )
        self.__niter_inp( )
        self.__delaywindow_inp( )
        self.__ratewindow_inp( )
        self.__append_inp( )
        self.__corrdepflags_inp( )
        self.__corrcomb_inp( )
        self.__docallib_inp( )
        self.__callib_inp( )
        self.__gaintable_inp( )
        self.__gainfield_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )
        self.__paramactive_inp( )
        self.__concatspws_inp( )
        self.__parang_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "fringefit.last" if os.path.isfile("fringefit.last") else "fringefit.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('fringefit.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['msselect'] = self.__msselect( self.__globals_( ) )
        _invocation_parameters['solint'] = self.__solint( self.__globals_( ) )
        _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
        _invocation_parameters['refant'] = self.__refant( self.__globals_( ) )
        _invocation_parameters['minsnr'] = self.__minsnr( self.__globals_( ) )
        _invocation_parameters['zerorates'] = self.__zerorates( self.__globals_( ) )
        _invocation_parameters['globalsolve'] = self.__globalsolve( self.__globals_( ) )
        _invocation_parameters['niter'] = self.__niter( self.__globals_( ) )
        _invocation_parameters['delaywindow'] = self.__delaywindow( self.__globals_( ) )
        _invocation_parameters['ratewindow'] = self.__ratewindow( self.__globals_( ) )
        _invocation_parameters['append'] = self.__append( self.__globals_( ) )
        _invocation_parameters['corrdepflags'] = self.__corrdepflags( self.__globals_( ) )
        _invocation_parameters['corrcomb'] = self.__corrcomb( self.__globals_( ) )
        _invocation_parameters['docallib'] = self.__docallib( self.__globals_( ) )
        _invocation_parameters['callib'] = self.__callib( self.__globals_( ) )
        _invocation_parameters['gaintable'] = self.__gaintable( self.__globals_( ) )
        _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
        _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
        _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
        _invocation_parameters['paramactive'] = self.__paramactive( self.__globals_( ) )
        _invocation_parameters['concatspws'] = self.__concatspws( self.__globals_( ) )
        _invocation_parameters['parang'] = self.__parang( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-12s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#fringefit( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, caltable=None, field=None, spw=None, intent=None, selectdata=None, timerange=None, uvrange=None, antenna=None, scan=None, observation=None, msselect=None, solint=None, combine=None, refant=None, minsnr=None, zerorates=None, globalsolve=None, niter=None, delaywindow=None, ratewindow=None, append=None, corrdepflags=None, corrcomb=None, docallib=None, callib=None, gaintable=None, gainfield=None, interp=None, spwmap=None, paramactive=None, concatspws=None, parang=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('fringefit.pre')
        _postfile = os.path.realpath('fringefit.last')
        task_result = None
        _arguments = [vis,caltable,field,spw,intent,selectdata,timerange,uvrange,antenna,scan,observation,msselect,solint,combine,refant,minsnr,zerorates,globalsolve,niter,delaywindow,ratewindow,append,corrdepflags,corrcomb,docallib,callib,gaintable,gainfield,interp,spwmap,paramactive,concatspws,parang]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if caltable is not None: local_global['caltable'] = caltable
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if intent is not None: local_global['intent'] = intent
            if selectdata is not None: local_global['selectdata'] = selectdata
            if solint is not None: local_global['solint'] = solint
            if combine is not None: local_global['combine'] = combine
            if refant is not None: local_global['refant'] = refant
            if minsnr is not None: local_global['minsnr'] = minsnr
            if zerorates is not None: local_global['zerorates'] = zerorates
            if globalsolve is not None: local_global['globalsolve'] = globalsolve
            if niter is not None: local_global['niter'] = niter
            if delaywindow is not None: local_global['delaywindow'] = delaywindow
            if ratewindow is not None: local_global['ratewindow'] = ratewindow
            if append is not None: local_global['append'] = append
            if corrdepflags is not None: local_global['corrdepflags'] = corrdepflags
            if corrcomb is not None: local_global['corrcomb'] = corrcomb
            if docallib is not None: local_global['docallib'] = docallib
            if paramactive is not None: local_global['paramactive'] = paramactive
            if concatspws is not None: local_global['concatspws'] = concatspws
            if parang is not None: local_global['parang'] = parang

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['caltable'] = self.__caltable( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['intent'] = self.__intent( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['solint'] = self.__solint( local_global )
            _invocation_parameters['combine'] = self.__combine( local_global )
            _invocation_parameters['refant'] = self.__refant( local_global )
            _invocation_parameters['minsnr'] = self.__minsnr( local_global )
            _invocation_parameters['zerorates'] = self.__zerorates( local_global )
            _invocation_parameters['globalsolve'] = self.__globalsolve( local_global )
            _invocation_parameters['niter'] = self.__niter( local_global )
            _invocation_parameters['delaywindow'] = self.__delaywindow( local_global )
            _invocation_parameters['ratewindow'] = self.__ratewindow( local_global )
            _invocation_parameters['append'] = self.__append( local_global )
            _invocation_parameters['corrdepflags'] = self.__corrdepflags( local_global )
            _invocation_parameters['corrcomb'] = self.__corrcomb( local_global )
            _invocation_parameters['docallib'] = self.__docallib( local_global )
            _invocation_parameters['paramactive'] = self.__paramactive( local_global )
            _invocation_parameters['concatspws'] = self.__concatspws( local_global )
            _invocation_parameters['parang'] = self.__parang( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['uvrange'] = self.__uvrange( _invocation_parameters ) if uvrange is None else uvrange
            _invocation_parameters['antenna'] = self.__antenna( _invocation_parameters ) if antenna is None else antenna
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['msselect'] = self.__msselect( _invocation_parameters ) if msselect is None else msselect
            _invocation_parameters['callib'] = self.__callib( _invocation_parameters ) if callib is None else callib
            _invocation_parameters['gaintable'] = self.__gaintable( _invocation_parameters ) if gaintable is None else gaintable
            _invocation_parameters['gainfield'] = self.__gainfield( _invocation_parameters ) if gainfield is None else gainfield
            _invocation_parameters['interp'] = self.__interp( _invocation_parameters ) if interp is None else interp
            _invocation_parameters['spwmap'] = self.__spwmap( _invocation_parameters ) if spwmap is None else spwmap

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['uvrange'] = self.__uvrange( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['msselect'] = self.__msselect( self.__globals_( ) )
            _invocation_parameters['solint'] = self.__solint( self.__globals_( ) )
            _invocation_parameters['combine'] = self.__combine( self.__globals_( ) )
            _invocation_parameters['refant'] = self.__refant( self.__globals_( ) )
            _invocation_parameters['minsnr'] = self.__minsnr( self.__globals_( ) )
            _invocation_parameters['zerorates'] = self.__zerorates( self.__globals_( ) )
            _invocation_parameters['globalsolve'] = self.__globalsolve( self.__globals_( ) )
            _invocation_parameters['niter'] = self.__niter( self.__globals_( ) )
            _invocation_parameters['delaywindow'] = self.__delaywindow( self.__globals_( ) )
            _invocation_parameters['ratewindow'] = self.__ratewindow( self.__globals_( ) )
            _invocation_parameters['append'] = self.__append( self.__globals_( ) )
            _invocation_parameters['corrdepflags'] = self.__corrdepflags( self.__globals_( ) )
            _invocation_parameters['corrcomb'] = self.__corrcomb( self.__globals_( ) )
            _invocation_parameters['docallib'] = self.__docallib( self.__globals_( ) )
            _invocation_parameters['callib'] = self.__callib( self.__globals_( ) )
            _invocation_parameters['gaintable'] = self.__gaintable( self.__globals_( ) )
            _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
            _invocation_parameters['paramactive'] = self.__paramactive( self.__globals_( ) )
            _invocation_parameters['concatspws'] = self.__concatspws( self.__globals_( ) )
            _invocation_parameters['parang'] = self.__parang( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-12s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#fringefit( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'fringefit', [ 'vis=' + repr(_pc.document['vis']), 'caltable=' + repr(_pc.document['caltable']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'intent=' + repr(_pc.document['intent']), 'selectdata=' + repr(_pc.document['selectdata']), 'timerange=' + repr(_pc.document['timerange']), 'uvrange=' + repr(_pc.document['uvrange']), 'antenna=' + repr(_pc.document['antenna']), 'scan=' + repr(_pc.document['scan']), 'observation=' + repr(_pc.document['observation']), 'msselect=' + repr(_pc.document['msselect']), 'solint=' + repr(_pc.document['solint']), 'combine=' + repr(_pc.document['combine']), 'refant=' + repr(_pc.document['refant']), 'minsnr=' + repr(_pc.document['minsnr']), 'zerorates=' + repr(_pc.document['zerorates']), 'globalsolve=' + repr(_pc.document['globalsolve']), 'niter=' + repr(_pc.document['niter']), 'delaywindow=' + repr(_pc.document['delaywindow']), 'ratewindow=' + repr(_pc.document['ratewindow']), 'append=' + repr(_pc.document['append']), 'corrdepflags=' + repr(_pc.document['corrdepflags']), 'corrcomb=' + repr(_pc.document['corrcomb']), 'docallib=' + repr(_pc.document['docallib']), 'callib=' + repr(_pc.document['callib']), 'gaintable=' + repr(_pc.document['gaintable']), 'gainfield=' + repr(_pc.document['gainfield']), 'interp=' + repr(_pc.document['interp']), 'spwmap=' + repr(_pc.document['spwmap']), 'paramactive=' + repr(_pc.document['paramactive']), 'concatspws=' + repr(_pc.document['concatspws']), 'parang=' + repr(_pc.document['parang']) ] )
            task_result = _fringefit_t( _pc.document['vis'],_pc.document['caltable'],_pc.document['field'],_pc.document['spw'],_pc.document['intent'],_pc.document['selectdata'],_pc.document['timerange'],_pc.document['uvrange'],_pc.document['antenna'],_pc.document['scan'],_pc.document['observation'],_pc.document['msselect'],_pc.document['solint'],_pc.document['combine'],_pc.document['refant'],_pc.document['minsnr'],_pc.document['zerorates'],_pc.document['globalsolve'],_pc.document['niter'],_pc.document['delaywindow'],_pc.document['ratewindow'],_pc.document['append'],_pc.document['corrdepflags'],_pc.document['corrcomb'],_pc.document['docallib'],_pc.document['callib'],_pc.document['gaintable'],_pc.document['gainfield'],_pc.document['interp'],_pc.document['spwmap'],_pc.document['paramactive'],_pc.document['concatspws'],_pc.document['parang'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('fringefit')
            casalog.post("Exception Reported: Error in fringefit: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'fringefit', task_result )

        #Added if _fringefit_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

fringefit = _fringefit( )

