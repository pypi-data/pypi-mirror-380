##################### generated by xml-casa (v2) from sdgaincal.xml #################
##################### 3435b5a8876f7acffd0f57525a93684d ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_sdgaincal import sdgaincal as _sdgaincal_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _sdgaincal:
    """
    sdgaincal ---- MS SD gain calibration task

    
    
    

    --------- parameter descriptions ---------------------------------------------

    infile     name of input SD dataset (must be MS)
    calmode    gain calibration mode
    radius     radius of central region to be used for calibration
    smooth     smooth data or not
    antenna    select data by antenna name or ID, e.g. "PM03"
    field      select data by field IDs and names, e.g. "3C2*" ("" = all)
    spw        select data by spw IDs (spectral windows), e.g., "3,5,7" ("" = all)
    scan       select data by scan numbers, e.g. "21~23" (""=all)
    intent     select data by observation intent, e.g. "OBSERVE_TARGET#ON_SOURCE" (""=all)
    applytable (List of) sky and/or tsys tables for pre-application
    interp     Interp type in time[,freq], per gaintable. default==linear,linear
    spwmap     Spectral window mappings to form for applytable(s)
               Only used if callib=False
               default: [] (apply solutions from each calibration spw to
               the same MS spw only)
               Any available calibration spw can be mechanically mapped to any 
                MS spw. 
               Examples:
                  spwmap=[0,0,1,1] means apply calibration 
                    from cal spw = 0 to MS spw 0,1 and cal spw 1 to MS spws 2,3.
                  spwmap=[[0,0,1,1],[0,1,0,1]] (use a list of lists for multiple
                    applytables)
    outfile    name of output caltable
    overwrite  overwrite the output file if already exists
    [1;42mRETURNS[1;m       void

    --------- examples -----------------------------------------------------------

    
    Keyword arguments:
    infile -- Name of input SD dataset
    calmode -- Gain calibration mode. Currently, only 'doublecircle' is supported.
    options: 'doublecircle'
    default: 'doublecircle'
    >>> calmode expandable parameter
    radius -- Radius of the central region for double circle calibration.
    Default ('') is a radius of the primary beam. If numeric value
    is given, it is interpreted as a value in arcsec.
    default: ''
    options: '20arcsec', 20.0
    smooth -- Whether apply smoothing during gain calibration or not.
    options: (bool) True, False
    default: True
    antenna -- select data by antenna name or ID
    default: '' (use all antennas)
    example: 'PM03'
    field -- select data by field IDs and names
    default: '' (use all fields)
    example: field='3C2*' (all names starting with 3C2)
    field='0,4,5~7' (field IDs 0,4,5,6,7)
    field='0,3C273' (field ID 0 or field named 3C273)
    this selection is in addition to the other selections to data
    spw -- select data by spw IDs (spectral windows)
    NOTE this task only supports spw ID selction and ignores channel
    selection.
    default: '' (use all spws and channels)
    example: spw='3,5,7' (spw IDs 3,5,7; all channels)
    spw='<2' (spw IDs less than 2, i.e., 0,1; all channels)
    spw='30~45GHz' (spw IDs with the center frequencies in range 30-45GHz; all channels)
    this selection is in addition to the other selections to data
    NOTE spw input must be '' (''= all) in calmode='tsys'.
    scan -- select data by scan numbers
    default: '' (use all scans)
    example: scan='21~23' (scan IDs 21,22,23)
    this selection is in addition to the other selections to data
    NOTE scan input must be '' (''= all) in calmode='tsys'.
    intent -- select data by observational intent, also referred to as 'scan intent'
    default: '' (use all scan intents)
    example: intent='*ON_SOURCE*' (any valid scan-intent expression accepted by the MSSelection module can be specified)
    this selection is in addition to the other selections to data
    applytable -- List of sky/Tsys calibration tables you want to pre-apply.
    default: ''
    >>> applytable expandable parameter
    interp -- Interpolation type (in time[,freq]) to use for each gaintable.
    When frequency interpolation is relevant (bandpass solutions,
    frequency-dependent polcal solutions, ALMA Tsys)
    separate time-dependent and freq-dependent interp
    types with a comma (freq _after_ the comma).
    Specifications for frequency are ignored when the
    calibration table has no channel-dependence.
    Time-dependent interp options ending in 'PD' enable a
    "phase delay" correction per spw for non-channel-dependent
    calibration types.
    For multi-obsId datasets, 'perobs' can be appended to
    the time-dependent interpolation specification to
    enforce obsId boundaries when interpolating in time.
    For multi-scan datasets, 'perscan' can be appended to
    the time-dependent interpolation specification to
    enforce scan boundaries when interpolating in time.
    Add 'flag' to the freq-dependent interpolation options
    to enforce channel-dependent flagging (rather than
    interpolation/extrapolation).
    default: '' --> 'linear,linear' for all gaintable(s)
    example: interp='nearest'   (in time, freq-dep will be
    linear, if relevant)
    interp='linear,cubic'  (linear in time, cubic
    in freq)
    interp='linearperobs,splineflag' (linear in time
    per obsId,
    spline in
    freq with
    channelized
    flagging)
    interp=',spline'  (spline in freq; linear in
    time by default)
    interp=['nearest,spline','linear']  (for multiple gaintables)
    Options: Time: 'nearest', 'linear', 'nearestPD', 'linearPD'
    Freq: 'nearest', 'linear', 'cubic', 'spline',
    'nearestflag', 'linearflag', 'cubicflag', 'splineflag',
    
    spwmap -- Spectral windows combinations to form for gaintable(s)
    default: [] (apply solutions from each spw to that spw only)
    Example:  spwmap=[0,0,1,1] means apply the caltable solutions
    from spw = 0 to the spw 0,1 and spw 1 to spw 2,3.
    spwmap=[[0,0,1,1],[0,1,0,1]]  (for multiple gaintables)
    
    Complicated example:
    
    gaintable=['tab1','tab2','tab3']
    gainfield='3C286'
    interp=['linear','nearest']
    spwmap=[[],[0,0,2]]
    
    This means: apply 3 cal tables, selecting only solutions for 3C286
    from tab1 (but all fields from tab2 and tab3, indicated by
    no gainfield entry for these files).  Linear interpolation
    (in time) will be used for 'tab1' and 'tab3' (default); 'tab2' will
    use nearest.  For the 'tab2', the calibration spws map
    will be mapped to the data spws according to 0->0, 0->1, 2->2.
    (I.e., for data spw=0 and 2, the spw mapping is one to one,
    but data spw 1 will be calibrated by solutions from spw 0.)
    
    outfile -- Name of output caltable.
    default: '' (<infile>_<suffix> for calibration)
    overwrite -- overwrite the output caltable if already exists
    options: (bool) True,False
    default: False
    
    
    DESCRIPTION:
    sdgaincal computes and removes a time-dependent gain variation in single-dish
    data on a per-spectral-window and per-antenna basis. Presently the task
    operates only on data taken with the ALMA fast-mapped, double-circle
    observation modes [1]. This task exploits the fact that the double-circle mode
    observes the same position in the center of the mapped field, approximately
    circular every sub-cycle, and normalizes the gains throughout the entire
    dataset, relative to the measured brightness at the center position.
    
    Note that this gain calibration task is done independently of the atmosphere
    (i.e. Tsys) and sky calibration steps. This can be applied through the sdcal
    task. Alternatively, you can pass those caltables to applytable parameter to
    apply them on-the-fly prior to gain calibration.
    
    Presently, this task has only one calibration mode: calmode='doublecircle'.
    In this mode, the size of the region that CASA regards as "the center" is
    user-configurable via the expandable 'radius' (in arcsec) parameter (under
    'calmode'). The default is to use the size of the primary beam. The data can
    also be smoothed in the time domain, prior to computation of the gain variation.
    Selection is by specral window/channels, field IDs, and antenna through the spw,
    field, and antenna selection parameters. The default is to use all data for the
    gain calibration. The caltable can be output with the 'outfile' parameter.
    
    REFERENCE:
    [1] Phillips et al, 2015. Fast Single-Dish Scans of the Sun Using ALMA
    


    """

    _info_group_ = """single dish"""
    _info_desc_ = """ MS SD gain calibration task"""

    __schema = {'infile': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'calmode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'doublecircle' ]}, 'radius': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'smooth': {'type': 'cBool'}, 'antenna': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scan': {'type': 'cStr', 'coerce': _coerce.to_str}, 'intent': {'type': 'cStr', 'coerce': _coerce.to_str}, 'applytable': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'interp': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'spwmap': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'outfile': {'type': 'cStr', 'coerce': _coerce.to_str}, 'overwrite': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 10 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __outfile_dflt( self, glb ):
        return ''

    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        return ''

    def __scan_dflt( self, glb ):
        return ''

    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        return ''

    def __calmode_dflt( self, glb ):
        return 'doublecircle'

    def __calmode( self, glb ):
        if 'calmode' in glb: return glb['calmode']
        return 'doublecircle'

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''

    def __antenna_dflt( self, glb ):
        return ''

    def __antenna( self, glb ):
        if 'antenna' in glb: return glb['antenna']
        return ''

    def __intent_dflt( self, glb ):
        return ''

    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        return ''

    def __infile_dflt( self, glb ):
        return ''

    def __infile( self, glb ):
        if 'infile' in glb: return glb['infile']
        return ''

    def __applytable_dflt( self, glb ):
        return ''

    def __applytable( self, glb ):
        if 'applytable' in glb: return glb['applytable']
        return ''

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __radius_dflt( self, glb ):
        if self.__calmode( glb ) == "doublecircle": return ""
        return None
    def __smooth_dflt( self, glb ):
        if self.__calmode( glb ) == "doublecircle": return bool(True)
        return None
    def __interp_dflt( self, glb ):
        if self.__applytable( glb ) != "": return ""
        return None
    def __spwmap_dflt( self, glb ):
        if self.__applytable( glb ) != "": return []
        return None

    #--------- return subparam values -------------------------------------------------
    def __radius( self, glb ):
        if 'radius' in glb: return glb['radius']
        dflt = self.__radius_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __smooth( self, glb ):
        if 'smooth' in glb: return glb['smooth']
        dflt = self.__smooth_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        dflt = self.__intent_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        dflt = self.__interp_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        dflt = self.__spwmap_dflt( glb )
        if dflt is not None: return dflt
        return [ ]

    #--------- subparam inp output ----------------------------------------------------
    def __infile_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__infile_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'name of input SD dataset (must be MS)'
        value = self.__infile( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'infile': value},{'infile': self.__schema['infile']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-10.10s = %s%-23s%s' % ('infile',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __calmode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__calmode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'doublecircle'
        description = 'gain calibration mode ("doublecircle")'
        value = self.__calmode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'calmode': value},{'calmode': self.__schema['calmode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-10.10s =\x1B[0m %s%-23s%s' % ('calmode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __radius_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__radius_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__radius_dflt( self.__globals_( ) ) is not None:
             description = 'radius of central region to be used for calibration'
             value = self.__radius( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'radius': value},{'radius': self.__schema['radius']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-7.7s =\x1B[0m %s%-23s%s' % ('radius',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __smooth_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__smooth_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        if self.__smooth_dflt( self.__globals_( ) ) is not None:
             description = 'smooth data or not'
             value = self.__smooth( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'smooth': value},{'smooth': self.__schema['smooth']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-7.7s =\x1B[0m %s%-23s%s' % ('smooth',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __antenna_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__antenna_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by antenna name or ID, e.g. "PM03"'
        value = self.__antenna( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'antenna': value},{'antenna': self.__schema['antenna']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-10.10s = %s%-23s%s' % ('antenna',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by field IDs and names, e.g. "3C2*" ("" = all)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-10.10s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by spw IDs (spectral windows), e.g., "3,5,7" ("" = all)'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-10.10s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'select data by scan numbers, e.g. "21~23" (""=all)'
        value = self.__scan( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-10.10s = %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__intent_dflt( self.__globals_( ) ) is not None:
             description = 'select data by observation intent, e.g. "OBSERVE_TARGET#ON_SOURCE" (""=all)'
             value = self.__intent( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-7.7s =\x1B[0m %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __applytable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__applytable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = '(List of) sky and/or tsys tables for pre-application'
        value = self.__applytable( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'applytable': value},{'applytable': self.__schema['applytable']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-10.10s =\x1B[0m %s%-23s%s' % ('applytable',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __interp_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interp_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__interp_dflt( self.__globals_( ) ) is not None:
             description = 'Interp type in time[,freq], per gaintable. default==linear,linear'
             value = self.__interp( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-7.7s =\x1B[0m %s%-23s%s' % ('interp',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __spwmap_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spwmap_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [ ]
        if self.__spwmap_dflt( self.__globals_( ) ) is not None:
             description = 'Spectral window mappings to form for applytable(s)'
             value = self.__spwmap( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-7.7s =\x1B[0m %s%-23s%s' % ('spwmap',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __outfile_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outfile_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'name of output caltable'
        value = self.__outfile( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-10.10s = %s%-23s%s' % ('outfile',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __overwrite_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__overwrite_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'overwrite the output file if already exists [True, False]'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-10.10s = %s%-23s%s' % ('overwrite',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'antenna' in glb: del glb['antenna']
        if 'infile' in glb: del glb['infile']
        if 'outfile' in glb: del glb['outfile']
        if 'field' in glb: del glb['field']
        if 'smooth' in glb: del glb['smooth']
        if 'intent' in glb: del glb['intent']
        if 'spwmap' in glb: del glb['spwmap']
        if 'scan' in glb: del glb['scan']
        if 'interp' in glb: del glb['interp']
        if 'radius' in glb: del glb['radius']
        if 'applytable' in glb: del glb['applytable']
        if 'calmode' in glb: del glb['calmode']
        if 'overwrite' in glb: del glb['overwrite']
        if 'spw' in glb: del glb['spw']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# sdgaincal -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__infile_inp( )
        self.__calmode_inp( )
        self.__radius_inp( )
        self.__smooth_inp( )
        self.__antenna_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__applytable_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )
        self.__outfile_inp( )
        self.__overwrite_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "sdgaincal.last" if os.path.isfile("sdgaincal.last") else "sdgaincal.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('sdgaincal.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['infile'] = self.__infile( self.__globals_( ) )
        _invocation_parameters['calmode'] = self.__calmode( self.__globals_( ) )
        _invocation_parameters['radius'] = self.__radius( self.__globals_( ) )
        _invocation_parameters['smooth'] = self.__smooth( self.__globals_( ) )
        _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['applytable'] = self.__applytable( self.__globals_( ) )
        _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
        _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
        _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
        _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdgaincal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, infile=None, calmode=None, radius=None, smooth=None, antenna=None, field=None, spw=None, scan=None, intent=None, applytable=None, interp=None, spwmap=None, outfile=None, overwrite=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('sdgaincal.pre')
        _postfile = os.path.realpath('sdgaincal.last')
        task_result = None
        _arguments = [infile,calmode,radius,smooth,antenna,field,spw,scan,intent,applytable,interp,spwmap,outfile,overwrite]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if infile is not None: local_global['infile'] = infile
            if calmode is not None: local_global['calmode'] = calmode
            if antenna is not None: local_global['antenna'] = antenna
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if scan is not None: local_global['scan'] = scan
            if applytable is not None: local_global['applytable'] = applytable
            if outfile is not None: local_global['outfile'] = outfile
            if overwrite is not None: local_global['overwrite'] = overwrite

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['infile'] = self.__infile( local_global )
            _invocation_parameters['calmode'] = self.__calmode( local_global )
            _invocation_parameters['antenna'] = self.__antenna( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['scan'] = self.__scan( local_global )
            _invocation_parameters['applytable'] = self.__applytable( local_global )
            _invocation_parameters['outfile'] = self.__outfile( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['radius'] = self.__radius( _invocation_parameters ) if radius is None else radius
            _invocation_parameters['smooth'] = self.__smooth( _invocation_parameters ) if smooth is None else smooth
            _invocation_parameters['intent'] = self.__intent( _invocation_parameters ) if intent is None else intent
            _invocation_parameters['interp'] = self.__interp( _invocation_parameters ) if interp is None else interp
            _invocation_parameters['spwmap'] = self.__spwmap( _invocation_parameters ) if spwmap is None else spwmap

        else:
            # invoke with inp/go semantics
            _invocation_parameters['infile'] = self.__infile( self.__globals_( ) )
            _invocation_parameters['calmode'] = self.__calmode( self.__globals_( ) )
            _invocation_parameters['radius'] = self.__radius( self.__globals_( ) )
            _invocation_parameters['smooth'] = self.__smooth( self.__globals_( ) )
            _invocation_parameters['antenna'] = self.__antenna( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['applytable'] = self.__applytable( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-10s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#sdgaincal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'sdgaincal', [ 'infile=' + repr(_pc.document['infile']), 'calmode=' + repr(_pc.document['calmode']), 'radius=' + repr(_pc.document['radius']), 'smooth=' + repr(_pc.document['smooth']), 'antenna=' + repr(_pc.document['antenna']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'scan=' + repr(_pc.document['scan']), 'intent=' + repr(_pc.document['intent']), 'applytable=' + repr(_pc.document['applytable']), 'interp=' + repr(_pc.document['interp']), 'spwmap=' + repr(_pc.document['spwmap']), 'outfile=' + repr(_pc.document['outfile']), 'overwrite=' + repr(_pc.document['overwrite']) ] )
            task_result = _sdgaincal_t( _pc.document['infile'],_pc.document['calmode'],_pc.document['radius'],_pc.document['smooth'],_pc.document['antenna'],_pc.document['field'],_pc.document['spw'],_pc.document['scan'],_pc.document['intent'],_pc.document['applytable'],_pc.document['interp'],_pc.document['spwmap'],_pc.document['outfile'],_pc.document['overwrite'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('sdgaincal')
            casalog.post("Exception Reported: Error in sdgaincal: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'sdgaincal', task_result )

        #Added if _sdgaincal_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

sdgaincal = _sdgaincal( )

