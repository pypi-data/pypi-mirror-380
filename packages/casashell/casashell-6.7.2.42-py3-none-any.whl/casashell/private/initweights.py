##################### generated by xml-casa (v2) from initweights.xml ###############
##################### dc4e272a28b720b03ce054150b7b2269 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_initweights import initweights as _initweights_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _initweights:
    """
    initweights ---- Initializes weight information in the MS

    --------- parameter descriptions ---------------------------------------------

    vis       Name of input visibility file (MS)
    wtmode    Initialization mode
    tsystable Tsys calibration table to apply on the fly
    gainfield Select a subset of calibrators from Tsys table
    interp    Interpolation type in time[,freq]. default==\'linear,linear\'
    spwmap    Spectral windows combinations to form for gaintable(s)
    dowtsp    Initialize the WEIGHT_SPECTRUM column
    [1;42mRETURNS[1;m      void

    --------- examples -----------------------------------------------------------

    
    
    This task provides for initialization of the weight information
    in the MS.  For ALMA interferometry and EVLA data, it should not
    generally be necessary to use this task, as the per-spectral window
    weight information should have been initialized properly at
    fill time (v4.2.2 and later). To set per-channel weights, use
    initweights(vis=finalvis,wtmode='weight',dowtsp=True)
    
    Several initialization modes are supported via the wtmode parameter.
    
    If wtmode='nyq' (the default), SIGMA and WEIGHT will be
    initialized according to bandwidth and integration time.  This
    is the theoretically correct mode for raw normalized visibilities.
    (e.g., ALMA).  For the EVLA, this is correct if switched-power
    and bandpass calibration will later be applied.
    
    If wtmode='sigma', WEIGHT will be initialized according to the
    existing SIGMA column.
    
    If wtmode='weight', WEIGHT_SPECTRUM will be initialized according
    to the existing WEIGHT column; dowtspec=T must be specified in
    this case.
    
    If wtmode='ones', SIGMA and WEIGHT will be initialized with 1.0,
    globally.  This is a traditional means of initializing weight
    information, and is adequate when the integration time and
    bandwidth are uniform. It is not recommended for modern
    instruments (ALMA, EVLA), where variety in observational setups
    is common, and properly initialized and calibrated weights
    will be used for imaging sensitivity estimates.
    
    There are two EXPERIMENTAL modes, wtmode='tsys' and 'tinttsys'.
    In the modes, SIGMA and WEIGHT will be initialized according to
    Tsys, bandwidth, and integration time (used only in 'tinttsys'),
    i.e.,
    tsys    : weight=bw/Tsys^2
    tinttsys: weight=bw*t_int/Tsys^2
    These modes use Tsys values to calculate weight as is done in
    Tsys calibration. Tsys values are taken from a tsys calibration
    table given as tsystable. Selection of gain field (gainfield),
    interpolation method (interp), and spectral window mapping (spwmap)
    are supported, too.
    Available types of interpolation are,
    Time: 'nearest', 'linear', the variation of those with 'perobs'
    or 'perscan', e.g., 'linearperobs' (enforce obsId
    boundaries in interpolation)
    Freq: 'nearest', 'linear', 'cubic', 'spline', and the variation
    of those with 'flag', e.g., 'linearflag' (with
    channelized flag).
    See the help of applycal for details of interpolations.
    Note if the weight in an MS is initialized with these modes and
    Tsys calibration table is applied with calwt=True after that, the
    weight would be contaminated by being devided by square of Tsys
    twice.
    !!! USERS ARE ADVISED TO USE THESE EXPERIMENTAL MODES WITH CARE !!!
    
    For the above wtmodes, if dowtsp=T (or if the WEIGHT_SPECTRUM
    column already exists), the WEIGHT_SPECTRUM column will be
    initialized (uniformly in channel in wtmode='nyq', 'sigma',
    'weight', and 'ones'), in a manner consistent with the
    disposition of the WEIGHT column.  If the WEIGHT_SPECTRUM
    column does not exist, dowtsp=T will force its creation.
    Use of the WEIGHT_SPECTRUM column is only meaningful
    for ALMA data which will be calibrated with channelized
    Tsys information, or if the weights will become channelized
    after calibration, e.g., via averaging over time- and
    channel-dependent flagging.  (A task for channel-dependent
    weight estimation from the data itself is also currently under
    development).
    In non-channelized modes (wtmode='nyq', 'sigma', 'weight', and
    'ones') or when dowtsp=F, SIGMA_SPECTRUM column will be removed
    from MS. On the other hand, SIGMA_SPECTRUM column is added and
    initialized in channelized modes (wtmode='tsys' and 'tinttsys')
    if dowtsp=T or WEIGHT_SPECTRUM already column exists.
    
    Two additional modes are available for managing the spectral
    weight info columns; these should be used with extreme care: If
    wtmode='delwtsp', the WEIGHT_SPECTRUM column will be deleted (if
    it exists).  If wtmode='delsigsp', the SIGMA_SPECTRUM column
    will be deleted (if it exists).  Note that creation of
    SIGMA_SPECTRUM is not supported via this method.
    
    Note that this task does not support any prior selection.
    Intialization of the weight information must currently be done
    globally or not at all.  This is to maintain consistency.
    
    


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Initializes weight information in the MS"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'wtmode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'delwtsp', 'nyq', 'ones', 'tsys', 'weight', 'tinttsys', 'sigma', 'delsigsp' ]}, 'tsystable': {'type': 'cPath', 'coerce': _coerce.expand_path}, 'gainfield': {'type': 'cStr', 'coerce': _coerce.to_str}, 'interp': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spwmap': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'dowtsp': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 12 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __dowtsp_dflt( self, glb ):
        return False

    def __dowtsp( self, glb ):
        if 'dowtsp' in glb: return glb['dowtsp']
        return False

    def __wtmode_dflt( self, glb ):
        return 'nyq'

    def __wtmode( self, glb ):
        if 'wtmode' in glb: return glb['wtmode']
        return 'nyq'



    #--------- return inp/go default --------------------------------------------------
    def __tsystable_dflt( self, glb ):
        if self.__wtmode( glb ) == "tsys": return ""
        if self.__wtmode( glb ) == "tinttsys": return ""
        return None
    def __gainfield_dflt( self, glb ):
        if self.__wtmode( glb ) == "tsys": return ""
        if self.__wtmode( glb ) == "tinttsys": return ""
        return None
    def __interp_dflt( self, glb ):
        if self.__wtmode( glb ) == "tsys": return ""
        if self.__wtmode( glb ) == "tinttsys": return ""
        return None
    def __spwmap_dflt( self, glb ):
        if self.__wtmode( glb ) == "tsys": return []
        if self.__wtmode( glb ) == "tinttsys": return []
        return None

    #--------- return subparam values -------------------------------------------------
    def __tsystable( self, glb ):
        if 'tsystable' in glb: return glb['tsystable']
        dflt = self.__tsystable_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __gainfield( self, glb ):
        if 'gainfield' in glb: return glb['gainfield']
        dflt = self.__gainfield_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __interp( self, glb ):
        if 'interp' in glb: return glb['interp']
        dflt = self.__interp_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __spwmap( self, glb ):
        if 'spwmap' in glb: return glb['spwmap']
        dflt = self.__spwmap_dflt( glb )
        if dflt is not None: return dflt
        return [  ]

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file (MS)'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-12.12s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __wtmode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__wtmode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'nyq'
        description = 'Initialization mode'
        value = self.__wtmode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'wtmode': value},{'wtmode': self.__schema['wtmode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-12.12s =\x1B[0m %s%-23s%s' % ('wtmode',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __tsystable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__tsystable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__tsystable_dflt( self.__globals_( ) ) is not None:
             description = 'Tsys calibration table to apply on the fly'
             value = self.__tsystable( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'tsystable': value},{'tsystable': self.__schema['tsystable']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-9.9s =\x1B[0m %s%-23s%s' % ('tsystable',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __gainfield_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gainfield_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__gainfield_dflt( self.__globals_( ) ) is not None:
             description = 'Select a subset of calibrators from Tsys table'
             value = self.__gainfield( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gainfield': value},{'gainfield': self.__schema['gainfield']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-9.9s =\x1B[0m %s%-23s%s' % ('gainfield',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __interp_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interp_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__interp_dflt( self.__globals_( ) ) is not None:
             description = 'Interpolation type in time[,freq]. default==\'linear,linear\''
             value = self.__interp( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interp': value},{'interp': self.__schema['interp']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-9.9s =\x1B[0m %s%-23s%s' % ('interp',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __spwmap_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spwmap_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__spwmap_dflt( self.__globals_( ) ) is not None:
             description = 'Spectral windows combinations to form for gaintable(s)'
             value = self.__spwmap( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spwmap': value},{'spwmap': self.__schema['spwmap']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-9.9s =\x1B[0m %s%-23s%s' % ('spwmap',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __dowtsp_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__dowtsp_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Initialize the WEIGHT_SPECTRUM column'
        value = self.__dowtsp( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'dowtsp': value},{'dowtsp': self.__schema['dowtsp']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-12.12s = %s%-23s%s' % ('dowtsp',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'dowtsp' in glb: del glb['dowtsp']
        if 'gainfield' in glb: del glb['gainfield']
        if 'spwmap' in glb: del glb['spwmap']
        if 'tsystable' in glb: del glb['tsystable']
        if 'vis' in glb: del glb['vis']
        if 'interp' in glb: del glb['interp']
        if 'wtmode' in glb: del glb['wtmode']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# initweights -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__wtmode_inp( )
        self.__tsystable_inp( )
        self.__gainfield_inp( )
        self.__interp_inp( )
        self.__spwmap_inp( )
        self.__dowtsp_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "initweights.last" if os.path.isfile("initweights.last") else "initweights.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('initweights.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['wtmode'] = self.__wtmode( self.__globals_( ) )
        _invocation_parameters['tsystable'] = self.__tsystable( self.__globals_( ) )
        _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
        _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
        _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
        _invocation_parameters['dowtsp'] = self.__dowtsp( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-9s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#initweights( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, wtmode=None, tsystable=None, gainfield=None, interp=None, spwmap=None, dowtsp=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('initweights.pre')
        _postfile = os.path.realpath('initweights.last')
        task_result = None
        _arguments = [vis,wtmode,tsystable,gainfield,interp,spwmap,dowtsp]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if wtmode is not None: local_global['wtmode'] = wtmode
            if dowtsp is not None: local_global['dowtsp'] = dowtsp

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['wtmode'] = self.__wtmode( local_global )
            _invocation_parameters['dowtsp'] = self.__dowtsp( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['tsystable'] = self.__tsystable( _invocation_parameters ) if tsystable is None else tsystable
            _invocation_parameters['gainfield'] = self.__gainfield( _invocation_parameters ) if gainfield is None else gainfield
            _invocation_parameters['interp'] = self.__interp( _invocation_parameters ) if interp is None else interp
            _invocation_parameters['spwmap'] = self.__spwmap( _invocation_parameters ) if spwmap is None else spwmap

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['wtmode'] = self.__wtmode( self.__globals_( ) )
            _invocation_parameters['tsystable'] = self.__tsystable( self.__globals_( ) )
            _invocation_parameters['gainfield'] = self.__gainfield( self.__globals_( ) )
            _invocation_parameters['interp'] = self.__interp( self.__globals_( ) )
            _invocation_parameters['spwmap'] = self.__spwmap( self.__globals_( ) )
            _invocation_parameters['dowtsp'] = self.__dowtsp( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-9s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#initweights( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'initweights', [ 'vis=' + repr(_pc.document['vis']), 'wtmode=' + repr(_pc.document['wtmode']), 'tsystable=' + repr(_pc.document['tsystable']), 'gainfield=' + repr(_pc.document['gainfield']), 'interp=' + repr(_pc.document['interp']), 'spwmap=' + repr(_pc.document['spwmap']), 'dowtsp=' + repr(_pc.document['dowtsp']) ] )
            task_result = _initweights_t( _pc.document['vis'],_pc.document['wtmode'],_pc.document['tsystable'],_pc.document['gainfield'],_pc.document['interp'],_pc.document['spwmap'],_pc.document['dowtsp'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('initweights')
            casalog.post("Exception Reported: Error in initweights: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'initweights', task_result )

        #Added if _initweights_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

initweights = _initweights( )

