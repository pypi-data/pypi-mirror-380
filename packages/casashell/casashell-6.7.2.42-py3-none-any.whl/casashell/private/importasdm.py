##################### generated by xml-casa (v2) from importasdm.xml ################
##################### 63f2bd0ee18ea79d81a985116dd0f469 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_importasdm import importasdm as _importasdm_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _importasdm:
    """
    importasdm ---- Convert an ALMA Science Data Model observation into a CASA visibility file (MS)

    
    Convert an ALMA Science Data Model observation into a CASA visibility
    file (MS)

    --------- parameter descriptions ---------------------------------------------

    asdm                     Name of input ASDM file (directory)
                             Default: none
                             
                                Example: asdm='ExecBlock3'
    vis                      Root ms name. 
                             Default: none
                             
                             Note that a prefix (.ms) is NOT appended to this
                             name.
    createmms                Create a Multi-MS partitioned according to the given
                             separation axis.
                             Default: False
                             Options: False|True
                             
                             For more detailed documentation on partition,
                             Multi-MS and the MPI use in CASA, please see CASA
                             Docs (https://casa.nrao.edu/casadocs/).
    separationaxis           Axis to do parallelization across
                             Default: 'auto'
                             Options: 'scan', 'spw', 'baseline', 'auto'
                             
                             * auto: will partition per scan/spw to obtain
                               optimal load balancing with the following
                               criteria:    
                               1 - Maximize the scan/spw/field distribution
                               across sub-MSs
                               2 - Generate sub-MSs with similar size
                             * 'scan' or 'spw': will partition the MS into
                               scan or spw. The individual sub-MSs may not be
                               balanced with respect to the number of rows.
                             * 'baseline': mostly useful for Single-Dish
                               data. This axis will partition the MS based on
                               the available baselines. If the user wants only
                               auto-correlations, use the
                               ocorr_mode='ao'. Note that if numsubms='auto',
                               partition will try to create as many subMSs as
                               the number of available servers in the
                               cluster. If the user wants to have one subMS
                               for each baseline, set the numsubms parameter
                               to a number higher than the number of baselines
                               to achieve this.
    numsubms                 The number of sub-MSs to create in the Multi-Ms.
                             Default: 'auto'
                             Options: any integer number (example: numsubms=4)
                             
                             The default 'auto' is to partition using the
                             number of available servers given when launching
                             CASA. If the task is unable to determine the
                             number of running servers, or the user did not
                             start CASA using mpicasa, numsubms will use 8 as
                             the default.
                             
                                Example: Launch CASA with 5 engines, where 4
                                of them will be used to create the MMS (the
                                first engine is used as the MPIClient):
                                mpicasa -n 5 casa --nogui --log2term
                                CASA> importasdm('uid__A1', createmms=True)
    corr_mode                Correlation mode to be considered on input.
                             Default: 'all'
                             Options: ao, co, ac, or all
    srt                      Spectral resolution type.
                             Default: 'all'
                             Options: fr, ca, bw, or all
    time_sampling            Specifies the time sampling (INTEGRATION and/or
                             SUBINTEGRATION) to be considered on input. 
                             Default: 'all'
                             Options: i, si, or all
                             
                             A quoted string containing a sequence of i, si,
                             or all separated by whitespaces is expected
    ocorr_mode               Output data for correlation mode AUTO_ONLY (ao) or
                             CROSS_ONLY (co) or CROSS_AND_AUTO (ca)
                             Default: 'ca'
                             Options: ao, co, ca
    compression              Produce compressed columns in the resulting measurement
                             set.
                             Default: False
                             Options: False|True
    lazy                     Make the MS DATA column read the ASDM Binary data
                             directly (faster import, smaller MS).
                             Default: False
                             Options: False|True
                             
                             Instead of writing a copy of the visibilities
                             into a standard DATA column, lazy=True will make
                             importasdm only write a lookup-table such that
                             later access to the DATA column will read the
                             ASDM binary visibility data directly. This
                             requires that the ASDM not be removed from its
                             location as long the the DATA column is
                             needed. Use method ms.asdmref() to query and
                             manipulate the reference to the ASDM.
                             
                             lazy=True will save ca. 50% disk space and
                             accelerate the DATA column access by
                             ca. 10%. lazy=True will only work when there is
                             visibility data in the ASDM, not with pure
                             radiometer data.
    asis                     Creates verbatim copies of the ASDM tables in the output
                             measurement set.
                             Default: none
                             
                             The value given to this option must be a list of
                             table names separated by space characters; the
                             wildcard character '*' is  allowed in table
                             names.
    wvr_corrected_data       Specifies which values are considerd in the ASDM binary
                             data to fill the DATA column in the MAIN table of the MS.
                             Default: no
                             Options: no|yes|both
                             
                             * no: uncorrected data
                             * yes: corrected data
                             * both: for corrected and uncorrected data. Note
                               if both is selected, two measurement sets are
                               created, one with uncorrected data and the
                               other with corrected data (which name is
                               suffixed by '-wvr-corrected')
    scans                    Processes only the scans specified in the option's value.
                             Default: none (all scans)
                             
                             This value is a semicolon separated list of scan
                             specifications. A scan specification consists in
                             an exec bock index  followed by the character ':'
                             followed by a comma separated list of scan
                             indexes or scan index ranges. A scan index is
                             relative to the exec block it belongs to. Scan
                             indexes are  1-based while exec blocks's are
                             0-based. 
                             
                                Examples: 
                                '0:1' 
                                '2:2~6' 
                                '0:1;1:2~6,8;2:,3:24~30'
                                '1,2' 
                                '3:' alone will be interpreted as 'all the
                                scans of the exec block#3'. An scan index or a
                                scan index range not preceded by an exec block
                                index will be interpreted as 'all the scans
                                with such indexes in all the exec blocks'.
    ignore_time              All the rows of the tables Feed, History, Pointing,
                             Source, SysCal, CalDevice, SysPower, and Weather are processed
                             independently of the time range of the selected exec block / scan.
                             Default: False
                             Options: False|True
    process_syspower         s processed if and only if this
                             parameter is set to true.
                             Default: True
                             Options: True|False
    process_caldevice        The CalDevice table is processed if and only if this
                             parameter is set to true.
                             Default: True
                             Options: True|False
    process_pointing         The Pointing table is processed if and only if this
                             parameter is set to true. 
                             Default: True
                             Options: True|False
                             
                             If set to False, the POINTING table is empty in
                             the resulting MS
    process_flags            Create online flags based on the Flag.xml, Antenna.xml
                             and SpectralWindow.xml files and copy them to the FLAG_CMD sub-table
                             of the MS.
                             Default: True
                             Options: True|False
                             
                             The flags will NOT be applied unless  the
                             parameter applyflags is set to True. Optionally,
                             the flags can also be saved to an external ASCII
                             file if savecmds is set to True.
    tbuff                    Time padding buffer (seconds)
                             Subparameter of process_flags=True
                             Default: 0.0
                             
                             NOTE: this time is in seconds. You should
                             currently set the value of tbuff to be 1.5x the
                             correlator integration time if greater than 1
                             second. For example, if the SDM has integrations
                             of 3 seconds, set tbuff=4.5.  Likewise, set
                             tbuff=15.0 for 10-sec integrations.
    applyflags               Apply the online flags to the MS.
                             Subparameter of process_flags=True
                             Default: False
                             Options: False|True
    savecmds                 Save the flag commands to an ASCII file given by the
                             parameter outfile. 
                             Subparameter of process_flags=True
                             Default: False
                             Options: False|True
    outfile                  Filename or list of filenames where to save the online
                             flag commands.
                             Subparameter of process_flags=True
                             Default: '' (it will save on a filename composed
                             from the MS name(s).) E.g., for vis='uid_A02.ms',
                             the outfile will be 'uid_A02_cmd.txt'.
    flagbackup               Back up flag column before applying flags.
                             Default: True
                             Options: True|False
    verbose                  Produce log output as asdm2MS is being run
                             Default: False
                             Options: False|True
    overwrite                Over write an existing MS(s) or MS(s), if the option
                             wvr_corrected_data='both'
                             Default: False  (do not overwrite)
                             Options: False|True
                             
                             NOTE: the overwrite parameter affects all the
                             output of the task. If any of the following
                             exist, it will not overwrite them. MS(s),
                             .flagversions, online flag files. When set to
                             True, it will overwrite the MS, .flagversions and
                             online flag file.
    bdfflags                 Set the MS FLAG column according to the ASDM _binary_
                             flags
                             Default: False
                             Options: False|True
    with_pointing_correction Add (ASDM::Pointing::encoder -
                             ASDM::Pointing::pointingDirection) to the value to be written in
                             MS::Pointing::direction
                             Default: False
                             Options: False|True
    convert_ephem2geo        if True, convert any attached ephemerides to the GEO
                             reference frame (time-spacing not changed)
                             Default: True
                             Options: True|False
                             
                             ALMA uses ephemerides with observer location
                             equal to the ALMA site. For later processing of
                             the radial velocity information in, e.g. cvel,  a
                             geocentric ephemeris is needed. Setting this
                             option to True will perform the conversion of
                             positions and velocities on all attached
                             ephemerides in the imported MS. This will neither
                             change the time-spacing nor the duration of the
                             ephemeris. No interpolation in time is done.
    polyephem_tabtimestep    Timestep (days) for the tabulation of polynomial
                             ephemerides. A value less than or equal to 0 sets the timestep to 0.001 days. 
                             Default: 0
                             
                             Presently, VLA data can contain polynomial
                             ephemerides. ALMA data uses tabulated values.
                             Polynomial ephemerides in the SDM are always
                             tabulated using some timestep when the ephemeris
                             tables attached to the MS are written. If a non-default
                             value is used and the ASDM contains tabulated values
                             then importasdm will log a warning messages informing
                             the user that polyephem_tabtimestep is not used for
                             tabulated ephemerides.
    [1;42mRETURNS[1;m                     void

    --------- examples -----------------------------------------------------------

    
    FOR MORE INFORMATION, SEE THE TASK PAGES OF IMPORTASDM IN CASA DOCS:
    https://casa.nrao.edu/casadocs/
    


    """

    _info_group_ = """import/export"""
    _info_desc_ = """Convert an ALMA Science Data Model observation into a CASA visibility file (MS)"""

    __schema = {'asdm': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'vis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'createmms': {'type': 'cBool'}, 'separationaxis': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'baseline', 'AUTO', 'SPW', 'SCAN', 'auto', 'spw', 'BASELINE', 'scan' ]}, 'numsubms': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'corr_mode': {'type': 'cStr', 'coerce': _coerce.to_str}, 'srt': {'type': 'cStr', 'coerce': _coerce.to_str}, 'time_sampling': {'type': 'cStr', 'coerce': _coerce.to_str}, 'ocorr_mode': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'co', 'ao', 'ca' ]}, 'compression': {'type': 'cBool'}, 'lazy': {'type': 'cBool'}, 'asis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'wvr_corrected_data': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'no', 'yes', 'both' ]}, 'scans': {'type': 'cStr', 'coerce': _coerce.to_str}, 'ignore_time': {'type': 'cBool'}, 'process_syspower': {'type': 'cBool'}, 'process_caldevice': {'type': 'cBool'}, 'process_pointing': {'type': 'cBool'}, 'process_flags': {'type': 'cBool'}, 'tbuff': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'applyflags': {'type': 'cBool'}, 'savecmds': {'type': 'cBool'}, 'outfile': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'flagbackup': {'type': 'cBool'}, 'verbose': {'type': 'cBool'}, 'overwrite': {'type': 'cBool'}, 'bdfflags': {'type': 'cBool'}, 'with_pointing_correction': {'type': 'cBool'}, 'convert_ephem2geo': {'type': 'cBool'}, 'polyephem_tabtimestep': {'type': 'cFloat', 'coerce': _coerce.to_float}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 24 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __process_flags_dflt( self, glb ):
        return True

    def __process_flags( self, glb ):
        if 'process_flags' in glb: return glb['process_flags']
        return True

    def __with_pointing_correction_dflt( self, glb ):
        return False

    def __with_pointing_correction( self, glb ):
        if 'with_pointing_correction' in glb: return glb['with_pointing_correction']
        return False

    def __process_syspower_dflt( self, glb ):
        return True

    def __process_syspower( self, glb ):
        if 'process_syspower' in glb: return glb['process_syspower']
        return True

    def __wvr_corrected_data_dflt( self, glb ):
        return 'no'

    def __wvr_corrected_data( self, glb ):
        if 'wvr_corrected_data' in glb: return glb['wvr_corrected_data']
        return 'no'

    def __process_caldevice_dflt( self, glb ):
        return True

    def __process_caldevice( self, glb ):
        if 'process_caldevice' in glb: return glb['process_caldevice']
        return True

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __convert_ephem2geo_dflt( self, glb ):
        return True

    def __convert_ephem2geo( self, glb ):
        if 'convert_ephem2geo' in glb: return glb['convert_ephem2geo']
        return True

    def __polyephem_tabtimestep_dflt( self, glb ):
        return float(0.)

    def __polyephem_tabtimestep( self, glb ):
        if 'polyephem_tabtimestep' in glb: return glb['polyephem_tabtimestep']
        return float(0.)

    def __corr_mode_dflt( self, glb ):
        return 'all'

    def __corr_mode( self, glb ):
        if 'corr_mode' in glb: return glb['corr_mode']
        return 'all'

    def __flagbackup_dflt( self, glb ):
        return True

    def __flagbackup( self, glb ):
        if 'flagbackup' in glb: return glb['flagbackup']
        return True

    def __time_sampling_dflt( self, glb ):
        return 'all'

    def __time_sampling( self, glb ):
        if 'time_sampling' in glb: return glb['time_sampling']
        return 'all'

    def __lazy_dflt( self, glb ):
        return False

    def __lazy( self, glb ):
        if 'lazy' in glb: return glb['lazy']
        return False

    def __compression_dflt( self, glb ):
        return False

    def __compression( self, glb ):
        if 'compression' in glb: return glb['compression']
        return False

    def __bdfflags_dflt( self, glb ):
        return False

    def __bdfflags( self, glb ):
        if 'bdfflags' in glb: return glb['bdfflags']
        return False

    def __ignore_time_dflt( self, glb ):
        return False

    def __ignore_time( self, glb ):
        if 'ignore_time' in glb: return glb['ignore_time']
        return False

    def __createmms_dflt( self, glb ):
        return False

    def __createmms( self, glb ):
        if 'createmms' in glb: return glb['createmms']
        return False

    def __asdm_dflt( self, glb ):
        return ''

    def __asdm( self, glb ):
        if 'asdm' in glb: return glb['asdm']
        return ''

    def __asis_dflt( self, glb ):
        return ''

    def __asis( self, glb ):
        if 'asis' in glb: return glb['asis']
        return ''

    def __scans_dflt( self, glb ):
        return ''

    def __scans( self, glb ):
        if 'scans' in glb: return glb['scans']
        return ''

    def __process_pointing_dflt( self, glb ):
        return True

    def __process_pointing( self, glb ):
        if 'process_pointing' in glb: return glb['process_pointing']
        return True

    def __ocorr_mode_dflt( self, glb ):
        return 'ca'

    def __ocorr_mode( self, glb ):
        if 'ocorr_mode' in glb: return glb['ocorr_mode']
        return 'ca'

    def __verbose_dflt( self, glb ):
        return False

    def __verbose( self, glb ):
        if 'verbose' in glb: return glb['verbose']
        return False

    def __srt_dflt( self, glb ):
        return 'all'

    def __srt( self, glb ):
        if 'srt' in glb: return glb['srt']
        return 'all'

    def __overwrite_dflt( self, glb ):
        return False

    def __overwrite( self, glb ):
        if 'overwrite' in glb: return glb['overwrite']
        return False



    #--------- return inp/go default --------------------------------------------------
    def __outfile_dflt( self, glb ):
        if self.__process_flags( glb ) == bool(True): return ""
        return None
    def __numsubms_dflt( self, glb ):
        if self.__createmms( glb ) == bool(True): return "auto"
        return None
    def __applyflags_dflt( self, glb ):
        if self.__process_flags( glb ) == bool(True): return bool(False)
        return None
    def __tbuff_dflt( self, glb ):
        if self.__process_flags( glb ) == bool(True): return float(0.0)
        return None
    def __separationaxis_dflt( self, glb ):
        if self.__createmms( glb ) == bool(True): return "auto"
        return None
    def __savecmds_dflt( self, glb ):
        if self.__process_flags( glb ) == bool(True): return bool(False)
        return None

    #--------- return subparam values -------------------------------------------------
    def __separationaxis( self, glb ):
        if 'separationaxis' in glb: return glb['separationaxis']
        dflt = self.__separationaxis_dflt( glb )
        if dflt is not None: return dflt
        return 'auto'
    def __numsubms( self, glb ):
        if 'numsubms' in glb: return glb['numsubms']
        dflt = self.__numsubms_dflt( glb )
        if dflt is not None: return dflt
        return 'auto'
    def __tbuff( self, glb ):
        if 'tbuff' in glb: return glb['tbuff']
        dflt = self.__tbuff_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __applyflags( self, glb ):
        if 'applyflags' in glb: return glb['applyflags']
        dflt = self.__applyflags_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __savecmds( self, glb ):
        if 'savecmds' in glb: return glb['savecmds']
        dflt = self.__savecmds_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __outfile( self, glb ):
        if 'outfile' in glb: return glb['outfile']
        dflt = self.__outfile_dflt( glb )
        if dflt is not None: return dflt
        return ''

    #--------- subparam inp output ----------------------------------------------------
    def __asdm_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__asdm_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input asdm directory (on disk)'
        value = self.__asdm( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'asdm': value},{'asdm': self.__schema['asdm']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('asdm',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Root name of the ms to be created. Note the .ms is NOT added'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __createmms_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__createmms_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Create a Multi-MS output'
        value = self.__createmms( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'createmms': value},{'createmms': self.__schema['createmms']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23s%s' % ('createmms',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __separationaxis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__separationaxis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'auto'
        if self.__separationaxis_dflt( self.__globals_( ) ) is not None:
             description = 'Axis to do parallelization across (scan, spw, baseline, auto)'
             value = self.__separationaxis( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'separationaxis': value},{'separationaxis': self.__schema['separationaxis']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('separationaxis',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __numsubms_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__numsubms_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'auto'
        if self.__numsubms_dflt( self.__globals_( ) ) is not None:
             description = 'The number of SubMSs to create (auto or any number)'
             value = self.__numsubms( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'numsubms': value},{'numsubms': self.__schema['numsubms']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('numsubms',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __corr_mode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__corr_mode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'all'
        description = 'Specifies the correlation mode to be considered on input. A quoted string containing a sequence of ao, co, ac,or all separated by whitespaces is expected'
        value = self.__corr_mode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'corr_mode': value},{'corr_mode': self.__schema['corr_mode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('corr_mode',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __srt_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__srt_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'all'
        description = 'Specifies the spectral resolution type to be considered on input. A quoted string containing a sequence of fr, ca, bw, or all separated by whitespaces is expected'
        value = self.__srt( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'srt': value},{'srt': self.__schema['srt']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('srt',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __time_sampling_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__time_sampling_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'all'
        description = 'Specifies the time sampling (INTEGRATION and/or SUBINTEGRATION)  to be considered on input. A quoted string containing a sequence of i, si, or all separated by whitespaces is expected'
        value = self.__time_sampling( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'time_sampling': value},{'time_sampling': self.__schema['time_sampling']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('time_sampling',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __ocorr_mode_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__ocorr_mode_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'ca'
        description = 'Output data for correlation mode AUTO_ONLY (ao) or CROSS_ONLY (co) or CROSS_AND_AUTO (ca)'
        value = self.__ocorr_mode( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'ocorr_mode': value},{'ocorr_mode': self.__schema['ocorr_mode']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('ocorr_mode',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __compression_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__compression_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Flag for turning on data compression'
        value = self.__compression( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'compression': value},{'compression': self.__schema['compression']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('compression',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __lazy_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__lazy_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Make the MS DATA column read the ASDM Binary data directly (faster import, smaller MS)'
        value = self.__lazy( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'lazy': value},{'lazy': self.__schema['lazy']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('lazy',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __asis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__asis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Creates verbatim copies of the ASDMtables in the output MeasurementSet. Value given must be a string of table names separated by spaces; A * wildcard is allowed.'
        value = self.__asis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'asis': value},{'asis': self.__schema['asis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('asis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __wvr_corrected_data_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__wvr_corrected_data_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'no'
        description = 'Specifies which values are considerd in the SDM binary data to fill the DATA column in the MAIN table of the MS; yes for corrected, no for uncorrected, both for corrected and uncorrected (resulting in two MSs)'
        value = self.__wvr_corrected_data( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'wvr_corrected_data': value},{'wvr_corrected_data': self.__schema['wvr_corrected_data']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('wvr_corrected_data',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __scans_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scans_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Processes only the specified scans.  A scan specification consists of an exec block index followed by the : character, followed by a comma separated list of scan indexes or scan index ranges. (e.g. 0:1;1:2~6,8;2:,3:24~30)'
        value = self.__scans( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scans': value},{'scans': self.__schema['scans']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('scans',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __ignore_time_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__ignore_time_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'All the rows of the tables Feed, History, Pointing, Source, SysCal, CalDevice, SysPower, and Weather are processed independently of the time range of the selected exec block / scan.'
        value = self.__ignore_time( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'ignore_time': value},{'ignore_time': self.__schema['ignore_time']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('ignore_time',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __process_syspower_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__process_syspower_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Process the SysPower table?'
        value = self.__process_syspower( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'process_syspower': value},{'process_syspower': self.__schema['process_syspower']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('process_syspower',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __process_caldevice_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__process_caldevice_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Process the CalDevice table?'
        value = self.__process_caldevice( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'process_caldevice': value},{'process_caldevice': self.__schema['process_caldevice']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('process_caldevice',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __process_pointing_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__process_pointing_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Process the Pointing table?'
        value = self.__process_pointing( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'process_pointing': value},{'process_pointing': self.__schema['process_pointing']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('process_pointing',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __process_flags_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__process_flags_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Create online flags in the FLAG_CMD sub-table?'
        value = self.__process_flags( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'process_flags': value},{'process_flags': self.__schema['process_flags']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-24.24s =\x1B[0m %s%-23s%s' % ('process_flags',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __tbuff_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__tbuff_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__tbuff_dflt( self.__globals_( ) ) is not None:
             description = 'Time padding buffer (seconds)'
             value = self.__tbuff( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'tbuff': value},{'tbuff': self.__schema['tbuff']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('tbuff',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __applyflags_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__applyflags_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__applyflags_dflt( self.__globals_( ) ) is not None:
             description = 'Apply the flags to the MS.'
             value = self.__applyflags( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'applyflags': value},{'applyflags': self.__schema['applyflags']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('applyflags',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __savecmds_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__savecmds_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__savecmds_dflt( self.__globals_( ) ) is not None:
             description = 'Save flag commands to an ASCII file'
             value = self.__savecmds( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'savecmds': value},{'savecmds': self.__schema['savecmds']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('savecmds',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __outfile_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__outfile_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__outfile_dflt( self.__globals_( ) ) is not None:
             description = 'Name of ASCII file to save flag commands'
             value = self.__outfile( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'outfile': value},{'outfile': self.__schema['outfile']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-21.21s =\x1B[0m %s%-23s%s' % ('outfile',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __flagbackup_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__flagbackup_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Back up flag column before applying flags.'
        value = self.__flagbackup( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'flagbackup': value},{'flagbackup': self.__schema['flagbackup']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('flagbackup',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __verbose_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__verbose_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Output lots of information while the filler is working'
        value = self.__verbose( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'verbose': value},{'verbose': self.__schema['verbose']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('verbose',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __overwrite_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__overwrite_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Over write an existing MS(s)'
        value = self.__overwrite( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'overwrite': value},{'overwrite': self.__schema['overwrite']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('overwrite',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __bdfflags_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__bdfflags_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Set the MS FLAG column according to the ASDM _binary_ flags'
        value = self.__bdfflags( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'bdfflags': value},{'bdfflags': self.__schema['bdfflags']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('bdfflags',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __with_pointing_correction_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__with_pointing_correction_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Add (ASDM::Pointing::encoder - ASDM::Pointing::pointingDirection) to the value to be written in MS::Pointing::direction'
        value = self.__with_pointing_correction( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'with_pointing_correction': value},{'with_pointing_correction': self.__schema['with_pointing_correction']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('with_pointing_correction',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __convert_ephem2geo_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__convert_ephem2geo_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'if True, convert any attached ephemerides to the GEO reference frame (time-spacing not changed)'
        value = self.__convert_ephem2geo( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'convert_ephem2geo': value},{'convert_ephem2geo': self.__schema['convert_ephem2geo']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('convert_ephem2geo',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __polyephem_tabtimestep_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__polyephem_tabtimestep_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.)
        description = 'Timestep (days) for the tabulation of polynomial ephemerides. A value <= 0 sets the timestep to 0.001 days.'
        value = self.__polyephem_tabtimestep( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'polyephem_tabtimestep': value},{'polyephem_tabtimestep': self.__schema['polyephem_tabtimestep']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-24.24s = %s%-23s%s' % ('polyephem_tabtimestep',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'process_flags' in glb: del glb['process_flags']
        if 'lazy' in glb: del glb['lazy']
        if 'outfile' in glb: del glb['outfile']
        if 'srt' in glb: del glb['srt']
        if 'corr_mode' in glb: del glb['corr_mode']
        if 'asis' in glb: del glb['asis']
        if 'ignore_time' in glb: del glb['ignore_time']
        if 'time_sampling' in glb: del glb['time_sampling']
        if 'numsubms' in glb: del glb['numsubms']
        if 'verbose' in glb: del glb['verbose']
        if 'polyephem_tabtimestep' in glb: del glb['polyephem_tabtimestep']
        if 'compression' in glb: del glb['compression']
        if 'createmms' in glb: del glb['createmms']
        if 'with_pointing_correction' in glb: del glb['with_pointing_correction']
        if 'vis' in glb: del glb['vis']
        if 'scans' in glb: del glb['scans']
        if 'process_syspower' in glb: del glb['process_syspower']
        if 'ocorr_mode' in glb: del glb['ocorr_mode']
        if 'wvr_corrected_data' in glb: del glb['wvr_corrected_data']
        if 'process_pointing' in glb: del glb['process_pointing']
        if 'bdfflags' in glb: del glb['bdfflags']
        if 'convert_ephem2geo' in glb: del glb['convert_ephem2geo']
        if 'overwrite' in glb: del glb['overwrite']
        if 'applyflags' in glb: del glb['applyflags']
        if 'process_caldevice' in glb: del glb['process_caldevice']
        if 'asdm' in glb: del glb['asdm']
        if 'tbuff' in glb: del glb['tbuff']
        if 'flagbackup' in glb: del glb['flagbackup']
        if 'separationaxis' in glb: del glb['separationaxis']
        if 'savecmds' in glb: del glb['savecmds']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# importasdm -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__asdm_inp( )
        self.__vis_inp( )
        self.__createmms_inp( )
        self.__separationaxis_inp( )
        self.__numsubms_inp( )
        self.__corr_mode_inp( )
        self.__srt_inp( )
        self.__time_sampling_inp( )
        self.__ocorr_mode_inp( )
        self.__compression_inp( )
        self.__lazy_inp( )
        self.__asis_inp( )
        self.__wvr_corrected_data_inp( )
        self.__scans_inp( )
        self.__ignore_time_inp( )
        self.__process_syspower_inp( )
        self.__process_caldevice_inp( )
        self.__process_pointing_inp( )
        self.__process_flags_inp( )
        self.__tbuff_inp( )
        self.__applyflags_inp( )
        self.__savecmds_inp( )
        self.__outfile_inp( )
        self.__flagbackup_inp( )
        self.__verbose_inp( )
        self.__overwrite_inp( )
        self.__bdfflags_inp( )
        self.__with_pointing_correction_inp( )
        self.__convert_ephem2geo_inp( )
        self.__polyephem_tabtimestep_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "importasdm.last" if os.path.isfile("importasdm.last") else "importasdm.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('importasdm.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['asdm'] = self.__asdm( self.__globals_( ) )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['createmms'] = self.__createmms( self.__globals_( ) )
        _invocation_parameters['separationaxis'] = self.__separationaxis( self.__globals_( ) )
        _invocation_parameters['numsubms'] = self.__numsubms( self.__globals_( ) )
        _invocation_parameters['corr_mode'] = self.__corr_mode( self.__globals_( ) )
        _invocation_parameters['srt'] = self.__srt( self.__globals_( ) )
        _invocation_parameters['time_sampling'] = self.__time_sampling( self.__globals_( ) )
        _invocation_parameters['ocorr_mode'] = self.__ocorr_mode( self.__globals_( ) )
        _invocation_parameters['compression'] = self.__compression( self.__globals_( ) )
        _invocation_parameters['lazy'] = self.__lazy( self.__globals_( ) )
        _invocation_parameters['asis'] = self.__asis( self.__globals_( ) )
        _invocation_parameters['wvr_corrected_data'] = self.__wvr_corrected_data( self.__globals_( ) )
        _invocation_parameters['scans'] = self.__scans( self.__globals_( ) )
        _invocation_parameters['ignore_time'] = self.__ignore_time( self.__globals_( ) )
        _invocation_parameters['process_syspower'] = self.__process_syspower( self.__globals_( ) )
        _invocation_parameters['process_caldevice'] = self.__process_caldevice( self.__globals_( ) )
        _invocation_parameters['process_pointing'] = self.__process_pointing( self.__globals_( ) )
        _invocation_parameters['process_flags'] = self.__process_flags( self.__globals_( ) )
        _invocation_parameters['tbuff'] = self.__tbuff( self.__globals_( ) )
        _invocation_parameters['applyflags'] = self.__applyflags( self.__globals_( ) )
        _invocation_parameters['savecmds'] = self.__savecmds( self.__globals_( ) )
        _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
        _invocation_parameters['flagbackup'] = self.__flagbackup( self.__globals_( ) )
        _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )
        _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
        _invocation_parameters['bdfflags'] = self.__bdfflags( self.__globals_( ) )
        _invocation_parameters['with_pointing_correction'] = self.__with_pointing_correction( self.__globals_( ) )
        _invocation_parameters['convert_ephem2geo'] = self.__convert_ephem2geo( self.__globals_( ) )
        _invocation_parameters['polyephem_tabtimestep'] = self.__polyephem_tabtimestep( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-24s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#importasdm( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, asdm=None, vis=None, createmms=None, separationaxis=None, numsubms=None, corr_mode=None, srt=None, time_sampling=None, ocorr_mode=None, compression=None, lazy=None, asis=None, wvr_corrected_data=None, scans=None, ignore_time=None, process_syspower=None, process_caldevice=None, process_pointing=None, process_flags=None, tbuff=None, applyflags=None, savecmds=None, outfile=None, flagbackup=None, verbose=None, overwrite=None, bdfflags=None, with_pointing_correction=None, convert_ephem2geo=None, polyephem_tabtimestep=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('importasdm.pre')
        _postfile = os.path.realpath('importasdm.last')
        task_result = None
        _arguments = [asdm,vis,createmms,separationaxis,numsubms,corr_mode,srt,time_sampling,ocorr_mode,compression,lazy,asis,wvr_corrected_data,scans,ignore_time,process_syspower,process_caldevice,process_pointing,process_flags,tbuff,applyflags,savecmds,outfile,flagbackup,verbose,overwrite,bdfflags,with_pointing_correction,convert_ephem2geo,polyephem_tabtimestep]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if asdm is not None: local_global['asdm'] = asdm
            if vis is not None: local_global['vis'] = vis
            if createmms is not None: local_global['createmms'] = createmms
            if corr_mode is not None: local_global['corr_mode'] = corr_mode
            if srt is not None: local_global['srt'] = srt
            if time_sampling is not None: local_global['time_sampling'] = time_sampling
            if ocorr_mode is not None: local_global['ocorr_mode'] = ocorr_mode
            if compression is not None: local_global['compression'] = compression
            if lazy is not None: local_global['lazy'] = lazy
            if asis is not None: local_global['asis'] = asis
            if wvr_corrected_data is not None: local_global['wvr_corrected_data'] = wvr_corrected_data
            if scans is not None: local_global['scans'] = scans
            if ignore_time is not None: local_global['ignore_time'] = ignore_time
            if process_syspower is not None: local_global['process_syspower'] = process_syspower
            if process_caldevice is not None: local_global['process_caldevice'] = process_caldevice
            if process_pointing is not None: local_global['process_pointing'] = process_pointing
            if process_flags is not None: local_global['process_flags'] = process_flags
            if flagbackup is not None: local_global['flagbackup'] = flagbackup
            if verbose is not None: local_global['verbose'] = verbose
            if overwrite is not None: local_global['overwrite'] = overwrite
            if bdfflags is not None: local_global['bdfflags'] = bdfflags
            if with_pointing_correction is not None: local_global['with_pointing_correction'] = with_pointing_correction
            if convert_ephem2geo is not None: local_global['convert_ephem2geo'] = convert_ephem2geo
            if polyephem_tabtimestep is not None: local_global['polyephem_tabtimestep'] = polyephem_tabtimestep

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['asdm'] = self.__asdm( local_global )
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['createmms'] = self.__createmms( local_global )
            _invocation_parameters['corr_mode'] = self.__corr_mode( local_global )
            _invocation_parameters['srt'] = self.__srt( local_global )
            _invocation_parameters['time_sampling'] = self.__time_sampling( local_global )
            _invocation_parameters['ocorr_mode'] = self.__ocorr_mode( local_global )
            _invocation_parameters['compression'] = self.__compression( local_global )
            _invocation_parameters['lazy'] = self.__lazy( local_global )
            _invocation_parameters['asis'] = self.__asis( local_global )
            _invocation_parameters['wvr_corrected_data'] = self.__wvr_corrected_data( local_global )
            _invocation_parameters['scans'] = self.__scans( local_global )
            _invocation_parameters['ignore_time'] = self.__ignore_time( local_global )
            _invocation_parameters['process_syspower'] = self.__process_syspower( local_global )
            _invocation_parameters['process_caldevice'] = self.__process_caldevice( local_global )
            _invocation_parameters['process_pointing'] = self.__process_pointing( local_global )
            _invocation_parameters['process_flags'] = self.__process_flags( local_global )
            _invocation_parameters['flagbackup'] = self.__flagbackup( local_global )
            _invocation_parameters['verbose'] = self.__verbose( local_global )
            _invocation_parameters['overwrite'] = self.__overwrite( local_global )
            _invocation_parameters['bdfflags'] = self.__bdfflags( local_global )
            _invocation_parameters['with_pointing_correction'] = self.__with_pointing_correction( local_global )
            _invocation_parameters['convert_ephem2geo'] = self.__convert_ephem2geo( local_global )
            _invocation_parameters['polyephem_tabtimestep'] = self.__polyephem_tabtimestep( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['separationaxis'] = self.__separationaxis( _invocation_parameters ) if separationaxis is None else separationaxis
            _invocation_parameters['numsubms'] = self.__numsubms( _invocation_parameters ) if numsubms is None else numsubms
            _invocation_parameters['tbuff'] = self.__tbuff( _invocation_parameters ) if tbuff is None else tbuff
            _invocation_parameters['applyflags'] = self.__applyflags( _invocation_parameters ) if applyflags is None else applyflags
            _invocation_parameters['savecmds'] = self.__savecmds( _invocation_parameters ) if savecmds is None else savecmds
            _invocation_parameters['outfile'] = self.__outfile( _invocation_parameters ) if outfile is None else outfile

        else:
            # invoke with inp/go semantics
            _invocation_parameters['asdm'] = self.__asdm( self.__globals_( ) )
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['createmms'] = self.__createmms( self.__globals_( ) )
            _invocation_parameters['separationaxis'] = self.__separationaxis( self.__globals_( ) )
            _invocation_parameters['numsubms'] = self.__numsubms( self.__globals_( ) )
            _invocation_parameters['corr_mode'] = self.__corr_mode( self.__globals_( ) )
            _invocation_parameters['srt'] = self.__srt( self.__globals_( ) )
            _invocation_parameters['time_sampling'] = self.__time_sampling( self.__globals_( ) )
            _invocation_parameters['ocorr_mode'] = self.__ocorr_mode( self.__globals_( ) )
            _invocation_parameters['compression'] = self.__compression( self.__globals_( ) )
            _invocation_parameters['lazy'] = self.__lazy( self.__globals_( ) )
            _invocation_parameters['asis'] = self.__asis( self.__globals_( ) )
            _invocation_parameters['wvr_corrected_data'] = self.__wvr_corrected_data( self.__globals_( ) )
            _invocation_parameters['scans'] = self.__scans( self.__globals_( ) )
            _invocation_parameters['ignore_time'] = self.__ignore_time( self.__globals_( ) )
            _invocation_parameters['process_syspower'] = self.__process_syspower( self.__globals_( ) )
            _invocation_parameters['process_caldevice'] = self.__process_caldevice( self.__globals_( ) )
            _invocation_parameters['process_pointing'] = self.__process_pointing( self.__globals_( ) )
            _invocation_parameters['process_flags'] = self.__process_flags( self.__globals_( ) )
            _invocation_parameters['tbuff'] = self.__tbuff( self.__globals_( ) )
            _invocation_parameters['applyflags'] = self.__applyflags( self.__globals_( ) )
            _invocation_parameters['savecmds'] = self.__savecmds( self.__globals_( ) )
            _invocation_parameters['outfile'] = self.__outfile( self.__globals_( ) )
            _invocation_parameters['flagbackup'] = self.__flagbackup( self.__globals_( ) )
            _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )
            _invocation_parameters['overwrite'] = self.__overwrite( self.__globals_( ) )
            _invocation_parameters['bdfflags'] = self.__bdfflags( self.__globals_( ) )
            _invocation_parameters['with_pointing_correction'] = self.__with_pointing_correction( self.__globals_( ) )
            _invocation_parameters['convert_ephem2geo'] = self.__convert_ephem2geo( self.__globals_( ) )
            _invocation_parameters['polyephem_tabtimestep'] = self.__polyephem_tabtimestep( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-24s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#importasdm( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'importasdm', [ 'asdm=' + repr(_pc.document['asdm']), 'vis=' + repr(_pc.document['vis']), 'createmms=' + repr(_pc.document['createmms']), 'separationaxis=' + repr(_pc.document['separationaxis']), 'numsubms=' + repr(_pc.document['numsubms']), 'corr_mode=' + repr(_pc.document['corr_mode']), 'srt=' + repr(_pc.document['srt']), 'time_sampling=' + repr(_pc.document['time_sampling']), 'ocorr_mode=' + repr(_pc.document['ocorr_mode']), 'compression=' + repr(_pc.document['compression']), 'lazy=' + repr(_pc.document['lazy']), 'asis=' + repr(_pc.document['asis']), 'wvr_corrected_data=' + repr(_pc.document['wvr_corrected_data']), 'scans=' + repr(_pc.document['scans']), 'ignore_time=' + repr(_pc.document['ignore_time']), 'process_syspower=' + repr(_pc.document['process_syspower']), 'process_caldevice=' + repr(_pc.document['process_caldevice']), 'process_pointing=' + repr(_pc.document['process_pointing']), 'process_flags=' + repr(_pc.document['process_flags']), 'tbuff=' + repr(_pc.document['tbuff']), 'applyflags=' + repr(_pc.document['applyflags']), 'savecmds=' + repr(_pc.document['savecmds']), 'outfile=' + repr(_pc.document['outfile']), 'flagbackup=' + repr(_pc.document['flagbackup']), 'verbose=' + repr(_pc.document['verbose']), 'overwrite=' + repr(_pc.document['overwrite']), 'bdfflags=' + repr(_pc.document['bdfflags']), 'with_pointing_correction=' + repr(_pc.document['with_pointing_correction']), 'convert_ephem2geo=' + repr(_pc.document['convert_ephem2geo']), 'polyephem_tabtimestep=' + repr(_pc.document['polyephem_tabtimestep']) ] )
            task_result = _importasdm_t( _pc.document['asdm'],_pc.document['vis'],_pc.document['createmms'],_pc.document['separationaxis'],_pc.document['numsubms'],_pc.document['corr_mode'],_pc.document['srt'],_pc.document['time_sampling'],_pc.document['ocorr_mode'],_pc.document['compression'],_pc.document['lazy'],_pc.document['asis'],_pc.document['wvr_corrected_data'],_pc.document['scans'],_pc.document['ignore_time'],_pc.document['process_syspower'],_pc.document['process_caldevice'],_pc.document['process_pointing'],_pc.document['process_flags'],_pc.document['tbuff'],_pc.document['applyflags'],_pc.document['savecmds'],_pc.document['outfile'],_pc.document['flagbackup'],_pc.document['verbose'],_pc.document['overwrite'],_pc.document['bdfflags'],_pc.document['with_pointing_correction'],_pc.document['convert_ephem2geo'],_pc.document['polyephem_tabtimestep'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('importasdm')
            casalog.post("Exception Reported: Error in importasdm: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'importasdm', task_result )

        #Added if _importasdm_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

importasdm = _importasdm( )

