##################### generated by xml-casa (v2) from deconvolve.xml ################
##################### 70265d8023e9665dfb4675bd32a692f9 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_deconvolve import deconvolve as _deconvolve_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _deconvolve:
    """
    deconvolve ---- Image-domain deconvolution

    Task deconvolve executes image-domain deconvolution with options for automasking and restoration. It can be viewed as the minor cycle of the iterative image reconstruction offered by the tclean task. The functionality that it introduces is the ability to just run the deconvolution step alone.
    

    --------- parameter descriptions ---------------------------------------------

    imagename         Pre-name of input and output images
                      example : imagename='try'
                      
                      Input images (* = required):
                      
                      try.psf*        - The point spread function
                      try.residual*   - The observed (or residual) image, such as one
                                        generated by tclean
                      try.model       - An existing model image from a previous run of
                                        tclean or deconvolve
                      try.mask        - A pre-defined mask to be either used directly or 
                                        combined with additional masking options
                      try.pb          - Primary beam model, if required for masking settings
                      
                      Output images:
                      
                      try.model       - A new or updated model image
                      try.residual    - An updated residual image
                      try.image       - A restored image, created only when restoration=True
                      try.mask        - The output mask
                      try.prev.mask   - An intermediate by-product of automasking
                                        (when usemask='auto-multithresh')
                      
                      For multi-term wideband imaging, all relevant images above will
                      have additional .tt0,.tt1, etc suffixes to indicate Taylor terms,
                      plus the following extra input images.
                      try.alpha       - spectral index
                      try.alpha.error - estimate of error on spectral index
                      try.beta        - spectral curvature (if nterms > 2)
                      
                      Tip :  Include a directory name in 'imagename' for all
                             output images to be sent there instead of the
                             current working directory : imagename='mydir/try'
                      
                      Tip :  Restarting a deconvolution run without changing 'imagename'
                             implies continuation from the existing model image on disk.
                             By default, the residual image will be recomputed.
                      
                      Note : All deconvolution runs will by default produce restored images.
                             For a niter=0 run, this will be redundant and can optionally
                             be turned off via the 'restoration=T/F' parameter.
                             
                      Note : All input/output images should be 4D image cubes with axes
                             [ra,dec,pol,chan], as is the default for the task tclean. Any input
                             images without this format must be modified (eg with imregrid,
                             imtrans, image.adddegaxes) in order to be accepted.
    startmodel        Name of starting model image
                      
                      The contents of the supplied starting model image will be
                      copied to the imagename.model before the run begins.
                      
                      example : startmodel = 'singledish.im'
                      
                      For deconvolver='mtmfs', one image per Taylor term must be provided.
                      example : startmodel = ['try.model.tt0', 'try.model.tt1']
                                startmodel = ['try.model.tt0']  will use a starting model only
                                                     for the zeroth order term.
                                startmodel = ['','try.model.tt1']  will use a starting model only
                                                     for the first order term.
                      
                      This starting model can be of a different image shape and size from
                      what is currently being imaged. If so, an image regrid is first triggered
                      to resample the input image onto the target coordinate system.
                      
                      If the startmodel is supplied, but a copy of of the destination
                      imagename.model already exists, deconvolve will exit with an error.
                      
                      A common usage is to set this parameter equal to a single dish image
                      
                      Negative components in the model image will be included as is.
    deconvolver       Name of minor cycle algorithm (hogbom,clark,multiscale,mem,clarkstokes,asp)
                      
                       Each of the following algorithms operate on residual images and psfs
                       from the gridder and produce output model and restored images.
                       Minor cycles stop when threshold or niter are reached. For all
                       methods, components are picked from the entire extent of the image or
                       (if specified) within a mask.
                      
                       hogbom : An adapted version of Hogbom Clean [Hogbom, 1974]
                               - Find the location of the peak residual
                               - Add this delta function component to the model image
                               - Subtract a scaled and shifted PSF of the same size as the image
                                 from regions of the residual image where the two overlap.
                               - Repeat
                      
                       clark : An adapted version of Clark Clean [Clark, 1980]
                               - Find the location of max(I^2+Q^2+U^2+V^2)
                               - Add delta functions to each stokes plane of the model image
                               - Subtract a scaled and shifted PSF within a small patch size
                                 from regions of the residual image where the two overlap.
                               - After several iterations trigger a Clark major cycle to subtract
                                 components from the visibility domain, but without de-gridding.
                               - Repeat
                      
                               ( Note : 'clark' maps to imagermode='' in the old clean task.
                                        'clark_exp' is another implementation that maps to
                                         imagermode='mosaic' or 'csclean' in the old clean task
                                         but the behavior is not identical. For now, please
                                         use deconvolver='hogbom' if you encounter problems. )
                      
                       clarkstokes : Clark Clean operating separately per Stokes plane
                      
                               (Note : 'clarkstokes_exp' is an alternate version. See above.)
                      
                       multiscale : MultiScale Clean [Cornwell, 2008]
                               - Smooth the residual image to multiple scale sizes
                               - Find the location and scale at which the peak occurs
                               - Add this multiscale component to the model image
                               - Subtract a scaled,smoothed,shifted PSF (within a small
                                 patch size per scale) from all residual images
                               - Repeat from step 2
                      
                      
                       mem : Maximum Entropy Method [Cornwell and Evans, 1985]
                               - Iteratively solve for values at all individual pixels via the
                                 MEM method. It minimizes an objective function of
                                 chi-square plus entropy (here, a measure of difference
                                 between the current model and a flat prior model).
                      
                               (Note : This MEM implementation is not very robust.
                                            Improvements will be made in the future.)
                      
                      	mtmfs : Multi-term (Multi Scale) Multi-Frequency Synthesis [Rau and Cornwell, 2011]
                                      - Smooth each Taylor residual image to multiple scale sizes
                                      - Solve a NTxNT system of equations per scale size to compute
                                        Taylor coefficients for components at all locations
                                      - Compute gradient chi-square and pick the Taylor coefficients
                                         and scale size at the location with maximum reduction in
                                         chi-square
                                      - Add multi-scale components to each Taylor-coefficient
                                        model image
                                      - Subtract scaled,smoothed,shifted PSF (within a small patch size
                                        per scale) from all smoothed Taylor residual images
                                      - Repeat from step 2
    scales            List of scale sizes (in pixels) for multi-scale and mtmfs algorithms.
                      This set of scale sizes should represent the sizes
                      (diameters in units of number of pixels)
                      of dominant features in the image being reconstructed.
                      
                      The smallest scale size is recommended to be 0 (point source),
                      the second the size of the synthesized beam and the third 3-5
                      times the synthesized beam, etc. For example, if the synthesized
                      beam is 10" FWHM and cell=2",try scales = [0,5,15].
                      
                      For numerical stability, the largest scale must be
                      smaller than the image (or mask) size and smaller than or
                      comparable to the scale corresponding to the lowest measured
                      spatial frequency (as a scale size much larger than what the
                      instrument is sensitive to is unconstrained by the data making
                      it harder to recovery from errors during the minor cycle).
    nterms            Number of Taylor coefficients in the spectral model
                      
                      - nterms=1 : Assume flat spectrum source
                      - nterms=2 : Spectrum is a straight line with a slope
                      - nterms=N : A polynomial of order N-1
                      
                      From a Taylor expansion of the expression of a power law, the
                      spectral index is derived as alpha = taylorcoeff_1 / taylorcoeff_0
                      
                      Spectral curvature is similarly derived when possible.
                      
                      The optimal number of Taylor terms depends on the available
                      signal to noise ratio, bandwidth ratio, and spectral shape of the
                      source as seen by the telescope (sky spectrum x PB spectrum).
                      
                      nterms=2 is a good starting point for wideband EVLA imaging
                      and the lower frequency bands of ALMA (when fractional bandwidth
                      is greater than 10%) and if there is at least one bright source for
                      which a dynamic range of greater than few 100 is desired.
                      
                      Spectral artifacts for the VLA often look like spokes radiating out from
                      a bright source (i.e. in the image made with standard mfs imaging).
                      If increasing the number of terms does not eliminate these artifacts,
                      check the data for inadequate bandpass calibration. If the source is away
                      from the pointing center, consider including wide-field corrections too.
                      
                      (Note : In addition to output Taylor coefficient images .tt0,.tt1,etc
                              images of spectral index (.alpha), an estimate of error on
                              spectral index (.alpha.error) and spectral curvature (.beta,
                              if nterms is greater than 2) are produced.
                              - These alpha, alpha.error and beta images contain
                                internal T/F masks based on a threshold computed
                                as peakresidual/10. Additional masking based on
                                .alpha/.alpha.error may be desirable.
                              - .alpha.error is a purely empirical estimate derived
                                from the propagation of error during the division of
                                two noisy numbers (alpha = xx.tt1/xx.tt0) where the
                                'error' on tt1 and tt0 are simply the values picked from
                                the corresponding residual images. The absolute value
                                of the error is not always accurate and it is best to interpret
                                the errors across the image only in a relative sense.)
    smallscalebias    A numerical control to bias the scales when using multi-scale or mtmfs algorithms.
                      The peak from each scale's smoothed residual is
                      multiplied by ( 1 - smallscalebias * scale/maxscale )
                      to increase or decrease the amplitude relative to other scales,
                      before the scale with the largest peak is chosen. 
                      Smallscalebias can be varied between -1.0 and 1.0. 
                      A score of 0.0 gives all scales equal weight (default). 
                      A score larger than 0.0 will bias the solution towards smaller scales. 
                      A score smaller than 0.0 will bias the solution towards larger scales.
                      The effect of smallscalebias is more pronounced when using multi-scale relative to mtmfs.
    fusedthreshold    g Hogbom Clean (number in units of Jy)
                      
                      fusedthreshold = 0.0001  : 0.1 mJy
                      
                      This is a subparameter of the Asp Clean deconvolver. When peak residual 
                      is lower than the threshold, Asp Clean is "switched to Hogbom Clean" (i.e. only use the 0 scale for cleaning) for 
                      the following number of iterations until it switches back to Asp Clean.
                      
                      NumberIterationsInHogbom = 50 + 2 * (exp(0.05 * NthHogbom) - 1)
                      
                      , where NthHogbom is the number of times Hogbom Clean has been triggered. 
                      
                      When the Asp Clean detects it is approaching convergence, it uses only the 0 scale for the following number of iterations for better computational efficiency. 
                      
                      NumberIterationsInHogbom = 500 + 2 * (exp(0.05 * NthHogbom) - 1)
    largestscale      s) allowed for the initial guess for the Asp Clean deconvolver.
                      
                      largestscale = 100
                      
                      The default initial scale sizes used by Asp Clean is [0, w, 2w, 4w, 8w], 
                      where `w` is the PSF width. The default `largestscale` is -1 which indicates 
                      users accept these initial scales. If `largestscale` is set, the initial scales 
                      would be [0, w, ... up to the `largestscale`]. This is only an initial guess,
                      and actual fitted scale sizes may evolve from these initial values.
                      
                      It is recommended not to set `largestscale` unless Asp Clean picks a large 
                      scale that has no constraints from the data (the UV hole issue).
    restoration       .
                      
                      Construct a restored image : imagename.image by convolving the model
                      image with a clean beam and adding the residual image to the result.
                      If a restoringbeam is specified, the residual image is also
                      smoothed to that target resolution before adding it in.
                      
                      If a .model does not exist, it will make an empty one and create
                      the restored image from the residuals ( with additional smoothing if needed ).
                      With algorithm='mtmfs', this will construct Taylor coefficient maps from
                      the residuals and compute .alpha and .alpha.error.
    restoringbeam     ze to use.
                      
                      - restoringbeam='' or ['']
                        A Gaussian fitted to the PSF main lobe (separately per image plane).
                      
                      - restoringbeam='10.0arcsec'
                        Use a circular Gaussian of this width for all planes
                      
                      - restoringbeam=['8.0arcsec','10.0arcsec','45deg']
                        Use this elliptical Gaussian for all planes
                      
                      - restoringbeam='common'
                        Automatically estimate a common beam shape/size appropriate for
                        all planes.
                      
                      Note : For any restoring beam different from the native resolution
                             the model image is convolved with the beam and added to
                             residuals that have been convolved to the same target resolution.
    niter             Maximum number of iterations
                      
                      A stopping criterion based on total iteration count.
                      Currently the parameter type is defined as an integer therefore the integer value 
                      larger than 2147483647 will not be set properly as it causes an overflow.
                      
                      Iterations are typically defined as the selecting one flux component
                      and partially subtracting it out from the residual image.
                      
                      niter=0 : Skip the deconvolution step (only do restoration)
                      
                      niter larger than zero : The minor cycle.
                      
                      Note :  The following additional triggers will also stop minor cycle
                              iterations. Whichever condition is triggered first stops the minor
                              cycle.
                      
                              'threshold' : The parameter value, compared to peak residual.
                              Divergence :  As detected by an increase of 10% in peak residual from
                                            the minimum so far (during minor cycle iterations).
                              
                              The first criterion to be satisfied takes precedence.
                      
                      Note :  Iteration counts for cubes or multi-field images :
                              For images with multiple planes (or image fields) on which the
                              deconvolver operates in sequence, iterations are counted across
                              all planes (or image fields). The iteration count is compared with
                              'niter' only after all channels/planes/fields have completed their
                              minor cycles and exited either due to 'niter' or 'threshold'.
                              Therefore, the actual number of iterations reported in the logger
                              can sometimes be larger than the user specified value in 'niter'.
                              For example, with niter=100, nchan=10,threshold=0,
                              a total of 1000 iterations will be done in the first set of minor cycles
                              before the total is compared with niter=100 and it exits.
    gain              Loop gain
                      
                      Fraction of the source flux to subtract out of the residual image
                      for the CLEAN algorithm and its variants.
                      
                      A low value (0.2 or less) is recommended when the sky brightness
                      distribution is not well represented by the basis functions used by
                      the chosen deconvolution algorithm. A higher value can be tried when
                      there is a good match between the true sky brightness structure and
                      the basis function shapes.  For example, for extended emission,
                      multiscale clean with an appropriate set of scale sizes will tolerate
                      a higher loop gain than Clark clean (for example).
    threshold         The minor cycle's stopping threshold (number in units of Jy, or string)
                      
                      threshold = 0.005  : 5mJy
                      threshold = '5.0mJy'
                             
                      Note : If nsigma is set (>0.0), the N-sigma threshold is calculated (see
                             the description under nsigma). Then threshold is modified as:
                             
                             threshold = max( threshold, nsgima_threshold )
    nsigma            Multiplicative factor for rms-based threshold stopping
                      
                      N-sigma threshold is calculated as nsigma * rms value per image plane determined
                      from a robust statistics. For nsigma > 0.0, in a minor cycle, a maximum of the two values,
                      the N-sigma threshold and threshold, is used as a stopping trigger
                      (see also the descreption under 'threshold').
                      Set nsigma=0.0 to preserve the previous deconvolve behavior without this feature.
                      The top level parameter, fastnoise is relevant for the rms noise calculation which is used 
                      to determine the threshold.
    interactive       Modify masks and parameters at runtime
                      
                      interactive=True will trigger an interactive GUI after deconvolution finishes.
                      
                      Options for runtime parameter modification are :
                      
                      Interactive clean mask : Draw a 1/0 mask (appears as a contour) by hand.
                                               If a mask is supplied at the task interface or if
                                               automasking is invoked, the current mask is
                                               displayed in the GUI and is available for manual
                                               editing.
                                               
                                               Note : If a mask contour is not visible, please
                                                          check the cursor display at the bottom of
                                                          GUI to see which parts of the mask image
                                                          have ones and zeros. If the entire mask=1
                                                          no contours will be visible.
                      
                      
                      Operation buttons : -- For the task deconvolve, all options stop the minor cycle.
                      
                      Iteration control : -- max cycleniter :  For task deconvolve, this contol has no effect.
                                          -- iterations left : Sets the limit on the number of iterations
                                                               about to be done.
                                          -- threshold :       Sets the peak residual stopping threshold for
                                                               for this execution of deconvolve.
    fullsummary       Return dictionary with complete convergence history 
                      
                      fullsummary=True: A full version of the summary dictionary is returned.
                      Keys include 'iterDone','peakRes','modelFlux','cycleThresh' that record the
                      convergence state at the end of each set of minor cycle iterations
                      separately for each image plane (i.e. channel/stokes) being
                      deconvolved. Additional keys report the convergence state at the 
                      start of minor cycle iterations, stopping criteria that triggered major 
                      cycles, and a processor ID per channel, for parallel cube runs.
                      
                      fullsummary=False (default): A shorten version of the summary dictionary is returned
                      with only 'iterDone','peakRes','modelFlux', and 'cycleThresh'.
                      
                      Detailed  information about the return dictionary fields may be found 
                      at CASA Docs > Synthesis Imaging > Iteration Control > Returned Dictionary.
    fastnoise         mask (user='multi-autothresh') and/or n-sigma stopping threshold
                      (nsigma>0.0) are/is used. If it is set to True,  a simpler but faster noise calucation is used. 
                      In this case, the threshold values are determined based on classic statistics (using all
                      unmasked pixels for the calculations).
                      
                      If it is set to False,  the new noise calculation
                      method is used based on pre-existing mask.   
                      
                      Case 1: no exiting mask
                      Calculate image statistics using Chauvenet algorithm 
                      
                      Case 2: there is an existing mask
                      Calculate image statistics by classical method on the region
                      outside the mask and inside the primary beam mask.
                      
                      In all cases above RMS noise is calculated from MAD.
    usemask           Type of mask(s) to be used for deconvolution
                      
                      user: (default) mask image(s) or user specified region file(s) or string CRTF expression(s)
                            subparameters: mask, pbmask
                      pb: primary beam mask
                            subparameter: pbmask
                            
                            Example: usemask="pb", pbmask=0.2
                                            Construct a mask at the 0.2 pb gain level.
                                            (Currently, this option will work only with
                                            gridders that produce .pb (i.e. mosaic and awproject)
                                            or if an externally produced .pb image exists on disk)
                          
                      auto-multithresh : auto-masking by multiple thresholds for deconvolution
                            subparameters : sidelobethreshold, noisethreshold, lownoisethreshold,
                                            negativethrehsold,  smoothfactor, minbeamfrac, cutthreshold,
                                            pbmask, growiterations, dogrowprune, minpercentchange, verbose
                            Additional top level parameter relevant to auto-multithresh: fastnoise
                      
                      
                      
                      
                      Note: By default the intermediate mask generated by automask at each deconvolution cycle
                            is over-written in the next cycle but one can save them by setting
                            the environment variable, SAVE_ALL_AUTOMASKS="true".
                            (e.g. in the CASA prompt, os.environ['SAVE_ALL_AUTOMASKS']="true" )
                            The saved CASA mask image name will be imagename.mask.autothresh#, where
                            # is the iteration cycle number.
    mask              Mask (a list of image name(s) or region file(s) or region string(s)
                      
                      
                                          The name of a CASA image or region file or region string that specifies
                                          a 1/0 mask to be used for deconvolution. Only locations with value 1 will
                                          be considered for the centers of flux components in the minor cycle.
                                          If regions specified fall completely outside of the image, deconvolve will throw an error.
                      
                                          Manual mask options/examples :
                      
                                          mask='xxx.mask'  : Use this CASA image named xxx.mask and containing
                                                             ones and zeros as the mask. 
                                                             If the mask is only different in spatial coordinates from what is being made 
                                                             it will be resampled to the target coordinate system before being used.
                                                             The mask has to have the same shape in velocity and Stokes planes
                                                             as the output image. Exceptions are single velocity and/or single
                                                             Stokes plane masks. They will be expanded to cover all velocity and/or
                                                             Stokes planes of the output cube.
                                                             
                                                             [ Note : If an error occurs during image resampling or
                                                                      if the expected mask does not appear, please try
                                                                      using tasks 'imregrid' or 'makemask' to resample
                                                                      the mask image onto a CASA image with the target
                                                                      shape and coordinates and supply it via the 'mask'
                                                                      parameter. ]
                      
                      
                                          mask='xxx.crtf' : A text file with region strings and the following on the first line
                                                               ( #CRTFv0 CASA Region Text Format version 0 )
                                                            This is the format of a file created via the viewer's region
                                                            tool when saved in CASA region file format.
                      
                                          mask='circle[[40pix,40pix],10pix]'  : A CASA region string.
                      
                                          mask=['xxx.mask','xxx.crtf', 'circle[[40pix,40pix],10pix]']  : a list of masks
                      
                      
                      
                      
                      
                                          Note : Mask images for deconvolution must contain 1 or 0 in each pixel.
                                                 Such a mask is different from an internal T/F mask that can be
                                                 held within each CASA image. These two types of masks are not
                                                 automatically interchangeable, so please use the makemask task
                                                 to copy between them if you need to construct a 1/0 based mask
                                                 from a T/F one.
                      
                                          Note : Work is in progress to generate more flexible masking options and
                                                 enable more controls.
    pbmask            Sub-parameter for usemask: primary beam mask
                      
                      Examples : pbmask=0.0 (default, no pb mask)
                                 pbmask=0.2 (construct a mask at the 0.2 pb gain level)
    sidelobethreshold Sub-parameter for "auto-multithresh": mask threshold based on sidelobe levels:
                      sidelobethreshold * max_sidelobe_level * peak residual
    noisethreshold    Sub-parameter for "auto-multithresh": mask threshold based on the noise level:
                      noisethreshold * rms + location (=median)
                      
                      The rms is calculated from MAD with rms = 1.4826*MAD.
    lownoisethreshold Sub-parameter for "auto-multithresh": mask threshold to grow previously masked regions via binary dilation:
                      lownoisethreshold * rms in residual image + location (=median)
                      
                      The rms is calculated from MAD with rms = 1.4826*MAD.
    negativethreshold Sub-parameter for "auto-multithresh": mask threshold for negative features:
                      -1.0* negativethreshold * rms + location(=median)
                      
                      The rms is calculated from MAD with rms = 1.4826*MAD.
    smoothfactor      Sub-parameter for "auto-multithresh": smoothing factor in a unit of the beam
    minbeamfrac       Sub-parameter for "auto-multithresh": minimum beam fraction in size to prune masks smaller than mimbeamfrac * beam
                      <=0.0 : No pruning
    cutthreshold      Sub-parameter for "auto-multithresh": threshold to cut the smoothed mask to create a final mask:
                      cutthreshold * peak of the smoothed mask
    growiterations    Sub-parameter for "auto-multithresh": Maximum number of iterations to perform using binary dilation for growing the mask
    dogrowprune       Experimental sub-parameter for "auto-multithresh": Do pruning on the grow mask
    verbose           he summary of automasking at the end of each automasking process
                      is printed in the logger.  Following information per channel will be listed in the summary.
                      
                      chan: channel number
                      masking?: F - stop updating automask for the subsequent iteration cycles
                      RMS: robust rms noise
                      peak: peak in residual image
                      thresh_type: type of threshold used (noise or sidelobe)
                      thresh_value: the value of threshold used
                      N_reg: number of the automask regions
                      N_pruned: number of the automask regions removed by pruning
                      N_grow: number of the grow mask regions
                      N_grow_pruned: number of the grow mask regions removed by pruning
                      N_neg_pix: number of pixels for negative mask regions
                      
                      Note that for a large cube, extra logging may slow down the process.
    [1;42mRETURNS[1;m              void

    --------- examples -----------------------------------------------------------

    
    
    Please refer to the CASAdocs pages for the task deconvolve for examples.
    
    


    """

    _info_group_ = """imaging"""
    _info_desc_ = """Image-domain deconvolution"""

    __schema = {'imagename': {'anyof': [{'type': 'cInt'}, {'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'startmodel': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'deconvolver': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'clarkstokes_exp', 'mtmfs', 'mem', 'clarkstokes', 'hogbom', 'clark_exp', 'clark', 'asp', 'multiscale' ]}, 'scales': {'anyof': [{'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'nterms': {'type': 'cInt'}, 'smallscalebias': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'fusedthreshold': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'largestscale': {'type': 'cInt'}, 'restoration': {'type': 'cBool'}, 'restoringbeam': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'niter': {'type': 'cInt'}, 'gain': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'threshold': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'nsigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'interactive': {'type': 'cBool'}, 'fullsummary': {'type': 'cBool'}, 'fastnoise': {'type': 'cBool'}, 'usemask': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'user', 'pb', 'auto-multithresh' ]}, 'mask': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'pbmask': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sidelobethreshold': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'noisethreshold': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'lownoisethreshold': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'negativethreshold': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'smoothfactor': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'minbeamfrac': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'cutthreshold': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'growiterations': {'type': 'cInt'}, 'dogrowprune': {'type': 'cBool'}, 'verbose': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 20 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __interactive_dflt( self, glb ):
        return False

    def __interactive( self, glb ):
        if 'interactive' in glb: return glb['interactive']
        return False

    def __startmodel_dflt( self, glb ):
        return ''

    def __startmodel( self, glb ):
        if 'startmodel' in glb: return glb['startmodel']
        return ''

    def __deconvolver_dflt( self, glb ):
        return 'hogbom'

    def __deconvolver( self, glb ):
        if 'deconvolver' in glb: return glb['deconvolver']
        return 'hogbom'

    def __fullsummary_dflt( self, glb ):
        return False

    def __fullsummary( self, glb ):
        if 'fullsummary' in glb: return glb['fullsummary']
        return False

    def __noisethreshold_dflt( self, glb ):
        return float(5.0)

    def __noisethreshold( self, glb ):
        if 'noisethreshold' in glb: return glb['noisethreshold']
        return float(5.0)

    def __niter_dflt( self, glb ):
        return int(100)

    def __niter( self, glb ):
        if 'niter' in glb: return glb['niter']
        return int(100)

    def __usemask_dflt( self, glb ):
        return 'user'

    def __usemask( self, glb ):
        if 'usemask' in glb: return glb['usemask']
        return 'user'

    def __restoration_dflt( self, glb ):
        return True

    def __restoration( self, glb ):
        if 'restoration' in glb: return glb['restoration']
        return True

    def __imagename_dflt( self, glb ):
        return ''

    def __imagename( self, glb ):
        if 'imagename' in glb: return glb['imagename']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __smoothfactor_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return float(1.0)
        return None
    def __negativethreshold_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return float(0.0)
        return None
    def __fusedthreshold_dflt( self, glb ):
        if self.__deconvolver( glb ) == "asp": return float(0.0)
        return None
    def __minbeamfrac_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return float(0.3)
        return None
    def __mask_dflt( self, glb ):
        if self.__usemask( glb ) == "user": return ""
        return None
    def __cutthreshold_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return float(0.01)
        return None
    def __smallscalebias_dflt( self, glb ):
        if self.__deconvolver( glb ) == "multiscale": return float(0.0)
        if self.__deconvolver( glb ) == "mtmfs": return float(0.0)
        return None
    def __verbose_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return bool(False)
        return None
    def __nterms_dflt( self, glb ):
        if self.__deconvolver( glb ) == "mtmfs": return int(2)
        return None
    def __restoringbeam_dflt( self, glb ):
        if self.__restoration( glb ) == bool(True): return []
        return None
    def __sidelobethreshold_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return float(3.0)
        return None
    def __fastnoise_dflt( self, glb ):
        if self.__niter( glb ) != int(0): return bool(True)
        return None
    def __pbmask_dflt( self, glb ):
        if self.__usemask( glb ) == "user": return float(0.0)
        if self.__usemask( glb ) == "pb": return float(0.2)
        if self.__usemask( glb ) == "auto-multithresh": return float(0.2)
        return None
    def __growiterations_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return int(75)
        return None
    def __gain_dflt( self, glb ):
        if self.__niter( glb ) != int(0): return float(0.1)
        return None
    def __scales_dflt( self, glb ):
        if self.__deconvolver( glb ) == "multiscale": return []
        if self.__deconvolver( glb ) == "mtmfs": return []
        return None
    def __largestscale_dflt( self, glb ):
        if self.__deconvolver( glb ) == "asp": return int(-1)
        return None
    def __threshold_dflt( self, glb ):
        if self.__niter( glb ) != int(0): return 0.0
        return None
    def __dogrowprune_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return bool(True)
        return None
    def __lownoisethreshold_dflt( self, glb ):
        if self.__usemask( glb ) == "auto-multithresh": return float(1.5)
        return None
    def __nsigma_dflt( self, glb ):
        if self.__niter( glb ) != int(0): return float(0.0)
        return None

    #--------- return subparam values -------------------------------------------------
    def __scales( self, glb ):
        if 'scales' in glb: return glb['scales']
        dflt = self.__scales_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __nterms( self, glb ):
        if 'nterms' in glb: return glb['nterms']
        dflt = self.__nterms_dflt( glb )
        if dflt is not None: return dflt
        return int(2)
    def __smallscalebias( self, glb ):
        if 'smallscalebias' in glb: return glb['smallscalebias']
        dflt = self.__smallscalebias_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __fusedthreshold( self, glb ):
        if 'fusedthreshold' in glb: return glb['fusedthreshold']
        dflt = self.__fusedthreshold_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __largestscale( self, glb ):
        if 'largestscale' in glb: return glb['largestscale']
        dflt = self.__largestscale_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __restoringbeam( self, glb ):
        if 'restoringbeam' in glb: return glb['restoringbeam']
        dflt = self.__restoringbeam_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __gain( self, glb ):
        if 'gain' in glb: return glb['gain']
        dflt = self.__gain_dflt( glb )
        if dflt is not None: return dflt
        return float(0.1)
    def __threshold( self, glb ):
        if 'threshold' in glb: return glb['threshold']
        dflt = self.__threshold_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __nsigma( self, glb ):
        if 'nsigma' in glb: return glb['nsigma']
        dflt = self.__nsigma_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __fastnoise( self, glb ):
        if 'fastnoise' in glb: return glb['fastnoise']
        dflt = self.__fastnoise_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __mask( self, glb ):
        if 'mask' in glb: return glb['mask']
        dflt = self.__mask_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __pbmask( self, glb ):
        if 'pbmask' in glb: return glb['pbmask']
        dflt = self.__pbmask_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __sidelobethreshold( self, glb ):
        if 'sidelobethreshold' in glb: return glb['sidelobethreshold']
        dflt = self.__sidelobethreshold_dflt( glb )
        if dflt is not None: return dflt
        return float(3.0)
    def __noisethreshold( self, glb ):
        if 'noisethreshold' in glb: return glb['noisethreshold']
        dflt = self.__noisethreshold_dflt( glb )
        if dflt is not None: return dflt
        return float(5.0)
    def __lownoisethreshold( self, glb ):
        if 'lownoisethreshold' in glb: return glb['lownoisethreshold']
        dflt = self.__lownoisethreshold_dflt( glb )
        if dflt is not None: return dflt
        return float(1.5)
    def __negativethreshold( self, glb ):
        if 'negativethreshold' in glb: return glb['negativethreshold']
        dflt = self.__negativethreshold_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __smoothfactor( self, glb ):
        if 'smoothfactor' in glb: return glb['smoothfactor']
        dflt = self.__smoothfactor_dflt( glb )
        if dflt is not None: return dflt
        return float(1.0)
    def __minbeamfrac( self, glb ):
        if 'minbeamfrac' in glb: return glb['minbeamfrac']
        dflt = self.__minbeamfrac_dflt( glb )
        if dflt is not None: return dflt
        return float(0.3)
    def __cutthreshold( self, glb ):
        if 'cutthreshold' in glb: return glb['cutthreshold']
        dflt = self.__cutthreshold_dflt( glb )
        if dflt is not None: return dflt
        return float(0.01)
    def __growiterations( self, glb ):
        if 'growiterations' in glb: return glb['growiterations']
        dflt = self.__growiterations_dflt( glb )
        if dflt is not None: return dflt
        return int(75)
    def __dogrowprune( self, glb ):
        if 'dogrowprune' in glb: return glb['dogrowprune']
        dflt = self.__dogrowprune_dflt( glb )
        if dflt is not None: return dflt
        return True
    def __verbose( self, glb ):
        if 'verbose' in glb: return glb['verbose']
        dflt = self.__verbose_dflt( glb )
        if dflt is not None: return dflt
        return False

    #--------- subparam inp output ----------------------------------------------------
    def __imagename_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__imagename_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Pre-name of input and output images'
        value = self.__imagename( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'imagename': value},{'imagename': self.__schema['imagename']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-20.20s = %s%-23s%s' % ('imagename',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __startmodel_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__startmodel_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of starting model image'
        value = self.__startmodel( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'startmodel': value},{'startmodel': self.__schema['startmodel']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-20.20s = %s%-23s%s' % ('startmodel',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __deconvolver_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__deconvolver_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'hogbom'
        description = 'Minor cycle algorithm (hogbom,clark,multiscale,mtmfs,mem,clarkstokes,asp)'
        value = self.__deconvolver( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'deconvolver': value},{'deconvolver': self.__schema['deconvolver']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-20.20s =\x1B[0m %s%-23s%s' % ('deconvolver',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __scales_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scales_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__scales_dflt( self.__globals_( ) ) is not None:
             description = 'List of scale sizes (in pixels) for multi-scale algorithms'
             value = self.__scales( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scales': value},{'scales': self.__schema['scales']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('scales',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __nterms_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__nterms_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(2)
        if self.__nterms_dflt( self.__globals_( ) ) is not None:
             description = 'Number of Taylor coefficients in the spectral model'
             value = self.__nterms( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'nterms': value},{'nterms': self.__schema['nterms']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('nterms',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __smallscalebias_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__smallscalebias_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__smallscalebias_dflt( self.__globals_( ) ) is not None:
             description = 'Biases the scale selection when using multi-scale or mtmfs deconvolvers'
             value = self.__smallscalebias( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'smallscalebias': value},{'smallscalebias': self.__schema['smallscalebias']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('smallscalebias',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __fusedthreshold_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fusedthreshold_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__fusedthreshold_dflt( self.__globals_( ) ) is not None:
             description = 'Threshold for triggering Hogbom Clean'
             value = self.__fusedthreshold( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fusedthreshold': value},{'fusedthreshold': self.__schema['fusedthreshold']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('fusedthreshold',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __largestscale_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__largestscale_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__largestscale_dflt( self.__globals_( ) ) is not None:
             description = 'Largest scale allowed for the Asp Clean deconvolver'
             value = self.__largestscale( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'largestscale': value},{'largestscale': self.__schema['largestscale']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('largestscale',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __restoration_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__restoration_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Do restoration steps (or not)'
        value = self.__restoration( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'restoration': value},{'restoration': self.__schema['restoration']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-20.20s =\x1B[0m %s%-23s%s' % ('restoration',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __restoringbeam_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__restoringbeam_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__restoringbeam_dflt( self.__globals_( ) ) is not None:
             description = 'Restoring beam shape to use. Default is the PSF main lobe'
             value = self.__restoringbeam( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'restoringbeam': value},{'restoringbeam': self.__schema['restoringbeam']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('restoringbeam',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __niter_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__niter_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(100)
        description = 'Maximum number of iterations'
        value = self.__niter( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'niter': value},{'niter': self.__schema['niter']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-20.20s =\x1B[0m %s%-23s%s' % ('niter',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __gain_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__gain_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.1)
        if self.__gain_dflt( self.__globals_( ) ) is not None:
             description = 'Loop gain'
             value = self.__gain( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'gain': value},{'gain': self.__schema['gain']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('gain',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __threshold_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__threshold_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__threshold_dflt( self.__globals_( ) ) is not None:
             description = 'Stopping threshold'
             value = self.__threshold( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'threshold': value},{'threshold': self.__schema['threshold']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('threshold',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __nsigma_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__nsigma_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__nsigma_dflt( self.__globals_( ) ) is not None:
             description = 'Multiplicative factor for rms-based threshold stopping'
             value = self.__nsigma( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'nsigma': value},{'nsigma': self.__schema['nsigma']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('nsigma',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __interactive_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interactive_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Modify masks and parameters at runtime'
        value = self.__interactive( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interactive': value},{'interactive': self.__schema['interactive']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-20.20s = %s%-23s%s' % ('interactive',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __fullsummary_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fullsummary_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Return dictionary with complete convergence history'
        value = self.__fullsummary( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fullsummary': value},{'fullsummary': self.__schema['fullsummary']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-20.20s = %s%-23s%s' % ('fullsummary',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __fastnoise_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fastnoise_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        if self.__fastnoise_dflt( self.__globals_( ) ) is not None:
             description = 'True: use the faster (old) noise calculation. False: use the new improved noise calculations'
             value = self.__fastnoise( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fastnoise': value},{'fastnoise': self.__schema['fastnoise']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('fastnoise',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __usemask_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__usemask_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'user'
        description = 'Type of mask(s) for deconvolution:  user, pb, or auto-multithresh'
        value = self.__usemask( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'usemask': value},{'usemask': self.__schema['usemask']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-20.20s =\x1B[0m %s%-23s%s' % ('usemask',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __mask_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__mask_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__mask_dflt( self.__globals_( ) ) is not None:
             description = 'Mask (a list of image name(s) or region file(s) or region string(s) )'
             value = self.__mask( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'mask': value},{'mask': self.__schema['mask']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('mask',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __pbmask_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__pbmask_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__pbmask_dflt( self.__globals_( ) ) is not None:
             description = 'primary beam mask'
             value = self.__pbmask( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'pbmask': value},{'pbmask': self.__schema['pbmask']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('pbmask',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __sidelobethreshold_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__sidelobethreshold_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(3.0)
        if self.__sidelobethreshold_dflt( self.__globals_( ) ) is not None:
             description = 'sidelobethreshold *  the max sidelobe level * peak residual'
             value = self.__sidelobethreshold( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'sidelobethreshold': value},{'sidelobethreshold': self.__schema['sidelobethreshold']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('sidelobethreshold',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __noisethreshold_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__noisethreshold_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(5.0)
        if self.__noisethreshold_dflt( self.__globals_( ) ) is not None:
             description = 'noisethreshold * rms in residual image + location(median)'
             value = self.__noisethreshold( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'noisethreshold': value},{'noisethreshold': self.__schema['noisethreshold']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('noisethreshold',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __lownoisethreshold_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__lownoisethreshold_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(1.5)
        if self.__lownoisethreshold_dflt( self.__globals_( ) ) is not None:
             description = 'lownoisethreshold * rms in residual image + location(median)'
             value = self.__lownoisethreshold( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'lownoisethreshold': value},{'lownoisethreshold': self.__schema['lownoisethreshold']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('lownoisethreshold',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __negativethreshold_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__negativethreshold_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__negativethreshold_dflt( self.__globals_( ) ) is not None:
             description = 'negativethreshold * rms in residual image + location(median)'
             value = self.__negativethreshold( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'negativethreshold': value},{'negativethreshold': self.__schema['negativethreshold']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('negativethreshold',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __smoothfactor_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__smoothfactor_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(1.0)
        if self.__smoothfactor_dflt( self.__globals_( ) ) is not None:
             description = 'smoothing factor in a unit of the beam'
             value = self.__smoothfactor( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'smoothfactor': value},{'smoothfactor': self.__schema['smoothfactor']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('smoothfactor',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __minbeamfrac_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minbeamfrac_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.3)
        if self.__minbeamfrac_dflt( self.__globals_( ) ) is not None:
             description = 'minimum beam fraction for pruning'
             value = self.__minbeamfrac( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minbeamfrac': value},{'minbeamfrac': self.__schema['minbeamfrac']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('minbeamfrac',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __cutthreshold_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__cutthreshold_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.01)
        if self.__cutthreshold_dflt( self.__globals_( ) ) is not None:
             description = 'threshold to cut the smoothed mask to create a final mask'
             value = self.__cutthreshold( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'cutthreshold': value},{'cutthreshold': self.__schema['cutthreshold']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('cutthreshold',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __growiterations_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__growiterations_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(75)
        if self.__growiterations_dflt( self.__globals_( ) ) is not None:
             description = 'number of binary dilation iterations for growing the mask'
             value = self.__growiterations( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'growiterations': value},{'growiterations': self.__schema['growiterations']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('growiterations',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __dogrowprune_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__dogrowprune_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        if self.__dogrowprune_dflt( self.__globals_( ) ) is not None:
             description = 'Do pruning on the grow mask'
             value = self.__dogrowprune( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'dogrowprune': value},{'dogrowprune': self.__schema['dogrowprune']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('dogrowprune',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __verbose_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__verbose_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__verbose_dflt( self.__globals_( ) ) is not None:
             description = 'True: print more automasking information in the logger'
             value = self.__verbose( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'verbose': value},{'verbose': self.__schema['verbose']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-17.17s =\x1B[0m %s%-23s%s' % ('verbose',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'smoothfactor' in glb: del glb['smoothfactor']
        if 'negativethreshold' in glb: del glb['negativethreshold']
        if 'deconvolver' in glb: del glb['deconvolver']
        if 'fusedthreshold' in glb: del glb['fusedthreshold']
        if 'minbeamfrac' in glb: del glb['minbeamfrac']
        if 'mask' in glb: del glb['mask']
        if 'cutthreshold' in glb: del glb['cutthreshold']
        if 'smallscalebias' in glb: del glb['smallscalebias']
        if 'verbose' in glb: del glb['verbose']
        if 'nterms' in glb: del glb['nterms']
        if 'restoringbeam' in glb: del glb['restoringbeam']
        if 'sidelobethreshold' in glb: del glb['sidelobethreshold']
        if 'imagename' in glb: del glb['imagename']
        if 'fastnoise' in glb: del glb['fastnoise']
        if 'interactive' in glb: del glb['interactive']
        if 'pbmask' in glb: del glb['pbmask']
        if 'growiterations' in glb: del glb['growiterations']
        if 'gain' in glb: del glb['gain']
        if 'scales' in glb: del glb['scales']
        if 'fullsummary' in glb: del glb['fullsummary']
        if 'largestscale' in glb: del glb['largestscale']
        if 'threshold' in glb: del glb['threshold']
        if 'usemask' in glb: del glb['usemask']
        if 'restoration' in glb: del glb['restoration']
        if 'niter' in glb: del glb['niter']
        if 'dogrowprune' in glb: del glb['dogrowprune']
        if 'lownoisethreshold' in glb: del glb['lownoisethreshold']
        if 'noisethreshold' in glb: del glb['noisethreshold']
        if 'nsigma' in glb: del glb['nsigma']
        if 'startmodel' in glb: del glb['startmodel']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# deconvolve -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__imagename_inp( )
        self.__startmodel_inp( )
        self.__deconvolver_inp( )
        self.__scales_inp( )
        self.__nterms_inp( )
        self.__smallscalebias_inp( )
        self.__fusedthreshold_inp( )
        self.__largestscale_inp( )
        self.__restoration_inp( )
        self.__restoringbeam_inp( )
        self.__niter_inp( )
        self.__gain_inp( )
        self.__threshold_inp( )
        self.__nsigma_inp( )
        self.__interactive_inp( )
        self.__fullsummary_inp( )
        self.__fastnoise_inp( )
        self.__usemask_inp( )
        self.__mask_inp( )
        self.__pbmask_inp( )
        self.__sidelobethreshold_inp( )
        self.__noisethreshold_inp( )
        self.__lownoisethreshold_inp( )
        self.__negativethreshold_inp( )
        self.__smoothfactor_inp( )
        self.__minbeamfrac_inp( )
        self.__cutthreshold_inp( )
        self.__growiterations_inp( )
        self.__dogrowprune_inp( )
        self.__verbose_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "deconvolve.last" if os.path.isfile("deconvolve.last") else "deconvolve.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('deconvolve.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
        _invocation_parameters['startmodel'] = self.__startmodel( self.__globals_( ) )
        _invocation_parameters['deconvolver'] = self.__deconvolver( self.__globals_( ) )
        _invocation_parameters['scales'] = self.__scales( self.__globals_( ) )
        _invocation_parameters['nterms'] = self.__nterms( self.__globals_( ) )
        _invocation_parameters['smallscalebias'] = self.__smallscalebias( self.__globals_( ) )
        _invocation_parameters['fusedthreshold'] = self.__fusedthreshold( self.__globals_( ) )
        _invocation_parameters['largestscale'] = self.__largestscale( self.__globals_( ) )
        _invocation_parameters['restoration'] = self.__restoration( self.__globals_( ) )
        _invocation_parameters['restoringbeam'] = self.__restoringbeam( self.__globals_( ) )
        _invocation_parameters['niter'] = self.__niter( self.__globals_( ) )
        _invocation_parameters['gain'] = self.__gain( self.__globals_( ) )
        _invocation_parameters['threshold'] = self.__threshold( self.__globals_( ) )
        _invocation_parameters['nsigma'] = self.__nsigma( self.__globals_( ) )
        _invocation_parameters['interactive'] = self.__interactive( self.__globals_( ) )
        _invocation_parameters['fullsummary'] = self.__fullsummary( self.__globals_( ) )
        _invocation_parameters['fastnoise'] = self.__fastnoise( self.__globals_( ) )
        _invocation_parameters['usemask'] = self.__usemask( self.__globals_( ) )
        _invocation_parameters['mask'] = self.__mask( self.__globals_( ) )
        _invocation_parameters['pbmask'] = self.__pbmask( self.__globals_( ) )
        _invocation_parameters['sidelobethreshold'] = self.__sidelobethreshold( self.__globals_( ) )
        _invocation_parameters['noisethreshold'] = self.__noisethreshold( self.__globals_( ) )
        _invocation_parameters['lownoisethreshold'] = self.__lownoisethreshold( self.__globals_( ) )
        _invocation_parameters['negativethreshold'] = self.__negativethreshold( self.__globals_( ) )
        _invocation_parameters['smoothfactor'] = self.__smoothfactor( self.__globals_( ) )
        _invocation_parameters['minbeamfrac'] = self.__minbeamfrac( self.__globals_( ) )
        _invocation_parameters['cutthreshold'] = self.__cutthreshold( self.__globals_( ) )
        _invocation_parameters['growiterations'] = self.__growiterations( self.__globals_( ) )
        _invocation_parameters['dogrowprune'] = self.__dogrowprune( self.__globals_( ) )
        _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-17s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#deconvolve( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, imagename=None, startmodel=None, deconvolver=None, scales=None, nterms=None, smallscalebias=None, fusedthreshold=None, largestscale=None, restoration=None, restoringbeam=None, niter=None, gain=None, threshold=None, nsigma=None, interactive=None, fullsummary=None, fastnoise=None, usemask=None, mask=None, pbmask=None, sidelobethreshold=None, noisethreshold=None, lownoisethreshold=None, negativethreshold=None, smoothfactor=None, minbeamfrac=None, cutthreshold=None, growiterations=None, dogrowprune=None, verbose=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('deconvolve.pre')
        _postfile = os.path.realpath('deconvolve.last')
        task_result = None
        _arguments = [imagename,startmodel,deconvolver,scales,nterms,smallscalebias,fusedthreshold,largestscale,restoration,restoringbeam,niter,gain,threshold,nsigma,interactive,fullsummary,fastnoise,usemask,mask,pbmask,sidelobethreshold,noisethreshold,lownoisethreshold,negativethreshold,smoothfactor,minbeamfrac,cutthreshold,growiterations,dogrowprune,verbose]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if imagename is not None: local_global['imagename'] = imagename
            if startmodel is not None: local_global['startmodel'] = startmodel
            if deconvolver is not None: local_global['deconvolver'] = deconvolver
            if restoration is not None: local_global['restoration'] = restoration
            if niter is not None: local_global['niter'] = niter
            if interactive is not None: local_global['interactive'] = interactive
            if fullsummary is not None: local_global['fullsummary'] = fullsummary
            if usemask is not None: local_global['usemask'] = usemask

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['imagename'] = self.__imagename( local_global )
            _invocation_parameters['startmodel'] = self.__startmodel( local_global )
            _invocation_parameters['deconvolver'] = self.__deconvolver( local_global )
            _invocation_parameters['restoration'] = self.__restoration( local_global )
            _invocation_parameters['niter'] = self.__niter( local_global )
            _invocation_parameters['interactive'] = self.__interactive( local_global )
            _invocation_parameters['fullsummary'] = self.__fullsummary( local_global )
            _invocation_parameters['usemask'] = self.__usemask( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['scales'] = self.__scales( _invocation_parameters ) if scales is None else scales
            _invocation_parameters['nterms'] = self.__nterms( _invocation_parameters ) if nterms is None else nterms
            _invocation_parameters['smallscalebias'] = self.__smallscalebias( _invocation_parameters ) if smallscalebias is None else smallscalebias
            _invocation_parameters['fusedthreshold'] = self.__fusedthreshold( _invocation_parameters ) if fusedthreshold is None else fusedthreshold
            _invocation_parameters['largestscale'] = self.__largestscale( _invocation_parameters ) if largestscale is None else largestscale
            _invocation_parameters['restoringbeam'] = self.__restoringbeam( _invocation_parameters ) if restoringbeam is None else restoringbeam
            _invocation_parameters['gain'] = self.__gain( _invocation_parameters ) if gain is None else gain
            _invocation_parameters['threshold'] = self.__threshold( _invocation_parameters ) if threshold is None else threshold
            _invocation_parameters['nsigma'] = self.__nsigma( _invocation_parameters ) if nsigma is None else nsigma
            _invocation_parameters['fastnoise'] = self.__fastnoise( _invocation_parameters ) if fastnoise is None else fastnoise
            _invocation_parameters['mask'] = self.__mask( _invocation_parameters ) if mask is None else mask
            _invocation_parameters['pbmask'] = self.__pbmask( _invocation_parameters ) if pbmask is None else pbmask
            _invocation_parameters['sidelobethreshold'] = self.__sidelobethreshold( _invocation_parameters ) if sidelobethreshold is None else sidelobethreshold
            _invocation_parameters['noisethreshold'] = self.__noisethreshold( _invocation_parameters ) if noisethreshold is None else noisethreshold
            _invocation_parameters['lownoisethreshold'] = self.__lownoisethreshold( _invocation_parameters ) if lownoisethreshold is None else lownoisethreshold
            _invocation_parameters['negativethreshold'] = self.__negativethreshold( _invocation_parameters ) if negativethreshold is None else negativethreshold
            _invocation_parameters['smoothfactor'] = self.__smoothfactor( _invocation_parameters ) if smoothfactor is None else smoothfactor
            _invocation_parameters['minbeamfrac'] = self.__minbeamfrac( _invocation_parameters ) if minbeamfrac is None else minbeamfrac
            _invocation_parameters['cutthreshold'] = self.__cutthreshold( _invocation_parameters ) if cutthreshold is None else cutthreshold
            _invocation_parameters['growiterations'] = self.__growiterations( _invocation_parameters ) if growiterations is None else growiterations
            _invocation_parameters['dogrowprune'] = self.__dogrowprune( _invocation_parameters ) if dogrowprune is None else dogrowprune
            _invocation_parameters['verbose'] = self.__verbose( _invocation_parameters ) if verbose is None else verbose

        else:
            # invoke with inp/go semantics
            _invocation_parameters['imagename'] = self.__imagename( self.__globals_( ) )
            _invocation_parameters['startmodel'] = self.__startmodel( self.__globals_( ) )
            _invocation_parameters['deconvolver'] = self.__deconvolver( self.__globals_( ) )
            _invocation_parameters['scales'] = self.__scales( self.__globals_( ) )
            _invocation_parameters['nterms'] = self.__nterms( self.__globals_( ) )
            _invocation_parameters['smallscalebias'] = self.__smallscalebias( self.__globals_( ) )
            _invocation_parameters['fusedthreshold'] = self.__fusedthreshold( self.__globals_( ) )
            _invocation_parameters['largestscale'] = self.__largestscale( self.__globals_( ) )
            _invocation_parameters['restoration'] = self.__restoration( self.__globals_( ) )
            _invocation_parameters['restoringbeam'] = self.__restoringbeam( self.__globals_( ) )
            _invocation_parameters['niter'] = self.__niter( self.__globals_( ) )
            _invocation_parameters['gain'] = self.__gain( self.__globals_( ) )
            _invocation_parameters['threshold'] = self.__threshold( self.__globals_( ) )
            _invocation_parameters['nsigma'] = self.__nsigma( self.__globals_( ) )
            _invocation_parameters['interactive'] = self.__interactive( self.__globals_( ) )
            _invocation_parameters['fullsummary'] = self.__fullsummary( self.__globals_( ) )
            _invocation_parameters['fastnoise'] = self.__fastnoise( self.__globals_( ) )
            _invocation_parameters['usemask'] = self.__usemask( self.__globals_( ) )
            _invocation_parameters['mask'] = self.__mask( self.__globals_( ) )
            _invocation_parameters['pbmask'] = self.__pbmask( self.__globals_( ) )
            _invocation_parameters['sidelobethreshold'] = self.__sidelobethreshold( self.__globals_( ) )
            _invocation_parameters['noisethreshold'] = self.__noisethreshold( self.__globals_( ) )
            _invocation_parameters['lownoisethreshold'] = self.__lownoisethreshold( self.__globals_( ) )
            _invocation_parameters['negativethreshold'] = self.__negativethreshold( self.__globals_( ) )
            _invocation_parameters['smoothfactor'] = self.__smoothfactor( self.__globals_( ) )
            _invocation_parameters['minbeamfrac'] = self.__minbeamfrac( self.__globals_( ) )
            _invocation_parameters['cutthreshold'] = self.__cutthreshold( self.__globals_( ) )
            _invocation_parameters['growiterations'] = self.__growiterations( self.__globals_( ) )
            _invocation_parameters['dogrowprune'] = self.__dogrowprune( self.__globals_( ) )
            _invocation_parameters['verbose'] = self.__verbose( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-17s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#deconvolve( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'deconvolve', [ 'imagename=' + repr(_pc.document['imagename']), 'startmodel=' + repr(_pc.document['startmodel']), 'deconvolver=' + repr(_pc.document['deconvolver']), 'scales=' + repr(_pc.document['scales']), 'nterms=' + repr(_pc.document['nterms']), 'smallscalebias=' + repr(_pc.document['smallscalebias']), 'fusedthreshold=' + repr(_pc.document['fusedthreshold']), 'largestscale=' + repr(_pc.document['largestscale']), 'restoration=' + repr(_pc.document['restoration']), 'restoringbeam=' + repr(_pc.document['restoringbeam']), 'niter=' + repr(_pc.document['niter']), 'gain=' + repr(_pc.document['gain']), 'threshold=' + repr(_pc.document['threshold']), 'nsigma=' + repr(_pc.document['nsigma']), 'interactive=' + repr(_pc.document['interactive']), 'fullsummary=' + repr(_pc.document['fullsummary']), 'fastnoise=' + repr(_pc.document['fastnoise']), 'usemask=' + repr(_pc.document['usemask']), 'mask=' + repr(_pc.document['mask']), 'pbmask=' + repr(_pc.document['pbmask']), 'sidelobethreshold=' + repr(_pc.document['sidelobethreshold']), 'noisethreshold=' + repr(_pc.document['noisethreshold']), 'lownoisethreshold=' + repr(_pc.document['lownoisethreshold']), 'negativethreshold=' + repr(_pc.document['negativethreshold']), 'smoothfactor=' + repr(_pc.document['smoothfactor']), 'minbeamfrac=' + repr(_pc.document['minbeamfrac']), 'cutthreshold=' + repr(_pc.document['cutthreshold']), 'growiterations=' + repr(_pc.document['growiterations']), 'dogrowprune=' + repr(_pc.document['dogrowprune']), 'verbose=' + repr(_pc.document['verbose']) ] )
            task_result = _deconvolve_t( _pc.document['imagename'],_pc.document['startmodel'],_pc.document['deconvolver'],_pc.document['scales'],_pc.document['nterms'],_pc.document['smallscalebias'],_pc.document['fusedthreshold'],_pc.document['largestscale'],_pc.document['restoration'],_pc.document['restoringbeam'],_pc.document['niter'],_pc.document['gain'],_pc.document['threshold'],_pc.document['nsigma'],_pc.document['interactive'],_pc.document['fullsummary'],_pc.document['fastnoise'],_pc.document['usemask'],_pc.document['mask'],_pc.document['pbmask'],_pc.document['sidelobethreshold'],_pc.document['noisethreshold'],_pc.document['lownoisethreshold'],_pc.document['negativethreshold'],_pc.document['smoothfactor'],_pc.document['minbeamfrac'],_pc.document['cutthreshold'],_pc.document['growiterations'],_pc.document['dogrowprune'],_pc.document['verbose'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('deconvolve')
            casalog.post("Exception Reported: Error in deconvolve: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'deconvolve', task_result )

        #Added if _deconvolve_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

deconvolve = _deconvolve( )

