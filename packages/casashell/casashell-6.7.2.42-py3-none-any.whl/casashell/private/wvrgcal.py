##################### generated by xml-casa (v2) from wvrgcal.xml ###################
##################### 62b478f27bd647d7dd85ba7e69456e62 ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_wvrgcal import wvrgcal as _wvrgcal_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _wvrgcal:
    """
    wvrgcal ---- Generate a gain table based on Water Vapour Radiometer data

    
    
    Information about the observation and the performance of WVRGCAL is written to the CASA logger
    and also returned in a dictionary; see the CASA cookbook for a more detailed description of these parameters.
    The dictionary element 'success' is True if no errors occured.
    
    Of particular note is the discrepancy parameter (Disc): high values (> a few hundred microns)
    may indicate some levels of cloud contamination and the effect of applying the WVRGCAL correction
    should be checked; values > 1000 um in all antennas have currently been found to indicate that
    WVRGCAL correction should not be used.
    
    
    vis -- Name of input visibility file
    default: none; example: vis='ngc5921.ms'
    
    caltable -- Name of output gain calibration table
    default: none; example: caltable='ngc5921.wvr'
    
    toffset -- Time offset (sec) between interferometric and WVR data
    default: 0 (ALMA default for cycle 1, for cycle 0, i.e. up to Jan 2013 it was -1)
    
    segsource -- Do a new coefficient calculation for each source
    default: True
    
    tie -- Prioritise tieing the phase of these sources as well as possible
    (requires segsource=True)
    default: [] example: ['3C273,NGC253', 'IC433,3C279']
    
    sourceflag -- Flag the WVR data for these source(s) as bad and do not produce corrections for it
    (requires segsource=True)
    default: [] (none) example: ['3C273']
    
    nsol -- Number of solutions for phase correction coefficients during this observation.
    By default only one set of coefficients is generated for the entire observation.
    If more sets are requested, then they will be evenly distributed in time throughout
    the observation. Values > 1 require segsource=False.
    default: 1
    
    disperse -- Apply correction for dispersion
    default: False
    
    wvrflag -- Regard the WVR data for these antenna(s) as bad and use interpolated values instead
    default: [] (none) example: ['DV03','DA05','PM02']
    
    statfield -- Compute the statistics (Phase RMS, Disc) on this field only
    default: '' (all)
    
    statsource -- Compute the statistics (Phase RMS, Disc) on this source only
    default: '' (all)
    
    smooth -- Smooth the calibration solution on the given timescale
    default: '' (no smoothing), example: '3s' smooth on a timescale of 3 seconds
    
    scale -- Scale the entire phase correction by this factor
    default: 1. (no scaling)
    
    spw -- List of the spectral window IDs for which solutions should be saved into the caltable
    default: [] (all spectral windows), example [17,19,21,23]
    
    wvrspw -- List of the spectral window IDs from which the WVR data should be taken
    default: [] (all WVR spectral windows), example [0]
    
    reversespw -- Reverse the sign of the correction for the listed SPWs
    (only neede for early ALMA data before Cycle 0)
    default: '' (none), example: reversespw='0~2,4'; spectral windows 0,1,2,4
    
    cont -- Estimate the continuum (e.g., due to clouds)
    default: False
    
    maxdistm -- maximum distance (m) an antenna may have to be considered for being part
    of the antenna set (minnumants to 3 antennas) for the interpolation of a solution
    for a flagged antenna
    default: 500.
    
    minnumants -- minimum number of near antennas required for interpolation
    default: 2
    
    mingoodfrac -- If the fraction of unflagged data for an antenna is below this value (0. to 1.),
    the antenna is flagged.
    default: 0.8
    
    usefieldtab -- derive the antenna AZ/EL values from the FIELD rather than the POINTING table
    default: False
    
    refant -- use the WVR data from this antenna for calculating the dT/dL parameters (can give ranked list)
    default: '' (use the first good or interpolatable antenna),
    examples: 'DA45' - use DA45
    ['DA45','DV51'] - use DA45 and if that is not good, use DV51 instead
    
    offsetstable -- subtract the temperature offsets in this table from the WVR measurements before
    using them to calculate the phase corrections
    default: '' (do not apply any offsets)
    examples: 'uid___A002_Xabd867_X2277.cloud_offsets' use the given table
    
    rseed -- set random seed (integer) for the wvrgcal fitting routine to this specific value
    default: 0 - use internal default value
    example: 54321
    
    

    --------- parameter descriptions ---------------------------------------------

    vis          Name of input visibility file
    caltable     Name of output gain calibration table
    toffset      Time offset (sec) between interferometric and WVR data
    segsource    Do a new coefficient calculation for each source
    sourceflag   Regard the WVR data for these source(s) as bad and do not produce corrections for it (requires segsource=True)
    tie          Prioritise tieing the phase of these sources as well as possible (requires segsource=True)
    nsol         Number of solutions for phase correction coefficients (nsol>1 requires segsource=False)
    disperse     Apply correction for dispersion
    wvrflag      Regard the WVR data for these antenna(s) as bad and replace its data with interpolated values from neighbouring antennas
    statfield    Compute the statistics (Phase RMS, Disc) on this field only
    statsource   Compute the statistics (Phase RMS, Disc) on this source only
    smooth       Smooth calibration solution on the given timescale
    scale        Scale the entire phase correction by this factor
    spw          List of the spectral window IDs for which solutions should be saved into the caltable
    wvrspw       List of the spectral window IDs from which the WVR data should be taken
    reversespw   Reverse the sign of the correction for the listed SPWs (only needed for early ALMA data before Cycle 0)
    cont         Estimate the continuum (e.g., due to clouds) (experimental)
    maxdistm     maximum distance (m) of an antenna used for interpolation for a flagged antenna
    minnumants   minimum number of near antennas (up to 3) required for interpolation
    mingoodfrac  If the fraction of unflagged data for an antenna is below this value (0. to 1.), the antenna is flagged.
    usefieldtab  derive the antenna AZ/EL values from the FIELD rather than the POINTING table
    refant       use the WVR data from this antenna for calculating the dT/dL parameters (can give ranked list)
    offsetstable subtract the temperature offsets in this table from the WVR measurements before calculating the phase corrections
    rseed        random seed for fitting routine, 0 == use internal default
    [1;42mRETURNS[1;m         variant

    --------- examples -----------------------------------------------------------

    
    
    wvrgcal(vis='uid___A002_X1d54a1_X5.ms', caltable='cal-wvr-uid___A002_X1d54a1_X5.W',
    toffset=-1, segsource=True, tie=['Titan,1037-295,NGC3256'], statsource='1037-295')
    
    


    """

    _info_group_ = """calibration"""
    _info_desc_ = """Generate a gain table based on Water Vapour Radiometer data"""

    __schema = {'vis': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'caltable': {'type': 'cPath', 'coerce': _coerce.expand_path}, 'toffset': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'segsource': {'type': 'cBool'}, 'sourceflag': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'tie': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'nsol': {'type': 'cInt'}, 'disperse': {'type': 'cBool'}, 'wvrflag': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'statfield': {'type': 'cStr', 'coerce': _coerce.to_str}, 'statsource': {'type': 'cStr', 'coerce': _coerce.to_str}, 'smooth': {'type': 'cStr', 'coerce': _coerce.to_str}, 'scale': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'spw': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'wvrspw': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'reversespw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'cont': {'type': 'cBool'}, 'maxdistm': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'minnumants': {'type': 'cInt', 'allowed': [ 1, 2, 3 ]}, 'mingoodfrac': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'usefieldtab': {'type': 'cBool'}, 'refant': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'offsetstable': {'type': 'cStr', 'coerce': _coerce.to_str}, 'rseed': {'type': 'cInt'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 13 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __segsource_dflt( self, glb ):
        return True

    def __segsource( self, glb ):
        if 'segsource' in glb: return glb['segsource']
        return True

    def __minnumants_dflt( self, glb ):
        return int(2)

    def __minnumants( self, glb ):
        if 'minnumants' in glb: return glb['minnumants']
        return int(2)

    def __toffset_dflt( self, glb ):
        return float(0)

    def __toffset( self, glb ):
        if 'toffset' in glb: return glb['toffset']
        return float(0)

    def __refant_dflt( self, glb ):
        return [  ]

    def __refant( self, glb ):
        if 'refant' in glb: return glb['refant']
        return [  ]

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __caltable_dflt( self, glb ):
        return ''

    def __caltable( self, glb ):
        if 'caltable' in glb: return glb['caltable']
        return ''

    def __offsetstable_dflt( self, glb ):
        return ''

    def __offsetstable( self, glb ):
        if 'offsetstable' in glb: return glb['offsetstable']
        return ''

    def __spw_dflt( self, glb ):
        return [  ]

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return [  ]

    def __smooth_dflt( self, glb ):
        return ''

    def __smooth( self, glb ):
        if 'smooth' in glb: return glb['smooth']
        return ''

    def __maxdistm_dflt( self, glb ):
        return float(500.)

    def __maxdistm( self, glb ):
        if 'maxdistm' in glb: return glb['maxdistm']
        return float(500.)

    def __scale_dflt( self, glb ):
        return float(1.)

    def __scale( self, glb ):
        if 'scale' in glb: return glb['scale']
        return float(1.)

    def __cont_dflt( self, glb ):
        return False

    def __cont( self, glb ):
        if 'cont' in glb: return glb['cont']
        return False

    def __wvrspw_dflt( self, glb ):
        return [  ]

    def __wvrspw( self, glb ):
        if 'wvrspw' in glb: return glb['wvrspw']
        return [  ]

    def __statfield_dflt( self, glb ):
        return ''

    def __statfield( self, glb ):
        if 'statfield' in glb: return glb['statfield']
        return ''

    def __usefieldtab_dflt( self, glb ):
        return False

    def __usefieldtab( self, glb ):
        if 'usefieldtab' in glb: return glb['usefieldtab']
        return False

    def __wvrflag_dflt( self, glb ):
        return [  ]

    def __wvrflag( self, glb ):
        if 'wvrflag' in glb: return glb['wvrflag']
        return [  ]

    def __disperse_dflt( self, glb ):
        return False

    def __disperse( self, glb ):
        if 'disperse' in glb: return glb['disperse']
        return False

    def __rseed_dflt( self, glb ):
        return int(0)

    def __rseed( self, glb ):
        if 'rseed' in glb: return glb['rseed']
        return int(0)

    def __reversespw_dflt( self, glb ):
        return ''

    def __reversespw( self, glb ):
        if 'reversespw' in glb: return glb['reversespw']
        return ''

    def __mingoodfrac_dflt( self, glb ):
        return float(0.8)

    def __mingoodfrac( self, glb ):
        if 'mingoodfrac' in glb: return glb['mingoodfrac']
        return float(0.8)

    def __statsource_dflt( self, glb ):
        return ''

    def __statsource( self, glb ):
        if 'statsource' in glb: return glb['statsource']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __tie_dflt( self, glb ):
        if self.__segsource( glb ) == bool(True): return []
        return None
    def __sourceflag_dflt( self, glb ):
        if self.__segsource( glb ) == bool(True): return []
        return None
    def __nsol_dflt( self, glb ):
        if self.__segsource( glb ) == bool(False): return int(1)
        return None

    #--------- return subparam values -------------------------------------------------
    def __sourceflag( self, glb ):
        if 'sourceflag' in glb: return glb['sourceflag']
        dflt = self.__sourceflag_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __tie( self, glb ):
        if 'tie' in glb: return glb['tie']
        dflt = self.__tie_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __nsol( self, glb ):
        if 'nsol' in glb: return glb['nsol']
        dflt = self.__nsol_dflt( glb )
        if dflt is not None: return dflt
        return int(1)

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __caltable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__caltable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of output gain calibration table'
        value = self.__caltable( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'caltable': value},{'caltable': self.__schema['caltable']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('caltable',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __toffset_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__toffset_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0)
        description = 'Time offset (sec) between interferometric and WVR data'
        value = self.__toffset( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'toffset': value},{'toffset': self.__schema['toffset']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('toffset',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __segsource_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__segsource_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Do a new coefficient calculation for each source'
        value = self.__segsource( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'segsource': value},{'segsource': self.__schema['segsource']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-13.13s =\x1B[0m %s%-23s%s' % ('segsource',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __sourceflag_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__sourceflag_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__sourceflag_dflt( self.__globals_( ) ) is not None:
             description = 'Regard the WVR data for these source(s) as bad and do not produce corrections for it (requires segsource=True)'
             value = self.__sourceflag( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'sourceflag': value},{'sourceflag': self.__schema['sourceflag']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('sourceflag',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __tie_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__tie_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__tie_dflt( self.__globals_( ) ) is not None:
             description = 'Prioritise tieing the phase of these sources as well as possible (requires segsource=True)'
             value = self.__tie( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'tie': value},{'tie': self.__schema['tie']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('tie',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __nsol_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__nsol_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(1)
        if self.__nsol_dflt( self.__globals_( ) ) is not None:
             description = 'Number of solutions for phase correction coefficients (nsol>1 requires segsource=False)'
             value = self.__nsol( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'nsol': value},{'nsol': self.__schema['nsol']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-10.10s =\x1B[0m %s%-23s%s' % ('nsol',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __disperse_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__disperse_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Apply correction for dispersion'
        value = self.__disperse( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'disperse': value},{'disperse': self.__schema['disperse']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('disperse',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __wvrflag_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__wvrflag_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'Regard the WVR data for these antenna(s) as bad and replace its data with interpolated values from neighbouring antennas'
        value = self.__wvrflag( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'wvrflag': value},{'wvrflag': self.__schema['wvrflag']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('wvrflag',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __statfield_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__statfield_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Compute the statistics (Phase RMS, Disc) on this field only'
        value = self.__statfield( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'statfield': value},{'statfield': self.__schema['statfield']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('statfield',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __statsource_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__statsource_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Compute the statistics (Phase RMS, Disc) on this source only'
        value = self.__statsource( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'statsource': value},{'statsource': self.__schema['statsource']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('statsource',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __smooth_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__smooth_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Smooth calibration solution on the given timescale'
        value = self.__smooth( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'smooth': value},{'smooth': self.__schema['smooth']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('smooth',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __scale_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scale_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(1.)
        description = 'Scale the entire phase correction by this factor'
        value = self.__scale( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scale': value},{'scale': self.__schema['scale']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('scale',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'List of the spectral window IDs for which solutions should be saved into the caltable'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __wvrspw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__wvrspw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'List of the spectral window IDs from which the WVR data should be taken'
        value = self.__wvrspw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'wvrspw': value},{'wvrspw': self.__schema['wvrspw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('wvrspw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __reversespw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__reversespw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Reverse the sign of the correction for the listed SPWs (only needed for early ALMA data before Cycle 0)'
        value = self.__reversespw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'reversespw': value},{'reversespw': self.__schema['reversespw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('reversespw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __cont_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__cont_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Estimate the continuum (e.g., due to clouds) (experimental)'
        value = self.__cont( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'cont': value},{'cont': self.__schema['cont']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('cont',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __maxdistm_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__maxdistm_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(500.)
        description = 'maximum distance (m) of an antenna used for interpolation for a flagged antenna'
        value = self.__maxdistm( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'maxdistm': value},{'maxdistm': self.__schema['maxdistm']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('maxdistm',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __minnumants_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__minnumants_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(2)
        description = 'minimum number of near antennas (up to 3) required for interpolation'
        value = self.__minnumants( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'minnumants': value},{'minnumants': self.__schema['minnumants']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('minnumants',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __mingoodfrac_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__mingoodfrac_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.8)
        description = 'If the fraction of unflagged data for an antenna is below this value (0. to 1.), the antenna is flagged.'
        value = self.__mingoodfrac( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'mingoodfrac': value},{'mingoodfrac': self.__schema['mingoodfrac']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('mingoodfrac',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __usefieldtab_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__usefieldtab_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'derive the antenna AZ/EL values from the FIELD rather than the POINTING table'
        value = self.__usefieldtab( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'usefieldtab': value},{'usefieldtab': self.__schema['usefieldtab']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('usefieldtab',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __refant_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__refant_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        description = 'use the WVR data from this antenna for calculating the dT/dL parameters (can give ranked list)'
        value = self.__refant( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'refant': value},{'refant': self.__schema['refant']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('refant',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __offsetstable_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__offsetstable_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'subtract the temperature offsets in this table from the WVR measurements before calculating the phase corrections'
        value = self.__offsetstable( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'offsetstable': value},{'offsetstable': self.__schema['offsetstable']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('offsetstable',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __rseed_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__rseed_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(0)
        description = 'random seed for fitting routine'
        value = self.__rseed( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'rseed': value},{'rseed': self.__schema['rseed']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-13.13s = %s%-23s%s' % ('rseed',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'cont' in glb: del glb['cont']
        if 'rseed' in glb: del glb['rseed']
        if 'toffset' in glb: del glb['toffset']
        if 'tie' in glb: del glb['tie']
        if 'disperse' in glb: del glb['disperse']
        if 'smooth' in glb: del glb['smooth']
        if 'scale' in glb: del glb['scale']
        if 'mingoodfrac' in glb: del glb['mingoodfrac']
        if 'reversespw' in glb: del glb['reversespw']
        if 'minnumants' in glb: del glb['minnumants']
        if 'offsetstable' in glb: del glb['offsetstable']
        if 'refant' in glb: del glb['refant']
        if 'vis' in glb: del glb['vis']
        if 'sourceflag' in glb: del glb['sourceflag']
        if 'wvrflag' in glb: del glb['wvrflag']
        if 'maxdistm' in glb: del glb['maxdistm']
        if 'nsol' in glb: del glb['nsol']
        if 'statsource' in glb: del glb['statsource']
        if 'statfield' in glb: del glb['statfield']
        if 'usefieldtab' in glb: del glb['usefieldtab']
        if 'segsource' in glb: del glb['segsource']
        if 'caltable' in glb: del glb['caltable']
        if 'wvrspw' in glb: del glb['wvrspw']
        if 'spw' in glb: del glb['spw']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# wvrgcal -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__caltable_inp( )
        self.__toffset_inp( )
        self.__segsource_inp( )
        self.__sourceflag_inp( )
        self.__tie_inp( )
        self.__nsol_inp( )
        self.__disperse_inp( )
        self.__wvrflag_inp( )
        self.__statfield_inp( )
        self.__statsource_inp( )
        self.__smooth_inp( )
        self.__scale_inp( )
        self.__spw_inp( )
        self.__wvrspw_inp( )
        self.__reversespw_inp( )
        self.__cont_inp( )
        self.__maxdistm_inp( )
        self.__minnumants_inp( )
        self.__mingoodfrac_inp( )
        self.__usefieldtab_inp( )
        self.__refant_inp( )
        self.__offsetstable_inp( )
        self.__rseed_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "wvrgcal.last" if os.path.isfile("wvrgcal.last") else "wvrgcal.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('wvrgcal.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
        _invocation_parameters['toffset'] = self.__toffset( self.__globals_( ) )
        _invocation_parameters['segsource'] = self.__segsource( self.__globals_( ) )
        _invocation_parameters['sourceflag'] = self.__sourceflag( self.__globals_( ) )
        _invocation_parameters['tie'] = self.__tie( self.__globals_( ) )
        _invocation_parameters['nsol'] = self.__nsol( self.__globals_( ) )
        _invocation_parameters['disperse'] = self.__disperse( self.__globals_( ) )
        _invocation_parameters['wvrflag'] = self.__wvrflag( self.__globals_( ) )
        _invocation_parameters['statfield'] = self.__statfield( self.__globals_( ) )
        _invocation_parameters['statsource'] = self.__statsource( self.__globals_( ) )
        _invocation_parameters['smooth'] = self.__smooth( self.__globals_( ) )
        _invocation_parameters['scale'] = self.__scale( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['wvrspw'] = self.__wvrspw( self.__globals_( ) )
        _invocation_parameters['reversespw'] = self.__reversespw( self.__globals_( ) )
        _invocation_parameters['cont'] = self.__cont( self.__globals_( ) )
        _invocation_parameters['maxdistm'] = self.__maxdistm( self.__globals_( ) )
        _invocation_parameters['minnumants'] = self.__minnumants( self.__globals_( ) )
        _invocation_parameters['mingoodfrac'] = self.__mingoodfrac( self.__globals_( ) )
        _invocation_parameters['usefieldtab'] = self.__usefieldtab( self.__globals_( ) )
        _invocation_parameters['refant'] = self.__refant( self.__globals_( ) )
        _invocation_parameters['offsetstable'] = self.__offsetstable( self.__globals_( ) )
        _invocation_parameters['rseed'] = self.__rseed( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-12s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#wvrgcal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, caltable=None, toffset=None, segsource=None, sourceflag=None, tie=None, nsol=None, disperse=None, wvrflag=None, statfield=None, statsource=None, smooth=None, scale=None, spw=None, wvrspw=None, reversespw=None, cont=None, maxdistm=None, minnumants=None, mingoodfrac=None, usefieldtab=None, refant=None, offsetstable=None, rseed=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('wvrgcal.pre')
        _postfile = os.path.realpath('wvrgcal.last')
        task_result = None
        _arguments = [vis,caltable,toffset,segsource,sourceflag,tie,nsol,disperse,wvrflag,statfield,statsource,smooth,scale,spw,wvrspw,reversespw,cont,maxdistm,minnumants,mingoodfrac,usefieldtab,refant,offsetstable,rseed]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if caltable is not None: local_global['caltable'] = caltable
            if toffset is not None: local_global['toffset'] = toffset
            if segsource is not None: local_global['segsource'] = segsource
            if disperse is not None: local_global['disperse'] = disperse
            if wvrflag is not None: local_global['wvrflag'] = wvrflag
            if statfield is not None: local_global['statfield'] = statfield
            if statsource is not None: local_global['statsource'] = statsource
            if smooth is not None: local_global['smooth'] = smooth
            if scale is not None: local_global['scale'] = scale
            if spw is not None: local_global['spw'] = spw
            if wvrspw is not None: local_global['wvrspw'] = wvrspw
            if reversespw is not None: local_global['reversespw'] = reversespw
            if cont is not None: local_global['cont'] = cont
            if maxdistm is not None: local_global['maxdistm'] = maxdistm
            if minnumants is not None: local_global['minnumants'] = minnumants
            if mingoodfrac is not None: local_global['mingoodfrac'] = mingoodfrac
            if usefieldtab is not None: local_global['usefieldtab'] = usefieldtab
            if refant is not None: local_global['refant'] = refant
            if offsetstable is not None: local_global['offsetstable'] = offsetstable
            if rseed is not None: local_global['rseed'] = rseed

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['caltable'] = self.__caltable( local_global )
            _invocation_parameters['toffset'] = self.__toffset( local_global )
            _invocation_parameters['segsource'] = self.__segsource( local_global )
            _invocation_parameters['disperse'] = self.__disperse( local_global )
            _invocation_parameters['wvrflag'] = self.__wvrflag( local_global )
            _invocation_parameters['statfield'] = self.__statfield( local_global )
            _invocation_parameters['statsource'] = self.__statsource( local_global )
            _invocation_parameters['smooth'] = self.__smooth( local_global )
            _invocation_parameters['scale'] = self.__scale( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['wvrspw'] = self.__wvrspw( local_global )
            _invocation_parameters['reversespw'] = self.__reversespw( local_global )
            _invocation_parameters['cont'] = self.__cont( local_global )
            _invocation_parameters['maxdistm'] = self.__maxdistm( local_global )
            _invocation_parameters['minnumants'] = self.__minnumants( local_global )
            _invocation_parameters['mingoodfrac'] = self.__mingoodfrac( local_global )
            _invocation_parameters['usefieldtab'] = self.__usefieldtab( local_global )
            _invocation_parameters['refant'] = self.__refant( local_global )
            _invocation_parameters['offsetstable'] = self.__offsetstable( local_global )
            _invocation_parameters['rseed'] = self.__rseed( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['sourceflag'] = self.__sourceflag( _invocation_parameters ) if sourceflag is None else sourceflag
            _invocation_parameters['tie'] = self.__tie( _invocation_parameters ) if tie is None else tie
            _invocation_parameters['nsol'] = self.__nsol( _invocation_parameters ) if nsol is None else nsol

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['caltable'] = self.__caltable( self.__globals_( ) )
            _invocation_parameters['toffset'] = self.__toffset( self.__globals_( ) )
            _invocation_parameters['segsource'] = self.__segsource( self.__globals_( ) )
            _invocation_parameters['sourceflag'] = self.__sourceflag( self.__globals_( ) )
            _invocation_parameters['tie'] = self.__tie( self.__globals_( ) )
            _invocation_parameters['nsol'] = self.__nsol( self.__globals_( ) )
            _invocation_parameters['disperse'] = self.__disperse( self.__globals_( ) )
            _invocation_parameters['wvrflag'] = self.__wvrflag( self.__globals_( ) )
            _invocation_parameters['statfield'] = self.__statfield( self.__globals_( ) )
            _invocation_parameters['statsource'] = self.__statsource( self.__globals_( ) )
            _invocation_parameters['smooth'] = self.__smooth( self.__globals_( ) )
            _invocation_parameters['scale'] = self.__scale( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['wvrspw'] = self.__wvrspw( self.__globals_( ) )
            _invocation_parameters['reversespw'] = self.__reversespw( self.__globals_( ) )
            _invocation_parameters['cont'] = self.__cont( self.__globals_( ) )
            _invocation_parameters['maxdistm'] = self.__maxdistm( self.__globals_( ) )
            _invocation_parameters['minnumants'] = self.__minnumants( self.__globals_( ) )
            _invocation_parameters['mingoodfrac'] = self.__mingoodfrac( self.__globals_( ) )
            _invocation_parameters['usefieldtab'] = self.__usefieldtab( self.__globals_( ) )
            _invocation_parameters['refant'] = self.__refant( self.__globals_( ) )
            _invocation_parameters['offsetstable'] = self.__offsetstable( self.__globals_( ) )
            _invocation_parameters['rseed'] = self.__rseed( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-12s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#wvrgcal( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'wvrgcal', [ 'vis=' + repr(_pc.document['vis']), 'caltable=' + repr(_pc.document['caltable']), 'toffset=' + repr(_pc.document['toffset']), 'segsource=' + repr(_pc.document['segsource']), 'sourceflag=' + repr(_pc.document['sourceflag']), 'tie=' + repr(_pc.document['tie']), 'nsol=' + repr(_pc.document['nsol']), 'disperse=' + repr(_pc.document['disperse']), 'wvrflag=' + repr(_pc.document['wvrflag']), 'statfield=' + repr(_pc.document['statfield']), 'statsource=' + repr(_pc.document['statsource']), 'smooth=' + repr(_pc.document['smooth']), 'scale=' + repr(_pc.document['scale']), 'spw=' + repr(_pc.document['spw']), 'wvrspw=' + repr(_pc.document['wvrspw']), 'reversespw=' + repr(_pc.document['reversespw']), 'cont=' + repr(_pc.document['cont']), 'maxdistm=' + repr(_pc.document['maxdistm']), 'minnumants=' + repr(_pc.document['minnumants']), 'mingoodfrac=' + repr(_pc.document['mingoodfrac']), 'usefieldtab=' + repr(_pc.document['usefieldtab']), 'refant=' + repr(_pc.document['refant']), 'offsetstable=' + repr(_pc.document['offsetstable']), 'rseed=' + repr(_pc.document['rseed']) ] )
            task_result = _wvrgcal_t( _pc.document['vis'],_pc.document['caltable'],_pc.document['toffset'],_pc.document['segsource'],_pc.document['sourceflag'],_pc.document['tie'],_pc.document['nsol'],_pc.document['disperse'],_pc.document['wvrflag'],_pc.document['statfield'],_pc.document['statsource'],_pc.document['smooth'],_pc.document['scale'],_pc.document['spw'],_pc.document['wvrspw'],_pc.document['reversespw'],_pc.document['cont'],_pc.document['maxdistm'],_pc.document['minnumants'],_pc.document['mingoodfrac'],_pc.document['usefieldtab'],_pc.document['refant'],_pc.document['offsetstable'],_pc.document['rseed'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('wvrgcal')
            casalog.post("Exception Reported: Error in wvrgcal: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'wvrgcal', task_result )

        #Added if _wvrgcal_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

wvrgcal = _wvrgcal( )

