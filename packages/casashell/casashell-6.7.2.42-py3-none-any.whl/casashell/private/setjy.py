##################### generated by xml-casa (v2) from setjy.xml #####################
##################### 00ebb1489d4e63a2ce3f6c2e5a10db6e ##############################
from __future__ import absolute_import
from casashell.private.stack_manip import find_local as __sf__
from casashell.private.stack_manip import find_frame as _find_frame
from casatools.typecheck import validator as _pc
from casatools.coercetype import coerce as _coerce
from casatools.errors import create_error_string
from casatasks.private.task_setjy import setjy as _setjy_t
from casatasks.private.task_logging import start_log as _start_log
from casatasks.private.task_logging import end_log as _end_log
from collections import OrderedDict
import numpy
import sys
import os

import shutil

def static_var(varname, value):
    def decorate(func):
        setattr(func, varname, value)
        return func
    return decorate

class _setjy:
    """
    setjy ---- Fills the model column with the visibilities of a calibrator

    
    This task places the model visibility amp and phase associated with a
    specified clean components image into the model column of the data
    set.  The flux density (I,Q,U,V) for a point source calibrator can be
    entered explicitly.
    
    setjy need only be run on the calibrator sources with a known flux
    density and/or model.
    
    Models are available in CASA for 3C48, 3C138, 3C286, and 3C147 between 230 MHz
    and 43 GHz.  In addition, P-band models for the frequency range between 230 -
    470 MHz are available in CASA for 3C123, 3C196, 3C295, and 3C380.
    These models are scaled to the precise frequency of the data.  Only I models are
    presently available.
    
    For Solar System Objects, model determination was updated and it is
    available via the 'Butler-JPL-Horizons 2012' standard. Currently they
    are modeled as uniformtemperature disks based on their ephemeris at
    the time of observation (note that this may oversimplify objects, in
    particular asteroids). Specify the name of the object in the 'field'
    parameter.
    
    The location of the models is system dependent:  At the AOC, the
    models are in the directory::/usr/lib/casapy/data/nrao/VLA/CalModels/
    3C286_L.im (egs).

    --------- parameter descriptions ---------------------------------------------

    vis           Name of input visibility file
                  Default: none
                  
                     Example: vis='ngc5921.ms'
    field         Select field using field id(s) or field name(s)
                  Default: '' (all fields, but run setjy one field
                  at a time)
                  
                  Use 'go listobs' to obtain the list id's or
                  names. If field string is a non-negative integer,
                  it is assumed a field index,  otherwise, it is
                  assumed a field name.
                  
                     Examples:
                     field='0~2'; field ids 0,1,2
                     field='0,4,5~7'; field ids 0,4,5,6,7
                     field='3C286,3C295'; field named 3C286 and
                     3C295
                     field = '3,4C*'; field id 3, all names
                     starting with 4C
                  Field name(s)
    spw           Select spectral window/channels
                  Default: '' (all spectral windows)
                  
                  NOTE: setjy only selects by spectral window, and
                  ignores channel selections.  Fine-grained control
                  could be achieved using (and possibly
                  constructing) a cube for model.
    selectdata    Other parameters for selecting part(s) of the MS to
                  operate on.
                  Default: False
                  Options: False|True
                  
                  Currently all time-oriented and most likely only
                  of interest when using a Solar System object as a
                  calibrator.
    timerange     Select data based on time range
                  Subparameter of selectdata=True
                  Default = '' (all)
                  
                     Examples:
                     timerange =
                     'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                     (Note: if YYYY/MM/DD is missing date defaults
                     to first day in data set.)
                     timerange='09:14:0~09:54:0' picks 40 min on
                     first day 
                     timerange= '25:00:00~27:30:00' picks 1 hr to 3
                     hr 30min on NEXT day
                     timerange='09:44:00' pick data within one
                     integration of time
                     timerange='>10:24:00' data after this time
    scan          Scan number range
                  Subparameter of selectdata=True
                  Default: '' = all
                  
                     Example:scan='1~5'
                  
                  For multiple MS input, a list of scan strings can
                  be used:
                  scan=['0~100','10~200']
                  scan='0~100; scan ids 0-100 for all input MSes
                  Check 'go listobs' to insure the scan numbers are
                  in order.
    intent        Select observing intent
                  Default: '' (all
                  
                     Example: using wildcard characters,
                     intent="*CALIBRATE_AMPLI*" will match field(s)
                     contains CALIBRATE_AMPLI in a list of intents
                  
                  WARNING: If a source with a specific field id has
                  scans that can be distinguishable with intent
                  selection, one should set
                  usescatch=True. Otherwise, any existing model of
                  the source may be cleared and overwritten even if
                  the part of the scans not selected by intent.
    observation   Select by observation ID(s)
                  Subparameter of selectdata=True
                  Default: '' = all
                  
                      Example: observation='0~2,4'
    scalebychan   Scale the flux density on a per channel basis?
                  Default: True
                  Options: True|False
                  
                  This determines whether the fluxdensity set in
                  the model is calculated on a per channel
                  basis. If False then it only one fluxdensity
                  value is calculated per spw.  (Either way, all
                  channels in spw are modified.)  It is effectively
                  True if fluxdensity[0] >  0.0.
    standard      Flux density standard, used if fluxdensity[0] less than 0.0
                  Default: 'Perley-Butler 2017'
                  Options: 'Baars', 'Perley 90', 'Perley-Taylor
                  95', 'Perley-Taylor 99', 'Perley-Butler 2010',
                  'Perley-Butler 2013', 'Perley-Butler 2017',
                  'Scaife-Heald 2012', 'Stevens-Reynolds 2016',
                  'Butler-JPL-Horizons 2010', 'Butler-JPL-Horizons
                  2012', 'manual' 'fluxscale'
                  
                  All but the last four options are for
                  extragalactic calibrators. The two 'Butler-JPL'
                  standards are for Solar System objects. Note that
                  Scaife-Heald 2012 is for the low frequencies
                  (mostly valid for the frequency range,
                  30-300MHz). 
                  
                  Flux density calculation with Solar System
                  objects depends on ephemerides. The setjy task
                  looks for the data in
                  os.getenv('CASAPATH').split()[0] +
                  '/data/ephemerides/JPL-Horizons'. If no ephemeris
                  for the right object at the right time is
                  present, the calculation will fail.  Ask the
                  helpdesk to make an ephemeris.
                  
                  For more information on individual calibrators,
                  see CASA Docs (https://casa.nrao.edu/casadocs/)
    model         Model image (I only) for setting the model visibilities.
                  Subparameter of standard="Perley-Butler 2010",
                  "Perley-Butler 2013", and "Perley-Butler 2017"
                  Default: '' (do not use a model image)
                  
                  The model can be a cube, and its channels do not
                  have to exactly match those of vis.  It is
                  recommended to use model for sources that are
                  resolved by the observation, but the
                  Butler-JPL-Horizons standard supplies a basic
                  model of what several Solar System objects look
                  like. Each field must be done separately when
                  using a model image. 
                  
                  Both the amplitude and phase are calculated.  At
                  the AOC or CV, the models are located in
                  casa['dirs']['data'] + '/nrao/VLA/CalModels/',
                  e.g. /usr/lib/casapy/data/nrao/VLA/CalModels/3C286_L.im
                  lib64
                  
                  If model does not start with '/', setjy will look
                  for a match in '.', './CalModels', and any
                  CalModels directories within the
                  casa['dirs']['data'] tree (excluding certain
                  branches).
                  
                  Note that model should be deconvolved, i.e. a set
                  of clean components instead of an image that has
                  been convolved with a clean beam.
    listmodels    List the available models for VLA calibrators or Tb
                  models for Solar System objects
                  Subparameter of standard="Perley-Butler 2010",
                  "Perley-Butler 2013", and "Perley-Butler 2017" 
                  Default: False
                  Options: False|True
                  
                  If True, do nothing but list candidates for model
                  (for extragalactic calibrators) that are present
                  on the system. It looks for *.im* *.mod* in
                  . including its sub-directories but skipping any
                  directory name start with ".", CalModels, and
                  CalModels directories in the casa['dirs']['data']
                  tree. It does not check whether they are
                  appropriate for the MS! If
                  standard='Butler-JPL-Horizons 2012', Tb models
                  (frequency-dependend brightness temperature
                  models) for Solar System objects used in the
                  standard. For standard='Butler-JPL-Horizons
                  2010', the recognized Solar System objects are
                  listed.
    fluxdensity   Specified flux density in Jy [I,Q,U,V]
                  Subparameter of standard="manual"
                  Default: -1 (uses [1,0,0,0] flux density for
                  unrecognized sources, and standard flux densities
                  for ones recognized by the default standard
                  Perley-Butler 2010).  
                  
                  Only one flux density can be specified at a
                  time. The phases are set to zero.
                  setjy will try to use the standard if fluxdensity
                  is not positive.
                  
                     Examples: 
                     fluxdensity=-1  will use the default standard
                     for recognized calibrators (like 3C286, 3C147
                     and 3C48) and insert 1.0  for selected fields
                     with unrecognized sources.
                     field = '1'; fluxdensity=[3.2,0,0,0] will put
                     in a flux density of I=3.2 for field='1'
                  
                  At present (June 2000), this is the only method
                  to insert apolarized flux density model.
                  
                     Example: fluxdensity=[2.63,0.21,-0.33,0.02]
                     will put in I,Q,U,V flux densities of
                     2.63,0.21,-0.33, and 0.02, respectively, in
                     the model column.
    spix          Spectral index for I flux density
                  Subparameter of standard="manual"
                  Default: [] =>0.0 (no effect)
                  Options: a float or a list of float values
                  
                  S = fluxdensity *
                  (freq/reffreq)**(spix[0]+spix[1]*log(freq/reffreq)+..)
                  
                  Only used if fluxdensity is being used.
                  IMPORTANT: If fluxdensity is positive, and spix
                  is nonzero, then reffreq must be set too!
                  
                  It is applied in the same way to all
                  polarizations, and does not account for Faraday
                  rotation or depolarization.
                  
                     Example: [-0.7, -0.15] for alpha and a curvature term
    reffreq       Reference frequency for spix
                  Subparameter of standard="manual"
                  Default: '1GHz' (this is only here to prevent
                  division by 0!)
                  
                  Given with a unit with an optional frequency
                  frame (if the frame is not given, LSRK is
                  assumed). There should be no space between the
                  value and the unit  (e.g. '100.0GHz' or 'TOPO
                  100.0GHz' are correct but with  '100.0 GHz' you
                  will see a warning message that it will be
                  defaulted to LSRK). 
                  
                     Example: '86.0GHz', 'TOPO 86.0GHz', '4.65e9Hz'
                  
                  NOTE: If the flux density is being scaled by
                  spectral index, then reffreq must be set to
                  whatever reference frequency is correct for the
                  given fluxdensity and spix.  It cannot be
                  determined from vis.  On the other hand, if spix
                  is 0, then any positive frequency can be used
                  (and ignored).
    polindex      Coefficients of the frequency-dependent linear
                  polarization index (polarization fraction) 
                  Subparameter of standard="manual"
                  Default: []
                  
                  Expressed as pol. index = sqrt(Q^2+U^2)/I = c0 +
                  c1*((freq-reffreq)/reffreq) +
                  c2*((freq-reffreq)/reffreq)^2 + .. When Q and U
                  flux densities are given fluxdensity, c0 is
                  determined from these flux densities and the
                  entry for c0 in polindex is ignored. Or Q and U
                  flux densities in fluxdensity can be set to 0.0
                  and then polindex[0] and polangle[0] are used to
                  determine Q and U at reffreq.
                  
                     Example: [0.2, -0.01] (= [c0,c1])
    polangle      Coefficients of the frequency-dependent linear
                  polarization angle (in radians)
                  Subparameter of standard="manual"
                  Default: []
                  
                  Expressed as pol. angle = 0.5*arctan(U/Q) = d0 +
                  d1*((freq-reffreq)/reffreq) +
                  d2*((freq-reffreq)/reffreq)^2 + .. When Q and U
                  flux densities are given in fluxdensity, d0 is
                  determined from these flux densities and the
                  entry for d0 in polangle is ignored. Or Q and U
                  flux densities in fluxdensity can be set to 0.0
                  and then polindex[0] and polangle[0] are used to
                  determine Q and U at reffreq. Here polangle
                  parameters are assumed to represent the intrinsic
                  polarization angle.
                  
                     Example: [0.57, 0.2] (=[d0,d1])
    rotmeas       Rotation measure (in rad/m^2)
                  Subparameter of standard="manual"
                  Default: 0.0
                  
                  Note on the use of polindex, polangle and rotmeas
                  When the frequnecy-dependent polindex and
                  polangle are used, be sure to include all the
                  coefficients of both polindex and polangle to
                  describe frequency depencency. Otherwise
                  frequency-dependent Q and U flux densities are
                  not calculated correctly. If rotmeas is given,
                  the calculated Q and U flux densities are then
                  corrected for the Faraday rotation.
    fluxdict      Output dictionary from fluxscale
                  Subparameter of standard="fluxscale"
                  
                  Using the flexibly results, the flux density,
                  spectral index, and reference frequency are
                  extracted and set to fluxdensity, spix, and
                  reffreq parameters, respectively. The field and
                  spw selections can be used to specify subset of
                  the fluxdict to be used to set the model. If they
                  are left as default (field="", spw="") all fields
                  and/or spws in the fluxdict (but those spws with
                  fluxd=-1 will be skipped) are used.
    useephemdir   Use directions in the ephemeris table for the solar
                  system object?
                  Subparameter of standard="Butler-JPL-Horizons
                  2012",
                  Default: False
                  Options: False|True
    interpolation Method to be used to interpolate in time for the time
                  variable sources (3C48,3C138,3C147).
                  Subparameter of standard="Perley-Butler 2013",
                  and "Perley-Butler 2017" 
                  Default: 'nearest'
                  Options: 'nearest|linear|cubic|spline'
                  
                  This parameter is ignored for other non-variable
                  sources in the standard.
    usescratch    Will create if necessary and use the MODEL_DATA
                  Default: True 
                  Options: True|False
                  
                  * If True: the model visibility will be evaluated
                    and saved on disk in the MODEL_DATA column.
                    This will increase your ms in size by a factor
                    of 1.5 (w.r.t. the case where  you only have
                    the DATA and the CORRECTED_DATA column). Use
                    True if you need to interact with the
                    MODEL_DATA in python, say. Also, use True if
                    you need finer than field and spw  selections
                    using scans/time (and when use with intent
                    selection, please see WARNING section in the
                    intent parameter description).
                  * If False: 'virtual' model is created. The model
                    information is saved either in the SOURCE_MODEL
                    column in the SOURCE table (if one exists) or
                    in the keyword of the main table in the MS, and
                    model visibilities are evaluated on the fly
                    when calculating  calibration or plotting in
                    plotms.
                  
                  By running usescratch=T, it will remove the
                  existing virtual model from previous
                  runs. usescratch=F will not remove the existing
                  MODEL_DATA but in subsequent process the virtual
                  model with matching field and spw combination
                  will be used if it exists regardless of the
                  presence of the MODEL_DATA column.
                  
                  NOTE: for usescratch=False, timerange, scan, and
                  observation are ignored (i.e. time-specific
                  virtual model is not possible.).
                  
                  VERY IMPORTANT: The current implementation of
                  time-dependent models (e.g. ephemerides sources)
                  within setjy is incompatible with the use of the
                  virtual model column. Please use ephemerides source
                  models only with usescratch=True
    ismms         to be used internally for MMS

    --------- examples -----------------------------------------------------------

    
    FOR MORE INFORMATION, SEE THE TASK PAGES OF SETJY IN CASA DOCS:
    https://casa.nrao.edu/casadocs/


    """

    _info_group_ = """imaging, calibration"""
    _info_desc_ = """Fills the model column with the visibilities of a calibrator"""

    __schema = {'vis': {'type': 'cStr', 'coerce': _coerce.to_str}, 'field': {'type': 'cStr', 'coerce': _coerce.to_str}, 'spw': {'type': 'cStr', 'coerce': _coerce.to_str}, 'selectdata': {'type': 'cBool'}, 'timerange': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'scan': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'intent': {'type': 'cStr', 'coerce': _coerce.to_str}, 'observation': {'anyof': [{'type': 'cStr', 'coerce': _coerce.to_str}, {'type': 'cInt'}]}, 'scalebychan': {'type': 'cBool'}, 'standard': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'Perley-Taylor 95', 'Butler-JPL-Horizons 2010', 'Perley-Butler 2010', 'Stevens-Reynolds 2016', 'Perley-Taylor 99', 'Perley-Butler 2013', 'Perley 90', 'Scaife-Heald 2012', 'manual', 'Butler-JPL-Horizons 2012', 'Perley-Butler 2017', 'fluxscale', 'Baars' ]}, 'model': {'type': 'cStr', 'coerce': _coerce.to_str}, 'listmodels': {'type': 'cBool'}, 'fluxdensity': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'spix': {'anyof': [{'type': 'cFloat', 'coerce': _coerce.to_float}, {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}]}, 'reffreq': {'type': 'cStr', 'coerce': _coerce.to_str}, 'polindex': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'polangle': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'rotmeas': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'fluxdict': {'type': 'cDict'}, 'useephemdir': {'type': 'cBool'}, 'interpolation': {'type': 'cStr', 'coerce': _coerce.to_str, 'allowed': [ 'nearest', 'linear', 'spline', '', 'cubic' ]}, 'usescratch': {'type': 'cBool'}, 'ismms': {'type': 'cBool'}}

    def __init__(self):
        self.__stdout = None
        self.__stderr = None
        self.__root_frame_ = None

    def __globals_(self):
        if self.__root_frame_ is None:
            self.__root_frame_ = _find_frame( )
            assert self.__root_frame_ is not None, "could not find CASAshell global frame"
        return self.__root_frame_

    def __to_string_(self,value):
        if type(value) is str:
            return "'%s'" % value
        else:
            return str(value)

    def __validate_(self,doc,schema):
        return _pc.validate(doc,schema)

    def __do_inp_output(self,param_prefix,description_str,formatting_chars):
        out = self.__stdout or sys.stdout
        description = description_str.split( )
        prefix_width = 23 + 16 + 4
        output = [ ]
        addon = ''
        first_addon = True
        if len(description) == 0:
            out.write(param_prefix + " #\n")
            return
        while len(description) > 0:
            ## starting a new line.....................................................................
            if len(output) == 0:
                ## for first line add parameter information............................................
                if len(param_prefix)-formatting_chars > prefix_width - 1:
                    output.append(param_prefix)
                    continue
                addon = param_prefix + ' #'
                first_addon = True
                addon_formatting = formatting_chars
            else:
                ## for subsequent lines space over prefix width........................................
                addon = (' ' * prefix_width) + '#'
                first_addon = False
                addon_formatting = 0
            ## if first word of description puts us over the screen width, bail........................
            if len(addon + description[0]) - addon_formatting + 1 > self.term_width:
                ## if we're doing the first line make sure it's output.................................
                if first_addon: output.append(addon)
                break
            while len(description) > 0:
                ## if the next description word puts us over break for the next line...................
                if len(addon + description[0]) - addon_formatting + 1 > self.term_width: break
                addon = addon + ' ' + description[0]
                description.pop(0)
            output.append(addon)
        out.write('\n'.join(output) + '\n')

    #--------- return nonsubparam values ----------------------------------------------

    def __standard_dflt( self, glb ):
        return 'Perley-Butler 2017'

    def __standard( self, glb ):
        if 'standard' in glb: return glb['standard']
        return 'Perley-Butler 2017'

    def __scalebychan_dflt( self, glb ):
        return True

    def __scalebychan( self, glb ):
        if 'scalebychan' in glb: return glb['scalebychan']
        return True

    def __ismms_dflt( self, glb ):
        return False

    def __ismms( self, glb ):
        if 'ismms' in glb: return glb['ismms']
        return False

    def __vis_dflt( self, glb ):
        return ''

    def __vis( self, glb ):
        if 'vis' in glb: return glb['vis']
        return ''

    def __selectdata_dflt( self, glb ):
        return False

    def __selectdata( self, glb ):
        if 'selectdata' in glb: return glb['selectdata']
        return False

    def __spw_dflt( self, glb ):
        return ''

    def __spw( self, glb ):
        if 'spw' in glb: return glb['spw']
        return ''

    def __usescratch_dflt( self, glb ):
        return True

    def __usescratch( self, glb ):
        if 'usescratch' in glb: return glb['usescratch']
        return True

    def __field_dflt( self, glb ):
        return ''

    def __field( self, glb ):
        if 'field' in glb: return glb['field']
        return ''



    #--------- return inp/go default --------------------------------------------------
    def __listmodels_dflt( self, glb ):
        if self.__standard( glb ) == "Perley-Butler 2017": return bool(False)
        if self.__standard( glb ) == "Perley-Butler 2013": return bool(False)
        if self.__standard( glb ) == "Perley-Butler 2010": return bool(False)
        if self.__standard( glb ) == "Butler-JPL-Horizons 2012": return bool(False)
        return None
    def __model_dflt( self, glb ):
        if self.__standard( glb ) == "Perley-Butler 2017": return ""
        if self.__standard( glb ) == "Perley-Butler 2013": return ""
        if self.__standard( glb ) == "Perley-Butler 2010": return ""
        return None
    def __intent_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __interpolation_dflt( self, glb ):
        if self.__standard( glb ) == "Perley-Butler 2017": return "nearest"
        if self.__standard( glb ) == "Perley-Butler 2013": return "nearest"
        return None
    def __reffreq_dflt( self, glb ):
        if self.__standard( glb ) == "manual": return "1GHz"
        return None
    def __polangle_dflt( self, glb ):
        if self.__standard( glb ) == "manual": return []
        return None
    def __rotmeas_dflt( self, glb ):
        if self.__standard( glb ) == "manual": return float(0.0)
        return None
    def __useephemdir_dflt( self, glb ):
        if self.__standard( glb ) == "Butler-JPL-Horizons 2012": return bool(False)
        return None
    def __scan_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __spix_dflt( self, glb ):
        if self.__standard( glb ) == "manual": return []
        return None
    def __fluxdensity_dflt( self, glb ):
        if self.__standard( glb ) == "manual": return [int(1),int(0),int(0),int(0)]
        return None
    def __polindex_dflt( self, glb ):
        if self.__standard( glb ) == "manual": return []
        return None
    def __observation_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __timerange_dflt( self, glb ):
        if self.__selectdata( glb ) == bool(True): return ""
        return None
    def __fluxdict_dflt( self, glb ):
        if self.__standard( glb ) == "fluxscale": return { }
        return None

    #--------- return subparam values -------------------------------------------------
    def __timerange( self, glb ):
        if 'timerange' in glb: return glb['timerange']
        dflt = self.__timerange_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __scan( self, glb ):
        if 'scan' in glb: return glb['scan']
        dflt = self.__scan_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __intent( self, glb ):
        if 'intent' in glb: return glb['intent']
        dflt = self.__intent_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __observation( self, glb ):
        if 'observation' in glb: return glb['observation']
        dflt = self.__observation_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __model( self, glb ):
        if 'model' in glb: return glb['model']
        dflt = self.__model_dflt( glb )
        if dflt is not None: return dflt
        return ''
    def __listmodels( self, glb ):
        if 'listmodels' in glb: return glb['listmodels']
        dflt = self.__listmodels_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __fluxdensity( self, glb ):
        if 'fluxdensity' in glb: return glb['fluxdensity']
        dflt = self.__fluxdensity_dflt( glb )
        if dflt is not None: return dflt
        return int(-1)
    def __spix( self, glb ):
        if 'spix' in glb: return glb['spix']
        dflt = self.__spix_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __reffreq( self, glb ):
        if 'reffreq' in glb: return glb['reffreq']
        dflt = self.__reffreq_dflt( glb )
        if dflt is not None: return dflt
        return '1GHz'
    def __polindex( self, glb ):
        if 'polindex' in glb: return glb['polindex']
        dflt = self.__polindex_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __polangle( self, glb ):
        if 'polangle' in glb: return glb['polangle']
        dflt = self.__polangle_dflt( glb )
        if dflt is not None: return dflt
        return [  ]
    def __rotmeas( self, glb ):
        if 'rotmeas' in glb: return glb['rotmeas']
        dflt = self.__rotmeas_dflt( glb )
        if dflt is not None: return dflt
        return float(0.0)
    def __fluxdict( self, glb ):
        if 'fluxdict' in glb: return glb['fluxdict']
        dflt = self.__fluxdict_dflt( glb )
        if dflt is not None: return dflt
        return { }
    def __useephemdir( self, glb ):
        if 'useephemdir' in glb: return glb['useephemdir']
        dflt = self.__useephemdir_dflt( glb )
        if dflt is not None: return dflt
        return False
    def __interpolation( self, glb ):
        if 'interpolation' in glb: return glb['interpolation']
        dflt = self.__interpolation_dflt( glb )
        if dflt is not None: return dflt
        return 'nearest'
    def __ismms( self, glb ):
        if 'ismms' in glb: return glb['ismms']
        dflt = self.__ismms_dflt( glb )
        if dflt is not None: return dflt
        return False

    #--------- subparam inp output ----------------------------------------------------
    def __vis_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__vis_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Name of input visibility file'
        value = self.__vis( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'vis': value},{'vis': self.__schema['vis']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('vis',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __field_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__field_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select field using field id(s) or field name(s)'
        value = self.__field( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'field': value},{'field': self.__schema['field']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('field',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __spw_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spw_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        description = 'Select spectral window/channels'
        value = self.__spw( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spw': value},{'spw': self.__schema['spw']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('spw',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __selectdata_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__selectdata_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        description = 'Other data selection parameters'
        value = self.__selectdata( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'selectdata': value},{'selectdata': self.__schema['selectdata']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-16.16s =\x1B[0m %s%-23s%s' % ('selectdata',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __timerange_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__timerange_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__timerange_dflt( self.__globals_( ) ) is not None:
             description = 'Select data based on time range'
             value = self.__timerange( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'timerange': value},{'timerange': self.__schema['timerange']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('timerange',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __scan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__scan_dflt( self.__globals_( ) ) is not None:
             description = 'Scan number range'
             value = self.__scan( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scan': value},{'scan': self.__schema['scan']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('scan',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __intent_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__intent_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__intent_dflt( self.__globals_( ) ) is not None:
             description = 'Select observing intent'
             value = self.__intent( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'intent': value},{'intent': self.__schema['intent']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('intent',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __observation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__observation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__observation_dflt( self.__globals_( ) ) is not None:
             description = 'Select by observation ID(s)'
             value = self.__observation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'observation': value},{'observation': self.__schema['observation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('observation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __scalebychan_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__scalebychan_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Scale the flux density on a per channel basis or else on a per spw basis'
        value = self.__scalebychan( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'scalebychan': value},{'scalebychan': self.__schema['scalebychan']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('scalebychan',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __standard_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__standard_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'Perley-Butler 2017'
        description = 'Flux density standard'
        value = self.__standard( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'standard': value},{'standard': self.__schema['standard']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('\x1B[1m\x1B[47m%-16.16s =\x1B[0m %s%-23s%s' % ('standard',pre,self.__to_string_(value),post),description,13+len(pre)+len(post))
    def __model_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__model_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return ''
        if self.__model_dflt( self.__globals_( ) ) is not None:
             description = 'File location for field model'
             value = self.__model( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'model': value},{'model': self.__schema['model']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('model',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __listmodels_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__listmodels_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__listmodels_dflt( self.__globals_( ) ) is not None:
             description = 'List the available models for VLA calibrators or Tb models for Solar System objects'
             value = self.__listmodels( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'listmodels': value},{'listmodels': self.__schema['listmodels']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('listmodels',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __fluxdensity_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fluxdensity_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return int(-1)
        if self.__fluxdensity_dflt( self.__globals_( ) ) is not None:
             description = 'Specified flux density in Jy [I,Q,U,V]; (-1 will lookup values)'
             value = self.__fluxdensity( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fluxdensity': value},{'fluxdensity': self.__schema['fluxdensity']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('fluxdensity',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __spix_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__spix_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__spix_dflt( self.__globals_( ) ) is not None:
             description = 'Spectral index (including higher terms) of I fluxdensity'
             value = self.__spix( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'spix': value},{'spix': self.__schema['spix']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('spix',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __reffreq_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__reffreq_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return '1GHz'
        if self.__reffreq_dflt( self.__globals_( ) ) is not None:
             description = 'Reference frequency for spix'
             value = self.__reffreq( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'reffreq': value},{'reffreq': self.__schema['reffreq']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('reffreq',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __polindex_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__polindex_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__polindex_dflt( self.__globals_( ) ) is not None:
             description = 'Coefficients of an expansion of frequency-dependent linear polarization fraction expression'
             value = self.__polindex( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'polindex': value},{'polindex': self.__schema['polindex']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('polindex',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __polangle_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__polangle_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return [  ]
        if self.__polangle_dflt( self.__globals_( ) ) is not None:
             description = 'Coefficients of an expansion of frequency-dependent polarization angle expression (in radians)'
             value = self.__polangle( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'polangle': value},{'polangle': self.__schema['polangle']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('polangle',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __rotmeas_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__rotmeas_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return float(0.0)
        if self.__rotmeas_dflt( self.__globals_( ) ) is not None:
             description = 'Rotation measure (in rad/m^2)'
             value = self.__rotmeas( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'rotmeas': value},{'rotmeas': self.__schema['rotmeas']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('rotmeas',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __fluxdict_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__fluxdict_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return { }
        if self.__fluxdict_dflt( self.__globals_( ) ) is not None:
             description = 'Output dictionary from fluxscale'
             value = self.__fluxdict( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'fluxdict': value},{'fluxdict': self.__schema['fluxdict']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('fluxdict',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __useephemdir_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__useephemdir_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__useephemdir_dflt( self.__globals_( ) ) is not None:
             description = 'Use directions in the ephemeris table'
             value = self.__useephemdir( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'useephemdir': value},{'useephemdir': self.__schema['useephemdir']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('useephemdir',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __interpolation_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__interpolation_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return 'nearest'
        if self.__interpolation_dflt( self.__globals_( ) ) is not None:
             description = 'Method to be used to interpolate in time'
             value = self.__interpolation( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'interpolation': value},{'interpolation': self.__schema['interpolation']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('interpolation',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))
    def __usescratch_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__usescratch_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return True
        description = 'Will create if necessary and use the MODEL_DATA'
        value = self.__usescratch( self.__globals_( ) )
        (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'usescratch': value},{'usescratch': self.__schema['usescratch']}) else ('\x1B[91m','\x1B[0m')
        self.__do_inp_output('%-16.16s = %s%-23s%s' % ('usescratch',pre,self.__to_string_(value),post),description,0+len(pre)+len(post))
    def __ismms_inp(self):
        def xml_default( ):
            ## play the crazy subparameter shell game
            dflt = self.__ismms_dflt( self.__globals_( ) )
            if dflt is not None: return dflt
            return False
        if self.__ismms_dflt( self.__globals_( ) ) is not None:
             description = 'to be used internally for MMS'
             value = self.__ismms( self.__globals_( ) )
             (pre,post) = (('','') if value == xml_default( ) else ('\x1B[34m','\x1B[0m')) if self.__validate_({'ismms': value},{'ismms': self.__schema['ismms']}) else ('\x1B[91m','\x1B[0m')
             self.__do_inp_output('   \x1B[92m%-13.13s =\x1B[0m %s%-23s%s' % ('ismms',pre,self.__to_string_(value),post),description,9+len(pre)+len(post))

    #--------- global default implementation-------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def set_global_defaults(self):
        self.set_global_defaults.state['last'] = self
        glb = self.__globals_( )
        if 'listmodels' in glb: del glb['listmodels']
        if 'field' in glb: del glb['field']
        if 'model' in glb: del glb['model']
        if 'standard' in glb: del glb['standard']
        if 'intent' in glb: del glb['intent']
        if 'interpolation' in glb: del glb['interpolation']
        if 'reffreq' in glb: del glb['reffreq']
        if 'polangle' in glb: del glb['polangle']
        if 'rotmeas' in glb: del glb['rotmeas']
        if 'useephemdir' in glb: del glb['useephemdir']
        if 'scan' in glb: del glb['scan']
        if 'vis' in glb: del glb['vis']
        if 'spix' in glb: del glb['spix']
        if 'scalebychan' in glb: del glb['scalebychan']
        if 'fluxdensity' in glb: del glb['fluxdensity']
        if 'usescratch' in glb: del glb['usescratch']
        if 'ismms' in glb: del glb['ismms']
        if 'polindex' in glb: del glb['polindex']
        if 'observation' in glb: del glb['observation']
        if 'spw' in glb: del glb['spw']
        if 'selectdata' in glb: del glb['selectdata']
        if 'timerange' in glb: del glb['timerange']
        if 'fluxdict' in glb: del glb['fluxdict']


    #--------- inp function -----------------------------------------------------------
    def inp(self):
        print("# setjy -- %s" % self._info_desc_)
        self.term_width, self.term_height = shutil.get_terminal_size(fallback=(80, 24))
        self.__vis_inp( )
        self.__field_inp( )
        self.__spw_inp( )
        self.__selectdata_inp( )
        self.__timerange_inp( )
        self.__scan_inp( )
        self.__intent_inp( )
        self.__observation_inp( )
        self.__scalebychan_inp( )
        self.__standard_inp( )
        self.__model_inp( )
        self.__listmodels_inp( )
        self.__fluxdensity_inp( )
        self.__spix_inp( )
        self.__reffreq_inp( )
        self.__polindex_inp( )
        self.__polangle_inp( )
        self.__rotmeas_inp( )
        self.__fluxdict_inp( )
        self.__useephemdir_inp( )
        self.__interpolation_inp( )
        self.__usescratch_inp( )
        self.__ismms_inp( )

    #--------- tget function ----------------------------------------------------------
    @static_var('state', __sf__('casa_inp_go_state'))
    def tget(self,savefile=None):
        from casashell.private.stack_manip import find_frame
        from runpy import run_path
        filename = savefile
        if filename is None:
            filename = "setjy.last" if os.path.isfile("setjy.last") else "setjy.saved"
        if os.path.isfile(filename):
            glob = find_frame( )
            newglob = run_path( filename, init_globals={ } )
            for i in newglob:
                glob[i] = newglob[i]
            self.tget.state['last'] = self
        else:
            print("could not find last file: %s\nsetting defaults instead..." % filename)
            self.set_global_defaults( )

    #--------- tput function ----------------------------------------------------------
    def tput(self,outfile=None):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s

        _postfile = outfile if outfile is not None else os.path.realpath('setjy.last')

        _invocation_parameters = OrderedDict( )
        _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
        _invocation_parameters['field'] = self.__field( self.__globals_( ) )
        _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
        _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
        _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
        _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
        _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
        _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
        _invocation_parameters['scalebychan'] = self.__scalebychan( self.__globals_( ) )
        _invocation_parameters['standard'] = self.__standard( self.__globals_( ) )
        _invocation_parameters['model'] = self.__model( self.__globals_( ) )
        _invocation_parameters['listmodels'] = self.__listmodels( self.__globals_( ) )
        _invocation_parameters['fluxdensity'] = self.__fluxdensity( self.__globals_( ) )
        _invocation_parameters['spix'] = self.__spix( self.__globals_( ) )
        _invocation_parameters['reffreq'] = self.__reffreq( self.__globals_( ) )
        _invocation_parameters['polindex'] = self.__polindex( self.__globals_( ) )
        _invocation_parameters['polangle'] = self.__polangle( self.__globals_( ) )
        _invocation_parameters['rotmeas'] = self.__rotmeas( self.__globals_( ) )
        _invocation_parameters['fluxdict'] = self.__fluxdict( self.__globals_( ) )
        _invocation_parameters['useephemdir'] = self.__useephemdir( self.__globals_( ) )
        _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
        _invocation_parameters['usescratch'] = self.__usescratch( self.__globals_( ) )
        _invocation_parameters['ismms'] = self.__ismms( self.__globals_( ) )

        try:
            with open(_postfile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-13s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#setjy( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: return False
        return True

    def __call__( self, vis=None, field=None, spw=None, selectdata=None, timerange=None, scan=None, intent=None, observation=None, scalebychan=None, standard=None, model=None, listmodels=None, fluxdensity=None, spix=None, reffreq=None, polindex=None, polangle=None, rotmeas=None, fluxdict=None, useephemdir=None, interpolation=None, usescratch=None, ismms=None ):
        def noobj(s):
           if s.startswith('<') and s.endswith('>'):
               return "None"
           else:
               return s
        _prefile = os.path.realpath('setjy.pre')
        _postfile = os.path.realpath('setjy.last')
        task_result = None
        _arguments = [vis,field,spw,selectdata,timerange,scan,intent,observation,scalebychan,standard,model,listmodels,fluxdensity,spix,reffreq,polindex,polangle,rotmeas,fluxdict,useephemdir,interpolation,usescratch,ismms]
        _invocation_parameters = OrderedDict( )
        if any(map(lambda x: x is not None,_arguments)):
            # invoke python style
            # set the non sub-parameters that are not None
            local_global = { }
            if vis is not None: local_global['vis'] = vis
            if field is not None: local_global['field'] = field
            if spw is not None: local_global['spw'] = spw
            if selectdata is not None: local_global['selectdata'] = selectdata
            if scalebychan is not None: local_global['scalebychan'] = scalebychan
            if standard is not None: local_global['standard'] = standard
            if usescratch is not None: local_global['usescratch'] = usescratch

            # the invocation parameters for the non-subparameters can now be set - this picks up those defaults
            _invocation_parameters['vis'] = self.__vis( local_global )
            _invocation_parameters['field'] = self.__field( local_global )
            _invocation_parameters['spw'] = self.__spw( local_global )
            _invocation_parameters['selectdata'] = self.__selectdata( local_global )
            _invocation_parameters['scalebychan'] = self.__scalebychan( local_global )
            _invocation_parameters['standard'] = self.__standard( local_global )
            _invocation_parameters['usescratch'] = self.__usescratch( local_global )

            # the sub-parameters can then be set. Use the supplied value if not None, else the function, which gets the appropriate default
            _invocation_parameters['timerange'] = self.__timerange( _invocation_parameters ) if timerange is None else timerange
            _invocation_parameters['scan'] = self.__scan( _invocation_parameters ) if scan is None else scan
            _invocation_parameters['intent'] = self.__intent( _invocation_parameters ) if intent is None else intent
            _invocation_parameters['observation'] = self.__observation( _invocation_parameters ) if observation is None else observation
            _invocation_parameters['model'] = self.__model( _invocation_parameters ) if model is None else model
            _invocation_parameters['listmodels'] = self.__listmodels( _invocation_parameters ) if listmodels is None else listmodels
            _invocation_parameters['fluxdensity'] = self.__fluxdensity( _invocation_parameters ) if fluxdensity is None else fluxdensity
            _invocation_parameters['spix'] = self.__spix( _invocation_parameters ) if spix is None else spix
            _invocation_parameters['reffreq'] = self.__reffreq( _invocation_parameters ) if reffreq is None else reffreq
            _invocation_parameters['polindex'] = self.__polindex( _invocation_parameters ) if polindex is None else polindex
            _invocation_parameters['polangle'] = self.__polangle( _invocation_parameters ) if polangle is None else polangle
            _invocation_parameters['rotmeas'] = self.__rotmeas( _invocation_parameters ) if rotmeas is None else rotmeas
            _invocation_parameters['fluxdict'] = self.__fluxdict( _invocation_parameters ) if fluxdict is None else fluxdict
            _invocation_parameters['useephemdir'] = self.__useephemdir( _invocation_parameters ) if useephemdir is None else useephemdir
            _invocation_parameters['interpolation'] = self.__interpolation( _invocation_parameters ) if interpolation is None else interpolation
            _invocation_parameters['ismms'] = self.__ismms( _invocation_parameters ) if ismms is None else ismms

        else:
            # invoke with inp/go semantics
            _invocation_parameters['vis'] = self.__vis( self.__globals_( ) )
            _invocation_parameters['field'] = self.__field( self.__globals_( ) )
            _invocation_parameters['spw'] = self.__spw( self.__globals_( ) )
            _invocation_parameters['selectdata'] = self.__selectdata( self.__globals_( ) )
            _invocation_parameters['timerange'] = self.__timerange( self.__globals_( ) )
            _invocation_parameters['scan'] = self.__scan( self.__globals_( ) )
            _invocation_parameters['intent'] = self.__intent( self.__globals_( ) )
            _invocation_parameters['observation'] = self.__observation( self.__globals_( ) )
            _invocation_parameters['scalebychan'] = self.__scalebychan( self.__globals_( ) )
            _invocation_parameters['standard'] = self.__standard( self.__globals_( ) )
            _invocation_parameters['model'] = self.__model( self.__globals_( ) )
            _invocation_parameters['listmodels'] = self.__listmodels( self.__globals_( ) )
            _invocation_parameters['fluxdensity'] = self.__fluxdensity( self.__globals_( ) )
            _invocation_parameters['spix'] = self.__spix( self.__globals_( ) )
            _invocation_parameters['reffreq'] = self.__reffreq( self.__globals_( ) )
            _invocation_parameters['polindex'] = self.__polindex( self.__globals_( ) )
            _invocation_parameters['polangle'] = self.__polangle( self.__globals_( ) )
            _invocation_parameters['rotmeas'] = self.__rotmeas( self.__globals_( ) )
            _invocation_parameters['fluxdict'] = self.__fluxdict( self.__globals_( ) )
            _invocation_parameters['useephemdir'] = self.__useephemdir( self.__globals_( ) )
            _invocation_parameters['interpolation'] = self.__interpolation( self.__globals_( ) )
            _invocation_parameters['usescratch'] = self.__usescratch( self.__globals_( ) )
            _invocation_parameters['ismms'] = self.__ismms( self.__globals_( ) )
        try:
            with open(_prefile,'w') as _f:
                for _i in _invocation_parameters:
                    _f.write("%-13s = %s\n" % (_i,noobj(repr(_invocation_parameters[_i]))))
                _f.write("#setjy( ")
                count = 0
                for _i in _invocation_parameters:
                    _f.write("%s=%s" % (_i,noobj(repr(_invocation_parameters[_i]))))
                    count += 1
                    if count < len(_invocation_parameters): _f.write(",")
                _f.write(" )\n")
        except: pass
        try:
            _logging_state_ = None
            assert _pc.validate(_invocation_parameters,self.__schema), create_error_string(_pc.errors)
            _logging_state_ = _start_log( 'setjy', [ 'vis=' + repr(_pc.document['vis']), 'field=' + repr(_pc.document['field']), 'spw=' + repr(_pc.document['spw']), 'selectdata=' + repr(_pc.document['selectdata']), 'timerange=' + repr(_pc.document['timerange']), 'scan=' + repr(_pc.document['scan']), 'intent=' + repr(_pc.document['intent']), 'observation=' + repr(_pc.document['observation']), 'scalebychan=' + repr(_pc.document['scalebychan']), 'standard=' + repr(_pc.document['standard']), 'model=' + repr(_pc.document['model']), 'listmodels=' + repr(_pc.document['listmodels']), 'fluxdensity=' + repr(_pc.document['fluxdensity']), 'spix=' + repr(_pc.document['spix']), 'reffreq=' + repr(_pc.document['reffreq']), 'polindex=' + repr(_pc.document['polindex']), 'polangle=' + repr(_pc.document['polangle']), 'rotmeas=' + repr(_pc.document['rotmeas']), 'fluxdict=' + repr(_pc.document['fluxdict']), 'useephemdir=' + repr(_pc.document['useephemdir']), 'interpolation=' + repr(_pc.document['interpolation']), 'usescratch=' + repr(_pc.document['usescratch']), 'ismms=' + repr(_pc.document['ismms']) ] )
            task_result = _setjy_t( _pc.document['vis'],_pc.document['field'],_pc.document['spw'],_pc.document['selectdata'],_pc.document['timerange'],_pc.document['scan'],_pc.document['intent'],_pc.document['observation'],_pc.document['scalebychan'],_pc.document['standard'],_pc.document['model'],_pc.document['listmodels'],_pc.document['fluxdensity'],_pc.document['spix'],_pc.document['reffreq'],_pc.document['polindex'],_pc.document['polangle'],_pc.document['rotmeas'],_pc.document['fluxdict'],_pc.document['useephemdir'],_pc.document['interpolation'],_pc.document['usescratch'],_pc.document['ismms'] )
        except Exception as e:
            from traceback import format_exc
            from casatasks import casalog
            casalog.origin('setjy')
            casalog.post("Exception Reported: Error in setjy: %s" % str(e),'SEVERE')
            casalog.post(format_exc( ))
            raise #exception is now raised
            #task_result = False
        finally:
            try:
                os.rename(_prefile,_postfile)
            except: pass
            if _logging_state_:
                task_result = _end_log( _logging_state_, 'setjy', task_result )

        #Added if _setjy_t returns False and does not raise an exception.
        if task_result is False:
            raise

        return task_result #Still needed

setjy = _setjy( )

