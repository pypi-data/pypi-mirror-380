import os
from pathlib import Path
from typing import Dict, Set, Any, Optional

import pyotp
import typer
from dotenv import load_dotenv, set_key

from t3api_utils.auth.interfaces import T3Credentials
from t3api_utils.cli.consts import (
    DEFAULT_ENV_PATH,
    DEFAULT_OTP_WHITELIST,
    DEFAULT_CREDENTIAL_EMAIL_WHITELIST,
    DEFAULT_T3_API_HOST,
    EnvKeys
)
from t3api_utils.exceptions import AuthenticationError
from t3api_utils.logging import get_logger
from t3api_utils.style import print_error, print_info, print_subheader

__all__ = ["DEFAULT_ENV_PATH", "ConfigManager", "config_manager", "generate_otp_from_seed", "load_credentials_from_env", "offer_to_save_credentials", "prompt_for_credentials_or_error", "resolve_auth_inputs_or_error"]

logger = get_logger(__name__)


class ConfigManager:
    """
    Centralized configuration manager for .t3.env file.

    Handles auto-generation, validation, and reading of the comprehensive
    .t3.env configuration file with all t3api-utils settings.
    """

    def __init__(self, config_path: str = DEFAULT_ENV_PATH):
        self.config_path = config_path
        self._config_cache: Optional[Dict[str, Any]] = None

    def ensure_config_exists(self) -> None:
        """Ensure .t3.env exists and is complete, auto-generating if needed."""
        if not self._config_exists() or self._needs_update():
            self._generate_config_file()
            print_info(f"Generated/updated {self.config_path} configuration file")

    def _config_exists(self) -> bool:
        """Check if config file exists."""
        return Path(self.config_path).exists()

    def _needs_update(self) -> bool:
        """Check if config file needs updating (missing keys or sections)."""
        if not self._config_exists():
            return True

        load_dotenv(dotenv_path=self.config_path)

        # Check for any missing required keys
        required_keys = [
            EnvKeys.T3_API_HOST,
            EnvKeys.HTTP_TIMEOUT,
            EnvKeys.MAX_WORKERS,
            EnvKeys.RATE_LIMIT_RPS,
            EnvKeys.OTP_WHITELIST,
            EnvKeys.EMAIL_WHITELIST,
        ]

        for key in required_keys:
            if not os.getenv(key.value):
                return True

        return False

    def _generate_config_file(self) -> None:
        """Generate comprehensive .t3.env file with all settings and comments."""
        # Read existing values to preserve them
        existing_values = {}
        if self._config_exists():
            load_dotenv(dotenv_path=self.config_path)
            for key in EnvKeys:
                value = os.getenv(key.value)
                if value:
                    existing_values[key.value] = value

        config_content = self._generate_config_template(existing_values)

        with open(self.config_path, 'w', encoding='utf-8') as f:
            f.write(config_content)

    def _generate_config_template(self, existing_values: Dict[str, str]) -> str:
        """Generate the complete .t3.env template with comments."""
        template = """# =============================================================================
# T3 API UTILS CONFIGURATION FILE
# =============================================================================
# This file contains all configuration settings for the t3api-utils library.
# Auto-generated by t3api-utils - edit values as needed.
#
# Settings are organized into logical sections with detailed comments.
# Uncomment and modify values to customize behavior.
# =============================================================================

# =============================================================================
# AUTHENTICATION CONFIGURATION
# =============================================================================

# Primary Metrc authentication credentials
# e.g., ca.metrc.com, mo.metrc.com, co.metrc.com
METRC_HOSTNAME={metrc_hostname}
# Your Metrc username
METRC_USERNAME={metrc_username}
# Your Metrc password
METRC_PASSWORD={metrc_password}
# Email address (required for co.metrc.com)
METRC_EMAIL={metrc_email}

# Alternative authentication methods (optional)
# Pre-existing JWT token (bypasses credentials)
JWT_TOKEN={jwt_token}
# API key authentication
# Your API key for T3 API
API_KEY={api_key}
# State code for API key (e.g., CA, MO, CO, MI)
API_STATE_CODE={api_state_code}

# =============================================================================
# API CONNECTION CONFIGURATION
# =============================================================================

# T3 API base URL - change for staging/custom environments
# Production API endpoint
T3_API_HOST={t3_api_host}

# Request timeout settings (seconds)
# General request timeout
HTTP_TIMEOUT={http_timeout}
# Connection establishment timeout
HTTP_CONNECT_TIMEOUT={http_connect_timeout}
# Response reading timeout
HTTP_READ_TIMEOUT={http_read_timeout}
# SSL certificate verification (true/false)
VERIFY_SSL={verify_ssl}

# =============================================================================
# PERFORMANCE CONFIGURATION
# =============================================================================

# Parallel processing limits
# Maximum concurrent threads/tasks
MAX_WORKERS={max_workers}
# Default batch size for data processing
BATCH_SIZE={batch_size}

# Rate limiting (prevents API throttling)
# Maximum requests per second
RATE_LIMIT_RPS={rate_limit_rps}
# Burst allowance for rate limiter
RATE_LIMIT_BURST={rate_limit_burst}

# Retry policy for failed requests
# Maximum retry attempts
RETRY_MAX_ATTEMPTS={retry_max_attempts}
# Exponential backoff multiplier
RETRY_BACKOFF_FACTOR={retry_backoff_factor}
# Minimum wait between retries (seconds)
RETRY_MIN_WAIT={retry_min_wait}

# =============================================================================
# HOSTNAME-SPECIFIC BEHAVIOR
# =============================================================================

# Metrc hostnames requiring OTP (two-factor authentication)
# Comma-separated list of hostnames
OTP_WHITELIST={otp_whitelist}

# TOTP seed for automatic OTP generation (optional)
# Base32-encoded seed from your authenticator app setup
# If set, OTP will be generated automatically for whitelisted hostnames
# If empty, you will be prompted to enter OTP manually
OTP_SEED={otp_seed}

# Metrc hostnames requiring email during authentication
# Comma-separated list of hostnames
EMAIL_WHITELIST={email_whitelist}

# =============================================================================
# DEVELOPMENT & DEBUG CONFIGURATION
# =============================================================================

# Logging configuration
# DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL={log_level}
# simple, detailed, json
LOG_FORMAT={log_format}
# Enable verbose debug output (true/false)
DEBUG_MODE={debug_mode}

# Development features
# Cache API responses for development (true/false)
CACHE_RESPONSES={cache_responses}

# =============================================================================
# OUTPUT & FILE HANDLING
# =============================================================================

# Default directories
# Directory for generated files
OUTPUT_DIR={output_dir}
# Temporary files directory
TEMP_DIR={temp_dir}

# File handling preferences
# Automatically open saved files (true/false)
AUTO_OPEN_FILES={auto_open_files}
# Remove empty CSV columns (true/false)
STRIP_EMPTY_COLUMNS={strip_empty_columns}
# Default export format (csv, json)
DEFAULT_FILE_FORMAT={default_file_format}

# =============================================================================
# END CONFIGURATION
# =============================================================================
"""

        # Fill in the template with existing or default values
        return template.format(
            # Authentication
            metrc_hostname=existing_values.get(EnvKeys.METRC_HOSTNAME.value, ""),
            metrc_username=existing_values.get(EnvKeys.METRC_USERNAME.value, ""),
            metrc_password=existing_values.get(EnvKeys.METRC_PASSWORD.value, ""),
            metrc_email=existing_values.get(EnvKeys.METRC_EMAIL.value, ""),
            jwt_token=existing_values.get(EnvKeys.JWT_TOKEN.value, ""),
            api_key=existing_values.get(EnvKeys.API_KEY.value, ""),
            api_state_code=existing_values.get(EnvKeys.API_STATE_CODE.value, ""),

            # API Connection
            t3_api_host=existing_values.get(EnvKeys.T3_API_HOST.value, DEFAULT_T3_API_HOST),
            http_timeout=existing_values.get(EnvKeys.HTTP_TIMEOUT.value, "30.0"),
            http_connect_timeout=existing_values.get(EnvKeys.HTTP_CONNECT_TIMEOUT.value, "10.0"),
            http_read_timeout=existing_values.get(EnvKeys.HTTP_READ_TIMEOUT.value, "60.0"),
            verify_ssl=existing_values.get(EnvKeys.VERIFY_SSL.value, "true"),

            # Performance
            max_workers=existing_values.get(EnvKeys.MAX_WORKERS.value, "10"),
            batch_size=existing_values.get(EnvKeys.BATCH_SIZE.value, "100"),
            rate_limit_rps=existing_values.get(EnvKeys.RATE_LIMIT_RPS.value, "10"),
            rate_limit_burst=existing_values.get(EnvKeys.RATE_LIMIT_BURST.value, "20"),
            retry_max_attempts=existing_values.get(EnvKeys.RETRY_MAX_ATTEMPTS.value, "3"),
            retry_backoff_factor=existing_values.get(EnvKeys.RETRY_BACKOFF_FACTOR.value, "2.0"),
            retry_min_wait=existing_values.get(EnvKeys.RETRY_MIN_WAIT.value, "1.0"),

            # Hostname behavior
            otp_whitelist=existing_values.get(EnvKeys.OTP_WHITELIST.value, "mi.metrc.com"),
            otp_seed=existing_values.get(EnvKeys.OTP_SEED.value, ""),
            email_whitelist=existing_values.get(EnvKeys.EMAIL_WHITELIST.value, "co.metrc.com"),

            # Development
            log_level=existing_values.get(EnvKeys.LOG_LEVEL.value, "INFO"),
            log_format=existing_values.get(EnvKeys.LOG_FORMAT.value, "detailed"),
            debug_mode=existing_values.get(EnvKeys.DEBUG_MODE.value, "false"),
            cache_responses=existing_values.get(EnvKeys.CACHE_RESPONSES.value, "false"),

            # Output
            output_dir=existing_values.get(EnvKeys.OUTPUT_DIR.value, "output"),
            temp_dir=existing_values.get(EnvKeys.TEMP_DIR.value, "temp"),
            auto_open_files=existing_values.get(EnvKeys.AUTO_OPEN_FILES.value, "true"),
            strip_empty_columns=existing_values.get(EnvKeys.STRIP_EMPTY_COLUMNS.value, "true"),
            default_file_format=existing_values.get(EnvKeys.DEFAULT_FILE_FORMAT.value, "csv"),
        )

    def get_config_value(self, key: EnvKeys, default: Any = None) -> Any:
        """Get a configuration value with type conversion and defaults."""
        load_dotenv(dotenv_path=self.config_path)
        value = os.getenv(key.value)

        if value is None:
            return default

        # Type conversion based on key
        if key in [EnvKeys.DEBUG_MODE, EnvKeys.VERIFY_SSL, EnvKeys.AUTO_OPEN_FILES,
                   EnvKeys.STRIP_EMPTY_COLUMNS, EnvKeys.CACHE_RESPONSES]:
            return value.lower() in ['true', '1', 'yes', 'on']
        elif key in [EnvKeys.HTTP_TIMEOUT, EnvKeys.HTTP_CONNECT_TIMEOUT, EnvKeys.HTTP_READ_TIMEOUT,
                     EnvKeys.RETRY_BACKOFF_FACTOR, EnvKeys.RETRY_MIN_WAIT]:
            try:
                return float(value)
            except ValueError:
                return default
        elif key in [EnvKeys.MAX_WORKERS, EnvKeys.BATCH_SIZE, EnvKeys.RATE_LIMIT_RPS,
                     EnvKeys.RATE_LIMIT_BURST, EnvKeys.RETRY_MAX_ATTEMPTS]:
            try:
                return int(value)
            except ValueError:
                return default
        elif key in [EnvKeys.OTP_WHITELIST, EnvKeys.EMAIL_WHITELIST]:
            # Convert comma-separated string to set
            return {hostname.strip() for hostname in value.split(',') if hostname.strip()}

        return value

    def get_otp_whitelist(self) -> Set[str]:
        """Get OTP whitelist with fallback to default."""
        whitelist = self.get_config_value(EnvKeys.OTP_WHITELIST)
        return whitelist if whitelist else DEFAULT_OTP_WHITELIST

    def get_email_whitelist(self) -> Set[str]:
        """Get email whitelist with fallback to default."""
        whitelist = self.get_config_value(EnvKeys.EMAIL_WHITELIST)
        return whitelist if whitelist else DEFAULT_CREDENTIAL_EMAIL_WHITELIST

    def get_api_host(self) -> str:
        """Get T3 API host with fallback to default."""
        host = self.get_config_value(EnvKeys.T3_API_HOST)
        return host if host else DEFAULT_T3_API_HOST

    def get_otp_seed(self) -> Optional[str]:
        """Get OTP seed for TOTP generation."""
        seed = self.get_config_value(EnvKeys.OTP_SEED)
        return seed.strip() if seed else None


# Global configuration manager instance
config_manager = ConfigManager()


def generate_otp_from_seed() -> Optional[str]:
    """
    Generate a 6-digit TOTP code from the OTP_SEED environment variable.

    Returns:
        6-digit OTP string if OTP_SEED is configured, None otherwise.

    Raises:
        AuthenticationError: If OTP_SEED is malformed or TOTP generation fails.
    """
    otp_seed = config_manager.get_otp_seed()
    if not otp_seed:
        return None

    try:
        totp = pyotp.TOTP(otp_seed)
        otp_code = totp.now()

        # Ensure it's always 6 digits (pad with zeros if needed)
        return f"{int(otp_code):06d}"

    except Exception as e:
        raise AuthenticationError(f"Failed to generate OTP from seed: {e}")


def load_credentials_from_env() -> Dict[str, str]:
    """
    Load credential values from the environment file (.env).

    Returns all available authentication values including Metrc credentials,
    JWT tokens, and API key credentials.
    """
    load_dotenv(dotenv_path=DEFAULT_ENV_PATH)

    creds = {}

    # Metrc credentials
    hostname = (os.getenv(EnvKeys.METRC_HOSTNAME.value) or "").strip()
    username = (os.getenv(EnvKeys.METRC_USERNAME.value) or "").strip()
    password = (os.getenv(EnvKeys.METRC_PASSWORD.value) or "").strip()
    email = (os.getenv(EnvKeys.METRC_EMAIL.value) or "").strip()

    # Alternative authentication methods
    jwt_token = (os.getenv(EnvKeys.JWT_TOKEN.value) or "").strip()
    api_key = (os.getenv(EnvKeys.API_KEY.value) or "").strip()
    api_state_code = (os.getenv(EnvKeys.API_STATE_CODE.value) or "").strip()

    if hostname:
        creds["hostname"] = hostname
    if username:
        creds["username"] = username
    if password:
        creds["password"] = password
    if email:
        creds["email"] = email
    if jwt_token:
        creds["jwt_token"] = jwt_token
    if api_key:
        creds["api_key"] = api_key
    if api_state_code:
        creds["api_state_code"] = api_state_code

    return creds


def offer_to_save_credentials(*, credentials: T3Credentials) -> None:
    """
    Offer to save credentials to the .env file if it's missing or out-of-date.
    """
    load_dotenv(dotenv_path=DEFAULT_ENV_PATH)
    env_exists = os.path.exists(DEFAULT_ENV_PATH)

    current_hostname = os.getenv(EnvKeys.METRC_HOSTNAME.value, "").strip()
    current_username = os.getenv(EnvKeys.METRC_USERNAME.value, "").strip()
    current_password = os.getenv(EnvKeys.METRC_PASSWORD.value, "").strip()
    current_email = os.getenv(EnvKeys.METRC_EMAIL.value, "").strip()

    hostname_differs = credentials["hostname"] != current_hostname
    username_differs = credentials["username"] != current_username
    password_differs = credentials["password"] != current_password

    # Only check email differences if the hostname requires email
    email_differs = False
    if credentials["hostname"] in config_manager.get_email_whitelist():
        email_differs = credentials.get("email") != current_email

    if not env_exists:
        if typer.confirm(
            f"No credentials file found. Save these values to {DEFAULT_ENV_PATH}?",
            default=True,
        ):
            logger.info("[green]Saving credentials to new environment file.[/green]")
            set_key(
                DEFAULT_ENV_PATH, EnvKeys.METRC_HOSTNAME.value, credentials["hostname"]
            )
            set_key(
                DEFAULT_ENV_PATH, EnvKeys.METRC_USERNAME.value, credentials["username"]
            )
            set_key(
                DEFAULT_ENV_PATH, EnvKeys.METRC_PASSWORD.value, credentials["password"]
            )
            email_value = credentials.get("email")
            if email_value:
                set_key(
                    DEFAULT_ENV_PATH, EnvKeys.METRC_EMAIL.value, email_value
                )
    elif hostname_differs or username_differs or password_differs or email_differs:
        if typer.confirm(
            f"Some credential values differ from those in {DEFAULT_ENV_PATH}. Update them?",
            default=True,
        ):
            logger.info("[cyan]Updating credentials in environment file.[/cyan]")
            set_key(
                DEFAULT_ENV_PATH, EnvKeys.METRC_HOSTNAME.value, credentials["hostname"]
            )
            set_key(
                DEFAULT_ENV_PATH, EnvKeys.METRC_USERNAME.value, credentials["username"]
            )
            set_key(
                DEFAULT_ENV_PATH, EnvKeys.METRC_PASSWORD.value, credentials["password"]
            )
            email_value = credentials.get("email")
            if email_value:
                set_key(
                    DEFAULT_ENV_PATH, EnvKeys.METRC_EMAIL.value, email_value
                )


def prompt_for_credentials_or_error(**kwargs: object) -> T3Credentials:
    """
    Prompt for any missing credentials, using provided values if available.
    """
    hostname = str(kwargs.get("hostname", "")) if kwargs.get("hostname") else None
    username = str(kwargs.get("username", "")) if kwargs.get("username") else None
    password = str(kwargs.get("password", "")) if kwargs.get("password") else None
    email = str(kwargs.get("email", "")) if kwargs.get("email") else None

    if hostname:
        print_info(f"Using stored value for hostname: {hostname}")
    else:
        hostname = typer.prompt("Enter Metrc hostname (e.g., mo.metrc.com)")

    if username:
        print_info(f"Using stored value for username: {username}")
    else:
        username = typer.prompt("Enter Metrc username")

    if password:
        print_info("Using stored value for password.")
    else:
        password = typer.prompt("Enter Metrc password", hide_input=True)

    credentials: T3Credentials = {
        "hostname": hostname or "",
        "username": username or "",
        "password": password or "",
        "otp": None,
        "email": None,
    }

    if hostname in config_manager.get_otp_whitelist():
        # Try to generate OTP from seed first, otherwise prompt user
        otp = generate_otp_from_seed()
        if otp:
            print_info("Using OTP generated from configured seed")
            credentials["otp"] = otp
        else:
            otp = typer.prompt("Enter 6-digit Metrc 2-factor authentication code")
            if not otp or len(otp) != 6 or not otp.isdigit():
                print_error("Invalid 2-factor authentication entered.")
                raise AuthenticationError(f"Invalid 2-factor authentication: {otp}")
            credentials["otp"] = otp

    if hostname in config_manager.get_email_whitelist():
        if email:
            print_info(f"Using stored value for email: {email}")
            credentials["email"] = email
        else:
            email_input = typer.prompt("Enter Metrc email address")
            if not email_input or "@" not in email_input:
                print_error("Invalid email address entered.")
                raise AuthenticationError(f"Invalid email address: {email_input}")
            credentials["email"] = email_input

    for key, value in credentials.items():
        if key not in ("otp", "email") and (not isinstance(value, str) or not value.strip()):
            print_error(f"Missing or empty credential: {key}")
            raise AuthenticationError(f"Missing or empty credential: {key}")

    return credentials


def resolve_auth_inputs_or_error() -> T3Credentials:
    """
    Resolve authentication credentials from env and/or prompt and offer to save.
    """
    print_subheader("Authentication Required")
    stored_credentials = load_credentials_from_env()
    credentials = prompt_for_credentials_or_error(**stored_credentials)
    offer_to_save_credentials(credentials=credentials)
    return credentials
