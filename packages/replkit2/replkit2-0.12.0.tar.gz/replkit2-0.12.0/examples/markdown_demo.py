#!/usr/bin/env python3
"""
Markdown Formatter Demo

This example demonstrates the markdown display type with:
- Frontmatter support
- Various markdown elements including Table and Alert
- Table truncation and transforms
- Custom element creation
- Builder pattern usage

Run:
    uv run python examples/markdown_demo.py
"""

from dataclasses import dataclass, field
import time
from replkit2 import App
from replkit2.textkit.markdown import (
    markdown,
    MarkdownElement,
    register_element,
)


# Custom markdown element
class Note(MarkdownElement):
    """Custom note element with colored background (in markdown)."""

    element_type = "note"

    def __init__(self, content: str, color: str = "blue"):
        self.content = content
        self.color = color

    @classmethod
    def from_dict(cls, data: dict) -> "Note":
        return cls(content=data.get("content", ""), color=data.get("color", "blue"))

    def render(self) -> str:
        return f"> **Note ({self.color}):** {self.content}"


# Register the custom element
register_element("note", Note)


@dataclass
class DemoState:
    """Simple state for the demo."""

    documents: list[dict] = field(default_factory=list)
    network_logs: list[dict] = field(default_factory=list)


app = App("markdown_demo", DemoState)


@app.command(display="markdown")
def welcome(state):
    """Show welcome message with various markdown elements."""
    return {
        "frontmatter": {"title": "Welcome to ReplKit2 Markdown", "version": "1.0", "author": "ReplKit2 Team"},
        "elements": [
            {"type": "heading", "content": "Getting Started", "level": 1},
            {"type": "text", "content": "ReplKit2 now supports markdown display with a rich set of elements."},
            {"type": "heading", "content": "Features", "level": 2},
            {
                "type": "list",
                "items": [
                    "YAML frontmatter for metadata",
                    "Standard markdown elements",
                    "Custom element support",
                    "Builder pattern for easy construction",
                ],
            },
            {"type": "heading", "content": "Code Example", "level": 2},
            {
                "type": "code_block",
                "content": '@app.command(display="markdown")\ndef my_command(state):\n    return {"elements": [...]}',
                "language": "python",
            },
            {
                "type": "blockquote",
                "content": "The markdown formatter preserves the data-first philosophy of ReplKit2.",
            },
            {"type": "alert", "content": "New in v0.9.0: Table and Alert elements!", "level": "success"},
            {"type": "note", "content": "This is a custom element!", "color": "green"},
            {"type": "raw", "content": "\n---\n\n*Generated by ReplKit2*"},
        ],
    }


@app.command(display="markdown")
def guide(state):
    """Show guide using the builder pattern."""
    return (
        markdown()
        .frontmatter(title="ReplKit2 Markdown Guide", date="2025-01-28", tags=["documentation", "markdown"])
        .heading("Using the Builder")
        .text("The markdown builder provides a fluent interface for creating documents.")
        .heading("Basic Elements", level=2)
        .text("You can add various elements in sequence:")
        .list_(
            [
                "Text paragraphs",
                "Headings with levels 1-6",
                "Code blocks with syntax highlighting",
                "Blockquotes for emphasis",
                "Lists (ordered and unordered)",
                "Tables with truncation and transforms",
                "Alerts with severity levels",
            ]
        )
        .heading("Advanced Usage", level=2)
        .code_block(
            """from replkit2.textkit import markdown

doc = (markdown()
    .frontmatter(title="My Doc")
    .heading("Chapter 1")
    .text("Content goes here...")
    .build())""",
            language="python",
        )
        .blockquote("Remember: The builder returns a dict with 'elements' and 'frontmatter' fields.")
        .heading("Custom Elements", level=2)
        .text("You can also use custom elements with the generic element() method:")
        .element("note", content="Custom elements auto-register!", color="yellow")
        .build()
    )


@app.command(display="markdown")
def api_docs(state):
    """Generate API documentation in markdown."""
    return {
        "frontmatter": {"title": "API Reference", "type": "reference", "auto_generated": True},
        "elements": [
            {"type": "heading", "content": "MarkdownElement API"},
            {"type": "text", "content": "Base class for all markdown elements."},
            {"type": "heading", "content": "Required Methods", "level": 2},
            {
                "type": "code_block",
                "content": """class MyElement(MarkdownElement):
    element_type = "my_element"  # Required
    
    @classmethod
    def from_dict(cls, data: dict) -> "MyElement":
        # Create instance from dict
        pass
    
    def render(self) -> str:
        # Return markdown string
        pass""",
                "language": "python",
            },
            {"type": "heading", "content": "Element Registration", "level": 2},
            {
                "type": "text",
                "content": "Elements must be explicitly registered using register_element() in v0.9.0+.",
            },
            {
                "type": "list",
                "items": [
                    "Define element_type class variable",
                    "Implement from_dict() class method",
                    "Implement render() instance method",
                ],
                "ordered": True,
            },
            {"type": "note", "content": "See the Note class in this file for a complete example.", "color": "blue"},
        ],
    }


@app.command()
def add_doc(state, title: str, content: str):
    """Add a document to track."""
    doc = {"title": title, "content": content, "id": len(state.documents) + 1}
    state.documents.append(doc)
    return f"Added document #{doc['id']}: {title}"


@app.command(display="table", headers=["ID", "Title", "Length"])
def list_docs(state):
    """List all tracked documents."""
    return [{"ID": doc["id"], "Title": doc["title"], "Length": len(doc["content"])} for doc in state.documents]


@app.command(display="markdown")
def table_demo(state):
    """Demonstrate Table element with truncation and transforms."""
    # Add some sample network logs if empty
    if not state.network_logs:
        base_time = int(time.time() * 1000)
        state.network_logs = [
            {
                "url": "https://api.example.com/users/profile/123456789/settings",
                "method": "GET",
                "status": 200,
                "size": 1024,
                "timestamp": base_time - 5000,
                "duration": 0.123,
            },
            {
                "url": "https://cdn.example.com/static/images/banner-hero-2025-01-28-final-v2.jpg",
                "method": "GET",
                "status": 304,
                "size": 0,
                "timestamp": base_time - 3000,
                "duration": 0.045,
            },
            {
                "url": "https://api.example.com/data/analytics/events/batch",
                "method": "POST",
                "status": 201,
                "size": 2048576,
                "timestamp": base_time - 1000,
                "duration": 1.234,
            },
        ]

    return {
        "elements": [
            {"type": "heading", "content": "Table with Truncation and Transforms"},
            {"type": "text", "content": "This table demonstrates the new display-level formatting features:"},
            {
                "type": "list",
                "items": [
                    "URLs are truncated in the middle to preserve domain and endpoint",
                    "Sizes are formatted from bytes to human-readable (1.5M, 1K)",
                    "Timestamps show time format",
                    "Duration shows seconds with precision",
                ],
            },
            {
                "type": "table",
                "headers": ["URL", "Method", "Status", "Size", "Time", "Duration"],
                "rows": state.network_logs,
                "truncate": {
                    "URL": {"max": 50, "mode": "middle"},
                },
                "transforms": {
                    "Size": "format_size",
                    "Time": "format_timestamp",
                    "Duration": "format_duration",
                },
            },
            {
                "type": "alert",
                "content": "Note: Full data is preserved - truncation happens only at display time!",
                "level": "info",
            },
        ]
    }


@app.command(display="markdown")
def alerts_demo(state):
    """Demonstrate Alert elements with different severity levels."""
    return (
        markdown()
        .heading("Alert Element Examples")
        .text("The Alert element provides contextual messages with different severity levels:")
        .element("alert", content="This is an error alert - something went wrong!", level="error")
        .element("alert", content="This is a warning - please review this action.", level="warning")
        .element("alert", content="This is an info alert - here's something to know.", level="info")
        .element("alert", content="This is a success alert - operation completed!", level="success")
        .heading("Using Alerts in Data", level=2)
        .text("Alerts can be used to provide contextual feedback in your commands:")
        .code_block(
            """{
    "type": "alert",
    "content": "Database migration completed successfully",
    "level": "success"
}""",
            language="json",
        )
        .build()
    )


@app.command(
    display="markdown",
    truncate={"path": {"max": 40, "mode": "start"}},
    transforms={"size": "format_size", "modified": "format_timestamp"},
)
def files_with_transforms(state):
    """Demonstrate command-level truncate and transforms."""
    # Mock file data
    files = [
        {
            "path": "/home/user/projects/replkit2/src/replkit2/app.py",
            "size": 15234,
            "modified": int(time.time() * 1000) - 3600000,
        },
        {
            "path": "/home/user/projects/replkit2/src/replkit2/textkit/markdown/table.py",
            "size": 8192,
            "modified": int(time.time() * 1000) - 86400000,
        },
        {
            "path": "/home/user/documents/important/project-report-2025-final.pdf",
            "size": 2097152,
            "modified": int(time.time() * 1000) - 172800000,
        },
    ]

    return {
        "elements": [
            {"type": "heading", "content": "Command-Level Transforms"},
            {"type": "text", "content": "This command uses truncate and transforms parameters in the decorator:"},
            {
                "type": "code_block",
                "content": '@app.command(\n    display="markdown",\n    truncate={"path": {"max": 40, "mode": "start"}},\n    transforms={"size": "format_size", "modified": "format_timestamp"}\n)',
                "language": "python",
            },
            {
                "type": "table",
                "headers": ["Path", "Size", "Modified"],
                "rows": files,
            },
            {
                "type": "alert",
                "content": "Paths are truncated from the start, preserving the filename!",
                "level": "info",
            },
        ]
    }


if __name__ == "__main__":
    app.run(title="Markdown Formatter Demo")
