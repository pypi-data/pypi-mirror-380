from __future__ import annotations
import collections.abc
import enum
import numpy
import numpy.typing
import typing
from . import private
__all__: list[str] = ['AbstractOptimizationAlgorithmCreator', 'Affine', 'AffineCompact', 'AngleAxis', 'BINARY', 'BaseRobustKernel', 'BlockSolverBase', 'BlockSolverSE2', 'BlockSolverSE3', 'BlockSolverSim3', 'BlockSolverX', 'CameraParameters', 'EdgeGICP', 'EdgeInverseSim3ProjectXYZ', 'EdgePointXY', 'EdgePointXYZ', 'EdgeProjectP2MC', 'EdgeProjectP2SC', 'EdgeProjectPSI2UV', 'EdgeProjectXYZ2UV', 'EdgeProjectXYZ2UVU', 'EdgeSBACam', 'EdgeSBAScale', 'EdgeSE2', 'EdgeSE2LotsOfXY', 'EdgeSE2OdomDifferentialCalib', 'EdgeSE2Offset', 'EdgeSE2PointXY', 'EdgeSE2PointXYBearing', 'EdgeSE2PointXYCalib', 'EdgeSE2PointXYOffset', 'EdgeSE2Prior', 'EdgeSE2SensorCalib', 'EdgeSE2TwoPointsXY', 'EdgeSE2XYPrior', 'EdgeSE3', 'EdgeSE3Expmap', 'EdgeSE3LotsOfXYZ', 'EdgeSE3Offset', 'EdgeSE3PointXYZ', 'EdgeSE3PointXYZDepth', 'EdgeSE3PointXYZDisparity', 'EdgeSE3Prior', 'EdgeSE3ProjectXYZ', 'EdgeSE3ProjectXYZOnlyPose', 'EdgeSim3', 'EdgeSim3ProjectXYZ', 'EdgeStereoSE3ProjectXYZ', 'EdgeStereoSE3ProjectXYZOnlyPose', 'EdgeVVGicp', 'EdgeXyzVsc', 'EstimatePropagator', 'EstimatePropagatorCost', 'EstimatePropagatorCostBase', 'EstimatePropagatorCostOdometry', 'Factory', 'G2O', 'G2OBatchStatistics', 'HyperDijkstra', 'HyperGraph', 'HyperGraphAction', 'IoFileFilter', 'IoFormat', 'IoWrapper', 'Isometry', 'Isometry2d', 'Isometry3d', 'JSON', 'JacobianWorkspace', 'LinearSolverCSparseSE2', 'LinearSolverCSparseSE3', 'LinearSolverCSparseSim3', 'LinearSolverCSparseX', 'LinearSolverCholmodSE2', 'LinearSolverCholmodSE3', 'LinearSolverCholmodSim3', 'LinearSolverCholmodX', 'LinearSolverDenseSE2', 'LinearSolverDenseSE3', 'LinearSolverDenseSim3', 'LinearSolverDenseX', 'LinearSolverEigenSE2', 'LinearSolverEigenSE3', 'LinearSolverEigenSim3', 'LinearSolverEigenX', 'LinearSolverPCGSE2', 'LinearSolverPCGSE3', 'LinearSolverPCGSim3', 'LinearSolverPCGX', 'MotionMeasurement', 'OdomConvert', 'OptimizableGraph', 'OptimizationAlgorithm', 'OptimizationAlgorithmDogleg', 'OptimizationAlgorithmGaussNewton', 'OptimizationAlgorithmLevenberg', 'OptimizationAlgorithmProperty', 'OptimizationAlgorithmWithHessian', 'Parameter', 'ParameterCamera', 'ParameterSE2Offset', 'ParameterSE3Offset', 'Projective', 'PyBlockSolverBase', 'Quaternion', 'RegisterOptimizationAlgorithmProxy', 'RobustKernelCauchy', 'RobustKernelDCS', 'RobustKernelFair', 'RobustKernelGemanMcClure', 'RobustKernelHuber', 'RobustKernelPseudoHuber', 'RobustKernelSaturated', 'RobustKernelScaleDelta', 'RobustKernelTukey', 'RobustKernelWelsch', 'Rotation2d', 'SBACam', 'SE2', 'SE3Quat', 'Sim3', 'Simulator', 'Simulator2D', 'Simulator2DConfig', 'Simulator3D', 'Simulator3DConfig', 'SimulatorConfig', 'Solver', 'SparseBlockMatrixX', 'SparseOptimizer', 'SparseOptimizerTerminateAction', 'StereoCameraParameters', 'TransformTraits', 'UniformCostFunction', 'VariableVectorXEdge', 'VectorXVertex', 'VelocityMeasurement', 'VertexCam', 'VertexIntrinsics', 'VertexIntrinsicsEstimate', 'VertexOdomDifferentialParams', 'VertexPointXY', 'VertexPointXYZ', 'VertexSCam', 'VertexSE2', 'VertexSE3', 'VertexSE3Expmap', 'VertexSim3Expmap', 'World', 'private']
class AbstractOptimizationAlgorithmCreator:
    pass
class AngleAxis:
    @staticmethod
    def ientity() -> AngleAxis:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsFloat, arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: AngleAxis) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: AngleAxis) -> Quaternion:
        ...
    @typing.overload
    def __mul__(self, arg0: Quaternion) -> Quaternion:
        ...
    def __rmul__(self, arg0: Quaternion) -> Quaternion:
        ...
    def angle(self) -> float:
        ...
    def axis(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def from_rotation_matrix(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    def inverse(self) -> AngleAxis:
        ...
    def matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    def rotation_matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    def to_rotation_matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @property
    def R(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
class BaseRobustKernel:
    def delta(self) -> float:
        ...
    def robustify(self, squared_error: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    def set_delta(self, delta: typing.SupportsFloat) -> None:
        ...
class BlockSolverBase(Solver):
    pass
class BlockSolverSE2(PyBlockSolverBase):
    @typing.overload
    def __init__(self, arg0: LinearSolverCholmodSE2) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverCSparseSE2) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverEigenSE2) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverDenseSE2) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverPCGSE2) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class BlockSolverSE3(PyBlockSolverBase):
    @typing.overload
    def __init__(self, arg0: LinearSolverCholmodSE3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverCSparseSE3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverEigenSE3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverDenseSE3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverPCGSE3) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class BlockSolverSim3(PyBlockSolverBase):
    @typing.overload
    def __init__(self, arg0: LinearSolverCholmodSim3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverCSparseSim3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverEigenSim3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverDenseSim3) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverPCGSim3) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class BlockSolverX(PyBlockSolverBase):
    @typing.overload
    def __init__(self, arg0: LinearSolverCholmodX) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverCSparseX) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverEigenX) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverDenseX) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: LinearSolverPCGX) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class CameraParameters(Parameter):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsFloat, arg1: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"], arg2: typing.SupportsFloat) -> None:
        ...
    def cam_map(self, trans_xyz: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def stereocam_uvu_map(self, trans_xyz: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
class EdgeGICP:
    def __init__(self) -> None:
        ...
    def cov0(self, e: typing.SupportsFloat) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        """
        return a covariance matrix for plane-plane
        """
    def cov1(self, e: typing.SupportsFloat) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        """
        return a covariance matrix for plane-plane
        """
    def make_rot0(self) -> None:
        """
        set up rotation matrix for pos0
        """
    def make_rot1(self) -> None:
        """
        set up rotation matrix for pos1
        """
    def prec0(self, e: typing.SupportsFloat) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        """
        returns a precision matrix for point-plane
        """
    def prec1(self, e: typing.SupportsFloat) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        """
        returns a precision matrix for point-plane
        """
    @property
    def R0(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @R0.setter
    def R0(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def R1(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @R1.setter
    def R1(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def normal0(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    @normal0.setter
    def normal0(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    @property
    def normal1(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    @normal1.setter
    def normal1(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    @property
    def pos0(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    @pos0.setter
    def pos0(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    @property
    def pos1(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    @pos1.setter
    def pos1(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class EdgeInverseSim3ProjectXYZ(private.BaseBinaryEdge_2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexPointXYZ_g2o::VertexSim3Expmap):
    def __init__(self) -> None:
        ...
class EdgePointXY(private.BaseBinaryEdge_2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexPointXY_g2o::VertexPointXY):
    def __init__(self) -> None:
        ...
class EdgePointXYZ(private.BaseBinaryEdge_3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexPointXYZ_g2o::VertexPointXYZ):
    def __init__(self) -> None:
        ...
class EdgeProjectP2MC(private.BaseBinaryEdge_2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexPointXYZ_g2o::VertexCam):
    def __init__(self) -> None:
        ...
class EdgeProjectP2SC(private.BaseBinaryEdge_3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexPointXYZ_g2o::VertexCam):
    def __init__(self) -> None:
        ...
class EdgeProjectPSI2UV(private.BaseFixedSizedEdge2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexPointXYZ_g2o::VertexSE3Expmap_g2o::VertexSE3Expmap):
    def __init__(self) -> None:
        ...
class EdgeProjectXYZ2UV(private.BaseBinaryEdge_2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexPointXYZ_g2o::VertexSE3Expmap):
    def __init__(self) -> None:
        ...
class EdgeProjectXYZ2UVU(private.BaseBinaryEdge_3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexPointXYZ_g2o::VertexSE3Expmap):
    def __init__(self) -> None:
        ...
class EdgeSBACam(private.BaseBinaryEdge_6_g2o::SE3Quat_g2o::VertexCam_g2o::VertexCam):
    def __init__(self) -> None:
        ...
class EdgeSBAScale(private.BaseBinaryEdge_1_double_g2o::VertexCam_g2o::VertexCam):
    def __init__(self) -> None:
        ...
class EdgeSE2(private.BaseBinaryEdge_3_g2o::SE2_g2o::VertexSE2_g2o::VertexSE2):
    def __init__(self) -> None:
        ...
class EdgeSE2LotsOfXY(private.BaseVariableEdge_Dyn_Eigen::Matrix<double, -1, 1, 0, -1, 1>):
    def __init__(self) -> None:
        ...
class EdgeSE2OdomDifferentialCalib(private.BaseFixedSizedEdge3_g2o::VelocityMeasurement_g2o::VertexSE2_g2o::VertexSE2_g2o::VertexOdomDifferentialParams):
    def __init__(self) -> None:
        ...
class EdgeSE2Offset(private.BaseBinaryEdge_3_g2o::SE2_g2o::VertexSE2_g2o::VertexSE2):
    def __init__(self) -> None:
        ...
class EdgeSE2PointXY(private.BaseBinaryEdge_2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexSE2_g2o::VertexPointXY):
    def __init__(self) -> None:
        ...
class EdgeSE2PointXYBearing(private.BaseBinaryEdge_1_double_g2o::VertexSE2_g2o::VertexPointXY):
    def __init__(self) -> None:
        ...
class EdgeSE2PointXYCalib(private.BaseFixedSizedEdge2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexSE2_g2o::VertexPointXY_g2o::VertexSE2):
    def __init__(self) -> None:
        ...
class EdgeSE2PointXYOffset(private.BaseBinaryEdge_2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexSE2_g2o::VertexPointXY):
    def __init__(self) -> None:
        ...
class EdgeSE2Prior(private.BaseUnaryEdge3_g2o::SE2_g2o::VertexSE2):
    def __init__(self) -> None:
        ...
class EdgeSE2SensorCalib(private.BaseFixedSizedEdge3_g2o::SE2_g2o::VertexSE2_g2o::VertexSE2_g2o::VertexSE2):
    def __init__(self) -> None:
        ...
class EdgeSE2TwoPointsXY(private.BaseFixedSizedEdge4_Eigen::Matrix<double, 4, 1, 0, 4, 1>_g2o::VertexSE2_g2o::VertexPointXY_g2o::VertexPointXY):
    def __init__(self) -> None:
        ...
class EdgeSE2XYPrior(private.BaseUnaryEdge2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexSE2):
    def __init__(self) -> None:
        ...
class EdgeSE3(private.BaseBinaryEdge_6_Eigen::Transform<double, 3, 1, 0>_g2o::VertexSE3_g2o::VertexSE3):
    def __init__(self) -> None:
        ...
class EdgeSE3Expmap(private.BaseBinaryEdge_6_g2o::SE3Quat_g2o::VertexSE3Expmap_g2o::VertexSE3Expmap):
    def __init__(self) -> None:
        ...
class EdgeSE3LotsOfXYZ(private.BaseVariableEdge_Dyn_Eigen::Matrix<double, -1, 1, 0, -1, 1>):
    def __init__(self) -> None:
        ...
class EdgeSE3Offset(private.BaseBinaryEdge_6_Eigen::Transform<double, 3, 1, 0>_g2o::VertexSE3_g2o::VertexSE3):
    def __init__(self) -> None:
        ...
class EdgeSE3PointXYZ(private.BaseBinaryEdge_3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexSE3_g2o::VertexPointXYZ):
    def __init__(self) -> None:
        ...
class EdgeSE3PointXYZDepth(private.BaseBinaryEdge_3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexSE3_g2o::VertexPointXYZ):
    def __init__(self) -> None:
        ...
class EdgeSE3PointXYZDisparity(private.BaseBinaryEdge_3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexSE3_g2o::VertexPointXYZ):
    def __init__(self) -> None:
        ...
class EdgeSE3Prior(private.BaseUnaryEdge6_Eigen::Transform<double, 3, 1, 0>_g2o::VertexSE3):
    def __init__(self) -> None:
        ...
class EdgeSE3ProjectXYZ(private.BaseBinaryEdge_2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexPointXYZ_g2o::VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def cam_project(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def is_depth_positive(self) -> bool:
        ...
    @property
    def cx(self) -> float:
        ...
    @cx.setter
    def cx(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def cy(self) -> float:
        ...
    @cy.setter
    def cy(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def fx(self) -> float:
        ...
    @fx.setter
    def fx(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def fy(self) -> float:
        ...
    @fy.setter
    def fy(self, arg0: typing.SupportsFloat) -> None:
        ...
class EdgeSE3ProjectXYZOnlyPose(private.BaseUnaryEdge2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def cam_project(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def is_depth_positive(self) -> bool:
        ...
    @property
    def Xw(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    @Xw.setter
    def Xw(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    @property
    def cx(self) -> float:
        ...
    @cx.setter
    def cx(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def cy(self) -> float:
        ...
    @cy.setter
    def cy(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def fx(self) -> float:
        ...
    @fx.setter
    def fx(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def fy(self) -> float:
        ...
    @fy.setter
    def fy(self, arg0: typing.SupportsFloat) -> None:
        ...
class EdgeSim3(private.BaseBinaryEdge_7_g2o::Sim3_g2o::VertexSim3Expmap_g2o::VertexSim3Expmap):
    def __init__(self) -> None:
        ...
class EdgeSim3ProjectXYZ(private.BaseBinaryEdge_2_Eigen::Matrix<double, 2, 1, 0, 2, 1>_g2o::VertexPointXYZ_g2o::VertexSim3Expmap):
    def __init__(self) -> None:
        ...
class EdgeStereoSE3ProjectXYZ(private.BaseBinaryEdge_3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexPointXYZ_g2o::VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def cam_project(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], arg1: typing.SupportsFloat) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def is_depth_positive(self) -> bool:
        ...
    @property
    def bf(self) -> float:
        ...
    @bf.setter
    def bf(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def cx(self) -> float:
        ...
    @cx.setter
    def cx(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def cy(self) -> float:
        ...
    @cy.setter
    def cy(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def fx(self) -> float:
        ...
    @fx.setter
    def fx(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def fy(self) -> float:
        ...
    @fy.setter
    def fy(self, arg0: typing.SupportsFloat) -> None:
        ...
class EdgeStereoSE3ProjectXYZOnlyPose(private.BaseUnaryEdge3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexSE3Expmap):
    def __init__(self) -> None:
        ...
    def cam_project(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def is_depth_positive(self) -> bool:
        ...
class EdgeVVGicp(private.BaseBinaryEdge_3_g2o::EdgeGICP_g2o::VertexSE3_g2o::VertexSE3):
    pl_pl: bool
    def __init__(self) -> None:
        ...
    @property
    def cov0(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @cov0.setter
    def cov0(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def cov1(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @cov1.setter
    def cov1(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
class EdgeXyzVsc(private.BaseBinaryEdge_3_Eigen::Matrix<double, 3, 1, 0, 3, 1>_g2o::VertexPointXYZ_g2o::VertexSCam):
    def __init__(self) -> None:
        ...
class EstimatePropagator:
    class EstimatePropagateAction:
        def __call__(self, arg0: OptimizableGraph.OptimizableGraph_Edge, arg1: collections.abc.Set[HyperGraph.Vertex], arg2: OptimizableGraph.OptimizableGraph_Vertex) -> None:
            ...
        def __init__(self) -> None:
            ...
    class EstimatePropagatorAdjacencyMapEntry:
        def __init__(self) -> None:
            ...
        def child(self) -> OptimizableGraph.OptimizableGraph_Vertex:
            ...
        def distance(self) -> float:
            ...
        def edge(self) -> OptimizableGraph.OptimizableGraph_Edge:
            ...
        def frontier_level(self) -> int:
            ...
        def parent(self) -> set[HyperGraph.Vertex]:
            ...
        def reset(self) -> None:
            ...
    class EstimatePropagatorVertexIDHashFunction:
        def __call__(self, v: OptimizableGraph.OptimizableGraph_Vertex) -> int:
            ...
    def __init__(self, g: OptimizableGraph) -> None:
        ...
    def adjacency_map(self) -> dict[OptimizableGraph.OptimizableGraph_Vertex, EstimatePropagator.EstimatePropagatorAdjacencyMapEntry]:
        ...
    def graph(self) -> OptimizableGraph:
        ...
    @typing.overload
    def propagate(self, v: OptimizableGraph.OptimizableGraph_Vertex, cost: EstimatePropagatorCostBase, action: EstimatePropagator.EstimatePropagateAction, maxDistance: typing.SupportsFloat = 1.7976931348623157e+308, maxEdgeCost: typing.SupportsFloat = 1.7976931348623157e+308) -> None:
        ...
    @typing.overload
    def propagate(self, vset: collections.abc.Set[HyperGraph.Vertex], cost: EstimatePropagatorCostBase, action: EstimatePropagator.EstimatePropagateAction, maxDistance: typing.SupportsFloat = 1.7976931348623157e+308, maxEdgeCost: typing.SupportsFloat = 1.7976931348623157e+308) -> None:
        ...
    def visited(self) -> set[HyperGraph.Vertex]:
        ...
class EstimatePropagatorCost(EstimatePropagatorCostBase):
    def __call__(self, edge: OptimizableGraph.OptimizableGraph_Edge, from: collections.abc.Set[HyperGraph.Vertex], to: OptimizableGraph.OptimizableGraph_Vertex) -> float:
        ...
    def __init__(self, graph: SparseOptimizer) -> None:
        ...
    def name(self) -> str:
        ...
class EstimatePropagatorCostBase:
    def __call__(self, edge: OptimizableGraph.OptimizableGraph_Edge, from: collections.abc.Set[HyperGraph.Vertex], to: OptimizableGraph.OptimizableGraph_Vertex) -> float:
        ...
    def __init__(self) -> None:
        ...
    def name(self) -> str:
        ...
class EstimatePropagatorCostOdometry(EstimatePropagatorCostBase):
    def __call__(self, edge: OptimizableGraph.OptimizableGraph_Edge, from: collections.abc.Set[HyperGraph.Vertex], to: OptimizableGraph.OptimizableGraph_Vertex) -> float:
        ...
    def __init__(self, graph: SparseOptimizer) -> None:
        ...
    def name(self) -> str:
        ...
class Factory:
    def __init__(self) -> None:
        ...
    def known_types(self) -> list[str]:
        ...
    def knows_tag(self, tag: str) -> tuple[bool, HyperGraph.HyperGraphElementType]:
        ...
class G2OBatchStatistics:
    @staticmethod
    def global_stats() -> G2OBatchStatistics:
        ...
    @staticmethod
    def set_global_stats(arg0: G2OBatchStatistics) -> None:
        ...
    def __init__(self) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def chi2(self) -> float:
        ...
    @chi2.setter
    def chi2(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def choleskyNNZ(self) -> int:
        ...
    @choleskyNNZ.setter
    def choleskyNNZ(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def hessian_dimension(self) -> int:
        ...
    @hessian_dimension.setter
    def hessian_dimension(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def hessian_landmark_dimension(self) -> int:
        ...
    @hessian_landmark_dimension.setter
    def hessian_landmark_dimension(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def hessian_pose_dimension(self) -> int:
        ...
    @hessian_pose_dimension.setter
    def hessian_pose_dimension(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def iteration(self) -> int:
        ...
    @iteration.setter
    def iteration(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def iterations_linear_solver(self) -> int:
        ...
    @iterations_linear_solver.setter
    def iterations_linear_solver(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def levenberg_iterations(self) -> int:
        ...
    @levenberg_iterations.setter
    def levenberg_iterations(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def num_edges(self) -> int:
        ...
    @num_edges.setter
    def num_edges(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def num_vertices(self) -> int:
        ...
    @num_vertices.setter
    def num_vertices(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def time_iteration(self) -> float:
        ...
    @time_iteration.setter
    def time_iteration(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_linear_solution(self) -> float:
        ...
    @time_linear_solution.setter
    def time_linear_solution(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_linear_solver(self) -> float:
        ...
    @time_linear_solver.setter
    def time_linear_solver(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_linearize(self) -> float:
        ...
    @time_linearize.setter
    def time_linearize(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_marginals(self) -> float:
        ...
    @time_marginals.setter
    def time_marginals(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_numeric_decomposition(self) -> float:
        ...
    @time_numeric_decomposition.setter
    def time_numeric_decomposition(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_quadratic_form(self) -> float:
        ...
    @time_quadratic_form.setter
    def time_quadratic_form(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_residuals(self) -> float:
        ...
    @time_residuals.setter
    def time_residuals(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_schur_complement(self) -> float:
        ...
    @time_schur_complement.setter
    def time_schur_complement(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_symbolic_decomposition(self) -> float:
        ...
    @time_symbolic_decomposition.setter
    def time_symbolic_decomposition(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_update(self) -> float:
        ...
    @time_update.setter
    def time_update(self, arg0: typing.SupportsFloat) -> None:
        ...
class HyperDijkstra:
    class HyperDijkstraAdjacencyMapEntry:
        def __init__(self, _child: HyperGraph.Vertex = None, _parent: HyperGraph.Vertex = None, _edge: HyperGraph.Edge = None, _distance: typing.SupportsFloat = 1.7976931348623157e+308) -> None:
            ...
        def child(self) -> HyperGraph.Vertex:
            ...
        def children(self) -> set[HyperGraph.Vertex]:
            ...
        def distance(self) -> float:
            ...
        def edge(self) -> HyperGraph.Edge:
            ...
        def parent(self) -> HyperGraph.Vertex:
            ...
    class HyperDijkstraCostFunction:
        pass
    class HyperDijkstraTreeAction:
        @typing.overload
        def perform(self, v: HyperGraph.Vertex, vParent: HyperGraph.Vertex, e: HyperGraph.Edge) -> float:
            ...
        @typing.overload
        def perform(self, v: HyperGraph.Vertex, vParent: HyperGraph.Vertex, e: HyperGraph.Edge, distance: typing.SupportsFloat) -> float:
            ...
    @staticmethod
    def compute_tree(arg0: collections.abc.Mapping[HyperGraph.Vertex, HyperDijkstra.HyperDijkstraAdjacencyMapEntry]) -> None:
        ...
    @staticmethod
    def visit_adjacency_map(amap: collections.abc.Mapping[HyperGraph.Vertex, HyperDijkstra.HyperDijkstraAdjacencyMapEntry], action: HyperDijkstra.HyperDijkstraTreeAction, useDistance: bool = False) -> None:
        ...
    def __init__(self, g: HyperGraph) -> None:
        ...
    def adjacency_map(self) -> dict[HyperGraph.Vertex, HyperDijkstra.HyperDijkstraAdjacencyMapEntry]:
        ...
    def adjacency_map_const(self) -> dict[HyperGraph.Vertex, HyperDijkstra.HyperDijkstraAdjacencyMapEntry]:
        ...
    def graph(self) -> HyperGraph:
        ...
    @typing.overload
    def shortest_paths(self, v: HyperGraph.Vertex, cost: HyperDijkstra.HyperDijkstraCostFunction, maxDistance: typing.SupportsFloat = 1.7976931348623157e+308, comparisonConditioner: typing.SupportsFloat = 0.001, directed: bool = False, maxEdgeCost: typing.SupportsFloat = 1.7976931348623157e+308) -> None:
        ...
    @typing.overload
    def shortest_paths(self, vset: collections.abc.Set[HyperGraph.Vertex], cost: HyperDijkstra.HyperDijkstraCostFunction, maxDistance: typing.SupportsFloat = 1.7976931348623157e+308, comparisonConditioner: typing.SupportsFloat = 0.001, directed: bool = False, maxEdgeCost: typing.SupportsFloat = 1.7976931348623157e+308) -> None:
        ...
    def visited(self) -> set[HyperGraph.Vertex]:
        ...
    def visited_const(self) -> set[HyperGraph.Vertex]:
        ...
class HyperGraph:
    class Data(HyperGraph.HyperGraphElement):
        def element_type(self) -> HyperGraph.HyperGraphElementType:
            ...
    class DataContainer:
        def __init__(self) -> None:
            ...
        def add_user_data(self, obs: HyperGraph.Data) -> None:
            ...
        def set_user_data(self, obs: HyperGraph.Data) -> None:
            ...
        def user_data(self) -> list[HyperGraph.Data]:
            ...
    class Edge(HyperGraph.HyperGraphElement):
        def __init__(self, id: typing.SupportsInt = ...) -> None:
            ...
        def element_type(self) -> HyperGraph.HyperGraphElementType:
            ...
        def id(self) -> int:
            ...
        def num_undefined_vertices(self) -> int:
            ...
        def resize(self, size: typing.SupportsInt) -> None:
            ...
        def set_id(self, id: typing.SupportsInt) -> None:
            ...
        def set_vertex(self, i: typing.SupportsInt, v: HyperGraph.Vertex) -> None:
            ...
        def vertex(self, i: typing.SupportsInt) -> HyperGraph.Vertex:
            ...
        def vertices(self) -> list[HyperGraph.Vertex]:
            ...
    class HyperGraphDefaultIds(enum.Enum):
        InvalidId: typing.ClassVar[HyperGraph.HyperGraphDefaultIds]  # value = <HyperGraphDefaultIds.InvalidId: -2>
        UnassignedId: typing.ClassVar[HyperGraph.HyperGraphDefaultIds]  # value = <HyperGraphDefaultIds.UnassignedId: -1>
    class HyperGraphElement:
        pass
    class HyperGraphElementType(enum.Enum):
        HGET_CACHE: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_CACHE: 3>
        HGET_DATA: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_DATA: 4>
        HGET_EDGE: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_EDGE: 1>
        HGET_NUM_ELEMS: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_NUM_ELEMS: 5>
        HGET_PARAMETER: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_PARAMETER: 2>
        HGET_VERTEX: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_VERTEX: 0>
    class Vertex(HyperGraph.HyperGraphElement):
        def __init__(self, id: typing.SupportsInt = ...) -> None:
            ...
        def element_type(self) -> HyperGraph.HyperGraphElementType:
            ...
        def id(self) -> int:
            ...
        def set_id(self, id: typing.SupportsInt) -> None:
            ...
    class VertexIDEdges:
        def __init__(self) -> None:
            ...
        def hash_of_graph(self) -> int:
            ...
        def lookup(self, arg0: typing.SupportsInt) -> tuple[..., ..., ..., false, ..., bool]:
            ...
    HGET_CACHE: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_CACHE: 3>
    HGET_DATA: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_DATA: 4>
    HGET_EDGE: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_EDGE: 1>
    HGET_NUM_ELEMS: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_NUM_ELEMS: 5>
    HGET_PARAMETER: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_PARAMETER: 2>
    HGET_VERTEX: typing.ClassVar[HyperGraph.HyperGraphElementType]  # value = <HyperGraphElementType.HGET_VERTEX: 0>
    InvalidId: typing.ClassVar[HyperGraph.HyperGraphDefaultIds]  # value = <HyperGraphDefaultIds.InvalidId: -2>
    UnassignedId: typing.ClassVar[HyperGraph.HyperGraphDefaultIds]  # value = <HyperGraphDefaultIds.UnassignedId: -1>
    def __init__(self) -> None:
        ...
    def add_edge(self, e: HyperGraph.Edge) -> bool:
        ...
    def add_vertex(self, v: HyperGraph.Vertex) -> bool:
        ...
    def change_id(self, v: HyperGraph.Vertex, new_id: typing.SupportsInt) -> bool:
        ...
    def clear(self) -> None:
        ...
    def edges(self) -> set[HyperGraph.Edge]:
        ...
    def hash(self) -> int:
        ...
    def remove_edge(self, e: HyperGraph.Edge) -> bool:
        ...
    def remove_vertex(self, v: HyperGraph.Vertex) -> bool:
        ...
    def set_edge_vertex(self, e: HyperGraph.Edge, pos: typing.SupportsInt, v: HyperGraph.Vertex) -> bool:
        ...
    def vertex(self, id: typing.SupportsInt) -> HyperGraph.Vertex:
        ...
    def vertices(self) -> dict[int, HyperGraph.Vertex]:
        ...
class HyperGraphAction:
    pass
class IoFileFilter:
    filter: str
    format: IoFormat
    def __init__(self, filter: str, format: IoFormat) -> None:
        ...
class IoFormat(enum.Enum):
    BINARY: typing.ClassVar[IoFormat]  # value = <IoFormat.BINARY: 1>
    G2O: typing.ClassVar[IoFormat]  # value = <IoFormat.G2O: 0>
    JSON: typing.ClassVar[IoFormat]  # value = <IoFormat.JSON: 2>
class IoWrapper:
    @staticmethod
    def file_filter(arg0: bool) -> list[IoFileFilter]:
        ...
    @staticmethod
    def format_for_file_extension(arg0: str) -> g2opy.g2opy.IoFormat | None:
        ...
    @staticmethod
    def to_string(arg0: IoFormat) -> str:
        ...
class Isometry2d:
    @staticmethod
    def identity() -> Isometry2d:
        ...
    def Quaternion(self) -> Quaternion:
        ...
    def __call__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: Isometry2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 3]"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 2]"], arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, n]"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion, arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, n]"]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Isometry2d) -> Isometry2d:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, n]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, n]"]:
        ...
    def cols(self) -> int:
        ...
    def inverse(self, traits: TransformTraits = ...) -> Isometry2d:
        ...
    def make_affine(self) -> None:
        ...
    def matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    def orientation(self) -> Quaternion:
        ...
    def position(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def rotation(self) -> Quaternion:
        ...
    def rotation_matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 2]"]:
        ...
    def rows(self) -> int:
        ...
    def set_identity(self) -> None:
        ...
    @typing.overload
    def set_rotation(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 2]"]) -> None:
        ...
    @typing.overload
    def set_rotation(self, arg0: Quaternion) -> None:
        ...
    def set_translation(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, n]"]) -> None:
        ...
    def translation(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    @property
    def R(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 2]"]:
        ...
    @property
    def t(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
class Isometry3d:
    @staticmethod
    def identity() -> Isometry3d:
        ...
    def Quaternion(self) -> Quaternion:
        ...
    def __call__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: Isometry3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[4, 4]"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"], arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, n]"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion, arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, n]"]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Isometry3d) -> Isometry3d:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, n]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, n]"]:
        ...
    def cols(self) -> int:
        ...
    def inverse(self, traits: TransformTraits = ...) -> Isometry3d:
        ...
    def make_affine(self) -> None:
        ...
    def matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[4, 4]"]:
        ...
    def orientation(self) -> Quaternion:
        ...
    def position(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def rotation(self) -> Quaternion:
        ...
    def rotation_matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    def rows(self) -> int:
        ...
    def set_identity(self) -> None:
        ...
    @typing.overload
    def set_rotation(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @typing.overload
    def set_rotation(self, arg0: Quaternion) -> None:
        ...
    def set_translation(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, n]"]) -> None:
        ...
    def translation(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    @property
    def R(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @property
    def t(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
class JacobianWorkspace:
    def __init__(self) -> None:
        ...
    def allocate(self) -> bool:
        ...
    @typing.overload
    def update_size(self, e: HyperGraph.Edge, reset: bool = False) -> None:
        ...
    @typing.overload
    def update_size(self, graph: OptimizableGraph, reset: bool = False) -> None:
        ...
    @typing.overload
    def update_size(self, num_vertices: typing.SupportsInt, dimension: typing.SupportsInt, reset: bool = False) -> None:
        ...
    def workspace_for_vertex(self, vertex_index: typing.SupportsInt) -> float:
        ...
class LinearSolverCSparseSE2:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverCSparseSE3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverCSparseSim3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverCSparseX:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverCholmodSE2:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverCholmodSE3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverCholmodSim3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverCholmodX:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverDenseSE2:
    def __init__(self) -> None:
        ...
class LinearSolverDenseSE3:
    def __init__(self) -> None:
        ...
class LinearSolverDenseSim3:
    def __init__(self) -> None:
        ...
class LinearSolverDenseX:
    def __init__(self) -> None:
        ...
class LinearSolverEigenSE2:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverEigenSE3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverEigenSim3:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverEigenX:
    def __init__(self) -> None:
        ...
    def set_block_ordering(self, arg0: bool) -> None:
        ...
    def set_write_debug(self, arg0: bool) -> None:
        ...
    def write_debug(self) -> bool:
        ...
class LinearSolverPCGSE2:
    def __init__(self) -> None:
        ...
class LinearSolverPCGSE3:
    def __init__(self) -> None:
        ...
class LinearSolverPCGSim3:
    def __init__(self) -> None:
        ...
class LinearSolverPCGX:
    def __init__(self) -> None:
        ...
class MotionMeasurement:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, x: typing.SupportsFloat, y: typing.SupportsFloat, theta: typing.SupportsFloat, dt: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, m: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], dt: typing.SupportsFloat) -> None:
        ...
    def dt(self) -> float:
        ...
    def measurement(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def set_dt(self, arg0: typing.SupportsFloat) -> None:
        ...
    def set_theta(self, arg0: typing.SupportsFloat) -> None:
        ...
    def set_x(self, arg0: typing.SupportsFloat) -> None:
        ...
    def set_y(self, arg0: typing.SupportsFloat) -> None:
        ...
    def theta(self) -> float:
        ...
    def x(self) -> float:
        ...
    def y(self) -> float:
        ...
class OdomConvert:
    @staticmethod
    def convert_to_motion(arg0: VelocityMeasurement, arg1: typing.SupportsFloat) -> MotionMeasurement:
        ...
    @staticmethod
    def convert_to_velocity(arg0: MotionMeasurement) -> VelocityMeasurement:
        ...
    @staticmethod
    def to_motion(arg0: VelocityMeasurement, arg1: typing.SupportsFloat) -> MotionMeasurement:
        ...
    @staticmethod
    def to_velocity(arg0: MotionMeasurement) -> VelocityMeasurement:
        ...
class OptimizableGraph(HyperGraph):
    class ActionType(enum.Enum):
        AT_NUM_ELEMENTS: typing.ClassVar[OptimizableGraph.ActionType]  # value = <ActionType.AT_NUM_ELEMENTS: 2>
        AT_POSTITERATION: typing.ClassVar[OptimizableGraph.ActionType]  # value = <ActionType.AT_POSTITERATION: 1>
        AT_PREITERATION: typing.ClassVar[OptimizableGraph.ActionType]  # value = <ActionType.AT_PREITERATION: 0>
    class EdgeIDCompare:
        def __call__(self: ..., arg0: ...) -> bool:
            ...
    class OptimizableGraph_Edge(HyperGraph.Edge, HyperGraph.DataContainer):
        def all_vertices_fixed(self) -> bool:
            ...
        def compute_error(self) -> None:
            ...
        def construct_quadratic_form(self) -> None:
            ...
        def create_vertex(self, arg0: typing.SupportsInt) -> OptimizableGraph.OptimizableGraph_Vertex:
            ...
        def dimension(self) -> int:
            ...
        def get_measurement_data(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
            ...
        def initial_estimate(self, from: collections.abc.Set[HyperGraph.Vertex], to: OptimizableGraph.OptimizableGraph_Vertex) -> None:
            ...
        def initial_estimate_possible(self, from: collections.abc.Set[HyperGraph.Vertex], to: OptimizableGraph.OptimizableGraph_Vertex) -> float:
            ...
        def internal_id(self) -> int:
            ...
        def level(self) -> int:
            ...
        def map_hessian_memory(self, d: typing.SupportsFloat, i: typing.SupportsInt, j: typing.SupportsInt, row_mayor: bool) -> None:
            ...
        def measurement_dimension(self) -> int:
            ...
        def measurement_dimension_at_compile_time(self) -> int:
            ...
        def minimal_measurement_dimension(self) -> int:
            ...
        def num_parameters(self) -> int:
            ...
        def param_ids(self) -> list[int]:
            ...
        def parameter(self, arg0: typing.SupportsInt) -> ...:
            ...
        def robust_kernel(self) -> ...:
            ...
        def set_level(self, l: typing.SupportsInt) -> None:
            ...
        def set_measurement_data(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> bool:
            ...
        def set_measurement_from_state(self) -> bool:
            ...
        def set_parameter_id(self, arg_num: typing.SupportsInt, param_id: typing.SupportsInt) -> bool:
            ...
        def set_robust_kernel(self, ptr: ...) -> None:
            ...
    class OptimizableGraph_Vertex(HyperGraph.Vertex, HyperGraph.DataContainer):
        def clear_quadratic_form(self) -> None:
            ...
        def col_in_hessian(self) -> int:
            ...
        def dimension(self) -> int:
            ...
        def discard_top(self) -> None:
            ...
        def estimate_dimension(self) -> int:
            ...
        def estimate_dimension_at_compile_time(self) -> int:
            ...
        def fixed(self) -> bool:
            ...
        def get_estimate_data(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
            ...
        def get_minimal_estimate_data(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
            ...
        def hessian_index(self) -> int:
            ...
        def lock_quadratic_form(self) -> None:
            ...
        def marginalized(self) -> bool:
            ...
        def minimal_estimate_dimension(self) -> int:
            ...
        def oplus(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> None:
            ...
        def pop(self) -> None:
            ...
        def push(self) -> None:
            ...
        def set_col_in_hessian(self, c: typing.SupportsInt) -> None:
            ...
        def set_dimension(self, arg0: typing.SupportsInt) -> bool:
            ...
        def set_estimate_data(self, estimate: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> bool:
            ...
        def set_fixed(self, fixed: bool) -> None:
            ...
        def set_hessian_index(self, ti: typing.SupportsInt) -> None:
            ...
        def set_id(self, id: typing.SupportsInt) -> None:
            ...
        def set_marginalized(self, marginalized: bool) -> None:
            ...
        def set_minimal_estimate_data(self, estimate: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> bool:
            ...
        def solve_direct(self, arg0: typing.SupportsFloat) -> bool:
            ...
        def stack_size(self) -> int:
            ...
        def unlock_quadratic_form(self) -> None:
            ...
        def update_cache(self) -> None:
            ...
    class VertexIDCompare:
        def __call__(self: ..., arg0: ...) -> bool:
            ...
    AT_NUM_ELEMENTS: typing.ClassVar[OptimizableGraph.ActionType]  # value = <ActionType.AT_NUM_ELEMENTS: 2>
    AT_POSTITERATION: typing.ClassVar[OptimizableGraph.ActionType]  # value = <ActionType.AT_POSTITERATION: 1>
    AT_PREITERATION: typing.ClassVar[OptimizableGraph.ActionType]  # value = <ActionType.AT_PREITERATION: 0>
    @staticmethod
    def init_multi_threading() -> bool:
        ...
    def __init__(self) -> None:
        ...
    def add_edge(self, e: HyperGraph.Edge) -> bool:
        ...
    def add_graph(self, graph: OptimizableGraph) -> None:
        ...
    def add_parameter(self, p: ...) -> bool:
        ...
    def add_post_iteration_action(self, action: ...) -> bool:
        ...
    def add_pre_iteration_action(self, action: ...) -> bool:
        ...
    @typing.overload
    def add_vertex(self, v: HyperGraph.Vertex, user_data: HyperGraph.Data) -> bool:
        ...
    @typing.overload
    def add_vertex(self, v: HyperGraph.Vertex) -> bool:
        ...
    def chi2(self) -> float:
        ...
    def clear_parameters(self) -> None:
        ...
    def dimensions(self) -> set[int]:
        ...
    def discard_top(self) -> None:
        ...
    def hash(self, include_estimates: bool) -> int:
        ...
    def jacobian_workspace(self) -> ...:
        ...
    def load(self, filename: str, format: IoFormat = ...) -> bool:
        ...
    def max_dimension(self) -> int:
        ...
    def optimize(self, iterations: typing.SupportsInt, online: bool = False) -> int:
        ...
    def parameter(self, id: typing.SupportsInt) -> ...:
        ...
    def pop(self) -> None:
        ...
    def post_iteration(self, arg0: typing.SupportsInt) -> None:
        ...
    def pre_iteration(self, arg0: typing.SupportsInt) -> None:
        ...
    def push(self) -> None:
        ...
    def recompute_jacobian_workspace_size(self) -> None:
        ...
    def remove_post_iteration_action(self, action: ...) -> bool:
        ...
    def remove_pre_iteration_action(self, action: ...) -> bool:
        ...
    def remove_vertex(self, v: HyperGraph.Vertex) -> bool:
        ...
    def save(self, filename: str, format: IoFormat = ..., level: typing.SupportsInt = 0) -> bool:
        ...
    def set_edge_vertex(self, e: HyperGraph.Edge, pos: typing.SupportsInt, v: HyperGraph.Vertex) -> bool:
        ...
    def set_fixed(self, vset: collections.abc.Set[HyperGraph.Vertex], fixes: bool) -> None:
        ...
    def verify_information_matrices(self, verbose: bool = False) -> bool:
        ...
    def vertex(self, id: typing.SupportsInt) -> OptimizableGraph.OptimizableGraph_Vertex:
        ...
class OptimizationAlgorithm:
    pass
class OptimizationAlgorithmDogleg(OptimizationAlgorithmWithHessian):
    def __init__(self, arg0: PyBlockSolverBase) -> None:
        ...
class OptimizationAlgorithmGaussNewton(OptimizationAlgorithmWithHessian):
    def __init__(self, arg0: PyBlockSolverBase) -> None:
        ...
class OptimizationAlgorithmLevenberg(OptimizationAlgorithmWithHessian):
    def __init__(self, arg0: PyBlockSolverBase) -> None:
        ...
class OptimizationAlgorithmProperty:
    pass
class OptimizationAlgorithmWithHessian(OptimizationAlgorithm):
    pass
class Parameter(HyperGraph.HyperGraphElement):
    def element_type(self) -> HyperGraph.HyperGraphElementType:
        ...
    def id(self) -> int:
        ...
    def set_id(self, id: typing.SupportsInt) -> None:
        ...
class ParameterCamera(Parameter):
    def __init__(self) -> None:
        ...
    def param(self) -> ...:
        ...
    def set_param(self, arg0: ...) -> None:
        ...
class ParameterSE2Offset(Parameter):
    def __init__(self) -> None:
        ...
    def inverse_offset_matrix(self) -> Isometry2d:
        ...
    def offset_matrix(self) -> Isometry2d:
        ...
    def param(self) -> ...:
        ...
    def set_param(self, arg0: ...) -> None:
        ...
    def set_param_data(self, arg0: collections.abc.Sequence[typing.SupportsFloat]) -> bool:
        ...
class ParameterSE3Offset(Parameter):
    def __init__(self) -> None:
        ...
    def inverse_offset(self) -> Isometry3d:
        ...
    def param(self) -> Isometry3d:
        ...
    def set_param(self, arg0: Isometry3d) -> None:
        ...
    def set_param_data(self, arg0: collections.abc.Sequence[typing.SupportsFloat]) -> bool:
        ...
class PyBlockSolverBase:
    pass
class Quaternion:
    @staticmethod
    def from_two_vectors(arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> Quaternion:
        ...
    @staticmethod
    def identity() -> Quaternion:
        ...
    def __imul__(self, arg0: Quaternion) -> Quaternion:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @typing.overload
    def __init__(self, w: typing.SupportsFloat, x: typing.SupportsFloat, y: typing.SupportsFloat, z: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[4, 1]"]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Quaternion) -> Quaternion:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def angular_distance(self, arg0: Quaternion) -> float:
        ...
    def coeffs(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[4, 1]"]:
        ...
    def conjugate(self) -> Quaternion:
        ...
    def dot(self, arg0: Quaternion) -> float:
        ...
    def inverse(self) -> Quaternion:
        ...
    def matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    def norm(self) -> float:
        ...
    def normalize(self) -> None:
        ...
    def normalized(self) -> Quaternion:
        ...
    def rotation_matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    def set_identity(self) -> None:
        ...
    def squared_norm(self) -> float:
        ...
    def vec(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def w(self) -> float:
        ...
    def x(self) -> float:
        ...
    def y(self) -> float:
        ...
    def z(self) -> float:
        ...
    @property
    def R(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
class RegisterOptimizationAlgorithmProxy:
    pass
class RobustKernelCauchy(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class RobustKernelDCS(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class RobustKernelFair(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class RobustKernelGemanMcClure(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class RobustKernelHuber(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class RobustKernelPseudoHuber(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class RobustKernelSaturated(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class RobustKernelScaleDelta(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat = 1.0) -> None:
        ...
    @typing.overload
    def __init__(self, kernel: BaseRobustKernel, delta: typing.SupportsFloat = 1.0) -> None:
        ...
    def kernel(self) -> BaseRobustKernel:
        ...
    def robustify(self, error: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    def set_kernel(self, ptr: BaseRobustKernel) -> None:
        ...
class RobustKernelTukey(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class RobustKernelWelsch(BaseRobustKernel):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, delta: typing.SupportsFloat) -> None:
        ...
    def robustify(self, e2: typing.SupportsFloat, rho: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
class Rotation2d:
    @staticmethod
    def ientity() -> Rotation2d:
        ...
    def __imul__(self, arg0: Rotation2d) -> Rotation2d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Rotation2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 2]"]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Rotation2d) -> Rotation2d:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def angle(self) -> float:
        ...
    def from_rotation_matrix(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 2]"]) -> None:
        ...
    def inverse(self) -> Rotation2d:
        ...
    def matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 2]"]:
        ...
    def rotation_matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 2]"]:
        ...
    def slerp(self, arg0: typing.SupportsFloat, arg1: Rotation2d) -> Rotation2d:
        ...
    def smallest_angle(self) -> float:
        ...
    def smallest_positive_angle(self) -> float:
        ...
    def to_rotation_matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 2]"]:
        ...
    @property
    def R(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 2]"]:
        ...
class SBACam(SE3Quat):
    @staticmethod
    def transform_f2w(m: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"], trans: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], qrot: Quaternion) -> None:
        ...
    @staticmethod
    def transform_w2f(m: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"], trans: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], qrot: Quaternion) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, r: Quaternion, t: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    @typing.overload
    def __init__(self, p: SE3Quat) -> None:
        ...
    def set_cam(self, fx: typing.SupportsFloat, fy: typing.SupportsFloat, cx: typing.SupportsFloat, cy: typing.SupportsFloat, tx: typing.SupportsFloat) -> None:
        """
        set up camera matrix
        """
    def set_derivative(self) -> None:
        """
        sets angle derivatives
        """
    def set_dr(self) -> None:
        """
        sets angle derivatives
        """
    def set_projection(self) -> None:
        """
        Set up world-to-image projection matrix (w2i), assumes camera parameters are filled.
        """
    def set_transform(self) -> None:
        """
        set transform from world to cam coords
        """
    def update(self, update: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[6, 1]"]) -> None:
        """
        update from the linear solution defined in se3quat
        """
    @property
    def Kcam(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        """
        camera matrix
        """
    @Kcam.setter
    def Kcam(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def baseline(self) -> float:
        """
        stereo baseline
        """
    @baseline.setter
    def baseline(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def cam(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        """
        camera matrix
        """
    @cam.setter
    def cam(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def dRdx(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @dRdx.setter
    def dRdx(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def dRdy(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @dRdy.setter
    def dRdy(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def dRdz(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @dRdz.setter
    def dRdz(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def w2i(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 4]"]:
        """
        transform from world to image coordinates
        """
    @w2i.setter
    def w2i(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"]) -> None:
        ...
    @property
    def w2n(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 4]"]:
        """
        transform from world to node coordinates
        """
    @w2n.setter
    def w2n(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"]) -> None:
        ...
class SE2:
    def Isometry2(self) -> Isometry2d:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __imul__(self, arg0: SE2) -> SE2:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Isometry2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsFloat, arg1: typing.SupportsFloat, arg2: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: SE2) -> SE2:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def from_vector(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    def inverse(self) -> SE2:
        ...
    def rotation(self) -> Rotation2d:
        ...
    def to_isometry(self) -> Isometry2d:
        ...
    def to_vector(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def translation(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def vector(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
class SE3Quat:
    @staticmethod
    def exp(update: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[6, 1]"]) -> SE3Quat:
        ...
    def Quaternion(self) -> Quaternion:
        ...
    def __getitem__(self, i: typing.SupportsInt) -> float:
        ...
    def __imul__(self, arg0: SE3Quat) -> SE3Quat:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, R: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]", "flags.f_contiguous"], t: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]) -> None:
        ...
    @typing.overload
    def __init__(self, q: Quaternion, t: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]) -> None:
        ...
    @typing.overload
    def __init__(self, v: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[6, 1]"]) -> None:
        ...
    @typing.overload
    def __init__(self, v: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[7, 1]"]) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: SE3Quat) -> SE3Quat:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def adj(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[6, 6]"]:
        ...
    def from_minimal_vector(self, v: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[6, 1]"]) -> None:
        ...
    def from_vector(self, v: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[7, 1]"]) -> None:
        ...
    def inverse(self) -> SE3Quat:
        ...
    def log(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[6, 1]"]:
        ...
    def map(self, xyz: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[4, 4]"]:
        ...
    def normalize_rotation(self) -> None:
        ...
    def orientation(self) -> Quaternion:
        ...
    def position(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def rotation(self) -> Quaternion:
        ...
    def set_rotation(self, q: Quaternion) -> None:
        ...
    def set_translation(self, t: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> None:
        ...
    def to_homogeneous_matrix(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[4, 4]"]:
        ...
    def to_isometry3d(self) -> Isometry3d:
        ...
    def to_minimal_vector(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[6, 1]"]:
        ...
    def to_vector(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[7, 1]"]:
        ...
    def translation(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def vector(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[7, 1]"]:
        ...
class Sim3:
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __imul__(self, arg0: Sim3) -> Sim3:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quaternion, arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], arg2: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"], arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], arg2: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[7, 1]"]) -> None:
        ...
    def __mul__(self, arg0: Sim3) -> Sim3:
        ...
    def inverse(self) -> Sim3:
        ...
    def log(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[7, 1]"]:
        ...
    def map(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def normalize_rotation(self) -> None:
        ...
    def rotation(self) -> Quaternion:
        ...
    def scale(self) -> float:
        ...
    def translation(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
class Simulator:
    def graph(self) -> OptimizableGraph:
        ...
    def seed(self, arg0: typing.SupportsInt) -> None:
        ...
    def world(self) -> World:
        ...
class Simulator2D(Simulator):
    config: Simulator2DConfig
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Simulator2DConfig) -> None:
        ...
    def setup(self) -> None:
        ...
    def simulate(self) -> None:
        ...
class Simulator2DConfig(SimulatorConfig):
    has_point_bearing_sensor: bool
    has_segment_sensor: bool
    def __init__(self) -> None:
        ...
    @property
    def max_segment_length(self) -> float:
        ...
    @max_segment_length.setter
    def max_segment_length(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def min_segment_length(self) -> float:
        ...
    @min_segment_length.setter
    def min_segment_length(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def nsegments(self) -> int:
        ...
    @nsegments.setter
    def nsegments(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def segment_grid_size(self) -> int:
        ...
    @segment_grid_size.setter
    def segment_grid_size(self, arg0: typing.SupportsInt) -> None:
        ...
class Simulator3D(Simulator):
    config: Simulator3DConfig
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Simulator3DConfig) -> None:
        ...
    def setup(self) -> None:
        ...
    def simulate(self) -> None:
        ...
class Simulator3DConfig(SimulatorConfig):
    has_point_depth_sensor: bool
    has_point_disparity_sensor: bool
    def __init__(self) -> None:
        ...
class SimulatorConfig:
    has_compass: bool
    has_gps: bool
    has_odom: bool
    has_point_sensor: bool
    has_pose_sensor: bool
    def __init__(self) -> None:
        ...
    @property
    def nlandmarks(self) -> int:
        ...
    @nlandmarks.setter
    def nlandmarks(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def sim_steps(self) -> int:
        ...
    @sim_steps.setter
    def sim_steps(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def world_size(self) -> float:
        ...
    @world_size.setter
    def world_size(self, arg0: typing.SupportsFloat) -> None:
        ...
class Solver:
    def additional_vector_space(self) -> int:
        ...
    def b(self) -> float:
        ...
    def levenberg(self) -> bool:
        ...
    def optimizer(self) -> SparseOptimizer:
        ...
    def set_additional_vector_space(self, arg0: typing.SupportsInt) -> None:
        ...
    def set_levenberg(self, arg0: bool) -> None:
        ...
    def set_optimizer(self, arg0: SparseOptimizer) -> None:
        ...
    def supports_schur(self) -> bool:
        ...
    def vector_size(self) -> int:
        ...
    def x(self) -> float:
        ...
class SparseBlockMatrixX:
    def __init__(self) -> None:
        ...
    def block(self, r: typing.SupportsInt, c: typing.SupportsInt) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, n]"]:
        ...
    def block_cols(self) -> list[dict[int, typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, n]"]]]:
        ...
    def clear(self, dealloc: bool = False) -> None:
        ...
    def col_base_of_block(self, arg0: typing.SupportsInt) -> int:
        ...
    def col_block_indices(self) -> list[int]:
        ...
    def cols(self) -> int:
        ...
    def cols_of_block(self, arg0: typing.SupportsInt) -> int:
        ...
    def has_block(self, r: typing.SupportsInt, c: typing.SupportsInt) -> bool:
        ...
    def non_zeros(self) -> int:
        ...
    def non_zeros_blocks(self) -> int:
        ...
    def row_base_of_block(self, arg0: typing.SupportsInt) -> int:
        ...
    def row_block_indices(self) -> list[int]:
        ...
    def rows(self) -> int:
        ...
    def rows_of_block(self, arg0: typing.SupportsInt) -> int:
        ...
    def scale(self, arg0: typing.SupportsFloat) -> None:
        ...
    def write_octave(self, filename: str, upperTriangle: bool = False) -> bool:
        ...
class SparseOptimizer(OptimizableGraph):
    def __init__(self) -> None:
        ...
    def active_chi2(self) -> float:
        ...
    def active_edges(self) -> list[OptimizableGraph.OptimizableGraph_Edge]:
        ...
    def active_robust_chi2(self) -> float:
        ...
    def active_vertices(self) -> list[OptimizableGraph.OptimizableGraph_Vertex]:
        ...
    def add_compute_error_action(self, action: ...) -> bool:
        ...
    def algorithm(self) -> ...:
        ...
    def batch_statistics(self) -> list[...]:
        ...
    def clear(self) -> None:
        ...
    def compute_active_errors(self) -> None:
        ...
    def compute_batch_statistics(self) -> bool:
        ...
    @typing.overload
    def compute_initial_guess(self) -> None:
        ...
    @typing.overload
    def compute_initial_guess(self, propagator: ...) -> None:
        ...
    @typing.overload
    def compute_marginals(self, arg0: collections.abc.Sequence[tuple[typing.SupportsInt, typing.SupportsInt]]) -> tuple[..., -1, -1, 0, -1, ..., bool]:
        ...
    @typing.overload
    def compute_marginals(self, arg0: OptimizableGraph.OptimizableGraph_Vertex) -> tuple[..., -1, -1, 0, -1, ..., bool]:
        ...
    @typing.overload
    def compute_marginals(self, arg0: collections.abc.Sequence[OptimizableGraph.OptimizableGraph_Vertex]) -> tuple[..., -1, -1, 0, -1, ..., bool]:
        ...
    @typing.overload
    def discard_top(self, arg0: collections.abc.Sequence[OptimizableGraph.OptimizableGraph_Vertex]) -> None:
        ...
    @typing.overload
    def discard_top(self) -> None:
        ...
    def find_active_edge(self, e: OptimizableGraph.OptimizableGraph_Edge) -> ...:
        ...
    def find_active_vertex(self, v: OptimizableGraph.OptimizableGraph_Vertex) -> ...:
        ...
    def find_gauge(self) -> OptimizableGraph.OptimizableGraph_Vertex:
        ...
    def force_stop_flag(self) -> bool:
        ...
    def gauge_freedom(self) -> bool:
        ...
    def index_mapping(self) -> list[OptimizableGraph.OptimizableGraph_Vertex]:
        ...
    @typing.overload
    def initialize_optimization(self, eset: collections.abc.Set[HyperGraph.Edge]) -> bool:
        ...
    @typing.overload
    def initialize_optimization(self, vset: collections.abc.Set[HyperGraph.Vertex], level: typing.SupportsInt = 0) -> bool:
        ...
    @typing.overload
    def initialize_optimization(self, level: typing.SupportsInt = 0) -> bool:
        ...
    def optimize(self, iterations: typing.SupportsInt, online: bool = False) -> int:
        ...
    @typing.overload
    def pop(self, vlist: collections.abc.Sequence[OptimizableGraph.OptimizableGraph_Vertex]) -> None:
        ...
    @typing.overload
    def pop(self, vlist: collections.abc.Set[HyperGraph.Vertex]) -> None:
        ...
    @typing.overload
    def pop(self) -> None:
        ...
    @typing.overload
    def push(self, vlist: collections.abc.Sequence[OptimizableGraph.OptimizableGraph_Vertex]) -> None:
        ...
    @typing.overload
    def push(self, vlist: collections.abc.Set[HyperGraph.Vertex]) -> None:
        ...
    @typing.overload
    def push(self) -> None:
        ...
    def remove_compute_error_action(self, action: ...) -> bool:
        ...
    def remove_vertex(self, v: HyperGraph.Vertex) -> bool:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    @typing.overload
    def set_algorithm(self, arg0: ...) -> None:
        ...
    def set_compute_batch_statistics(self, arg0: bool) -> None:
        ...
    def set_force_stop_flag(self, flag: bool) -> None:
        ...
    def set_verbose(self, verbose: bool) -> None:
        ...
    def solver(self) -> ...:
        ...
    def terminate(self) -> bool:
        ...
    def update(self, update: typing.SupportsFloat) -> None:
        ...
    def update_initialization(self, vset: collections.abc.Set[HyperGraph.Vertex], eset: collections.abc.Set[HyperGraph.Edge]) -> bool:
        ...
    def verbose(self) -> bool:
        ...
class SparseOptimizerTerminateAction(HyperGraphAction):
    def __call__(self, arg0: HyperGraph, arg1: ...) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def gain_threshold(self) -> float:
        ...
    def max_iterations(self) -> int:
        ...
    def set_gain_threshold(self, arg0: typing.SupportsFloat) -> None:
        ...
    def set_max_iterations(self, arg0: typing.SupportsInt) -> None:
        ...
class StereoCameraParameters:
    def __init__(self) -> None:
        ...
    @property
    def baseline(self) -> float:
        ...
    @baseline.setter
    def baseline(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def focal_length(self) -> float:
        ...
    @focal_length.setter
    def focal_length(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def principle_point(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    @principle_point.setter
    def principle_point(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 1]"]) -> None:
        ...
class TransformTraits(enum.Enum):
    Affine: typing.ClassVar[TransformTraits]  # value = <TransformTraits.Affine: 2>
    AffineCompact: typing.ClassVar[TransformTraits]  # value = <TransformTraits.AffineCompact: 18>
    Isometry: typing.ClassVar[TransformTraits]  # value = <TransformTraits.Isometry: 1>
    Projective: typing.ClassVar[TransformTraits]  # value = <TransformTraits.Projective: 32>
class UniformCostFunction(HyperDijkstra.HyperDijkstraCostFunction):
    def __call__(self, edge: HyperGraph.Edge, from: HyperGraph.Vertex, to: HyperGraph.Vertex) -> float:
        ...
class VariableVectorXEdge(private.BaseVariableEdge_Dyn_Eigen::Matrix<double, -1, 1, 0, -1, 1>):
    def __init__(self) -> None:
        ...
class VectorXVertex(private.BaseVertexDyn_Eigen::Matrix<double, -1, 1, 0, -1, 1>):
    def __init__(self) -> None:
        ...
    def oplus_impl(self, arg0: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]", "flags.writeable"]) -> None:
        ...
class VelocityMeasurement:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, vl: typing.SupportsFloat, vr: typing.SupportsFloat, dt: typing.SupportsFloat) -> None:
        ...
    def dt(self) -> float:
        ...
    def measurement(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def set_dt(self, arg0: typing.SupportsFloat) -> None:
        ...
    def set_vl(self, arg0: typing.SupportsFloat) -> None:
        ...
    def set_vr(self, arg0: typing.SupportsFloat) -> None:
        ...
    def vl(self) -> float:
        ...
    def vr(self) -> float:
        ...
class VertexCam(private.BaseVertex6_g2o::SBACam):
    def __init__(self) -> None:
        ...
class VertexIntrinsics(private.BaseVertex4_g2o::VertexIntrinsicsEstimate):
    def __init__(self) -> None:
        ...
class VertexIntrinsicsEstimate:
    def __init__(self) -> None:
        ...
    @property
    def values(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[5, 1]"]:
        ...
    @values.setter
    def values(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[5, 1]"]) -> None:
        ...
class VertexOdomDifferentialParams(private.BaseVertex3_Eigen::Matrix<double, 3, 1, 0, 3, 1>):
    def __init__(self) -> None:
        ...
class VertexPointXY(private.BaseVertex2_Eigen::Matrix<double, 2, 1, 0, 2, 1>):
    def __init__(self) -> None:
        ...
class VertexPointXYZ(private.BaseVertex3_Eigen::Matrix<double, 3, 1, 0, 3, 1>):
    def __init__(self) -> None:
        ...
class VertexSCam(private.BaseVertex6_Eigen::Transform<double, 3, 1, 0>):
    Kcam: typing.ClassVar[numpy.ndarray]  # value = array([[0., 0., 0.],...
    baseline: typing.ClassVar[float] = 0.0
    @staticmethod
    def set_cam(fx: typing.SupportsFloat, fy: typing.SupportsFloat, cx: typing.SupportsFloat, cy: typing.SupportsFloat, tx: typing.SupportsFloat) -> None:
        """
        set up camera matrix
        """
    @staticmethod
    def transform_f2w(m: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"], trans: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], qrot: Quaternion) -> None:
        ...
    @staticmethod
    def transform_w2f(m: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"], trans: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"], qrot: Quaternion) -> None:
        ...
    def __init__(self) -> None:
        ...
    def map_point(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 1]"]:
        ...
    def oplus_impl(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> None:
        ...
    def set_all(self) -> None:
        """
        set all aux transforms
        """
    def set_derivative(self) -> None:
        """
        sets angle derivatives
        """
    def set_dr(self) -> None:
        """
        sets angle derivatives
        """
    def set_projection(self) -> None:
        """
        Set up world-to-image projection matrix (w2i), assumes camera parameters are filled.
        """
    def set_transform(self) -> None:
        """
        set transform from world to cam coords
        """
    @property
    def dRdx(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @dRdx.setter
    def dRdx(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def dRdy(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @dRdy.setter
    def dRdy(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def dRdz(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 3]"]:
        ...
    @dRdz.setter
    def dRdz(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 3]"]) -> None:
        ...
    @property
    def w2i(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 4]"]:
        ...
    @w2i.setter
    def w2i(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"]) -> None:
        ...
    @property
    def w2n(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[3, 4]"]:
        ...
    @w2n.setter
    def w2n(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[3, 4]"]) -> None:
        ...
class VertexSE2(private.BaseVertex3_g2o::SE2):
    def __init__(self) -> None:
        ...
class VertexSE3(private.BaseVertex6_Eigen::Transform<double, 3, 1, 0>):
    def __init__(self) -> None:
        ...
class VertexSE3Expmap(private.BaseVertex6_g2o::SE3Quat):
    def __init__(self) -> None:
        ...
class VertexSim3Expmap(private.BaseVertex7_g2o::Sim3):
    def __init__(self) -> None:
        ...
    def cam_map1(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
    def cam_map2(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[2, 1]"]) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[2, 1]"]:
        ...
class World:
    def graph(self) -> OptimizableGraph:
        ...
Affine: TransformTraits  # value = <TransformTraits.Affine: 2>
AffineCompact: TransformTraits  # value = <TransformTraits.AffineCompact: 18>
BINARY: IoFormat  # value = <IoFormat.BINARY: 1>
G2O: IoFormat  # value = <IoFormat.G2O: 0>
Isometry: TransformTraits  # value = <TransformTraits.Isometry: 1>
JSON: IoFormat  # value = <IoFormat.JSON: 2>
Projective: TransformTraits  # value = <TransformTraits.Projective: 32>
