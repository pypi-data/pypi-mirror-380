# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _synthesisutils
else:
    import _synthesisutils

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class synthesisutils(object):
    r"""Proxy of C++ casac::synthesisutils class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> synthesisutils"""
        _synthesisutils.synthesisutils_swiginit(self, _synthesisutils.new_synthesisutils())

    def contdatapartition(self, *args, **kwargs):
        r"""
        contdatapartition(self, _selpars=initialize_record(""), _npart=long(1)) -> record *


        Summary:
            Partition data selection parameters for continuum imaging

        Input Parameters:
            selpars                   All selection parameters for one or more MSs
            npart                     Number of partitions

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_contdatapartition(self, *args, **kwargs)

    def advisechansel(self, *args, **kwargs):
        r"""
        advisechansel(self, _freqstart=casac::variant( ), _freqend=casac::variant( ), _freqstep=casac::variant( ), _freqframe=string("LSRK"), _ephemtable=string(""), _msname=string(""), _fieldid=long(0), _getfreqrange=bool(false), _spwselection=string("")) -> record *


        Summary:
            Advise on spw and chan selection optimal for the image frequency range wanted

        Description:


        It is a helper function, for cube imaging, that allows you to
        determine the spectral window data selection you may need to cover a
        given range of frequencies.

        In the mode with getfreqrange=False, the freqstep can be used (i.e., set to the channel width) to achieve the extra padding needed for data selection at the beginning and end of the desired cube range in order to retrieve all channels that will potentially contribute to the edge channels of the cube (to maximize S/N). If freqstep is not specified, it is taken as zero, and the output channel range will typically be slightly smaller.

        The meaning of freqframe parameter is dependent on the value of getfreqrange.
        When getfreqrange=False, frequency parameters are considered as input parameters that are known to be in the frame specified by freqframe; but when getfreqrange=True, the frequency parameters are output parameters that will be determined in the frame specified by freqframe. In the former case, the frequencies will be converted to the frame of the data as a function of time in order to locate which channels match.

        You need to specify the field_id for which this calculation is
        being done.

        If the parameter {tt getfreqrange=True} then the reverse is requested. You set {tt spwselection} to be the range of data selection you want to use and you'll get the range of frequency covered in the frame you set. The freqstart and freqend output values correspond to the frequency of the extreme edges of the requested channel range.
        Inputs
        ----------------
        freqstart
        Begining of frequency range
        allowed:  double, string, quantity
        example: freqstart='1.0GHz'
        Default:
        ----------------
        freqend
        End of frequency range
        allowed:  double, string, quantity
        example: freqend='2.0GHz'
        Default:''
        -----------------
        freqstep
        spectral channel resolution of intended image
        allowed:  double, string, quantity
        example: freqstep='1.0MHz'
        Default:''
        -----------------
        freqframe
        frame in which frequency is being expressed in other parameters. For solar system  moving sources if the frame of the source is intended then this parameter can be 'SOURCE'
        allowed : one of the following strings 'LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO', 'GALACTO', 'LGROUP','CMB', 'SOURCE'
        Default: 'LSRK'
        ----------------
        msname
        name of a valid measurement set.
        allowed: string
        Default: ''
        -----------------
        ephemtable
        when freqframe='SOURCE' this parameter is used
        name of a valid ephemeris table or 'TRACKFIELD' to use the ephemeris table attached to the FIELD subtable of the ms or one of the following solar system object: 'MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS', 'NEPTUNE', 'PLUTO', 'SUN', 'MOON'
        allowed: string
        Default: ''
        -----------------
        fieldid
        fieldid to use (needed to get the direction on the sky for any spectral frame conversion)
        allowed: integer
        Default: 0
        -------------------
        getfreqrange
        if set then freqrange is returned in the frame requested for the data selected
        allowed: bool
        Default: False
        -----------------
        spwselection
        if getfreqrange=True then this is needed to find the range of frequency in the frame requested. It should have the spectral window selection syntax as defined in the msselection (Casa memo 3)
        allowed: string
        Default: ''

        Input Parameters:
            freqstart                 Begining of frequency range in Hz
            freqend                   End of frequency range in Hz
            freqstep                  spectral channel resolution of intended image in Hz
            freqframe                 frame in which frequency is being expressed in other parameters
            ephemtable                valid ephemeris table name or TRACKFIELD (use ephemeris in FIELD subtable) if freqframe is SOURCE
            msname                    name of an ms, if empty string it will use the ms's used in selectvis
            fieldid                   fieldid to use when msname is not empty otherwise ignored and field selected in selectvis is used
            getfreqrange              if set then freqrange is returned in the frame requested for the data selected
            spwselection              if getfreqrange=True then this is needed to find the range of frequency in the frame requested

        Example:

        Example 1
        In this example, we are interested in an image cube which span 20.0682GHz to 20.1982 in LSRK  which will have a channel resolution of 3.9MHz. The field we are interested the one with fieldid=4

        #############################
        >>> from casatools import synthesisutils
        >>> syut=synthesisutils()
        >>> syut.advisechansel(freqstart='20.0682GHz', freqend='20.1982GHz', freqstep='3.9kHz', freqframe='LSRK', msname='test1.ms')
        {'nchan': array([109,  23], dtype=int32),  'spw': array([4, 5], dtype=int32),
        'start': array([19,  0], dtype=int32)}
        # implies 108 channels of spw 4 starting channel 19 and 23 channels of spw 5 starting at channel 0 would contribute data to the frequency range under consideration
        #############################

        Example 2

        To determine what is the frequency range in a given frame is covered by a given spwselection of the ms

        ##############
        >>> syut.advisechansel(msname='test3.ms', freqframe='LSRK', getfreqrange=True, spwselection='0:20~210')

        {'freqend': {'unit': 'Hz', 'value': 362746224619.3091}, 'freqstart': {'unit': 'Hz', 'value': 362512788988.5036}}

        ##############

        Example 3:

        Same as Example 1 but with a solar system moving source and the frequency range provided is in the frame of the source. We are using the ephemeris table attached to the FIELD subtable of the ms.

        ##########
        >>> syut.advisechansel(msname='uid___A002_Xc05f54_X142a_target.spw31.contsub.ms', freqstart='362.5145206GHz', freqend='362.7476643GHz', freqstep='122.064714kHz', fieldid=3, freqframe='SOURCE', ephemtable='TRACKFIELD')
        ###########
        Now one can do the same with a valid ephemeris table
        ###########
        >>> syut.advisechansel(msname='uid___A002_Xc05f54_X142a_target.spw31.contsub.ms', freqstart='362.5145206GHz', freqend='362.7476643GHz', freqstep='122.064714kHz', fieldid=3, freqframe='SOURCE', ephemtable='EPHEM0_Titan_57889.1.tab')
        ###########

        Or if we want it in the frame of a solar system source known by casa, e.g 'SATURN'
        ############
        >>> syut.advisechansel(msname='uid___A002_Xc05f54_X142a_target.spw31.contsub.ms', freqstart='362.5145206GHz', freqend='362.7476643GHz', freqstep='122.064714kHz', fieldid=3, freqframe='SOURCE', ephemtable='SATURN')
        ############

        Example 4:

        Same as Example 2  but with a solar system moving source and the frequency range we want to find is in the frame of the source.

        ############
        >>> syut.advisechansel(msname='uid___A002_Xc05f54_X142a_target.spw31.contsub.ms', fieldid=3, freqframe='SOURCE', ephemtable='TRACKFIELD', getfreqrange=True, spwselection='31:9~1919')
        #############
        similarly if we want it in the frame of a solar system source known casa e.g saturn
        #############
        >>> syut.advisechansel(msname='uid___A002_Xc05f54_X142a_target.spw31.contsub.ms', fieldid=3, freqframe='SOURCE', ephemtable='SATURN', getfreqrange=True, spwselection='31:9~1919')
        #############

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_advisechansel(self, *args, **kwargs)

    def cubedatapartition(self, *args, **kwargs):
        r"""
        cubedatapartition(self, _selpars=initialize_record(""), _npart=long(1), _fstart=casac::variant( ), _fend=casac::variant( ), _frame=string("LSRK")) -> record *


        Summary:
            Partition data selection parameters for CUBE imaging

        Description:


        returns a dictionary with data spectral parttiion that maps  data  to  nparts
        of the input range frequency... usually to be used for doing data selection
        when imaging a cube from fstart to fend in npart subcubes

        Input Parameters:
            selpars                   All selection parameters for one or more MSs
            npart                     Number of partitions
            fstart                    start frequency of cube image
            fend                      end frequency of cube image
            frame                     frame of fstart and fend

        Example:

        ##make a synthesisutils tool
        siu=casac.synthesisutils()
        ### define first ms parameters
        msrec={'msname':'ngc5921.ms.contsub', 'field':'0', 'spw':'0'}
        pars={'ms0':msrec}
        ##  can add ms1, ms2 etc for multiple ms  into dictionary pars

        ##now get the data selections for 20 subpart of a cube that
        ## spans from 1.412787GHz to 1.413287GHz
        siu.cubedatapartition(selprs=pars, npart=20, fstart='1.412787GHz', fend='1.413287GHz', frame='LSRK')

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_cubedatapartition(self, *args, **kwargs)

    def cubeimagepartition(self, *args, **kwargs):
        r"""
        cubeimagepartition(self, _impars=initialize_record(""), _npart=long(1)) -> record *


        Summary:
            Partition image cube parameters for CUBE deconvolution

        Input Parameters:
            impars                    All imaging parameters for one or more image fields
            npart                     Number of partitions

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_cubeimagepartition(self, *args, **kwargs)

    def cubedataimagepartition(self, *args, **kwargs):
        r"""
        cubedataimagepartition(self, _selpars=initialize_record(""), _incsys=initialize_record(""), _npart=long(1), _nchannel=long(1)) -> record *


        Summary:
            Partition data/image cube parameters for CUBE deconvolution

        Input Parameters:
            selpars                   All selection parameters for one or more MSs
            incsys                    input coordinate system
            npart                     Number of partitions
            nchannel                  Number of channels

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_cubedataimagepartition(self, *args, **kwargs)

    def checkselectionparams(self, *args, **kwargs):
        r"""
        checkselectionparams(self, _selpars=initialize_record("")) -> record *


        Summary:
            Check and Fix Selection Parameters for one MS

        Input Parameters:
            selpars                   All selection parameters for one MS

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_checkselectionparams(self, *args, **kwargs)

    def checkimageparams(self, *args, **kwargs):
        r"""
        checkimageparams(self, _impars=initialize_record("")) -> record *


        Summary:
            Check and Fix Imaging Parameters for one field

        Input Parameters:
            impars                    All imaging parameters for one image-field

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_checkimageparams(self, *args, **kwargs)

    def checkgridparams(self, *args, **kwargs):
        r"""
        checkgridparams(self, _gridpars=initialize_record("")) -> record *


        Summary:
            Check and Fix Gridding/FTM Parameters for one field

        Input Parameters:
            gridpars                  All gridding/ftm parameters for one image-field

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_checkgridparams(self, *args, **kwargs)

    def updateimpars(self, *args, **kwargs):
        r"""
        updateimpars(self, _impars=initialize_record("")) -> record *


        Summary:
            check the consistency between the csys record and other impars and update/modify impars if necessary

        Input Parameters:
            impars                    All image parameters of one image-field

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_updateimpars(self, *args, **kwargs)

    def getOptimumSize(self, *args, **kwargs):
        r"""
        getOptimumSize(self, _size=long(100)) -> long


        Summary:
            Get Optimum Image size

        Input Parameters:
            size                      Input size

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_getOptimumSize(self, *args, **kwargs)

    def fitPsfBeam(self, *args, **kwargs):
        r"""
        fitPsfBeam(self, _imagename=string(""), _nterms=long(1), _psfcutoff=float(0.35)) -> bool


        Summary:
            Fit a restoring beam to the PSF, and save it in the PSF image.

        Input Parameters:
            imagename                 Image Prefix name
            nterms                    Single or Multi-Term (to pick namng conventions)
            psfcutoff                 A fractional cut-off level to determine what part of the PSF is sent to the beam fitter

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_fitPsfBeam(self, *args, **kwargs)

    def taylor_coeffs_to_cube(self, *args, **kwargs):
        r"""
        taylor_coeffs_to_cube(self, _cubename=string(""), _mtname=string(""), _nterms=long(2), _reffreq=string("")) -> bool


        Summary:
            Convert Taylor-coefficient images to a Cube

        Input Parameters:
            cubename                  Cube Image Name prefix
            mtname                    Multi-Term Image Name Prefix
            nterms                    Single or Multi-Term (to pick naming conventions)
            reffreq                   Reference Frequency to use for the Taylor expansion

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_taylor_coeffs_to_cube(self, *args, **kwargs)

    def cube_to_taylor_sum(self, *args, **kwargs):
        r"""
        cube_to_taylor_sum(self, _cubename=string(""), _mtname=string(""), _nterms=long(2), _reffreq=string(""), _imtype=long(0), _pblimit=float(0.2)) -> bool


        Summary:
            Convert Cube images to Taylor Weighted averages across frequency

        Input Parameters:
            cubename                  Cube Image Name prefix
            mtname                    Multi-Term Image Name Prefix
            nterms                    Single or Multi-Term (to pick naming conventions)
            reffreq                   Reference Frequency to use for the Taylor expansion
            imtype                    0 : Collapse the PSF cube to 2nterms-1 images. 1 : Collapse the residual cube to nterms images. 2 : Collapse the pb cube to a single .tt0 image
            pblimit                   pblimit

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_cube_to_taylor_sum(self, *args, **kwargs)

    def remove_freq_dep_pb(self, *args, **kwargs):
        r"""
        remove_freq_dep_pb(self, _cubename=string(""), _mtname=string(""), _pblimit=float(0.2)) -> bool


        Summary:
            Divide by the frequency dependent PB and multiply by an avg PB

        Input Parameters:
            cubename                  Cube Image Name prefix
            mtname                    mt-prefix for average PB to apply after removing the frequency dependent PB
            pblimit                   pblimit

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_remove_freq_dep_pb(self, *args, **kwargs)

    def apply_freq_dep_pb(self, *args, **kwargs):
        r"""
        apply_freq_dep_pb(self, _cubename=string(""), _mtname=string(""), _pblimit=float(0.2)) -> bool


        Summary:
            Divide by the avgPB and multiply by the frequency dependent PB

        Input Parameters:
            cubename                  Cube Image Name prefix
            mtname                    mt-prefix for average PB to remove before applying the frequency dependent PB
            pblimit                   pblimit

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_apply_freq_dep_pb(self, *args, **kwargs)

    def done(self):
        r"""
        done(self) -> bool


        Summary:
            Close the tool

        --------------------------------------------------------------------------------

        """
        return _synthesisutils.synthesisutils_done(self)
    __swig_destroy__ = _synthesisutils.delete_synthesisutils

# Register synthesisutils in _synthesisutils:
_synthesisutils.synthesisutils_swigregister(synthesisutils)

