# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _synthesisimager
else:
    import _synthesisimager

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class synthesisimager(object):
    r"""Proxy of C++ casac::synthesisimager class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> synthesisimager"""
        _synthesisimager.synthesisimager_swiginit(self, _synthesisimager.new_synthesisimager())

    def selectdata(self, *args, **kwargs):
        r"""
        selectdata(self, _selpars=initialize_record("")) -> bool


        Summary:
            Select data from one MS

        Input Parameters:
            selpars                   All parameters that control selection within one MS

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_selectdata(self, *args, **kwargs)

    def tuneselectdata(self):
        r"""
        tuneselectdata(self) -> record *


        Summary:
            reselect the data to match image definition

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_tuneselectdata(self)

    def defineimage(self, *args, **kwargs):
        r"""
        defineimage(self, _impars=initialize_record(""), _gridpars=initialize_record("")) -> bool


        Summary:
            Define image coordinate systems FTMs

        Input Parameters:
            impars                    All parameters that control image coordinate system definition
            gridpars                  All parameters that control ftmachines and gridding parameters

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_defineimage(self, *args, **kwargs)

    def normalizerinfo(self, *args, **kwargs):
        r"""
        normalizerinfo(self, _normpars=initialize_record("")) -> bool


        Summary:
            pass normalizer info for C++ normalization in lieu of python based normalization

        Input Parameters:
            normpars                  Normalization parameters in a record

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_normalizerinfo(self, *args, **kwargs)

    def setdata(self, *args, **kwargs):
        r"""
        setdata(self, _msname=string(""), _spw=string(""), _freqbeg=string(""), _freqend=string(""), _freqframe=string("LSRK"), _field=string(""), _antenna=string(""), _timestr=string(""), _scan=string(""), _obs=string(""), _state=string(""), _uvdist=string(""), _taql=string(""), _usescratch=bool(false), _readonly=bool(false), _incrmodel=bool(false)) -> bool


        Summary:
            Select data from one MS via conventional parameters (in lieu of selectdata)

        Description:


        Select data from one MS. Call this function in succession if there are
        multiple MSs.

        Input Parameters:
            msname                    Name of one measurement set
            spw                       Spectral Window / Channel / Frequency selection
            freqbeg                   Starting frequency/velocity/channel as a string with units. If spw is also supplied, the intersection will be used
            freqend                   End frequency/velocity/channel as a string with units.
            freqframe                 Frequency frame in which freqbeg and freqend are specified.
            field                     Field selection
            antenna                   Antenna / Baseline selection
            timestr                   Time range selection
            scan                      Scan selection
            obs                       Observation id selection
            state                     Scan Intent or State selection
            uvdist                    UV range selection
            taql                      Generic taql selection
            usescratch                Use scratch column (True) or virtual records (False) for model data
            readonly                  Open the MS in readonly mode. No model data will be written.
            incrmodel                 Subtract existing model data and start with residuals

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_setdata(self, *args, **kwargs)

    def setimage(self, *args, **kwargs):
        r"""
        setimage(self, _imagename=string(""), _nx=long(128), _ny=long(-1), _cellx=casac::variant( ), _celly=casac::variant( ), _stokes=string("I"), _phasecenter=casac::variant( ), _nchan=long(-1), _freqstart=casac::variant( ), _freqstep=casac::variant( ), _restfreq=casac::variant( ), _facets=long(1), _ftmachine=string("gridft"), _ntaylorterms=long(1), _reffreq=casac::variant( ), _projection=string("SIN"), _distance=casac::variant( ), _freqframe=string("LSRK"), _tracksource=bool(false), _trackdir=casac::variant( ), _overwrite=bool(true), _padding=float(1.0), _useautocorr=bool(false), _usedoubleprec=bool(true), _wprojplanes=long(1), _convfunc=string("SF"), _startmodel=string(""), _aterm=bool(true), _psterm=bool(true), _mterm=bool(false), _wbawp=bool(true), _cfcache=string(""), _usepointing=bool(false), _pointingoffsetsigdev=casac::variant( ), _dopbcorr=bool(true), _conjbeams=bool(false), _computepastep=float(360.0), _rotatepastep=float(5.0)) -> bool


        Summary:
            Define the image coordinate systems and types via conventinal parameters in lieu of defineimage

        Description:


        Define the image coordinate systems and shapes.

        Input Parameters:
            imagename                 Base image name
            nx                        Total number of spatial pixels in x
            ny                        Total number of spatial pixels in y
            cellx                     Cellsize in x (e.g. '1arcsec')
            celly                     Cellsize in y (e.g. '1arcsec')
            stokes                    Stokes parameters to image (e.g. 'IQUV')
            phasecenter               Direction of phase center as a diretion measure or a field id 
            nchan                     Number of channels; a -1 (default) means all the channels as selected in selectvis and combined into one continuum channel 
            freqstart                 Start channel; A 0-relative channel number of the spwid  or a frequency quantity      or a velocity quantity or radial velocity measure
            freqstep                  Step in channel; integer for number of channels or frequency quantity or velocity quantity or radial velocity measure
            restfreq                  rest frequency to use; default => use the one available in ms 
            facets                    Number of facets on each axis
            ftmachine                 FT-Machine type
            ntaylorterms              Number of terms for a spectral Taylor expansion
            reffreq                   Reference Frequency of the image. Also used in the Taylor expansion.
            projection                Image coordinate system projection
            distance                  Distance to object: usually ignore this! (m)
            freqframe                 Frequency frame in which freqstart and freqstep are specified.
            tracksource               Track a source.
            trackdir                  Name of moving source, e.g planet or moon, to keep fixed in image
            overwrite                 Overwrite the image if it exists (true)
            padding                   FFT padding
            useautocorr               Use auto correlations
            usedoubleprec             Double Precision gridding or not
            wprojplanes               Number of w-projection planes
            convfunc                  Name of convolution function
            startmodel                Starting model ( image name or component list name )
            aterm                     Set the antenna aperture tmer (aterm) on/off
            psterm                    Set the Prolate Spheroidal term (psterm) on/off
            mterm                     Set the mosaic term (mterm) on/off
            wbawp                     Set usage of the wide-band A-Projection algorithm
            cfcache                   Name of convolution function disk cache
            usepointing               Control application of the pointing correction
            pointingoffsetsigdev      Control application of the pointing correction for heterogenous array allowing for antenna pointing group identification using this parameter. The parameter has a significant cost on the memory used for gridding. Please utilize it wisely.
            dopbcorr                  Control normalization of the raw image by the model PB
            conjbeams                 Set conjbeams on/off
            computepastep             Increment in PA after which re-computation of the GCFs is triggered.  360.0 implies compute GCFs for only the first PA value encountered in the MS.
            rotatepastep              Increment in PA after which trigger in-memory rotation of the GCF nearest to the current PA value in the CF cache.

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_setimage(self, *args, **kwargs)

    def setweighting(self, *args, **kwargs):
        r"""
        setweighting(self, _type=string("natural"), _rmode=string("norm"), _noise=casac::variant( ), _robust=double(0.0), _fieldofview=casac::variant( ), _npixels=long(0), _multifield=bool(false), _usecubebriggs=bool(false), _uvtaper=std::vector< std::string >({})) -> bool


        Summary:
            Set parameters to control weighting during imaging

        Input Parameters:
            type                      Data weighting scheme
            rmode                     rmode
            noise                     Noise level
            robust                    Robustness weighting factor
            fieldofview               Field of view
            npixels                   NPixels
            multifield                Multifield
            usecubebriggs             Use per channel weight density calculation for Briggs style weighting
            uvtaper                   Parameters of uv-taper Gaussian

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_setweighting(self, *args, **kwargs)

    def makepsf(self):
        r"""
        makepsf(self) -> bool


        Summary:
            Make the psf

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_makepsf(self)

    def apparentsens(self):
        r"""
        apparentsens(self) -> record *


        Summary:
            Calculate apparent aggregate sensitivity in the selected visibilities

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_apparentsens(self)

    def predictmodel(self):
        r"""
        predictmodel(self) -> bool


        Summary:
            Predict model visibilities.

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_predictmodel(self)

    def drygridding(self, *args, **kwargs):
        r"""
        drygridding(self, _cflist=std::vector< std::string >({""})) -> bool


        Summary:
            Run a dry gridding run.

        Description:




        Input Parameters:
            cflist                     List of CFs 

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_drygridding(self, *args, **kwargs)

    def fillcfcache(self, *args, **kwargs):
        r"""
        fillcfcache(self, _cflist=std::vector< std::string >({""}), _ftmname=string(""), _cfcpath=string(""), _pstermon=bool(
        	false
              ), _atermon=bool(
        	true
              ), _conjbeams=bool(
        	false
              )) -> bool


        Summary:
             Fill a potentially blank CFCache held inside the AWProject-class FTMachines. 

        Description:




        Input Parameters:
            cflist                     List of CFs 
            ftmname                    Name of the FTMachine used 
            cfcpath                    Path to the CFCache on the disk 
            pstermon                   Is the PS-term ON? 
            atermon                    Is the A-term ON? 
            conjbeams                  Use WB A-Projection algorithm (use frequency-conjugate beams)? 

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_fillcfcache(self, *args, **kwargs)

    def reloadcfcache(self):
        r"""
        reloadcfcache(self) -> bool


        Summary:
             Re-load the CFCache, the name of which should already be set in the tool. 

        Description:




        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_reloadcfcache(self)

    def executemajorcycle(self, *args, **kwargs):
        r"""
        executemajorcycle(self, _controls=initialize_record("")) -> bool


        Summary:
            Run a major cycle

        Input Parameters:
            controls                  All parameters that control major cycle

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_executemajorcycle(self, *args, **kwargs)

    def makepb(self):
        r"""
        makepb(self) -> bool


        Summary:
            Make the primary beam

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_makepb(self)

    def makesdimage(self):
        r"""
        makesdimage(self) -> bool


        Summary:
            Make the single-dish image

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_makesdimage(self)

    def makesdpsf(self):
        r"""
        makesdpsf(self) -> bool


        Summary:
            Make the single-dish PSF

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_makesdpsf(self)

    def makeimage(self, *args, **kwargs):
        r"""
        makeimage(self, _type=string("observed"), _image=string(""), _compleximage=string(""), _model=long(0)) -> bool


        Summary:
            calculate images of different type by gridding

        Description:


        This tool function actually does gridding (and Fourier inversion if
        needed) of visibility data to make an image. It allows calculation of
        various types of image:
        begin{description}
        item[observed] Make the dirty image from the DATA column ({em default})
        item[model] Make the dirty image from the MODEL_DATA column
        item[corrected] Make the dirty image from the CORRECTED_DATA column
        item[residual] Make the dirty image from the difference of the
        CORRECTED_DATA and MODEL_DATA columns
        item[psf] Make the point spread function
        item[singledish] Make a single dish image
        item[coverage] Make a single dish or mosaic coverage image
        item[holography] Make a complex holography image (experimental)

        end{description}

        Input Parameters:
            type                      Type of output image
            image                     Name of output image
            compleximage              Name of output complex image
            model                     In case of multifield which image

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_makeimage(self, *args, **kwargs)

    def unlockimages(self, *args, **kwargs):
        r"""
        unlockimages(self, _imagefieldid=long(0)) -> bool


        Summary:
            release some images attached to this process

        Description:


        Try to unlock images if the need arise

        Input Parameters:
            imagefieldid              which image or outlier to unlock

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_unlockimages(self, *args, **kwargs)

    def estimatememory(self):
        r"""
        estimatememory(self) -> casac::variant *


        Summary:
            Get an estimate in kilobytes of memory that will be needed

        Description:


        This function returns an estimate of the memory (RAM) to be used by sythesisimager tool. Need to be run after functions setdata and defineimage are done

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_estimatememory(self)

    def getimstore(self, *args, **kwargs):
        r"""
        getimstore(self, _id=long(0)) -> casac::synthesisimstore *


        Summary:
            Get Image Store

        Input Parameters:
            id                        Image field id

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_getimstore(self, *args, **kwargs)

    def getImageName(self, *args, **kwargs):
        r"""
        getImageName(self, _facetId=long(0), _imageId=string("IMAGE"), _taylorTerm=long(0)) -> string


        Summary:
            Get Image Name

        Description:


        Get the image name for the given type of image (eg 'PB'), the facet index, and the taylor term.


        Input Parameters:
            facetId                   Facet index
            imageId                   Image identifer (eg 'PSF')
            taylorTerm                Taylor term. Only needed for mfs deconvolvers.

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_getImageName(self, *args, **kwargs)

    def getcsys(self):
        r"""
        getcsys(self) -> record *


        Summary:
            get internally stored coordsys record

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_getcsys(self)

    def updatenchan(self):
        r"""
        updatenchan(self) -> long


        Summary:
            get internally stored updated nchan

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_updatenchan(self)

    def getweightdensity(self):
        r"""
        getweightdensity(self) -> string


        Summary:
            Save natural gridded wt to disk.

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_getweightdensity(self)

    def setweightdensity(self, *args, **kwargs):
        r"""
        setweightdensity(self, _type=string("")) -> bool


        Summary:
            Load the gridded weight density into image weighting generation

        Description:


        Load the gridded weight density into image weighting; useful in parallel when weight density is combined into one image and loaded in each process. if no imagename is passed the imagename.weight is loaded


        Input Parameters:
            type                      name of image holding combined weight density

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_setweightdensity(self, *args, **kwargs)

    def initmpi(self):
        r"""
        initmpi(self) -> bool


        Summary:
            init c++ based mpi

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_initmpi(self)

    def releasempi(self):
        r"""
        releasempi(self) -> bool


        Summary:
            release c++ based mpi back to python

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_releasempi(self)

    def inithpg(self):
        r"""
        inithpg(self) -> bool


        Summary:
            init gpu code

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_inithpg(self)

    def hpg_enabled(self):
        r"""
        hpg_enabled(self) -> bool


        Summary:
            init gpu code

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_hpg_enabled(self)

    def done(self):
        r"""
        done(self) -> bool


        Summary:
            Close the tool

        --------------------------------------------------------------------------------

        """
        return _synthesisimager.synthesisimager_done(self)
    __swig_destroy__ = _synthesisimager.delete_synthesisimager

# Register synthesisimager in _synthesisimager:
_synthesisimager.synthesisimager_swigregister(synthesisimager)

