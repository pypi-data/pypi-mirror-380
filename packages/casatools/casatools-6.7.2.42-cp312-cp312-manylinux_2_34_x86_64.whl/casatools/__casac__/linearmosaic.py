# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _linearmosaic
else:
    import _linearmosaic

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class linearmosaic(object):
    r"""Proxy of C++ casac::linearmosaic class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> linearmosaic"""
        _linearmosaic.linearmosaic_swiginit(self, _linearmosaic.new_linearmosaic())

    def defineoutputimage(self, *args, **kwargs):
        r"""
        defineoutputimage(self, _nx=long(128), _ny=long(-1), _cellx=casac::variant( ), _celly=casac::variant( ), _imagecenter=casac::variant( ), _outputimage=string(""), _outputweight=string("")) -> bool


        Summary:
            Set the output direction image parameters and name

        Description:


        Define the direction axes output image parameters.
        The output image will get the same number of spectral and polarization planes as the input images. This function create a fresh new output image. If an image of the same name exist on disk it will be erased. The spectral and polarization part of the image will be identical to the images that are being mosaiced.

        The output image will by default be flux correct and the weight image will be ${sum_p A_p^2(theta)}$ where the primary beam is $  A_p(theta)$

        Input Parameters:
            nx                        Total number of spatial pixels in x
            ny                        Total number of spatial pixels in y
            cellx                     Cellsize in x (e.g. '1arcsec')
            celly                     Cellsize in y (e.g. '1arcsec')
            imagecenter               Direction of phase center as a diretion measure 
            outputimage               output image name 
            outputweight              output weight image name 

        Example:

        lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos', outputweight='test.weightlinmos')

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_defineoutputimage(self, *args, **kwargs)

    def setoutputimage(self, *args, **kwargs):
        r"""
        setoutputimage(self, _outputimage=string(""), _outputweight=string(""), _imageweighttype=long(1), _weighttype=long(1)) -> bool


        Summary:
            Use this function to mosaic on an existing image and weight image

        Description:


        Use this function if the mosaicing is to be done onto a previous mosaic or image. For now the stokes and spectral characteristic of the images to be mosaic and the output image has to be similar (i.e the user has to regrid them prior to linearmosaic if necessary).
        The weightimage represents the sensitivity image of the image (for example the weighted primary beam coverage of a mosaic)

        {tt imageweighttype} parameter:

        If the image is of the type that has been normalized to be flux correct then the imageweighttype should 0.
        If the image has been  apodized by a primary beam then imageweighttype should be 1
        and if the image is multiplied by $PB^2$ then it should be 2.

        {tt weighttype} parameter:
        This should be 1 if the weight image is the sum of Primary beams or equivalent
        and it should be 2 if it is the sum of of $PB^2$

        Input Parameters:
            outputimage               Existing mosaic imagename
            outputweight              Existing weight image for mosaic
            imageweighttype           what kind of weight was already applied to image n 0: flux correct n 1:  Primary beam equivalent weight n 2:  $PB^2$ equivalent weight n 
            weighttype                what kind of weight  is weight image  n 1: Primary beam equivalent weight n 2: $PB^2$ equivalent n 

        Example:

        lm.setoutputimage(outputimage='testoo.linmos', outputweight='testoo.linmos.weight', imageweightype=0, weighttype=2)

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_setoutputimage(self, *args, **kwargs)

    def saultweightimage(self, *args, **kwargs):
        r"""
        saultweightimage(self, _outputimage=string(""), _fracpeak=double(0.1)) -> bool


        Summary:
            Use this function to create a Sault-weighted image

        Description:


        'Sault weighted' image is one which is more pleasant to view (without high noise at the edges of mosaic images), it is flux correct upto a where the beam coverage becomes low and is tapered off onwards just to keep the noise from rising in the overall image(see  Eq[2] from Sault, Staveley-Smith and Brouw (1996), Astron. Astrophys. Suppl, 120, 375)

        Input Parameters:
            outputimage               Name of image to create the Sault-Weighted image
            fracpeak                  Upto what fraction of peak of coverage should the image be flux correct

        Example:

        lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos')
        lm.makemosaic(images=['FIELD_31/img.image', 'FIELD_33/img.image'], weightimages=['FIELD_31/img.pb', 'FIELD_33/img.pb'])
        ###the above will make a flux correct mosaic of the 2 images in a flux correct fashion in test.linmos
        #Now make a Sault weighted image to use in the viewer
        lm.saultweightimage('test_sault.linmos')

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_saultweightimage(self, *args, **kwargs)

    def setlinmostype(self, *args, **kwargs):
        r"""
        setlinmostype(self, _linmostype=string("optimal")) -> bool


        Summary:
            Use this function to set if you want to mosaic in flatnoise domain

        Description:


        Use this function if the mosaicing is to be done using a non optimal weighting mode.


        For now {tt optimal} (which is the default) follows this equation
        begin{equation}
        I^{lm}(theta)={{sum_p A_p(theta)(I_p(theta)A_p(theta))w_p}over{sum_p A_p^2(theta)w_p}}
        end{equation}

        And {tt pbweight} follows this one
        begin{equation}
        I^{lm}(theta)={{sum_p (I_p(theta)A_p(theta))w_p}over{sum_p A_p(theta)w_p}}
        end{equation}

        where $A_p(theta)$ is the primary beam (PB) of a given pointing $p$, $w_p$ is a sensitivity weight and the image of that pointing is $I_p(theta)$; the linear mosaic being $I^{lm}(theta)$
        For now  $w_p=1$

        Input Parameters:
            linmostype                Type of weighting for linear mosaic

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_setlinmostype(self, *args, **kwargs)

    def makemosaic(self, *args, **kwargs):
        r"""
        makemosaic(self, _images=casac::variant( ), _weightimages=casac::variant( ), _imageweighttype=long(1), _weighttype=long(1)) -> bool


        Summary:
            mosaic images in a weighted fashion onto ouput image

        Description:


        Put the list of images onto the mosaic image using the weight images

        Input Parameters:
            images                    Name of images to mosaic
            weightimages              Name of images to mosaic
            imageweighttype           what kind of weight is already applied to image n 0: flux correct n 1: Primary beam equivalent weight n 2: PB^2 equivalent n 
            weighttype                what kind of weight image it is n 1: Primary beam equivalent weight n 2: PB^2 equivalent n 

        Example:

        lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos')

        ###make a mosaic of two fields
        lm.makemosaic(images=['FIELD_31/img.image', 'FIELD_33/img.image'], weightimages=['FIELD_31/img.pb', 'FIELD_33/img.pb'])

        ####now we have another submosaic (which is flux corrected) we want to add to this mosaic

        lm.makemosaic(images='submosaic.image', weightimages='submosaic.flux',  imageweighttype=0, weighttype=1)

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_makemosaic(self, *args, **kwargs)
    __swig_destroy__ = _linearmosaic.delete_linearmosaic

# Register linearmosaic in _linearmosaic:
_linearmosaic.linearmosaic_swigregister(linearmosaic)

