# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _msuvbinner
else:
    import _msuvbinner

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class msuvbinner(object):
    r"""Proxy of C++ casac::msuvbinner class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, _phasecenter=casac::variant( ), _nx=long(256), _ny=long(256), _ncorr=long(1), _nchan=long(1), _cellx=string("1arcsec"), _celly=string("1arcsec"), _fstart=string("1GHz"), _fstep=string("1MHz"), _memfrac=double(0.5), _wproject=bool(false), _doflag=bool(false)) -> msuvbinner"""
        _msuvbinner.msuvbinner_swiginit(self, _msuvbinner.new_msuvbinner(*args, **kwargs))

    def selectdata(self, *args, **kwargs):
        r"""
        selectdata(self, _msname=string(""), _spw=string(""), _field=string("0"), _baseline=string(""), _scan=string(""), _uvrange=string(""), _taql=string("")) -> bool


        Summary:
            select the data from input ms that will go on the gridded vis

        Description:




        Input Parameters:
            msname                    Path to the MS to import
            spw                        Spectral window selection (using MSSelection syntax) 
            field                      field selection 
            baseline                   baselines selection (using MSSelection syntax) 
            scan                       Scan selection 
            uvrange                    uvrange 
            taql                       Generic TaQL selection 

        --------------------------------------------------------------------------------

        """
        return _msuvbinner.msuvbinner_selectdata(self, *args, **kwargs)

    def setoutputms(self, *args, **kwargs):
        r"""
        setoutputms(self, _outms=string("")) -> bool


        Summary:
            define gridded visibilities output; either existing grid or a new one will be made

        Description:


        Where  gridded visibilities will be stored;  either an already existant ms or a new one will be made. If a file of the name exist and the input parameters match then new gridded data will be added to the existing one; this is the way to add data of multiple epochs on the same grid.


        Input Parameters:
            outms                      Output ms name 

        --------------------------------------------------------------------------------

        """
        return _msuvbinner.msuvbinner_setoutputms(self, *args, **kwargs)

    def filloutputms(self):
        r"""
        filloutputms(self) -> bool


        Summary:
            launch gridding process from selected input to set output

        Description:


        launch gridding process from selected input to set output


        Example:

        from casatools import msuvbinner
        ##define the output grid parameters, like phasecenter and number of channels
        msbinner=msuvbinner(phasecenter='J2000 19h30m20.9 -19d50m22.7', nx=2000, ny=2000, ncorr=1, nchan=16, cellx='10arcsec', celly='10arcsec', fstart='975MHz', fstep='50kHz', memfrac=0.9, wproject=False, doflag=False)
        #select the data; note taql usage to avoid a baseline band where -10m > V < 10m
        msbinner.selectdata(msname='myinput1.ms', spw='0', field='0', taql='UVW[1] > 10 or UVW[1] < -10')
        #define the name of the output grid
        msbinner.setoutputms('myuvgrid.ms')
        ## grid the input data to the output grid
        msbinner.filloutputms()
        ##select a second input visibilities
        msbinner.selectdata(msname='myinput2.ms', spw='0', field='0', taql='')
        ##add it to the previously defined output grid
        msbinner.filloutputms()
        del msbinner

        --------------------------------------------------------------------------------

        """
        return _msuvbinner.msuvbinner_filloutputms(self)
    __swig_destroy__ = _msuvbinner.delete_msuvbinner

# Register msuvbinner in _msuvbinner:
_msuvbinner.msuvbinner_swigregister(msuvbinner)

