# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _atcafiller
else:
    import _atcafiller

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class atcafiller(object):
    r"""Proxy of C++ casac::atcafiller class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> atcafiller"""
        _atcafiller.atcafiller_swiginit(self, _atcafiller.new_atcafiller())

    def open(self, *args, **kwargs):
        r"""
        open(self, _msname=string(""), _filenames=std::vector< std::string >({}), _options=std::vector< std::string >({})) -> bool


        Summary:
            Specify the names of the data files and MeasurementSet

        Description:


        This function does the actual filling of the data from rpfits format
        files to a MeasurementSet. After the completion of the fill operation
        you should call the done method to avoid problems with incomplete
        flushing of the data to disk. You may want to run select before fill, to
        reduce the amount of data you read in.

        In the filenames argument commas are not allowed because of the
        wildcard capability.

        The options argument allows for special processing options during the
        filling process.

        * birdie: remove self generated birdies in 128 MHz
        data by deleting every other channel and the edge
        channels
        * reweight: suppress ringing of interference spikes by
        reweighting the lag spectrum for minimum spectral sidelobe response
        * noxycorr: do not apply the xyphase
        correction using the noise cal xy phase measurements (use if you
        know there was a problem with the measurements)
        * compress: Compress the data, model, corrected data and imaging weight
        columns (may reduce dynamic range)
        * fastmosaic: Produce a MeasurementSet with small tiles to optimize I/O
        for observations with a large number of pointings and a short time (a few
        integrations) on each pointing. Failing to use this options for such data
        may cause very inefficient access, especially for continuum data
        (10-100 times slower)
        * hires: For data taken in binning mode: set the TIME_CENTROID column to
        the center of each bin (normally center of integration interval). The TIME column is
        unaffected. TIME_CENTROID will no longer be in time order for dual frequency
        mode.
        * noac : Do not load the autocorrelations

        Input Parameters:
            msname                    Filename for MeasurementSet to create 
            filenames                 Existing RPFITS files to read; wild cards accepted, don't use commas 
            options                   Processing options: birdie, rfiflag, noxycorr, compress, fastmosaic, hires, reweight, noac 

        Example:

        #Specify that we want to load the data from files 1999-01-01_0101.C999 and
        #1999-01-01_0202.C999 in the directory /data/RPFITS into the MeasurementSet
        #myms.
        atf = atcafiller()
        atf.open('myms',
        '/data/RPFITS/1999-01-01_0101.C999 /data/RPFITS/1999-01-01_0202.C999',
        'birdie reweight')
        atf.fill()
        del atf
        myms:=ms('myms')
        myms.nrow()
        #1204
        myms.close()

        --------------------------------------------------------------------------------

        """
        return _atcafiller.atcafiller_open(self, *args, **kwargs)

    def fill(self):
        r"""
        fill(self) -> bool


        Summary:
            Fill the MeasurementSet

        Description:


        This function does the actual filling of the data from rpfits format
        files to a MeasurementSet. You may want to run select before fill, to
        reduce the amount of data you read in.

        Example:

        #Specify that we want to load the data from files 1999-01-01_0101.C999 and
        #1999-01-01_0202.C999 in the directory /data/RPFITS into the MeasurementSet #myms.
        atf = atcafiller()
        atf.open('myms',
        '/data/RPFITS/1999-01-01_0101.C999 /data/RPFITS/1999-01-01_0202.C999',
        'birdie reweight')
        atf.fill()
        del atf
        myms:=ms('myms')
        myms.nrow()
        #1204
        myms.close()

        --------------------------------------------------------------------------------

        """
        return _atcafiller.atcafiller_fill(self)

    def select(self, *args, **kwargs):
        r"""
        select(self, _firstscan=long(0), _lastscan=long(9999), _spw=std::vector< long >({-1}), _lowfreq=Quantity(std::vector<double>(1,0.1),"GHz"), _highfreq=Quantity(std::vector<double>(1,999.0),"GHz"), _fields=std::vector< std::string >({}), _edge=float(8.0)) -> bool


        Summary:
            Select the data to fill

        Description:



        Select on various items, to load only a subset of the data present in
        the input file. The default is to load everything.
        Note that the frequency selection using lowfreq and highfreq acts purely on
        center (reference) frequencies, channel selection is not available at this stage.
        Use freqchain to select the frequency chain (or IF) to load,
        specify either 1 or 2, the default of zero will load both.
        Use the fields parameter to specify a list of field names (sources) you
        want to load.
        For detailed selection of complex observations the last two parameters let
        you specify the required bandwidth (in whole MHz) and number of channels
        of the first frequency chain.

        Input Parameters:
            firstscan                 First scan to read
            lastscan                  Last scan to read
            spw                       Select one or more spectralwindows , -1=all 
            lowfreq                   Lowest reference frequency to select
            highfreq                  Highest reference frequency to select
            fields                    List of field names (sources) to select 
            edge                      Percentage of edge channels to flag 

        Example:

        #Select scans 4 to 10 inclusive, frequency chain 1, all data with a
        #reference frequency of more than 1.4 GHz.
        atf = atcafiller()
        atf.open('myms', '/data/RPFITS/1999-01-01_0101.C999')
        atf.select(firstscan=4, lastscan=10, freqchain=1, lowfreq=1.4,edge=10)
        atf.fill()
        del atf

        --------------------------------------------------------------------------------

        """
        return _atcafiller.atcafiller_select(self, *args, **kwargs)

    def opacities(self, *args, **kwargs):
        r"""
        opacities(self, _fghz=std::vector< double >({}), _tempk=float(300.0), _humi=float(50.0), _press=float(1010.0), _height=float(200.0)) -> std::vector< double >


        Summary:
            Calculate opacity correction

        Description:


        This function does the actual filling of the data from rpfits format
        files to a MeasurementSet. You may want to run select before fill, to
        reduce the amount of data you read in.

        Input Parameters:
            fghz                      array of frequencies
            tempk                     surface temperature in K
            humi                      humidity in %
            press                     surface pressure in hPa
            height                    observatory height in m

        Example:

        #
        atf = atcafiller()
        opac=atf.opacities([22.0,23.0],300.,50.,1013.,200.)
        print opac
        del atf

        --------------------------------------------------------------------------------

        """
        return _atcafiller.atcafiller_opacities(self, *args, **kwargs)
    __swig_destroy__ = _atcafiller.delete_atcafiller

# Register atcafiller in _atcafiller:
_atcafiller.atcafiller_swigregister(atcafiller)

