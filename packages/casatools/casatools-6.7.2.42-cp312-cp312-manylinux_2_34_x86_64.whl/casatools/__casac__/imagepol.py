# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _imagepol
else:
    import _imagepol

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class imagepol(object):
    r"""Proxy of C++ casac::imagepol class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> imagepol"""
        _imagepol.imagepol_swiginit(self, _imagepol.new_imagepol())

    def imagepoltestimage(self, *args, **kwargs):
        r"""
        imagepoltestimage(self, _outfile=string("imagepol.iquv"), _rm=std::vector< double >({0.0}), _pa0=double(0.0), _sigma=double(0.01), _nx=long(32), _ny=long(32), _nf=long(32), _f0=double(1.4e9), _bw=double(128.0e6)) -> bool


        Summary:
            Attach the Imagepol tool to a test image file

        Description:



        This function can be used to generate a test image and then
        attach the Imagepol tool to it.

        The test image is 4-dimensional (RA, DEC, Stokes and Frequency).  The
        Stokes axis holds I,Q,U and V.  The source is just a constant I (if you
        don't add noise all spatial pixels will be identical) and V.  Q and U
        vary with frequency according to the specified Rotation Measure
        components (no attempt to handle bandwidth smearing within channels is
        made).  The actual values of I,Q,U, and V are chosen arbitrarily
        otherwise (could be added as arguments if desired).

        You can use this image, in particular, to explore the Rotation Measure
        algorithms in functions rotationmeasure and
        fourierrotationmeasure.

        If you don't specify the Rotation Measure, then it is chosen for you so
        that there is no position angle ambiguity between adjacent channels
        (the value will be sent to the Logger).

        The noise added to the image is specified as a fraction of the total
        intensity (constant).  Gaussian noise with a standard deviation of
        {stfaf sigma * $I_{max}$} is then added to the image.

        Input Parameters:
            outfile                   Output image file name
            rm                        Rotation Measure (rad/m/m).  Default is auto no-ambiguity determine.
            pa0                       Position angle (degrees) at zero wavelength
            sigma                     Fractional noise level
            nx                        Shape of image in x direction
            ny                        Shape of image in y direction
            nf                        Shape of image in frequency direction
            f0                        Reference frequency (Hz)
            bw                        Bandwidth (Hz)

        Example:


        #
        print 't----t imagepoltestimage Ex 1 t----'
        po.imagepoltestimage(outfile='imagepoltestimage', rm=200)
        po.rotationmeasure(rm='rm.out',rmmax=250)
        ia.open('rm.out')
        ia.statistics()
        #viewer()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_imagepoltestimage(self, *args, **kwargs)

    def complexlinpol(self, *args, **kwargs):
        r"""
        complexlinpol(self, _outfile=string("")) -> bool


        Summary:
            Complex linear polarization

        Description:



        This function  produces
        the complex linear polarization; $Q+iU$ and writes
        it to a disk image file.

        The Image tool cannot yet handle Complex
        images.  You must therefore write the Complex image to disk.  The
        Viewer can display Complex images. Also the
        Table tool can access Complex images.

        Input Parameters:
            outfile                   Output image file name

        Example:


        #
        print 't----t complexlinpol Ex 1 t----'
        po.open('stokes.image')
        po.complexlinpol('cplx')
        tb.open('cplx')
        #tb.browse()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_complexlinpol(self, *args, **kwargs)

    def complexfraclinpol(self, *args, **kwargs):
        r"""
        complexfraclinpol(self, _outfile=string("")) -> bool


        Summary:
            Complex fractional linear polarization

        Description:



        This function produces
        the complex fractional linear polarization; $(Q+iU)/I$ and writes
        it to a disk image file.

        The Image tool cannot yet handle Complex
        images.  You must therefore write the Complex image to disk.  The
        Viewer can display Complex images. Also the
        Table tool can access Complex images.

        Input Parameters:
            outfile                   Output image file name

        Example:


        #
        print 't----t complexfraclinpol Ex 1 t----'
        po.open('stokes.image')
        po.complexfraclinpol('cplx2')
        tb.open('cplx2')
        #tb.browse()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_complexfraclinpol(self, *args, **kwargs)

    def depolratio(self, *args, **kwargs):
        r"""
        depolratio(self, _infile=string(""), _debias=bool(false), _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> casac::image *


        Summary:
            Linear depolarization ratio

        Description:



        This function  returns the linear
        depolarization ratio computed from two frequencies; this is the ratio of
        the fractional linear polarization at the two frequencies.  Generally
        this is done when you have generated two images, each at a different frequency
        (continuum work). Thus if the fractional linear polarization images are
        $m_{nu 1}$ and $m_{nu 2}$ then the depolarization ratio is
        $m_{nu 1}/ m_{nu 2}$.

        This function operates with two images; the first (at frequency $nu 1$)
        is the one attached to your Imagepol tool.  The second (at
        frequency $nu 2$) is supplied via the argument {stfaf infile}, which
        is  a String holding the name of the
        imagefile.

        In generating the depolarization ratio, you may optionally debias the
        linearly polarized intensity.  This requires the standard deviation of
        the thermal noise.  You can either supply it if you know it, or it will
        be worked out for you with outliers from the mean clipped at the
        specified level.

        You can get the depolarization ratio error image with function
        sigmadepolratio.

        Input Parameters:
            infile                    Other image
            debias                    Debias the linearly polarized intensity ?
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        #print 't----t depolratio Ex 1 t----'
        #po.open('stokes.4800')
        #dpr = po.depolratio(infile='stokes.8300')        # m_4800 / m_8300
        #edpr = po.sigmadepolratio(infile='stokes.8300');
        #dpr.done()
        #edpr.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_depolratio(self, *args, **kwargs)

    def close(self):
        r"""
        close(self) -> bool


        Summary:
            Close the image tool

        Description:



        This function closes the imagepol tool.  This means that it detaches
        the tool from its imagefile (flushing all the changes first).  The
        imagepol tool is ``null'' after this change (it is not destroyed) and
        calling any toolfunction other than open will result in an
        error.

        Example:


        #
        print 't----t close Ex 1 t----'
        # First create image and attach it to imagepol tool
        po.imagepoltestimage('myimagepol')
        po.close()              # Detaches image from Imagepol tool
        print '!!!EXPECT ERROR HERE!!!'
        po.summary()            # No image so this results in an error.
        po.open('myimagepol')   # Image is reattached
        po.summary()            # No error
        po.close()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_close(self)

    def done(self):
        r"""
        done(self) -> bool


        Summary:
            Close this Imagepol tool

        Description:





        This function is the same as close().

        Example:


        #
        print 't----t done Ex 1 t----'
        po.open('myimagepol')
        po.done()             # Detaches image from Imagepol tool
        print '!!!EXPECT ERROR HERE!!!'
        po.summary()          # No image so this results in an error.
        po.open('myimagepol') # Image is reattached
        po.summary()          # No error
        po.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_done(self)

    def fourierrotationmeasure(self, *args, **kwargs):
        r"""
        fourierrotationmeasure(self, _complex=string(""), _amp=string(""), _pa=string(""), _real=string(""), _imag=string(""), _zerolag0=bool(false)) -> bool


        Summary:
            Find Rotation Measure (Fourier approach)

        Description:



        This function  will only work if
        you attach the Imagepol tool (using open) to an image containing
        Stokes Q and U, and a regular frequency axis.  It Fourier transforms
        the complex linear polarization (Q+iU) over the spectral axis to the
        rotation measure axis.  Thus, if your input image contained
        RA/DEC/Stokes/Frequency, the output image would be
        RA/DEC/RotationMeasure.  The Rotation Measure axis has as many pixels
        as the spectral axis.

        This method enables you to see the polarization as a function of
        Rotation Meausure.  Its main use is when searching for large RMs.  See
        Killeen, Fluke, Zhao and Ekers (1999, preprint) for a description of
        this method (or http://www.atnf.csiro.au/verb+~+nkilleen/rm.ps) and its
        advantages over the traditional method
        (rotationmeasure) of
        extracting the Rotation Measure.

        Although you can write out the complex polarization image with the
        argument {stfaf complex}, you can't do much with it because Image
        tools cannot handle complex images.  Hence you can
        also write out the complex linear polarization image in any or all of
        the other forms.

        The argument {stfaf zerolag0} allows you to force the zero lag (or
        central bin) of the Rotation Measure spectrum to zero (effectively by
        subtracting the mean of Q and U from the Q and U images).  This may
        avoid Gibbs phenomena from any strong low Rotation Measure signal which
        would normally fall into the central bin.

        Input Parameters:
            complex                   Output complex linear polarization image file name.  Default is unset.
            amp                       Output linear polarization amplitude image file name  Default is unset.
            pa                        Output linear polarization position angle (degrees) image file name  Default is unset.
            real                      Output linear polarization real image file name  Default is unset.
            imag                      Output linear polarization imaginary angle image file name  Default is unset.
            zerolag0                  Force zero lag to 0 ?

        Example:


        #
        print 't----t fourierrotationmeasure Ex 1 t----'
        po.imagepoltestimage(outfile='iquv.im', rm=[5.0e5,1e6], nx=8, ny=8, nf=512,
        f0=1.4e9, bw=8e6)
        po.fourierrotationmeasure(amp='amp')
        ia.open('amp')
        ia.statistics()
        #viewer()                     # And reorder to put RM along X-axis
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_fourierrotationmeasure(self, *args, **kwargs)

    def fraclinpol(self, *args, **kwargs):
        r"""
        fraclinpol(self, _debias=bool(false), _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> casac::image *


        Summary:
            Fractional linear polarization

        Description:

        This function
        returns the fractional linear polarization; $sqrt{(Q^2+U^2)}/I$.

        You may optionally debias the polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level.

        Input Parameters:
            debias                    Debias the linearly polarized intensity ?
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name  Default is unset.

        Example:


        #
        print 't----t fraclinpol Ex 1 t----'
        po.open('stokes.image')
        flp = po.fraclinpol()
        flp.summary()
        flp.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_fraclinpol(self, *args, **kwargs)

    def fractotpol(self, *args, **kwargs):
        r"""
        fractotpol(self, _debias=bool(false), _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> casac::image *


        Summary:
            Fractional total polarization

        Description:

        This function
        returns the fractional linear polarization; $sqrt{(Q^2+U^2+V^2)}/I$.

        You may optionally debias the polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level.

        If your image contains only Q and U, or only V, then just
        those components contribute to the total polarized intensity.

        Input Parameters:
            debias                    Debias the total polarized intensity ?
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t fractotpol Ex 1 t----'
        po.open('stokes.image')
        ftp = po.fractotpol()
        ftp.statistics()
        ftp.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_fractotpol(self, *args, **kwargs)

    def linpolint(self, *args, **kwargs):
        r"""
        linpolint(self, _debias=bool(false), _clip=double(10.0), _sigma=double(-1), _outfile=string(""), _region=casac::variant( ), _mask=string(""), _stretch=bool(false)) -> casac::image *


        Summary:
            Linearly polarized intensity

        Description:


        This application returns the linearly polarized intensity; $sqrt{(Q^2+U^2)}$.

        The linearly polarized intensity may optionally be debiased (if debias=True).
        This requires an estimate of the thermal noise level (sigma). The resulting
        image will be computed using

        $sqrt{(Q^2 + U^2 - sigma^2)}$

        If the specified value of sigma is positive, that is the value that will
        be used for debiasing. If it is not, the value used for sigma is computed
        using the following algorithm:

        1. First, a stokes plane(s) is chosen on which the sigma computation is performed.
        If the V plane exists, that is used to compute sigma. If not, then the value of
        sigma is computed to be the average of the sigma values of the Q and U planes.

        2. For the relevant plane(s), the sigma value is computed for unmasked pixel values
        which lie within +/- (clip * stddev) values of the mean for that plane, where the mean
        and stddev (the standard deviation) are computed by using all unmasked pixel values
        in the relevant plane. In this way, outliers (eg pixels due to possible
        astronomical signals) are excluded in the computation of sigma.

        In the output image, pixels for which the expression inside the square root is
        negative are masked, and their values are set to zero.

        If a region and/or mask is specified, debias=True and sigma is not positive so
        that the value of sigma is determined using the algorithm above, the region and mask
        are applied first to the plane(s) from which the value of sigma is determined and
        then sigma is computed.

        Input Parameters:
            debias                    Debias the linearly polarized intensity ?
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.
            region                    Region selection. Default is to use the full image.
            mask                      Mask to use. Default setting is none.
            stretch                   Stretch the mask if necessary and possible? Default value is false.

        Example:


        #
        print 't----t linpolint Ex 1 t----'
        po.open('stokes.image')
        lpi = po.linpolint()
        lpi.statistics()
        lpi.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_linpolint(self, *args, **kwargs)

    def linpolposang(self, *args, **kwargs):
        r"""
        linpolposang(self, _outfile=string(""), _region=casac::variant( ), _mask=string(""), _stretch=bool(false)) -> casac::image *


        Summary:
            Linearly polarized position angle

        Description:



        This function returns the linearly polarized position angle image 0.5*arctan(U/Q) in degrees.
        The output image will not have a restoring beam, even if the input image does.

        Input Parameters:
            outfile                   Output image file name.  Default is unset.
            region                    Region selection. Default is to use the full image.
            mask                      Mask to use. Default setting is none.
            stretch                   Stretch the mask if necessary and possible? Default value is false.

        Example:


        #
        print 't----t linpolposang Ex 1 t----'
        po.open('stokes.image')
        lppa = po.linpolposang()
        lppa.statistics()
        lppa.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_linpolposang(self, *args, **kwargs)

    def makecomplex(self, *args, **kwargs):
        r"""
        makecomplex(self, _complex=string(""), _real=string(""), _imag=string(""), _amp=string(""), _phase=string("")) -> bool


        Summary:
            Make a Complex image

        Description:



        This function generates a Complex imagefile from either
        a real and imaginary, or an amplitude and phase pair of images.
        If you give a linear position angle image for the phase,
        it will be multipled by two before the real and imaginary
        parts are formed.

        Input Parameters:
            complex                   Output complex image file name.  Must be specified.
            real                      Input real image file name. Default is unset.
            imag                      Input imaginary image file name. Default is unset.
            amp                       Input amplitude image file name. Default is unset.
            phase                     Input phase image file name. Default is unset.

        Example:


        #
        print 't----t makecomplex Ex 1 t----'
        po.open('stokes.image')
        po.complexlinpol('qu.cplx1')
        q = po.stokesq()
        u = po.stokesu()
        q2 = q.subimage('q',overwrite=true)
        u2 = u.subimage('u',overwrite=true)
        po.makecomplex('qu.cplx2', real='q', imag='u')
        po.close()
        #


        In this example we make two complex linear polarization
        images which should be identical.

        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_makecomplex(self, *args, **kwargs)

    def open(self, *args, **kwargs):
        r"""
        open(self, _image=casac::variant( )) -> bool


        Summary:
            Open a new image with this imagepol tool

        Description:



        Before polarimetric analysis can commence, an imagefile must be
        attached to the imagepol tool using the open function.  Also, use this
        function when you are finished analyzing the current imagefile and
        want to attach to another one.  This function detaches the imagetool
        from the current imagefile, if one exists, and reattaches it (opens)
        to the new imagefile.

        The input image file may be in native casa, fits, or Miriad
        format.  Look htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
        information on foreign images.

        The input image must have a Stokes axis. The exact collection of
        Stokes that the image has, determines what the Imagepol tool can
        compute. Stokes I, Q, U, and V refer to total intensity, two
        components of linear polarization, and circular polatization,
        respectively. Therefore, if you ask for linear polarization and the
        image only has Stokes I and V, you will get an error.

        The input image may contain data at many frequencies. For example, the
        image may be a 4D image with axes RA, DEC, Stokes and Frequency (order
        not important) where the Frequency axis is regularly sampled. However,
        the image may also contain many frequencies at irregular
        intervals. Such an image may be created with the Image tool function
        imageconcat. It enables you to concatenate images along an axis, and
        it allows irregular coordinate values along that axis.

        Input Parameters:
            image                     image file name or image record (generated by ia.torecord()) 

        Example:


        #
        print 't----t open Ex 1 t----'
        po.open('stokes.image')
        po.close()
        #


        The {stff open} function first closes the old imagefile if one exists.

        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_open(self, *args, **kwargs)

    def pol(self, *args, **kwargs):
        r"""
        pol(self, _which=string(""), _debias=bool(false), _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> casac::image *


        Summary:
            Polarized quantities

        Description:



        This function just packages the other specific polarization
        functions into one where you specify an operation with the
        argument {stfaf which} (can be useful for scripts).
        This argument can take the values:

        begin{itemize}
        item 'lpi' - linearly polarized intensity (function
        linpolint)

        item 'tpi' - total polarized intensity (function
        totpolint)

        item 'lppa' linearly polarized position angle (function
        linpolposang)

        item 'flp' - fractional linear polarization (function
        fraclinpol)

        item 'ftp' - fractional total polarized intensity (function
        fractotpol)

        end{itemize}

        Input Parameters:
            which                     Specify operation. One of 'lpi', 'tpi', 'lppa', 'flp', 'ftp' (case insensitive) 
            debias                    Debias the polarized intensity ?
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t pol Ex 1 t----'
        po.open('stokes.image')
        lpi = po.pol('lpi')
        lpi.statistics()
        lpi.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_pol(self, *args, **kwargs)

    def rotationmeasure(self, *args, **kwargs):
        r"""
        rotationmeasure(self, _rm=string(""), _rmerr=string(""), _pa0=string(""), _pa0err=string(""), _nturns=string(""), _chisq=string(""), _sigma=double(-1), _rmfg=double(0.0), _rmmax=double(0.0), _maxpaerr=double(1e30), _plotter=string(""), _nx=long(5), _ny=long(5)) -> bool


        Summary:
            Find Rotation Measure (traditional approach)

        Description:



        This function generates the rotation
        measure image from a collection of different frequencies.  It will only
        work if the Imagepol tool is attached to an image containing
        Stokes $Q$ and $U$, and a frequency axis (regular or irregular) with at
        least 2 pixels.  It will work out the position angle images for you.

        See also the fourierrotationmeasure
        function for a new Fourier-based approach.

        Rotation Measure algorithms that work robustly are not common.  The main
        problem is in trying to account for the $n- pi$ ambiguity (see Leahy et
        al, Astronomy & Astrophysics, 156, 234 or Killeen et al;
        http://www.atnf.csiro.au/verb+~+nkilleen/rm.ps).

        The algorithm that this function uses is that of Leahy et al. (see Appendix A.1).  But as in all
        these algorithms, the basic process is that for each spatial pixel, a
        vector of position angles (i.e.  at the different frequencies) is fit to
        determine the rotation measure and the position angle at zero wavelength
        (and their errors).   An image containing
        the number of $n- pi$ turns that were added to the data
        at each spatial pixel and for which the best fit was found can be written.
        The reduced chi-squared image for the fits can also be written.

        Note that no assessment of curvature (i.e. deviation
        from the simple linear position angle - $lambda^2$ functional form)
        is made.

        Any combination of output images can be written.

        The argument {stfaf sigma} gives the thermal noise in Stokes Q and U.
        By default it is determined automatically using the image data.  But if it proves
        to be inaccurate (maybe not many signal-free pixels), it may be specified.
        This is used for calculating the error in the
        position angles (propagation of Gaussian errors).

        The argument {stfaf maxpaerr} specifies the maximum allowable error in
        the position angle that is acceptable.  The default is an infinite
        value.  From the standard propagation of errors, the error in the
        linearly polarized position angle is determined from the Stokes $Q$ and
        $U$ images (at each spatial pixel for each frequency).  At each spatial
        pixel we do a fit to the position angle vector (i.e.  at the different
        frequencies) to determine the rotation measure.  If the position angle
        error for any pixel in the vector exceeds the specified value, it is
        dropped from the fit.     The process generates an error for the
        fit and this is used to compute the errors in the output
        images.

        Note that {stfaf maxpaerr} is {it not} used to specify that any pixel
        for which the output position angle error exceeds this value
        should be masked out.

        The argument {stfaf rmfg} is used to specify a foreground RM value.  For
        example, you may know the mean RM in some direction out of the Galaxy,
        then including this can aid the algorithm by reducing ambiguity.

        The argument {stfaf rmmax} specifies the maximum absolute RM that
        should be solved for.  This quite an important parameter.  If you leave
        it at the default, zero, no ambiguity handling will be
        used.  So some apriori information should be supplied; this
        is the basic problem with rotation measure algorithms.

        Input Parameters:
            rm                        Output Rotation Measure image file name. Default is unset.
            rmerr                     Output Rotation Measure error image file name. Default is unset.
            pa0                       Output position angle (degrees) at zero wavelength image file name. Default is unset.
            pa0err                    Output position angle (degrees) at zero wavelength error image file name. Default is unset.
            nturns                    Output number of turns image file name. Default is unset.
            chisq                     Output reduced chi squared image file name. Default is unset.
            sigma                     Estimate of the thermal noise.  Default is auto estimate.
            rmfg                      Foreground Rotation Measure (rad/m/m) to subtract.
            rmmax                     Maximum rotation measure (rad/m/m) to solve for. IMPORTANT TO SPECIFY.
            maxpaerr                  Maximum input position angle error (degrees) to allow
            plotter                   Name of plotter.  Default is none.
            nx                        Number of plots in x direction
            ny                        Number of plots in y direction

        Example:


        #
        print 't----t rotationmeasure Ex 1 t----'
        #im = ia.imageconcat(outfile='stokes.image',
        #                    infiles='im.f1 im.f2 im.f3 im.f4 im.f5', axis=4)
        po.open('stokes.image')
        ok = po.rotationmeasure(rm='rm', rmerr='rmerr', rmmax=800, maxpaerr=10)
        #



        Say we have 5 images, each with axes RA, DEC, Stokes, and Frequency in
        that order.  We use the Image tool to concatenate these images
        along the frequency axis - you have ordered them in increasing or
        decreasing frequency order.  We then compute the Rotation Measure
        and Rotation Measure error images with the traditional method and
        write them out to disk.

        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_rotationmeasure(self, *args, **kwargs)

    def sigma(self, *args, **kwargs):
        r"""
        sigma(self, _clip=double(10.0)) -> double


        Summary:
            Find best guess at thermal noise

        Description:



        This function returns the standard deviation from V, Q&U or I in that
        order of precedence.  It is attempting to give you the best estimate of
        the thermal noise it can from the data.  Outliers from the mean are
        clipped at the specified level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination

        Example:


        #
        print 't----t sigma Ex 1 t----'
        po.open('stokes.image')
        sigma = po.sigma()
        print 'sigma=', sigma
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigma(self, *args, **kwargs)

    def sigmadepolratio(self, *args, **kwargs):
        r"""
        sigmadepolratio(self, _infile=string(""), _debias=bool(false), _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> casac::image *


        Summary:
            Error in linear depolarization ratio

        Description:



        This function  returns the error
        in the linear depolarization ratio computed from two frequencies; this
        is the ratio of the fractional linear polarization at the two
        frequencies.  Generally this is done when you have generated two
        images, each at a different frequency (continuum work). Thus if the
        fractional linear polarzation images are $m1$ and $m2$ then the
        depolarization ratio is $m1/m2$.

        This function operates with two images; the first is attached
        to the Imagepol tool.  The second is supplied via the
        argument {stfaf infile}, which is  a String
        holding the name of the imagefile.

        In generating the depolarization ratio, and hence its error, you may
        optionally debias the  linearly polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level.

        You can get the depolarization ratio image with function
        depolratio.

        Input Parameters:
            infile                    Other image.  Required input.
            debias                    Debias the linearly polarized intensity ?
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        #print 't----t sigmadepolratio Ex 1 t----'
        #po.open('stokes.4800')
        #dpr = po.depolratio('stokes.8300')
        #edpr = po.sigmadepolratio('stokes.8300');
        #dpr.done()
        #edpr.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmadepolratio(self, *args, **kwargs)

    def sigmafraclinpol(self, *args, **kwargs):
        r"""
        sigmafraclinpol(self, _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> casac::image *


        Summary:
            Error in fractional linear polarization

        Description:



        This function  returns the
        error (standard deviation) of the fractional linear polarization.
        This result comes from standard propagation of errors.  The result is
        an on-the-fly Image tool as the error is signal-to-noise ratio
        dependent.

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t sigmafraclinpol Ex 1 t----'
        po.open('stokes.image')
        sigflp = po.sigmafraclinpol()
        sigflp.statistics()
        sigflp.done()           # free up resources
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmafraclinpol(self, *args, **kwargs)

    def sigmafractotpol(self, *args, **kwargs):
        r"""
        sigmafractotpol(self, _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> casac::image *


        Summary:
            Error in fractional total polarization

        Description:



        This function  returns the
        error (standard deviation) of the fractional total polarization.  This
        result comes from standard propagation of errors.  The result is an
        on-the-fly Image tool as the error is signal-to-noise ratio dependent.

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t sigmafractotpol Ex 1 t----'
        po.open('stokes.image')
        sigftp = po.sigmafractotpol()
        sigftp.statistics()
        sigftp.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmafractotpol(self, *args, **kwargs)

    def sigmalinpolint(self, *args, **kwargs):
        r"""
        sigmalinpolint(self, _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> double


        Summary:
            Error in linearly polarized intensity

        Description:



        This function  returns the error (standard
        deviation) of the linearly polarized intensity; $sqrt{(Q^2+U^2)}$.
        This result comes from standard propagation of statistical errors.
        The result is a float as the error is not signal-to-noise
        ratio dependent

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t sigmalinpolint Ex 1 t----'
        po.open('stokes.image')
        siglpi = po.sigmalinpolint()
        print 'siglpi=', siglpi
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmalinpolint(self, *args, **kwargs)

    def sigmalinpolposang(self, *args, **kwargs):
        r"""
        sigmalinpolposang(self, _clip=double(10.0), _sigma=double(-1), _outfile=string("")) -> casac::image *


        Summary:
            Error in linearly polarized position angle

        Description:



        This function  returns the
        error (standard deviation) of the linearly polarized position angle
        ($0.5 tan^{-1}(U/Q)$$sqrt{(Q^2+U^2)}$) in degrees.  This result
        comes from standard propagation of errors.  The result is an
        on-the-fly Image tool as the error is signal-to-noise ratio dependent.

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t sigmalinpolposang Ex 1 t----'
        po.open('stokes.image')
        siglppa = po.sigmalinpolposang()
        siglppa.statistics()
        siglppa.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmalinpolposang(self, *args, **kwargs)

    def sigmastokes(self, *args, **kwargs):
        r"""
        sigmastokes(self, _which=string(""), _clip=double(10.0)) -> double


        Summary:
            Find standard deviation of specified Stokes data

        Description:



        This function  returns the standard
        deviation of the noise for the specified Stokes.  Outliers from the mean
        are clipped at the specified level.

        Input Parameters:
            which                     Must specify Stokes parameter. One of 'I', 'Q', 'U', 'V' (case insensitive) 
            clip                      Clip level for auto-sigma determination

        Example:


        #
        print 't----t sigmastokes Ex 1 t----'
        po.open('stokes.image')
        sigq = po.sigmastokes('q', 10.0)
        print 'sigq=', sigq
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmastokes(self, *args, **kwargs)

    def sigmastokesi(self, *args, **kwargs):
        r"""
        sigmastokesi(self, _clip=double(10.0)) -> double


        Summary:
            Find standard deviation of Stokes I data

        Description:



        This function  returns the standard deviation of the noise for the
        Stokes I data.  Outliers from the mean are clipped at the specified
        level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination

        Example:


        #
        print 't----t sigmastokesi Ex 1 t----'
        po.open('stokes.image')
        sigi = po.sigmastokesi(10.0)
        print 'sigi=', sigi
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmastokesi(self, *args, **kwargs)

    def sigmastokesq(self, *args, **kwargs):
        r"""
        sigmastokesq(self, _clip=double(10.0)) -> double


        Summary:
            Find standard deviation of Stokes Q data

        Description:



        This function  returns the standard deviation of the noise for the
        Stokes Q data.  Outliers from the mean are clipped at the specified
        level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination

        Example:


        #
        print 't----t sigmastokesq Ex 1 t----'
        po.open('stokes.image')
        sigq = po.sigmastokesq(10.0)
        print 'sigq=', sigq
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmastokesq(self, *args, **kwargs)

    def sigmastokesu(self, *args, **kwargs):
        r"""
        sigmastokesu(self, _clip=double(10.0)) -> double


        Summary:
            Find standard deviation of Stokes U data

        Description:



        This function  returns the standard
        deviation of the noise for the Stokes U data.  Outliers from the mean
        are clipped at the specified level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination

        Example:


        #
        print 't----t sigmastokesu Ex 1 t----'
        po.open('stokes.image')
        sigu = po.sigmastokesu(10.0)
        print 'sigu=', sigu
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmastokesu(self, *args, **kwargs)

    def sigmastokesv(self, *args, **kwargs):
        r"""
        sigmastokesv(self, _clip=double(10.0)) -> double


        Summary:
            Find standard deviation of Stokes V data

        Description:



        This function  returns the standard
        deviation of the noise for the Stokes V data.  Outliers from the mean
        are clipped at the specified level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination

        Example:


        #
        print 't----t sigmastokesv Ex 1 t----'
        po.open('stokes.image')
        sigv = po.sigmastokesv(10.0)
        print 'sigv=', sigv
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmastokesv(self, *args, **kwargs)

    def sigmatotpolint(self, *args, **kwargs):
        r"""
        sigmatotpolint(self, _clip=double(10.0), _sigma=double(-1)) -> double


        Summary:
            Error in total polarized intensity

        Description:



        This function  returns the error (standard
        deviation) of the total polarized intensity; $sqrt{(Q^2+U^2+V^2)}$.
        This result comes from standard propagation of statistical errors.
        The result is a float as the error is not signal-to-noise
        ratio dependent

        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.

        Input Parameters:
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noise.  Default is auto determined.

        Example:


        #
        print 't----t sigmastotpolint Ex 1 t----'
        po.open('stokes.image')
        sigtpi = po.sigmatotpolint()
        print 'sigtpi=', sigtpi
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_sigmatotpolint(self, *args, **kwargs)

    def stokes(self, *args, **kwargs):
        r"""
        stokes(self, _which=string(""), _outfile=string("")) -> casac::image *


        Summary:
            Stokes

        Description:



        This function returns an on-the-fly image tool containing the
        specified Stokes only.  This interface can be useful for scripts.

        Input Parameters:
            which                     Must specify Stokes. One of 'I', 'Q', 'U', 'V' (case insensitive) 
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t stokes Ex 1 t----'
        po.open('stokes.image')
        q = po.stokes('q')
        q.statistics()
        q.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_stokes(self, *args, **kwargs)

    def stokesi(self, *args, **kwargs):
        r"""
        stokesi(self, _outfile=string("")) -> casac::image *


        Summary:
            Stokes I

        Description:


        This function returns an on-the-fly image tool containing Stokes I only.

        Input Parameters:
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t stokesi Ex 1 t----'
        po.open('stokes.image')
        i = po.stokesi()
        i.statistics()
        i.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_stokesi(self, *args, **kwargs)

    def stokesq(self, *args, **kwargs):
        r"""
        stokesq(self, _outfile=string("")) -> casac::image *


        Summary:
            Stokes Q

        Description:


        This function returns an on-the-fly image tool containing Stokes Q only.

        Input Parameters:
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t stokesq Ex 1 t----'
        po.open('stokes.image')
        q = po.stokesq()
        q.statistics()
        q.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_stokesq(self, *args, **kwargs)

    def stokesu(self, *args, **kwargs):
        r"""
        stokesu(self, _outfile=string("")) -> casac::image *


        Summary:
            Stokes U

        Description:


        This function returns an on-the-fly image tool containing Stokes U only.

        Input Parameters:
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t stokesu Ex 1 t----'
        po.open('stokes.image')
        u = po.stokesu()
        u.statistics()
        u.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_stokesu(self, *args, **kwargs)

    def stokesv(self, *args, **kwargs):
        r"""
        stokesv(self, _outfile=string("")) -> casac::image *


        Summary:
            Stokes V

        Description:


        This function returns an on-the-fly image tool containing Stokes V only.

        Input Parameters:
            outfile                   Output image file name.  Default is unset.

        Example:


        #
        print 't----t stokesv Ex 1 t----'
        po.open('stokes.image')
        v = po.stokesv()
        v.statistics()
        v.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_stokesv(self, *args, **kwargs)

    def summary(self):
        r"""
        summary(self) -> bool


        Summary:
            Summarise Imagepol tool

        Description:



        This function just lists a summary of the Imagepol tool to the logger.
        Currently it just summarizes the image to which the tool is attached.

        Example:


        #
        print 't----t summary Ex 1 t----'
        po.open('stokes.image')
        po.summary()
        #
        #Image name       : stokes.image
        #Object name      :
        #Image type       : PagedImage
        #Image quantity   : Intensity
        #Pixel mask(s)    : None
        #Region(s)        : None
        #
        #Direction reference : J2000
        #Spectral  reference : TOPO
        #Velocity  type      : RADIO
        #Rest frequency      : 1.4e+09 Hz
        #Telescope           : UNKNOWN
        #Observer            : UNKNOWN
        #Date observation    : UNKNOWN
        #
        #Axis Coord Type      Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
        #------------------------------------------------------------------------------------------------
        #0    0     Direction Right Ascension   SIN    32   32  00:00:00.000    16.00 -6.000000e+01 arcsec
        #1    0     Direction Declination       SIN    32   32 +00.00.00.000    16.00  6.000000e+01 arcsec
        #2    1     Stokes    Stokes                    4    4       I Q U V
        #3    2     Spectral  Frequency                32   32       1.4e+09    16.00  4.000000e+06 Hz
        #                     Velocity                                     0    16.00 -8.565499e+02 km/s
        #
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_summary(self)

    def totpolint(self, *args, **kwargs):
        r"""
        totpolint(self, _debias=bool(false), _clip=double(10.0), _sigma=double(-1), _outfile=string(""), _region=casac::variant( ), _mask=string(""), _stretch=bool(false)) -> casac::image *


        Summary:
            Total polarized intensity

        Description:


        This application returns the total polarized intensity;

        $sqrt{( Q^2+ U^2+ V^2)}$.

        If the image contains only Q and U, or only V, then just
        those components contribute to the total polarized intensity.

        The polarized intensity may optionally be debiased (if debias=True).
        This requires an estimate of the thermal noise level (sigma).
        The resulting image will be computed using

        $sqrt{(Q^2 + U^2 + V^2 - sigma^2)}$

        If the specified value of sigma is positive, that is the value that will
        be used for debiasing. If it is not, the value used for sigma is computed
        using the following algorithm:

        1. First, a stokes plane(s) is chosen on which the sigma computation is performed.
        If the V plane exists, that is used to compute sigma. If not, then the value of
        sigma is computed to be the average of the sigma values of the Q and U planes.

        2. For the relevant plane(s), the sigma value is computed for unmasked pixel values
        which lie within +/- (clip * stddev) values of the mean for that plane, where the mean
        and stddev (the standard deviation) are computed by using all unmasked pixel values
        in the relevant plane. In this way, outliers (eg pixels due to possible
        astronomical signals) are excluded in the computation of sigma.

        In the output image, pixels for which the expression inside the square root is
        negative are masked, and their values are set to zero.

        If a region and/or mask is specified, debias=True and sigma is not positive so
        that the value of sigma is determined using the algorithm above, the region and mask
        are applied first to the plane(s) from which the value of sigma is determined and
        then sigma is computed.

        Input Parameters:
            debias                    Debias the total polarized intensity ?
            clip                      Clip level for auto-sigma determination
            sigma                     Standard deviation of thermal noised.  Default is auto determined.
            outfile                   Output image file name.  Default is unset.
            region                    Region selection. Default is to use the full image.
            mask                      Mask to use. Default setting is none.
            stretch                   Stretch the mask if necessary and possible? Default value is false.

        Example:


        #
        print 't----t totpolint Ex 1 t----'
        po.open('stokes.image')
        tpi = po.totpolint()
        tpi.statistics()
        tpi.done()
        #


        --------------------------------------------------------------------------------

        """
        return _imagepol.imagepol_totpolint(self, *args, **kwargs)
    __swig_destroy__ = _imagepol.delete_imagepol

# Register imagepol in _imagepol:
_imagepol.imagepol_swigregister(imagepol)

