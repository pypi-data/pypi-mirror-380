##################### generated by xml-casa (v2) from simulator.xml #################
##################### fa27e622696d3e2e500786ae4519c6b1 ##############################
from __future__ import absolute_import 
from .__casac__.simulator import simulator as _simulator

from .errors import create_error_string
from .typecheck import CasaValidator as _validator
_pc = _validator( )
from .coercetype import coerce as _coerce


class simulator:
    _info_group_ = """simulator"""
    _info_desc_ = """Tool for simulation"""
    ### self
    def __init__(self, *args, **kwargs):
        """Create a simulator tool.
        
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _simulator()

    def open(self, ms=''):
        """A simulator tool can either operate on an existing MeasurementSet,
        predicting and/or corrupting data on the existing uvw coordinates
        
        -- to do that open the MS with sm.openfromms(msname).
        
        or it can be used to create a new MeasurementSet from descriptions of
        the array configuration and the observational parameters
        
        -- to create a new MS, use this method sm.open(msname).
        
        You will also need to run setconfig, setfield, setspw, setspwindow,
        setfeed, and settimes.
        
        Creating the actual (empty) MS is accomplished with sm.observe.
        Data can be subsequently sm.predict-ed and sm.corrupt-ed.
        
        NOTE: sm.predict assumes the model image units are Jy/pixel, and
        in fact will overwrite the brightness units of the image itself!
        
        """
        return self._swigobj.open(ms)

    def openfromms(self, ms=''):
        """A simulator tool can either operate on an existing MeasurementSet,
        predicting and/or corrupting data on the existing uvw coordinates
        - to do that open the MS with sm.openfromms(msname)
        or it can be used to create a new MeasurementSet from descriptions of
        the array configuration and the observational parameters.
        - to create a new MS, use sm.open(msname).
        
        NOTE: sm.predict assumes the model image units are Jy/pixel, and in
        fact will overwrite the brightness units of the image itself!
        
        """
        return self._swigobj.openfromms(ms)

    def close(self):
        """Close tools and write data to disk. This is a synonym for done.
        
        """
        return self._swigobj.close()

    def done(self):
        """Close tools and write data to disk. This is a synonym for done.
        
        """
        return self._swigobj.done()

    def name(self):
        """Returns the name of the attached MeasurementSet.
        
        """
        return self._swigobj.name()

    def summary(self):
        """Writes a summary of the currently set properties to the default logger.
        
        """
        return self._swigobj.summary()

    def type(self):
        """This function returns the string `Simulator'.  It is used so that in a
        script, you can make sure this variable is a simulator tool.
        
        """
        return self._swigobj.type()

    def settimes(self, integrationtime=[ ], usehourangle=True, referencetime=[ ]):
        """This method sets values to be used in sm.observe.
        
        If usehourangle=False, the start and stop times in sm.observe are
        referenced to referencetime.
        
        If usehourangle=True, then in sm.observe, starttime/stoptime will be
        interpreted as startha/stopha.
        In that case, the start and stop times are calculated such that the
        start time is later than the reference time, but less than one day
        later.  The hour angles refer to the first source observed.
        
        """
        return self._swigobj.settimes(integrationtime, usehourangle, referencetime)

    def observe(self, sourcename='', spwname='', starttime=[ ], stoptime=[ ], add_observation=False, state_sig=True, state_ref=False, state_cal=float(0.0), state_load=float(0.0), state_sub_scan=int(0), state_obs_mode='OBSERVE_TARGET.ON_SOURCE', observer='CASA simulator', project='CASA simulation'):
        """Observe a given source with a given spectral window for the specified
        times, including start, stop, integration, and gap times.
        
        If usehourangle=False (set with settimes), the start and stop times
        are referenced to referencetime.
        
        If userhourangle=True, starttime/stoptime are interpreted as
        startha/stopha, the start and stop times are calculated such that the
        start time is later than the reference time, but less than one day
        later, and the hour angles refer to the first source observed.
        
        setconfig, setspwindow, setfeed, and setfield must
        be run before observe can be run.
        
        See also sm.observemany
        
        """
        return self._swigobj.observe(sourcename, spwname, starttime, stoptime, add_observation, state_sig, state_ref, state_cal, state_load, state_sub_scan, state_obs_mode, observer, project)

    def observemany(self, sourcenames=[  ], spwname='', starttimes=[ '0s' ], stoptimes=[ '3600s' ], directions=[ '' ], add_observation=False, state_sig=True, state_ref=False, state_cal=float(0.0), state_load=float(0.0), state_sub_scan=int(0), state_obs_mode='OBSERVE_TARGET#ON_SOURCE', observer='CASA simulator', project='CASA simulation'):
        """Observe given sources with a given spectral window for the specified
        times, including start, stop, integration, and gap times.
        
        If usehourangle=False (set with settimes), the start and stop times
        are referenced to referencetime.
        
        If userhourangle=True, starttime/stoptime are interpreted as
        startha/stopha, the start and stop times are calculated such that the
        start time is later than the reference time, but less than one day
        later, and the hour angles refer to the first source observed.
        
        See also sm.observe
        
        """
        return self._swigobj.observemany(sourcenames, spwname, starttimes, stoptimes, directions, add_observation, state_sig, state_ref, state_cal, state_load, state_sub_scan, state_obs_mode, observer, project)

    def setlimits(self, shadowlimit=float(1e-6), elevationlimit=[ ]):
        """Data are flagged for two conditions:
        
        - Below elevation limit: If either of the antennas point below the
        specified elevation limit then the data are flagged. The elevation is
        calculated correctly for antennas at different locations (such as
        occurs in VLBI).
        
        - Shadowing: If one antenna shadows another such that the fractional
        (geometric) blockage is greater than the specified limit then the data
        are flagged. No correction for blockage is made for shadowed but
        non-flagged points.
        
        """
        return self._swigobj.setlimits(shadowlimit, elevationlimit)

    def setauto(self, autocorrwt=float(0.0)):
        """
        """
        return self._swigobj.setauto(autocorrwt)

    def setconfig(self, telescopename='VLA', x=[ float(0) ], y=[ float(0) ], z=[ float(0) ], dishdiameter=[ float(0) ], offset=[ float(0) ], mount=[ 'ALT-AZ' ], antname=[ 'A' ], padname=[ 'P' ], coordsystem='global', referencelocation=[ ]):
        """Set the positions of the antennas.
        - The name of the telescope will control which voltage pattern
        is applied to the data (see sm.setvp for details).
        - The diameter(s) will be written to the antenna subtable but
        ONLY affect the calculated visibilities in sm.predict if
        telescope=ALMA,ACA,OVRO, *and*  ftmachine=mosaic
        (see sm.setvp for details).
        - simutil::readantenna can be used to read an antenna config. file
        which includes many existing observatories.
        see help for the simobserve task, or the example below
        
        """
        return self._swigobj.setconfig(telescopename, x, y, z, dishdiameter, offset, mount, antname, padname, coordsystem, referencelocation)

    def setfeed(self, mode='', x=[ float(0) ], y=[ float(0) ], pol=[ 'R' ]):
        """Specify feed parameters. At this moment, you only have the choice
        between 'perfect R L' and 'perfect X Y' (i.e., you cannot invent
        your own corrupted feeds yet).  Doesn't need to be run if you want
        perfect R and L feeds.
        
        """
        return self._swigobj.setfeed(mode, x, y, pol)

    def setfield(self, sourcename='SOURCE', sourcedirection=[ ], calcode='', distance=[ ]):
        """Set one or more observed fields, including name and coordinates.
        Can be invoked multiple times for a complex observation.
        Must be invoked at least once before sm.observe.
        
        If the distance to the object is set then the phase term includes a
        curvature for the near-field effect at the center of the image.
        
        """
        return self._swigobj.setfield(sourcename, sourcedirection, calcode, distance)

    def setmosaicfield(self, sourcename='SOURCE', calcode='', fieldcenter=[ ], xmosp=int(1), ymosp=int(1), mosspacing=[ ], distance=[ ]):
        """Set mosaic fields by internally invoking setfield multiple times.
        Currently only handle a rectangular mosaicing pattern.  Either
        setfield or setmosaicfield must be invoked at least once before
        observe.
        
        If the distance to the object is set then the phase term includes a
        curvature for the near-field effect at the center of the image.
        
        """
        return self._swigobj.setmosaicfield(sourcename, calcode, fieldcenter, xmosp, ymosp, mosspacing, distance)

    def setspwindow(self, spwname='XBAND', freq=[ ], deltafreq=[ ], freqresolution=[ ], refcode='TOPO', nchannels=int(1), stokes='RR LL'):
        """Set one or more spectral windows for the observations, including
        starting frequency, number of channels, channel increment and
        resolution, and stokes parameters observed.  Can be invoked
        multiple times for a complex observation.  Must be invoked at
        least once before observe.
        
        """
        return self._swigobj.setspwindow(spwname, freq, deltafreq, freqresolution, refcode, nchannels, stokes)

    def setdata(self, spwid=[ int(0) ], fieldid=[ int(0) ], msselect=''):
        """This setup tool function selects which data are to be used
        subsequently. After invocation of setdata, only the selected data are
        operated on.
        
        """
        return self._swigobj.setdata(spwid, fieldid, msselect)

    def predict(self, imagename=[  ], complist='', incremental=False):
        """Predict astronomical data from an image.  The (u,v) coordinates
        already exist, either from a MeasurementSet we have read in or by
        generating the MeasurementSet coordinates and empty data through
        smobserve.  This method calculates visibilities for those
        coordinates.
        
        - predict(incremental=False) calculates new visibilities and
        replaces the DATA column,
        - predict(incremental=True) calculates new visibilities, adds
        them to the DATA column
        - predict for any value of incremental then sets CORRECTED_DATA
        equal to DATA, and MODEL_DATA to 1
        - predict assumes model image units are Jy/pixel, and in fact
        will overwrite the brightness units of the image itself!
        - treatment of primary beam depends critically on parameters set in
        sm.setvp() and sm.setoptions(ftmachine) - see help sm.setvp for
        details. For componentlists, if sm.setvp() is run prior to predict, then the spectral variation of each component in the componentlist will include the multiplicative term of the beam value for each channel frequency. So a flat spectrum component will show the frequency variation of the beam in the predicted visibilities.
        
        
        """
        return self._swigobj.predict(imagename, complist, incremental)

    def setoptions(self, ftmachine='ft', cache=int(0), tile=int(16), gridfunction='SF', location=[ ], padding=float(1.3), facets=int(1), maxdata=float(2000.0), wprojplanes=int(1)):
        """Set options for predict.  See also imager help.
        
        To simulate single dish data, use gridft=SD and gridfunction=PB.
        
        To invoke primary beam convolution in the uv domain, use
        ftmachine="mosaic".  This is the only option that allows
        heterogeneous array simulation - see the example below and
        help sm.setvp for more details.
        
        """
        return self._swigobj.setoptions(ftmachine, cache, tile, gridfunction, location, padding, facets, maxdata, wprojplanes)

    def setvp(self, dovp=True, usedefaultvp=True, vptable='', dosquint=True, parangleinc=[ ], skyposthreshold=[ ], pblimit=float(1.0e-2)):
        """Set the voltage pattern model (and hence, the primary beam) used
        for a Telecope.  There are currently two ways to set the voltage
        pattern: by using the extensive list of defaults which the system
        knows about, or by creating a voltage pattern description with
        the vpmanager.  If you are
        simulating a telescope which doesn't yet exist, you will need to
        supply a model voltage pattern using
        the vpmanager.
        
        sm.predict behavior depends critically on the parameters here, and
        the ftmachine parameter set in sm.setoptions
        
        sm.predict will always query the vpmanager for a primary beam/VP pattern.
        if usedefaultvp==True, it will reset the vpmanager first, so that
        the PB obtained will be the default for the given telescope name
        if usedefaultvp==False, it will check whether vptable is set, and if so,
        load that table into the vpmanager and use the beams therein.
        if usedefaultvp==False and vptable is not set, it will use whatever is
        already set in the vpmanager (see example below for overriding a
        default telescope beam).
        
        What sm.predict does with the obtained PB depends on the ftmachine and
        dovp parameters:
        
        if ftmachine=="mosaic":
        - a message "Performing Mosaic Gridding" indicates that one is using
        uv domain convolution for simulating from images.
        - if the primary beam returned by the vpmanager is ALMA, ACA, or OVRO,
        heterogeneous gridding will be invoked, and the dish diameter set
        in sm.setconfig, or already in the antenna subtable, will be used
        to convolve sky model images.
        for ALMA or ACA, dish diameter =12m will use a 10.7m Airy pattern,
        and dish diameter =7m will use a 6.25m Airy pattern.
        see help sm.setoptions for an example.
        - otherwise the PB returned by the vpmanager will be used.
        - heterogeneous simulation only works at present from a sky model
        image, NOT from sky model components. If you want to simulate a
        heterogeneous array, please add components to an image using
        ia.modify, and don't specify a component list in sm.predict.
        Homogeneous array simulation from component lists works fine.
        - IF dovp=True, the primary beam returned by the vpmanager will
        be used to convolve sky model components.  This is not automatically
        invoked by ftmachine="mosaic", but needs to be set explicitly with
        sm.setvp() if you are simulating from components in addition to or
        instead of sky model images.
        
        if ftmachine=="ft" (the default):
        - a message "Synthesis Gridding" indicates that if requested with
        dovp==True, image domain PB convolution will be used.
        - if dovp==True, the primary beam returned by the vpmanager will be
        used to convolve sky model components and images.
        
        
        """
        return self._swigobj.setvp(dovp, usedefaultvp, vptable, dosquint, parangleinc, skyposthreshold, pblimit)

    def corrupt(self):
        """Add errors specified by the set* functions (such as noise, gains,
        polarization leakage, bandpass, etc) to the visibility data.  The
        errors are applied to the DATA and CORRECTED_DATA columns.
        
        Note that corrupt handles only
        visibility-plane effects, not image-plane effects such as pointing
        errors and voltage patterns, which get applied in predict.  Note, the
        function applies errors to both cross- and auto-correlation data; The
        auto-correlation data are corrupted properly only for the thermalnoise
        set by setnoise.
        
        """
        return self._swigobj.corrupt()

    def reset(self):
        """Reset the visibility corruption terms: this means that corrupt
        introduces no errors.
        
        """
        return self._swigobj.reset()

    def setbandpass(self, mode='calculate', table='', interval=[ ], amplitude=[ float(0.0) ]):
        """Set the level of bandpass errors. The error distributions are normal, mean
        zero, with the variances as specified. (Not yet implemented).
        
        """
        return self._swigobj.setbandpass(mode, table, interval, amplitude)

    def setapply(self, table='', type='', t=float(0.0), field=[ ], interp='linear', calwt=False, spwmap=[ int(-1) ], opacity=float(0.0)):
        """Arrange for corruption by existing cal tables, in a manner
        exactly analogous to calibrater.setapply.
        
        """
        return self._swigobj.setapply(table, type, t, field, interp, calwt, spwmap, opacity)

    def setgain(self, mode='fbm', table='', interval=[ ], amplitude=[ float(0.01) ]):
        """Set the level of gain errors.  Gain drift is implemented as
        fractional brownian motion with rms amplitude as specified.
        Interval is not currently used.
        
        
        """
        return self._swigobj.setgain(mode, table, interval, amplitude)

    def settrop(self, mode='screen', table='', pwv=float(3.0), deltapwv=float(0.15), beta=float(1.1), windspeed=float(7.), simint=float(-1.)):
        """Set up for corruption by the atmosphere - attenuation and increase in
        noise.
        
        """
        return self._swigobj.settrop(mode, table, pwv, deltapwv, beta, windspeed, simint)

    def setpointingerror(self, epjtablename='', applypointingoffsets=False, dopbcorrection=False):
        """Set the pointing error from a calpointing table
        
        """
        return self._swigobj.setpointingerror(epjtablename, applypointingoffsets, dopbcorrection)

    def setleakage(self, mode='constant', table='', amplitude=[ float(0.01) ], offset=[ float(0.) ]):
        """Set the level of polarization leakage between feeds.
        Currently, no time dependence is available.
        
        """
        return self._swigobj.setleakage(mode, table, amplitude, offset)

    def oldsetnoise(self, mode='calculate', table='', simplenoise=[ ], antefficiency=float(0.8), correfficiency=float(0.85), spillefficiency=float(0.85), tau=float(0.1), trx=float(50), tatmos=float(230.0), tcmb=float(2.7)):
        """Set various system parameters from which the thermal (ie, random
        additive) noise level will be calculated.
        
        For mode=simplenoise, one specifies the standard deviation for the
        noise to be added to real and imaginary parts of the visibility.
        
        For mode=calculate, the noise will vary with dish diameter,
        antenna efficiency, system temperature, opacity, sky temperature,
        etc.  The noise will increase with the airmass if tau is greater
        than zero.  The noise is calculated according to the Brown
        Equation (ie, R.L. Brown's calculation of MMA sensitivity,
        3Oct95):
        
        ``dS = 4*sqrt(2) *( T_rx*exp(-tau_atm) +
        T_atm*( exp(tau_atm) - epsilon_l + T_cmb) )
        *epsilon_q *epsilon_a *pi *D^2 *sqrt(dnu*dt)``
        
        """
        return self._swigobj.oldsetnoise(mode, table, simplenoise, antefficiency, correfficiency, spillefficiency, tau, trx, tatmos, tcmb)

    def setnoise(self, mode='simplenoise', table='', simplenoise=[ ], pground=[ ], relhum=float(20.0), altitude=[ ], waterheight=[ ], pwv=[ ], tatmos=float(250.0), tau=float(0.1), antefficiency=float(0.8), spillefficiency=float(0.85), correfficiency=float(0.88), trx=float(50), tground=float(270.0), tcmb=float(2.73), OTF=True, senscoeff=float(0.), rxtype=int(0)):
        """Set various system parameters from which the thermal (ie, random
        additive) noise level will be calculated.
        
        For mode=simplenoise, one specifies the standard deviation "sigma"
        for the noise to be added to real and imaginary parts of the visibility.
        The noise in amplitude per visibility is approximately "sigma" although
        it is not Gaussian (see Thompson, Moran, and Swenson fig. 6.9)
        and the point source noise in a Stokes I image will approximately be
        sigma/sqrt(n_pol * n_baselines * n_integrations * n_chan),
        where n_pol are the number of polarizations in the MS (typically 2),
        and n_integrations are the number of correlator integration times
        in the MS (~ track time / int. time)
        
        For mode=tsys-atm or tsys-manual, the noise will vary with dish
        diameter, antenna efficiency, system temperature, opacity, sky
        temperature, etc.  The noise will increase with the airmass if tau
        is greater than zero.  The noise is calculated according to the
        Brown Equation (ie, R.L. Brown's calculation of MMA sensitivity,
        3Oct95):
        
        ``dS = 4*sqrt(2) *( T_rx*exp(-tau_atm) +
        T_atm*( exp(tau_atm) - epsilon_l + T_cmb) )
        *epsilon_q *epsilon_a *pi *D^2 *sqrt(dnu*dt)``
        
        For mode=tsys-atm, the sky brightness temperature is calculated
        using an atmospheric model created for the user-input PWV.  For
        mode=tsys-manual, the user specifies the sky brightness temperature
        manually.
        
        """
        return self._swigobj.setnoise(mode, table, simplenoise, pground, relhum, altitude, waterheight, pwv, tatmos, tau, antefficiency, spillefficiency, correfficiency, trx, tground, tcmb, OTF, senscoeff, rxtype)

    def setpa(self, mode='calculate', table='', interval=[ ]):
        """Corrupt phase by the parallactic angle
        
        """
        return self._swigobj.setpa(mode, table, interval)

    def setseed(self, seed=int(185349251)):
        """
        """
        return self._swigobj.setseed(seed)

