##################### generated by xml-casa (v2) from synthesisutils.xml ############
##################### 19f133338e28509761eee6c6c563b16d ##############################
from __future__ import absolute_import 
from .__casac__.synthesisutils import synthesisutils as _synthesisutils

from .errors import create_error_string
from .typecheck import CasaValidator as _validator
_pc = _validator( )
from .coercetype import coerce as _coerce
from .synthesisimstore import synthesisimstore as _wrap_synthesisimstore

class synthesisutils:
    _info_group_ = """synthesisutils"""
    _info_desc_ = """tool for synthesis imaging"""
    ### self
    def __init__(self, *args, **kwargs):
        """This is used to construct {tt synthesisutils} tool.
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _synthesisutils()

    def contdatapartition(self, selpars={ }, npart=int(1)):
        """
        """
        return self._swigobj.contdatapartition(selpars, npart)

    def advisechansel(self, freqstart=[ ], freqend=[ ], freqstep=[ ], freqframe='LSRK', ephemtable='', msname='', fieldid=int(0), getfreqrange=False, spwselection=''):
        """It is a helper function, for cube imaging, that allows you to
        determine the spectral window data selection you may need to cover a
        given range of frequencies.
        
        In the mode with getfreqrange=False, the freqstep can be used (i.e., set to the channel width) to achieve the extra padding needed for data selection at the beginning and end of the desired cube range in order to retrieve all channels that will potentially contribute to the edge channels of the cube (to maximize S/N). If freqstep is not specified, it is taken as zero, and the output channel range will typically be slightly smaller.
        
        The meaning of freqframe parameter is dependent on the value of getfreqrange.
        When getfreqrange=False, frequency parameters are considered as input parameters that are known to be in the frame specified by freqframe; but when getfreqrange=True, the frequency parameters are output parameters that will be determined in the frame specified by freqframe. In the former case, the frequencies will be converted to the frame of the data as a function of time in order to locate which channels match.
        
        You need to specify the field_id for which this calculation is
        being done.
        
        If the parameter {tt getfreqrange=True} then the reverse is requested. You set {tt spwselection} to be the range of data selection you want to use and you'll get the range of frequency covered in the frame you set. The freqstart and freqend output values correspond to the frequency of the extreme edges of the requested channel range.
        Inputs
        ----------------
        freqstart
        Begining of frequency range
        allowed:  double, string, quantity
        example: freqstart='1.0GHz'
        Default:
        ----------------
        freqend
        End of frequency range
        allowed:  double, string, quantity
        example: freqend='2.0GHz'
        Default:''
        -----------------
        freqstep
        spectral channel resolution of intended image
        allowed:  double, string, quantity
        example: freqstep='1.0MHz'
        Default:''
        -----------------
        freqframe
        frame in which frequency is being expressed in other parameters. For solar system  moving sources if the frame of the source is intended then this parameter can be 'SOURCE'
        allowed : one of the following strings 'LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO', 'GALACTO', 'LGROUP','CMB', 'SOURCE'
        Default: 'LSRK'
        ----------------
        msname
        name of a valid measurement set.
        allowed: string
        Default: ''
        -----------------
        ephemtable
        when freqframe='SOURCE' this parameter is used
        name of a valid ephemeris table or 'TRACKFIELD' to use the ephemeris table attached to the FIELD subtable of the ms or one of the following solar system object: 'MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS', 'NEPTUNE', 'PLUTO', 'SUN', 'MOON'
        allowed: string
        Default: ''
        -----------------
        fieldid
        fieldid to use (needed to get the direction on the sky for any spectral frame conversion)
        allowed: integer
        Default: 0
        -------------------
        getfreqrange
        if set then freqrange is returned in the frame requested for the data selected
        allowed: bool
        Default: False
        -----------------
        spwselection
        if getfreqrange=True then this is needed to find the range of frequency in the frame requested. It should have the spectral window selection syntax as defined in the msselection (Casa memo 3)
        allowed: string
        Default: ''
        """
        return self._swigobj.advisechansel(freqstart, freqend, freqstep, freqframe, ephemtable, msname, fieldid, getfreqrange, spwselection)

    def cubedatapartition(self, selpars={ }, npart=int(1), fstart=[ ], fend=[ ], frame='LSRK'):
        """returns a dictionary with data spectral parttiion that maps  data  to  nparts
        of the input range frequency... usually to be used for doing data selection
        when imaging a cube from fstart to fend in npart subcubes
        """
        return self._swigobj.cubedatapartition(selpars, npart, fstart, fend, frame)

    def cubeimagepartition(self, impars={ }, npart=int(1)):
        """
        """
        return self._swigobj.cubeimagepartition(impars, npart)

    def cubedataimagepartition(self, selpars={ }, incsys={ }, npart=int(1), nchannel=int(1)):
        """
        """
        return self._swigobj.cubedataimagepartition(selpars, incsys, npart, nchannel)

    def checkselectionparams(self, selpars={ }):
        """
        """
        return self._swigobj.checkselectionparams(selpars)

    def checkimageparams(self, impars={ }):
        """
        """
        return self._swigobj.checkimageparams(impars)

    def checkgridparams(self, gridpars={ }):
        """
        """
        return self._swigobj.checkgridparams(gridpars)

    def updateimpars(self, impars={ }):
        """
        """
        return self._swigobj.updateimpars(impars)

    def getOptimumSize(self, size=int(100)):
        """
        """
        return self._swigobj.getOptimumSize(size)

    def fitPsfBeam(self, imagename='', nterms=int(1), psfcutoff=float(0.35)):
        """
        """
        return self._swigobj.fitPsfBeam(imagename, nterms, psfcutoff)

    def taylor_coeffs_to_cube(self, cubename='', mtname='', nterms=int(2), reffreq=''):
        """
        """
        return self._swigobj.taylor_coeffs_to_cube(cubename, mtname, nterms, reffreq)

    def cube_to_taylor_sum(self, cubename='', mtname='', nterms=int(2), reffreq='', imtype=int(0), pblimit=float(0.2)):
        """
        """
        return self._swigobj.cube_to_taylor_sum(cubename, mtname, nterms, reffreq, imtype, pblimit)

    def remove_freq_dep_pb(self, cubename='', mtname='', pblimit=float(0.2)):
        """
        """
        return self._swigobj.remove_freq_dep_pb(cubename, mtname, pblimit)

    def apply_freq_dep_pb(self, cubename='', mtname='', pblimit=float(0.2)):
        """
        """
        return self._swigobj.apply_freq_dep_pb(cubename, mtname, pblimit)

    def done(self):
        """
        """
        return self._swigobj.done()

