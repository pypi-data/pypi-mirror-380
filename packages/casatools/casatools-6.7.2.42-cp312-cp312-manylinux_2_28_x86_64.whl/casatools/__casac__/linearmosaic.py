# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_linearmosaic')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_linearmosaic')
    _linearmosaic = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_linearmosaic', [dirname(__file__)])
        except ImportError:
            import _linearmosaic
            return _linearmosaic
        try:
            _mod = imp.load_module('_linearmosaic', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _linearmosaic = swig_import_helper()
    del swig_import_helper
else:
    import _linearmosaic
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class linearmosaic(_object):
    """Proxy of C++ casac::linearmosaic class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, linearmosaic, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, linearmosaic, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(self) -> linearmosaic"""
        this = _linearmosaic.new_linearmosaic()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def defineoutputimage(self, *args, **kwargs):
        """
        defineoutputimage(self, _nx, _ny, _cellx, _celly, _imagecenter, _outputimage, _outputweight) -> bool



        Summary:
            Set the output direction image parameters and name

        Description:


        Define the direction axes output image parameters.
        The output image will get the same number of spectral and polarization planes as the input images. This function create a fresh new output image. If an image of the same name exist on disk it will be erased. The spectral and polarization part of the image will be identical to the images that are being mosaiced.

        The output image will by default be flux correct and the weight image will be ${sum_p A_p^2(theta)}$ where the primary beam is $  A_p(theta)$

        Input Parameters:
            nx                        Total number of spatial pixels in x
            ny                        Total number of spatial pixels in y
            cellx                     Cellsize in x (e.g. '1arcsec')
            celly                     Cellsize in y (e.g. '1arcsec')
            imagecenter               Direction of phase center as a diretion measure 
            outputimage               output image name 
            outputweight              output weight image name 

        Example:

        lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos', outputweight='test.weightlinmos')

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_defineoutputimage(self, *args, **kwargs)


    def setoutputimage(self, *args, **kwargs):
        """
        setoutputimage(self, _outputimage, _outputweight, _imageweighttype, _weighttype) -> bool



        Summary:
            Use this function to mosaic on an existing image and weight image

        Description:


        Use this function if the mosaicing is to be done onto a previous mosaic or image. For now the stokes and spectral characteristic of the images to be mosaic and the output image has to be similar (i.e the user has to regrid them prior to linearmosaic if necessary).
        The weightimage represents the sensitivity image of the image (for example the weighted primary beam coverage of a mosaic)

        {tt imageweighttype} parameter:

        If the image is of the type that has been normalized to be flux correct then the imageweighttype should 0.
        If the image has been  apodized by a primary beam then imageweighttype should be 1
        and if the image is multiplied by $PB^2$ then it should be 2.

        {tt weighttype} parameter:
        This should be 1 if the weight image is the sum of Primary beams or equivalent
        and it should be 2 if it is the sum of of $PB^2$

        Input Parameters:
            outputimage               Existing mosaic imagename
            outputweight              Existing weight image for mosaic
            imageweighttype           what kind of weight was already applied to image n 0: flux correct n 1:  Primary beam equivalent weight n 2:  $PB^2$ equivalent weight n 
            weighttype                what kind of weight  is weight image  n 1: Primary beam equivalent weight n 2: $PB^2$ equivalent n 

        Example:

        lm.setoutputimage(outputimage='testoo.linmos', outputweight='testoo.linmos.weight', imageweightype=0, weighttype=2)

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_setoutputimage(self, *args, **kwargs)


    def saultweightimage(self, *args, **kwargs):
        """
        saultweightimage(self, _outputimage, _fracpeak) -> bool



        Summary:
            Use this function to create a Sault-weighted image

        Description:


        'Sault weighted' image is one which is more pleasant to view (without high noise at the edges of mosaic images), it is flux correct upto a where the beam coverage becomes low and is tapered off onwards just to keep the noise from rising in the overall image(see  Eq[2] from Sault, Staveley-Smith and Brouw (1996), Astron. Astrophys. Suppl, 120, 375)

        Input Parameters:
            outputimage               Name of image to create the Sault-Weighted image
            fracpeak                  Upto what fraction of peak of coverage should the image be flux correct

        Example:

        lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos')
        lm.makemosaic(images=['FIELD_31/img.image', 'FIELD_33/img.image'], weightimages=['FIELD_31/img.pb', 'FIELD_33/img.pb'])
        ###the above will make a flux correct mosaic of the 2 images in a flux correct fashion in test.linmos
        #Now make a Sault weighted image to use in the viewer
        lm.saultweightimage('test_sault.linmos')

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_saultweightimage(self, *args, **kwargs)


    def setlinmostype(self, *args, **kwargs):
        """
        setlinmostype(self, _linmostype) -> bool



        Summary:
            Use this function to set if you want to mosaic in flatnoise domain

        Description:


        Use this function if the mosaicing is to be done using a non optimal weighting mode.


        For now {tt optimal} (which is the default) follows this equation
        begin{equation}
        I^{lm}(theta)={{sum_p A_p(theta)(I_p(theta)A_p(theta))w_p}over{sum_p A_p^2(theta)w_p}}
        end{equation}

        And {tt pbweight} follows this one
        begin{equation}
        I^{lm}(theta)={{sum_p (I_p(theta)A_p(theta))w_p}over{sum_p A_p(theta)w_p}}
        end{equation}

        where $A_p(theta)$ is the primary beam (PB) of a given pointing $p$, $w_p$ is a sensitivity weight and the image of that pointing is $I_p(theta)$; the linear mosaic being $I^{lm}(theta)$
        For now  $w_p=1$

        Input Parameters:
            linmostype                Type of weighting for linear mosaic

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_setlinmostype(self, *args, **kwargs)


    def makemosaic(self, *args, **kwargs):
        """
        makemosaic(self, _images, _weightimages, _imageweighttype, _weighttype) -> bool



        Summary:
            mosaic images in a weighted fashion onto ouput image

        Description:


        Put the list of images onto the mosaic image using the weight images

        Input Parameters:
            images                    Name of images to mosaic
            weightimages              Name of images to mosaic
            imageweighttype           what kind of weight is already applied to image n 0: flux correct n 1: Primary beam equivalent weight n 2: PB^2 equivalent n 
            weighttype                what kind of weight image it is n 1: Primary beam equivalent weight n 2: PB^2 equivalent n 

        Example:

        lm.defineoutputimage(nx=3000, cellx='3arcsec', imagecenter='19h13m13.469 4d50m09.649', outputimage='test.linmos')

        ###make a mosaic of two fields
        lm.makemosaic(images=['FIELD_31/img.image', 'FIELD_33/img.image'], weightimages=['FIELD_31/img.pb', 'FIELD_33/img.pb'])

        ####now we have another submosaic (which is flux corrected) we want to add to this mosaic

        lm.makemosaic(images='submosaic.image', weightimages='submosaic.flux',  imageweighttype=0, weighttype=1)

        --------------------------------------------------------------------------------

        """
        return _linearmosaic.linearmosaic_makemosaic(self, *args, **kwargs)

    __swig_destroy__ = _linearmosaic.delete_linearmosaic
    __del__ = lambda self: None
linearmosaic_swigregister = _linearmosaic.linearmosaic_swigregister
linearmosaic_swigregister(linearmosaic)

# This file is compatible with both classic and new-style classes.


