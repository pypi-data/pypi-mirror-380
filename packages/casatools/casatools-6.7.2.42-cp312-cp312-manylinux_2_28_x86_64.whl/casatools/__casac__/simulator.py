# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_simulator')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_simulator')
    _simulator = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_simulator', [dirname(__file__)])
        except ImportError:
            import _simulator
            return _simulator
        try:
            _mod = imp.load_module('_simulator', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _simulator = swig_import_helper()
    del swig_import_helper
else:
    import _simulator
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class simulator(_object):
    """Proxy of C++ casac::simulator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, simulator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, simulator, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(self) -> simulator"""
        this = _simulator.new_simulator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def open(self, *args, **kwargs):
        """
        open(self, _ms) -> bool



        Summary:
            Construct a simulator tool and create a new MeasurementSet

        Description:


        A simulator tool can either operate on an existing MeasurementSet,
        predicting and/or corrupting data on the existing uvw coordinates

        -- to do that open the MS with sm.openfromms(msname).

        or it can be used to create a new MeasurementSet from descriptions of
        the array configuration and the observational parameters

        -- to create a new MS, use this method sm.open(msname).

        You will also need to run setconfig, setfield, setspw, setspwindow,
        setfeed, and settimes.

        Creating the actual (empty) MS is accomplished with sm.observe.
        Data can be subsequently sm.predict-ed and sm.corrupt-ed.

        NOTE: sm.predict assumes the model image units are Jy/pixel, and
        in fact will overwrite the brightness units of the image itself!


        Input Parameters:
            ms                        MeasurementSet to be created

        Example:

        In this example, we read in the antenna coordinates from an ASCII file,
        and simulate a single-pointing VLA observation with a calibrator.
        Note that no primary beam attenuation will be applied (see sm.setvp).

        tabname = 'VLAC.LOCAL.TAB'
        asciifile = 'VLAC.LOCAL.STN'
        mytab=table.create()
        mytab.fromascii(tabname, asciifile);
        xx=[]; yy:=[]; zz:=[]; diam:=[];
        xx = mytab.getcol('X');
        yy = mytab.getcol('Y');
        zz = mytab.getcol('Z');
        diam = mytab.getcol('DIAM');
        #
        sm.open('NEW1.ms')
        # do configuration
        posvla = me.observatory('vla');  #  me.observatory('ALMA') also works!
        sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam,
        mount='alt-az', antname='VLA',
        coordsystem='local', referencelocation=posvla);

        # Initialize the spectral windows
        sm.setspwindow(spwname='CBand', freq='5GHz',
        deltafreq='50MHz',
        freqresolution='50MHz',
        nchannels=1,
        stokes='RR RL LR LL');
        sm.setspwindow(spwname='LBand', freq='1.420GHz',
        deltafreq='3.2MHz',
        freqresolution='3.2MHz',
        nchannels=32,
        stokes='RR LL');

        # Initialize the source and calibrater
        sm.setfield(sourcename='My cal',
        sourcedirection=['J2000','00h0m0.0','+45.0.0.000'],
        calcode='A');
        sm.setfield(sourcename='My source',
        sourcedirection=['J2000','01h0m0.0','+47.0.0.000']);

        sm.setlimits(shadowlimit=0.001, elevationlimit='8.0deg');
        sm.setauto(autocorrwt=0.0);

        sm.settimes(integrationtime='10s', usehourangle=F,
        referencetime=me.epoch('utc', 'today'));

        sm.observe('My cal', 'LBand', starttime='0s', stoptime='300s');
        sm.observe('My source', 'LBand', starttime='310s', stoptime='720s');
        sm.observe('My cal', 'CBand', starttime='720s', stoptime='1020s');
        sm.observe('My source', 'CBand', starttime='1030s', stoptime='1500s');

        sm.setdata(spwid=1, fieldid=1);
        sm.predict(imagename='M31.MOD');
        sm.setdata(spwid=2, fieldid=2);
        sm.predict(imagename='BigLBand.MOD');
        sm.close();

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_open(self, *args, **kwargs)


    def openfromms(self, *args, **kwargs):
        """
        openfromms(self, _ms) -> bool



        Summary:
            Construct a simulator tool using an already existing  MS

        Description:


        A simulator tool can either operate on an existing MeasurementSet,
        predicting and/or corrupting data on the existing uvw coordinates
        - to do that open the MS with sm.openfromms(msname)
        or it can be used to create a new MeasurementSet from descriptions of
        the array configuration and the observational parameters.
        - to create a new MS, use sm.open(msname).

        NOTE: sm.predict assumes the model image units are Jy/pixel, and in
        fact will overwrite the brightness units of the image itself!


        Input Parameters:
            ms                        MeasurementSet to be processed

        Example:

        sm.openfromms('3C273XC1.MS');
        sm.predict('3C273XC1.imagename');
        sm.setnoise(simplenoise='10mJy');
        sm.setgain(interval='100s', amplitude=0.01);
        sm.corrupt();
        sm.close();

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_openfromms(self, *args, **kwargs)


    def close(self):
        """
        close(self) -> bool



        Summary:
            Close the simulator tool

        Description:


        Close tools and write data to disk. This is a synonym for done.


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_close(self)


    def done(self):
        """
        done(self) -> bool



        Summary:
            Close the simulator tool

        Description:


        Close tools and write data to disk. This is a synonym for done.


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_done(self)


    def name(self):
        """
        name(self) -> string



        Summary:
            Provide the name of the attached MeasurementSet

        Description:


        Returns the name of the attached MeasurementSet.


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_name(self)


    def summary(self):
        """
        summary(self) -> bool



        Summary:
            Summarize the current state

        Description:


        Writes a summary of the currently set properties to the default logger.


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_summary(self)


    def type(self):
        """
        type(self) -> string



        Summary:
            Return the type of this tool

        Description:


        This function returns the string `Simulator'.  It is used so that in a
        script, you can make sure this variable is a simulator tool.


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_type(self)


    def settimes(self, *args, **kwargs):
        """
        settimes(self, _integrationtime, _usehourangle, _referencetime) -> bool



        Summary:
            Set integration time, etc.

        Description:


        This method sets values to be used in sm.observe.

        If usehourangle=False, the start and stop times in sm.observe are
        referenced to referencetime.

        If usehourangle=True, then in sm.observe, starttime/stoptime will be
        interpreted as startha/stopha.
        In that case, the start and stop times are calculated such that the
        start time is later than the reference time, but less than one day
        later.  The hour angles refer to the first source observed.


        Input Parameters:
            integrationtime           Integration time
            usehourangle              Use starttime/stoptime as hour angles - else they are referenced to referencetime
            referencetime             Reference time for starttime and stoptime. Epoch Measure . E.g me.epoch('UTC', '50000.0d') 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_settimes(self, *args, **kwargs)


    def observe(self, *args, **kwargs):
        """
        observe(self, _sourcename, _spwname, _starttime, _stoptime, _add_observation, _state_sig, _state_ref, _state_cal, _state_load, _state_sub_scan, _state_obs_mode, _observer, _project) -> bool



        Summary:
            Observe a given configuration

        Description:


        Observe a given source with a given spectral window for the specified
        times, including start, stop, integration, and gap times.

        If usehourangle=False (set with settimes), the start and stop times
        are referenced to referencetime.

        If userhourangle=True, starttime/stoptime are interpreted as
        startha/stopha, the start and stop times are calculated such that the
        start time is later than the reference time, but less than one day
        later, and the hour angles refer to the first source observed.

        setconfig, setspwindow, setfeed, and setfield must
        be run before observe can be run.

        See also sm.observemany


        Input Parameters:
            sourcename                Name of source or field (must be specified)
            spwname                   Unique user-supplied name for this spectral window
            starttime                 Start time referenced to referencetime, or start hour angle
            stoptime                  Stop time referenced to referencetime, or stop hour angle
            add_observation           Add a new line to the OBSERVATION subtable for this call
            state_sig                 a new line will be added to STATE if the following don't match
            state_ref                 
            state_cal                 
            state_load                
            state_sub_scan            
            state_obs_mode            
            observer                  
            project                   

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_observe(self, *args, **kwargs)


    def observemany(self, *args, **kwargs):
        """
        observemany(self, _sourcenames, _spwname, _starttimes, _stoptimes, _directions, _add_observation, _state_sig, _state_ref, _state_cal, _state_load, _state_sub_scan, _state_obs_mode, _observer, _project) -> bool



        Summary:
            Observe a given configuration

        Description:


        Observe given sources with a given spectral window for the specified
        times, including start, stop, integration, and gap times.

        If usehourangle=False (set with settimes), the start and stop times
        are referenced to referencetime.

        If userhourangle=True, starttime/stoptime are interpreted as
        startha/stopha, the start and stop times are calculated such that the
        start time is later than the reference time, but less than one day
        later, and the hour angles refer to the first source observed.

        See also sm.observe


        Input Parameters:
            sourcenames               Name of sources
            spwname                   Unique user-supplied name for this spectral window
            starttimes                Start times referenced to referencetime, or start hour angle
            stoptimes                 Stop time referenced to referencetime, or stop hour angle
            directions                
            add_observation           Add a new line to the OBSERVATION subtable for this call
            state_sig                 a new line will be added to STATE if the following don't match
            state_ref                 
            state_cal                 
            state_load                
            state_sub_scan            
            state_obs_mode            
            observer                  
            project                   

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_observemany(self, *args, **kwargs)


    def setlimits(self, *args, **kwargs):
        """
        setlimits(self, _shadowlimit, _elevationlimit) -> bool



        Summary:
            Set limits for observing

        Description:


        Data are flagged for two conditions:

        - Below elevation limit: If either of the antennas point below the
        specified elevation limit then the data are flagged. The elevation is
        calculated correctly for antennas at different locations (such as
        occurs in VLBI).

        - Shadowing: If one antenna shadows another such that the fractional
        (geometric) blockage is greater than the specified limit then the data
        are flagged. No correction for blockage is made for shadowed but
        non-flagged points.


        Input Parameters:
            shadowlimit               Maximum fraction of geometrically shadowed area before flagging occurs
            elevationlimit            Minimum elevation angle before flagging occurs

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setlimits(self, *args, **kwargs)


    def setauto(self, *args, **kwargs):
        """
        setauto(self, _autocorrwt) -> bool



        Summary:
            Set autocorrelation weight

        Description:




        Input Parameters:
            autocorrwt                Weight to assign autocorrelations (0=none)

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setauto(self, *args, **kwargs)


    def setconfig(self, *args, **kwargs):
        """
        setconfig(self, _telescopename, _x, _y, _z, _dishdiameter, _offset, _mount, _antname, _padname, _coordsystem, _referencelocation) -> bool



        Summary:
            Set the antenna configuration

        Description:


        Set the positions of the antennas.
        - The name of the telescope will control which voltage pattern
        is applied to the data (see sm.setvp for details).
        - The diameter(s) will be written to the antenna subtable but
        ONLY affect the calculated visibilities in sm.predict if
        telescope=ALMA,ACA,OVRO, *and*  ftmachine=mosaic
        (see sm.setvp for details).
        - simutil::readantenna can be used to read an antenna config. file
        which includes many existing observatories.
        see help for the simobserve task, or the example below


        Input Parameters:
            telescopename             Name of the telescope we are simulating (determines VP)
            x                         Vector of x values of all antennas [m]
            y                         Vector of y values of all antennas [m]
            z                         Vector of z values of all antennas [m]
            dishdiameter              Vector of diameters of all antennas [m]
            offset                    Vector of offset of all antennas [m]
            mount                     Vector of mount types of all antennas (recognized mounts are 'ALT-AZ', 'EQUATORIAL', 'X-Y', 'ORBITING', 'BIZARRE'
            antname                   Vector of names of all antennas
            padname                   Vector of names of pads or stations
            coordsystem               Coordinate system of antenna positions [x,y,z], possibilities are 'global', 'local' , 'longlat'
            referencelocation         Reference location [required for local coords] Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', -20.2deg', 6000km') or  me.observatory('ALMA') 

        Example:

        # known antenna configurations are stored in the data repository,
        # for historical reasons under 'alma' even though this includes all
        # known observatories:
        configdir=casa.values()[0]['data']+'/alma/simmos/'

        # please look in that directory if your observatory is present.
        # if so, simutil can be used to read the file:
        from simutil import simutil
        # a simutil must be instantiated to use most methods
        u=simutil()
        x,y,z,d,padnames,telescope,posobs = u.readantenna(configdir+'vla.a.cfg')

        # note that readantenna converts the positions to earth-centered
        # global, from whatever format is in the configuration file, so
        # coordsystem='global' should be used in setconfig
        sm.setconfig(telescopename=telescope, x=x, y=y, z=z,
        dishdiameter=d.tolist(),
        mount=['alt-az'], antname=padnames,
        coordsystem='global', referencelocation=pospbs);

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setconfig(self, *args, **kwargs)


    def setfeed(self, *args, **kwargs):
        """
        setfeed(self, _mode, _x, _y, _pol) -> bool



        Summary:
            Set the feed parameters

        Description:


        Specify feed parameters. At this moment, you only have the choice
        between 'perfect R L' and 'perfect X Y' (i.e., you cannot invent
        your own corrupted feeds yet).  Doesn't need to be run if you want
        perfect R and L feeds.


        Input Parameters:
            mode                      Mode for specifying feed parameters (currently, perfect only)
            x                         Some very secretive feed array parameter x
            y                         Some more very secretive feed array parameter y 
            pol                        

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setfeed(self, *args, **kwargs)


    def setfield(self, *args, **kwargs):
        """
        setfield(self, _sourcename, _sourcedirection, _calcode, _distance) -> bool



        Summary:
            Set one or more observed fields

        Description:


        Set one or more observed fields, including name and coordinates.
        Can be invoked multiple times for a complex observation.
        Must be invoked at least once before sm.observe.

        If the distance to the object is set then the phase term includes a
        curvature for the near-field effect at the center of the image.


        Input Parameters:
            sourcename                Name of source or field (must be specified)
            sourcedirection           Direction Measure of Coordinates of source to be observed. E.g me.direction('J2000', '30.5deg','-20.2deg'). 
            calcode                   Calibration code
            distance                  Distance to the object

        Example:

        sm.setconfig(telescopename=telescope, x=x, y=y, z=z,
        dishdiameter=d.tolist(),
        mount=['alt-az'], antname=padnames,
        coordsystem='global', referencelocation=pospbs);

        sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
        freqresolution='50MHz', nchannels=1, stokes='RR
        LL');
        dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
        sm.setfield(sourcename='SIMU1', sourcedirection=dir0);
        sm.settimes(integrationtime='10s', usehourangle=True,
        referencetime=me.epoch('TAI', '2012/01/01/00:00:00'))
        sm.observe(sourcename='SIMU1', spwname='XBAND',
        starttime='0s', stoptime='3600s')

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setfield(self, *args, **kwargs)


    def setmosaicfield(self, *args, **kwargs):
        """
        setmosaicfield(self, _sourcename, _calcode, _fieldcenter, _xmosp, _ymosp, _mosspacing, _distance) -> bool



        Summary:
            Set observed mosaic fields

        Description:


        Set mosaic fields by internally invoking setfield multiple times.
        Currently only handle a rectangular mosaicing pattern.  Either
        setfield or setmosaicfield must be invoked at least once before
        observe.

        If the distance to the object is set then the phase term includes a
        curvature for the near-field effect at the center of the image.


        Input Parameters:
            sourcename                Name of source or field (must be specified).
            calcode                   Calibration code
            fieldcenter               Coordinates of mosaic field center
            xmosp                     Number of mosaic pointing in horizontal direction
            ymosp                     Number of mosaic pointing in vertical direction
            mosspacing                Spacing between mosaic pointings
            distance                  Distance to the object

        Example:

        sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam,
        mount='alt-az', antname='VLA',
        coordsystem='local', referencelocation=dm.observatory('vla'));

        sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
        freqresolution='50MHz', nchannels=1, stokes='RR
        LL');
        dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
        sm.setmosaicfield(sourcename='SIMU1', fieldcenter=dir0,
        xmosp=2, ymosp=2, mosspacing='154.5arcsec');
        sm.settimes(integrationtime='10s');
        sm.observe('SIMU1_1', 'XBAND', starttime='0s', stoptime='100s');
        sm.observe('SIMU1_2', 'XBAND', starttime='110s', stoptime='210s');
        sm.observe('SIMU1_3', 'XBAND', starttime='220s', stoptime='320s');
        sm.observe('SIMU1_4', 'XBAND', starttime='330s', stoptime='430s');

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setmosaicfield(self, *args, **kwargs)


    def setspwindow(self, *args, **kwargs):
        """
        setspwindow(self, _spwname, _freq, _deltafreq, _freqresolution, _refcode, _nchannels, _stokes) -> bool



        Summary:
            Set one or more spectral windows

        Description:


        Set one or more spectral windows for the observations, including
        starting frequency, number of channels, channel increment and
        resolution, and stokes parameters observed.  Can be invoked
        multiple times for a complex observation.  Must be invoked at
        least once before observe.


        Input Parameters:
            spwname                   Unique user-supplied name for this spectral window
            freq                      Starting frequency
            deltafreq                 Frequency increment per channel
            freqresolution            Frequency resolution per channel
            refcode                   Spectral reference code e.g. LSRK, TOPO, BARY
            nchannels                 Number of channels
            stokes                    Stokes types to simulate

        Example:

        To simulate a two spectral window (or two IF's in VLA jargon) data
        set, use setpwid as follows (here we are simulating 16 channels, 50MHz
        wide channel for each spectral window)


        sm.setspwindow(spwname='CBAND', freq='2GHz', deltafreq='50MHz',
        freqresolution='50MHz', nchannels=16, stokes='RR LL');

        sm.setspwindow(spwname='SBAND', freq='5GHz', deltafreq='50MHz',
        freqresolution='50MHz', nchannels=16, stokes='RR LL');


        Note that the spwname is used in observe to determine which spectral window
        to use.

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setspwindow(self, *args, **kwargs)


    def setdata(self, *args, **kwargs):
        """
        setdata(self, _spwid, _fieldid, _msselect) -> bool



        Summary:
            Set the data parameters selection for subsequent processing

        Description:


        This setup tool function selects which data are to be used
        subsequently. After invocation of setdata, only the selected data are
        operated on.


        Input Parameters:
            spwid                     Spectral Window Ids (0 relative) to select
            fieldid                   Field Ids (0 relative) to select
            msselect                  TAQL select string applied as a logical 'and' with the other selections

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setdata(self, *args, **kwargs)


    def predict(self, *args, **kwargs):
        """
        predict(self, _imagename, _complist, _incremental) -> bool



        Summary:
            Predict astronomical data from an image or components

        Description:


        Predict astronomical data from an image.  The (u,v) coordinates
        already exist, either from a MeasurementSet we have read in or by
        generating the MeasurementSet coordinates and empty data through
        smobserve.  This method calculates visibilities for those
        coordinates.

        - predict(incremental=False) calculates new visibilities and
        replaces the DATA column,
        - predict(incremental=True) calculates new visibilities, adds
        them to the DATA column
        - predict for any value of incremental then sets CORRECTED_DATA
        equal to DATA, and MODEL_DATA to 1
        - predict assumes model image units are Jy/pixel, and in fact
        will overwrite the brightness units of the image itself!
        - treatment of primary beam depends critically on parameters set in
        sm.setvp() and sm.setoptions(ftmachine) - see help sm.setvp for
        details. For componentlists, if sm.setvp() is run prior to predict, then the spectral variation of each component in the componentlist will include the multiplicative term of the beam value for each channel frequency. So a flat spectrum component will show the frequency variation of the beam in the predicted visibilities.



        Input Parameters:
            imagename                 Name of image from which to predict visibilities
            complist                  Name of component list
            incremental               Add this model to the existing Data Visibilities?

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_predict(self, *args, **kwargs)


    def setoptions(self, *args, **kwargs):
        """
        setoptions(self, _ftmachine, _cache, _tile, _gridfunction, _location, _padding, _facets, _maxdata, _wprojplanes) -> bool



        Summary:
            Set various processing options

        Description:


        Set options for predict.  See also imager help.

        To simulate single dish data, use gridft=SD and gridfunction=PB.

        To invoke primary beam convolution in the uv domain, use
        ftmachine='mosaic'.  This is the only option that allows
        heterogeneous array simulation - see the example below and
        help sm.setvp for more details.


        Input Parameters:
            ftmachine                 Fourier transform machine. Possibilities are 'ft', 'sd', 'mosaic'
            cache                     Size of gridding cache in complex pixels
            tile                      Size of a gridding tile in pixels (in 1 dimension)
            gridfunction              Gridding function. String: 'SF'|'BOX'|'PB'
            location                  Location used in phase rotations. Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', '-20.2deg', '6000km') or  me.observatory('ALMA') 
            padding                   Padding factor in image plane (>=1.0)
            facets                    Number of facets
            maxdata                   Maximum data to write to a single TSM file (MB)
            wprojplanes               Number of projection planes when using wproject as the ft-machine

        Example:

        # set some options
        sm.setoptions(cache=10000000, tile=32, gridfunction='BOX', me.location('vla'))


        # set ftmachine to invoke uv-domain primary beam convolution, and use that
        # to simulate a heterogeneous ALMA 7m+12m array.
        from simutil import simutil
        u=simutil()
        configdir=casa.values()[0]['data']+'/alma/simmos/'
        x,y,z,d,padnames,telescope,posobs = u.readantenna(configdir+'alma.cycle5.1.cfg')
        x2,y2,z2,d2,padnames2,telescope2,posobs2 = u.readantenna(configdir+'aca.cycle5.cfg')

        sm.open('new.het.alma.ms')
        sm.setconfig(telescopename='ALMA',
        x=np.append(x,x2),y=np.append(y,y2),z=np.append(z,z2),
        dishdiameter=np.append(d,d2),
        mount=['alt-az'], padname=np.append(padnames,padnames2).tolist(),
        coordsystem='global', referencelocation=posobs)
        sm.setspwindow(spwname='band1', freq='330GHz',
        deltafreq='1GHz',freqresolution='1GHz',nchannels=1,stokes='XX YY')
        sm.setfeed(mode='perfect X Y',pol=[''])
        sm.setlimits(shadowlimit=0.01, elevationlimit='10deg')
        sm.setauto(0.0)
        sm.setfield(sourcename='src1',
        sourcedirection='ICRS 10:00:00.00 -23.01.22',
        calcode='OBJ', distance='0m')
        sm.setfield(sourcename='src2',
        sourcedirection='ICRS 10:00:00.00 -23.01.32',
        calcode='OBJ', distance='0m')
        sm.settimes(integrationtime='10s', usehourangle=True,
        referencetime=me.epoch('TAI', '2012/01/01/00:00:00'))
        etime='600s'
        sm.observe(sourcename='src1', spwname='band1',
        starttime=qa.mul(-1,qa.quantity(etime)),
        stoptime=qa.quantity(0,'s'));
        sm.observe(sourcename='src2', spwname='band1',
        starttime=qa.quantity(0,'s'),
        stoptime=qa.quantity(etime));
        sm.setoptions(ftmachine='mosaic')
        sm.predict(imagename='point.ra10.image')
        sm.done()

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setoptions(self, *args, **kwargs)


    def setvp(self, *args, **kwargs):
        """
        setvp(self, _dovp, _usedefaultvp, _vptable, _dosquint, _parangleinc, _skyposthreshold, _pblimit) -> bool



        Summary:
            Set the voltage pattern model for subsequent processing

        Description:


        Set the voltage pattern model (and hence, the primary beam) used
        for a Telecope.  There are currently two ways to set the voltage
        pattern: by using the extensive list of defaults which the system
        knows about, or by creating a voltage pattern description with
        the vpmanager.  If you are
        simulating a telescope which doesn't yet exist, you will need to
        supply a model voltage pattern using
        the vpmanager.

        sm.predict behavior depends critically on the parameters here, and
        the ftmachine parameter set in sm.setoptions

        sm.predict will always query the vpmanager for a primary beam/VP pattern.
        if usedefaultvp==True, it will reset the vpmanager first, so that
        the PB obtained will be the default for the given telescope name
        if usedefaultvp==False, it will check whether vptable is set, and if so,
        load that table into the vpmanager and use the beams therein.
        if usedefaultvp==False and vptable is not set, it will use whatever is
        already set in the vpmanager (see example below for overriding a
        default telescope beam).

        What sm.predict does with the obtained PB depends on the ftmachine and
        dovp parameters:

        if ftmachine=='mosaic':
        - a message 'Performing Mosaic Gridding' indicates that one is using
        uv domain convolution for simulating from images.
        - if the primary beam returned by the vpmanager is ALMA, ACA, or OVRO,
        heterogeneous gridding will be invoked, and the dish diameter set
        in sm.setconfig, or already in the antenna subtable, will be used
        to convolve sky model images.
        for ALMA or ACA, dish diameter =12m will use a 10.7m Airy pattern,
        and dish diameter =7m will use a 6.25m Airy pattern.
        see help sm.setoptions for an example.
        - otherwise the PB returned by the vpmanager will be used.
        - heterogeneous simulation only works at present from a sky model
        image, NOT from sky model components. If you want to simulate a
        heterogeneous array, please add components to an image using
        ia.modify, and don't specify a component list in sm.predict.
        Homogeneous array simulation from component lists works fine.
        - IF dovp=True, the primary beam returned by the vpmanager will
        be used to convolve sky model components.  This is not automatically
        invoked by ftmachine='mosaic', but needs to be set explicitly with
        sm.setvp() if you are simulating from components in addition to or
        instead of sky model images.

        if ftmachine=='ft' (the default):
        - a message 'Synthesis Gridding' indicates that if requested with
        dovp==True, image domain PB convolution will be used.
        - if dovp==True, the primary beam returned by the vpmanager will be
        used to convolve sky model components and images.



        Input Parameters:
            dovp                      Multiply by the voltage pattern (ie, primary beam) when simulating
            usedefaultvp              Look up the default VP for this telescope and frequency?
            vptable                   If usedefaultvp is false, provide a VP Table made with vpmanager
            dosquint                  Activate the beam squint in the VP model
            parangleinc               Parallactice angle increment for squint application
            skyposthreshold           Position threshold on the sky for feed arrays ?? 
            pblimit                   Primary beam limit to use in feed arrays ? 

        Example:

        # use the default primary beam in subsequent sm.predict (according to
        # whatever telescope name was set in sm.setconfig)
        sm.setvp(dovp=True, usedefaultvp=True)
        sm.predict(imagename='point.ra10.image',complist='point.cl')

        # use an alternate VP table e.g. of the format created by vpmanager:
        sm.setvp(dovp=True, usedefaultvp=False, vptable='MyAlternateVLAPBModel.TAB', dosquint=F);
        sm.predict(imagename='point.ra10.image',complist='point.cl')

        # set a VP and then use it overridding the default
        # (if telescope='NGVLA' was used previously in setconfig,
        # or if an MS was loaded with observatory name = 'NGVLA')
        vp.setpbairy(telescope='NGVLA',dishdiam='10m',maxrad='5deg')
        sm.setvp(dovp=True,usedefaultvp=False)
        sm.predict(imagename='point.ra10.image',complist='point.cl')

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setvp(self, *args, **kwargs)


    def corrupt(self):
        """
        corrupt(self) -> bool



        Summary:
            Corrupt the data with visibility errors

        Description:


        Add errors specified by the set* functions (such as noise, gains,
        polarization leakage, bandpass, etc) to the visibility data.  The
        errors are applied to the DATA and CORRECTED_DATA columns.

        Note that corrupt handles only
        visibility-plane effects, not image-plane effects such as pointing
        errors and voltage patterns, which get applied in predict.  Note, the
        function applies errors to both cross- and auto-correlation data; The
        auto-correlation data are corrupted properly only for the thermalnoise
        set by setnoise.


        Example:

        sm,openfromms('3C273XC1.MS');
        sm.predict('3C273XC1.FAKE.IMAGE');
        sm.setnoise( mode='simplenoise', simplenoise='0.1Jy');
        sm.setpa( mode='calculate');
        sm.corrupt();

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_corrupt(self)


    def reset(self):
        """
        reset(self) -> bool



        Summary:
            Reset the corruption terms

        Description:


        Reset the visibility corruption terms: this means that corrupt
        introduces no errors.


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_reset(self)


    def setbandpass(self, *args, **kwargs):
        """
        setbandpass(self, _mode, _table, _interval, _amplitude) -> bool



        Summary:
            Set the bandpasses

        Description:


        Set the level of bandpass errors. The error distributions are normal, mean
        zero, with the variances as specified. (Not yet implemented).


        Input Parameters:
            mode                      Mode of operation. String: 'calculate'|'table'
            table                     Name of table
            interval                  Coherence interval e.g. '1h'
            amplitude                 Variances errors in amplitude and phase

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setbandpass(self, *args, **kwargs)


    def setapply(self, *args, **kwargs):
        """
        setapply(self, _table, _type, _t, _field, _interp, _calwt, _spwmap, _opacity) -> bool



        Summary:
            Arrange for corruption by existing cal tables

        Description:


        Arrange for corruption by existing cal tables, in a manner
        exactly analogous to calibrater.setapply.


        Input Parameters:
            table                     Calibration table name
            type                      Component type
            t                         Interpolation interval (seconds)
            field                     Select on field
            interp                    Interpolation type (in time)
            calwt                     Calibrate weights?
            spwmap                    Spectral windows to apply
            opacity                   Array-wide zenith opacity (for type='TOPAC')

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setapply(self, *args, **kwargs)


    def setgain(self, *args, **kwargs):
        """
        setgain(self, _mode, _table, _interval, _amplitude) -> bool



        Summary:
            Set the gains

        Description:


        Set the level of gain errors.  Gain drift is implemented as
        fractional brownian motion with rms amplitude as specified.
        Interval is not currently used.



        Input Parameters:
            mode                      Mode of operation. String: 'fbm'
            table                     Optional name of table to write
            interval                  timescale for gain variations NOT USED
            amplitude                 amplitude scale (RMS) for gain variations [real,imag] or scalar

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setgain(self, *args, **kwargs)


    def settrop(self, *args, **kwargs):
        """
        settrop(self, _mode, _table, _pwv, _deltapwv, _beta, _windspeed, _simint) -> bool



        Summary:
            Set tropospheric gain corruptions

        Description:


        Set up for corruption by the atmosphere - attenuation and increase in
        noise.


        Input Parameters:
            mode                      Mode of operation - screen or individual antennas
            table                     Name of optional cal table to write
            pwv                       total precipitable water vapour in mm
            deltapwv                  RMS PWV fluctuations *as a fraction of PWV parameter*
            beta                      exponent of fractional brownian motion
            windspeed                 wind speed for screen type corruption (m/s)
            simint                    simulation time step interval (s)

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_settrop(self, *args, **kwargs)


    def setpointingerror(self, *args, **kwargs):
        """
        setpointingerror(self, _epjtablename, _applypointingoffsets, _dopbcorrection) -> bool



        Summary:
            Set the Pointing error

        Description:


        Set the pointing error from a calpointing table


        Input Parameters:
            epjtablename              Name of a table that has E-Jones errors for Pointing 
            applypointingoffsets      Apply pointing offsets
            dopbcorrection            apply primary beam correction

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setpointingerror(self, *args, **kwargs)


    def setleakage(self, *args, **kwargs):
        """
        setleakage(self, _mode, _table, _amplitude, _offset) -> bool



        Summary:
            Set the polarization leakage

        Description:


        Set the level of polarization leakage between feeds.
        Currently, no time dependence is available.


        Input Parameters:
            mode                      Mode of operation. String: 'constant'
            table                     Optional name of table to write
            amplitude                 Magnitude of pol leakage [real,imag]
            offset                    Meam of pol leakage [real,imag]

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setleakage(self, *args, **kwargs)


    def oldsetnoise(self, *args, **kwargs):
        """
        oldsetnoise(self, _mode, _table, _simplenoise, _antefficiency, _correfficiency, _spillefficiency, _tau, _trx, _tatmos, _tcmb) -> bool



        Summary:
            Set the noise level fixed sigma (mode=simplenoise) or Brown's equation (mode=calculate) OBSOLETE VERSION

        Description:


        Set various system parameters from which the thermal (ie, random
        additive) noise level will be calculated.

        For mode=simplenoise, one specifies the standard deviation for the
        noise to be added to real and imaginary parts of the visibility.

        For mode=calculate, the noise will vary with dish diameter,
        antenna efficiency, system temperature, opacity, sky temperature,
        etc.  The noise will increase with the airmass if tau is greater
        than zero.  The noise is calculated according to the Brown
        Equation (ie, R.L. Brown's calculation of MMA sensitivity,
        3Oct95):

        ``dS = 4*sqrt(2) *( T_rx*exp(-tau_atm) +
        T_atm*( exp(tau_atm) - epsilon_l + T_cmb) )
        *epsilon_q *epsilon_a *pi *D^2 *sqrt(dnu*dt)``


        Input Parameters:
            mode                      Mode of operation. String: 'simplenoise'|'calculate' 
            table                     Name of noise table - not currently implemented
            simplenoise               Level of noise (if mode=simplenoise)
            antefficiency             antenna efficiency
            correfficiency            Correlation efficiency
            spillefficiency           Forward spillover efficiency
            tau                       Atmospheric Opacity
            trx                       Receiver temp (ie, all non-atmospheric Tsys contributions) [K]
            tatmos                    (Physical, not Brightness) Temperature of atmosphere [K]
            tcmb                      Temperature of cosmic microwave background [K]

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_oldsetnoise(self, *args, **kwargs)


    def setnoise(self, *args, **kwargs):
        """
        setnoise(self, _mode, _table, _simplenoise, _pground, _relhum, _altitude, _waterheight, _pwv, _tatmos, _tau, _antefficiency, _spillefficiency, _correfficiency, _trx, _tground, _tcmb, _OTF, _senscoeff, _rxtype) -> bool



        Summary:
            Set the noise level fixed sigma (mode=simplenoise) or Brown's equation using the ATM model for frequency-dependent atmospheric opacity (mode=tsys-atm) or Brown's equation, manually specifying the zenith opacity (constant across the band) and atmospheric temperature (mode=tsys-manual)

        Description:


        Set various system parameters from which the thermal (ie, random
        additive) noise level will be calculated.

        For mode=simplenoise, one specifies the standard deviation 'sigma'
        for the noise to be added to real and imaginary parts of the visibility.
        The noise in amplitude per visibility is approximately 'sigma' although
        it is not Gaussian (see Thompson, Moran, and Swenson fig. 6.9)
        and the point source noise in a Stokes I image will approximately be
        sigma/sqrt(n_pol * n_baselines * n_integrations * n_chan),
        where n_pol are the number of polarizations in the MS (typically 2),
        and n_integrations are the number of correlator integration times
        in the MS (~ track time / int. time)

        For mode=tsys-atm or tsys-manual, the noise will vary with dish
        diameter, antenna efficiency, system temperature, opacity, sky
        temperature, etc.  The noise will increase with the airmass if tau
        is greater than zero.  The noise is calculated according to the
        Brown Equation (ie, R.L. Brown's calculation of MMA sensitivity,
        3Oct95):

        ``dS = 4*sqrt(2) *( T_rx*exp(-tau_atm) +
        T_atm*( exp(tau_atm) - epsilon_l + T_cmb) )
        *epsilon_q *epsilon_a *pi *D^2 *sqrt(dnu*dt)``

        For mode=tsys-atm, the sky brightness temperature is calculated
        using an atmospheric model created for the user-input PWV.  For
        mode=tsys-manual, the user specifies the sky brightness temperature
        manually.


        Input Parameters:
            mode                      Mode of operation.
            table                     Name of optional cal table to write (if OTF=False)
            simplenoise               Level of noise if not calculated by amt
            pground                   Ground pressure for ATM model (if tsys-atm)
            relhum                    ground relative humidity for ATM model (if tsys-atm)
            altitude                  site altitude for ATM model (if tsys-atm)
            waterheight               Height of water layer for ATM model (if tsys-atm)
            pwv                       Precipitable Water Vapor ATM model (if tsys-atm)
            tatmos                    Temperature of atmosphere [K] (if tsys-manual)
            tau                       Zenith Atmospheric Opacity (if tsys-manual)
            antefficiency             Antenna efficiency
            spillefficiency           Forward spillover efficiency
            correfficiency            Correlation efficiency
            trx                       Receiver temp (ie, all non-atmospheric Tsys contributions) [K]
            tground                   Temperature of ground/spill [K]
            tcmb                      Temperature of cosmic microwave background [K]
            OTF                       calculate noise on-the-fly (WARNING: only experts with high-RAM machines should use False)
            senscoeff                 sensitivity constant (1./sqrt(2) for interferometer [default]; 1. for total power)
            rxtype                    Receiver type; 0=2SB, 1=DSB e.g. ALMA B9

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setnoise(self, *args, **kwargs)


    def setpa(self, *args, **kwargs):
        """
        setpa(self, _mode, _table, _interval) -> bool



        Summary:
            Corrupt phase by the parallactic angle

        Description:


        Corrupt phase by the parallactic angle


        Input Parameters:
            mode                      Mode of operation. String: 'calculate'|'table'
            table                     Name of table
            interval                  Interval for parallactic angle application, e.g. '10s'

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setpa(self, *args, **kwargs)


    def setseed(self, *args, **kwargs):
        """
        setseed(self, _seed) -> bool



        Summary:
            Set the seed for the random number generator

        Description:





        Input Parameters:
            seed                      Seed

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setseed(self, *args, **kwargs)

    __swig_destroy__ = _simulator.delete_simulator
    __del__ = lambda self: None
simulator_swigregister = _simulator.simulator_swigregister
simulator_swigregister(simulator)

# This file is compatible with both classic and new-style classes.


