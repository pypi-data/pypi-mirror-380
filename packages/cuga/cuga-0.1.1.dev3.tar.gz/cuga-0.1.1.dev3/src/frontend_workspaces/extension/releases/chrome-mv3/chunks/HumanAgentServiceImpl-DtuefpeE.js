const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["chunks/ZendeskServiceDesk-C7eV6cpN.js","chunks/AppContainer-DlJO1h2A.js","chunks/sidepanel-CYx2dhah.js","assets/sidepanel-DzK75Nfj.css","chunks/ServiceDeskImpl-B4MsmRMX.js","chunks/SFServiceDesk-CeHRqQ-2.js","chunks/NiceDFOServiceDesk-IYalKUiY.js","chunks/GenesysMessengerServiceDesk-B3NAWu_r.js"])))=>i.map(i=>d[i]);
import{_ as D,$ as M,A as m,S as v,q as C,F as T}from"./sidepanel-CYx2dhah.js";import{c as _,d as N,B as w,e as x,u as R,s as k,f as d,r as F,h as O,i as P,j as H,k as W,m as j,n as U,o as Y,p as y,M as f,q as S,t as I,v as E,w as L,x as G,y as B,z as Z,C as Q,D as X,E as q,F as ee,G as te,H as se,I as ae,J as ie,K as re,L as ne,N as ce,V as oe}from"./AppContainer-DlJO1h2A.js";const J="::",K=["region","version","auth_code","session_id","integration_id","service_instance_id","subscription_id"],z={serialize:o=>K.map(t=>o[t]).join(J),deserialize:o=>{const e=o.split(J),t={};return K.forEach((s,a)=>{t[s]=e[a]}),t}},he=3e3,de=2e4,ge=5e3,le=5e3,ue=1500,{FROM_USER:Se,RECONNECTED:pe,DISCONNECTED:ve,AGENT_ENDED_CHAT:fe,AGENT_JOINED:Ee,USER_ENDED_CHAT:Me,CHAT_WAS_ENDED:ye,TRANSFER_TO_AGENT:Ae,AGENT_LEFT_CHAT:Ce,RELOAD_WARNING:De,SHARING_CANCELLED:V,SHARING_DECLINED:we,SHARING_ACCEPTED:ke,SHARING_REQUESTED:me,SHARING_ENDED:b}=m;class Te{constructor(e){this.chatStarted=!1,this.showingDisconnectedError=!1,this.isAgentTyping=!1,this.uploadingFiles=new Set,this.showLeaveWarning=!0,this.serviceManager=e}getCustomServiceDeskName(){var e,t;return this.serviceManager.store.getState().config.public.serviceDeskFactory?(t=(e=this.serviceDesk).getName)==null?void 0:t.call(e):void 0}async initialize(){var n;if(this.serviceDesk)throw new Error("A service desk has already been created!");const{store:e,instance:t}=this.serviceManager,s=e.getState(),{config:a,persistedToBrowserStorage:i}=s,r=_(i.chatState.agentState.serviceDeskState);if(this.serviceDeskCallback=new _e(this.serviceManager,this),a.public.serviceDeskFactory){const c={callback:this.serviceDeskCallback,instance:t,persistedState:r};this.serviceDesk=await a.public.serviceDeskFactory(c),Ne(this.serviceDesk),N("Initializing a custom service desk")}else{const{initConfig:c,mainConfig:g}=a.remote,{serviceDesk:l}=a.public,A=l.integrationType||c.service_desk.integration_type;switch(A){case w.ZENDESK:{const h=g.service_desk,{ZendeskServiceDesk:u}=await D(async()=>{const{ZendeskServiceDesk:p}=await import("./ZendeskServiceDesk-C7eV6cpN.js");return{ZendeskServiceDesk:p}},__vite__mapDeps([0,1,2,3,4]));this.serviceDesk=new u(this.serviceDeskCallback,h,this.serviceManager);break}case w.SALES_FORCE:{const h=x(a.public),u=g.service_desk,{SFServiceDesk:p}=await D(async()=>{const{SFServiceDesk:$}=await import("./SFServiceDesk-CeHRqQ-2.js");return{SFServiceDesk:$}},__vite__mapDeps([5,1,2,3,4]));this.serviceDesk=new p(this.serviceDeskCallback,u,h,this.serviceManager);break}case w.NICE_DFO:{const{NiceDFOServiceDesk:h}=await D(async()=>{const{NiceDFOServiceDesk:u}=await import("./NiceDFOServiceDesk-IYalKUiY.js");return{NiceDFOServiceDesk:u}},__vite__mapDeps([6,1,2,3,4]));this.serviceDesk=new h(this.serviceDeskCallback,l.niceDFO,this.serviceManager);break}case w.GENESYS_MESSENGER:{const h=l.genesysMessenger,{GenesysMessengerServiceDesk:u}=await D(async()=>{const{GenesysMessengerServiceDesk:p}=await import("./GenesysMessengerServiceDesk-B3NAWu_r.js");return{GenesysMessengerServiceDesk:p}},__vite__mapDeps([7,1,2,3,4]));this.serviceDesk=new u(this.serviceDeskCallback,h,this.serviceManager);break}default:throw new Error(`Invalid service desk type: "${A}"`)}N(`Initializing built-in service desk ${A}`)}this.showLeaveWarning=!((n=this.serviceDesk)!=null&&n.reconnect)}updateState(e){var t;(t=this.serviceDesk)!=null&&t.updateState&&this.serviceDesk.updateState(e)}async startChat(e,t){var a;if(!this.serviceDesk)throw new Error("A service desk has not been configured.");if(this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState.isSuspended&&await this.endChat(!0,!0,!1),this.chatStarted)throw new Error("A chat is already running. A call to endChat must be made before a new chat can start.");const{serviceManager:s}=this;s.actions.track({eventName:"User Clicked to Start Human Chat",eventDescription:"User clicked button to start a human chat."});try{this.chatStarted=!0,this.isAgentTyping=!1,this.uploadingFiles.clear(),this.serviceManager.store.dispatch(R(this.uploadingFiles.size>0));const i=Re(e),r={type:"agent:pre:startChat",message:t,sessionHistoryKey:i};if(await s.fire(r),r.cancelStartChat){this.chatStarted=!1,await this.fireEndChat(!1,!0),s.store.dispatch(k(!1,null)),s.actions.track({eventName:"Human Chat Canceled By agent:pre:startChat ",eventDescription:"Human chat was canceled by agent:pre:startChat "});return}const n=(a=s.store.getState().config.public.serviceDesk)==null?void 0:a.agentJoinTimeoutSeconds;n&&(this.waitingForAgentJoinedTimer=setTimeout(()=>this.handleAgentJoinedTimeout(),n*1e3)),s.store.dispatch(k(!0,e.ui_state.id)),await this.serviceDesk.startChat(t,{agentAppInfo:{sessionHistoryKey:i},preStartChatPayload:r.preStartChatPayload})}catch(i){throw d("[startChat] An error with the service desk occurred.",i),this.serviceDeskCallback&&await this.serviceDeskCallback.setErrorStatus({type:M.CONNECTING,logInfo:i}),s.store.dispatch(k(!1,null)),this.chatStarted=!1,this.cancelAgentJoinedTimer(),i}}async firePreEndChat(e){const t={type:"agent:pre:endChat",endedByAgent:e,preEndChatPayload:null,cancelEndChat:!1};return await this.serviceManager.fire(t),t}async fireEndChat(e,t){await this.serviceManager.fire({type:"agent:endChat",endedByAgent:e,requestCancelled:t})}async endChat(e,t=!0,s=!0){if(!this.chatStarted||!this.serviceDesk)return;const a={eventName:"Human chat ended",eventDescription:e?"User ended chat":"Chat was ended by instance method"};this.serviceManager.actions.track(a);const{isConnected:i}=this.persistedAgentState();let r;if(i&&(r=await this.firePreEndChat(!1),r.cancelEndChat))return;const n=e?Me:ye;await this.doEndChat(!1,r==null?void 0:r.preEndChatPayload,t,s,n)}async doEndChat(e,t,s,a,i){const{isConnected:r}=this.persistedAgentState(),n=this.isSuspended();this.cancelAgentJoinedTimer(),this.closeScreenShareRequestModal(v.CANCELLED);try{await F(this.serviceDesk.endChat({endedByAgent:e,preEndChatPayload:t}),ge)}catch(c){d("[doEndChat] An error with the service desk occurred.",c)}if(r&&s){const{agentProfile:c}=this.persistedAgentState();await O(i,c,!0,n,this.serviceManager)}this.chatStarted=!1,this.isAgentTyping=!1,this.serviceManager.store.dispatch(P()),await this.fireEndChat(e,!r),r&&a&&await H(ue,n,this.serviceManager)}async sendMessageToAgent(e,t){if(!this.serviceDesk||!this.chatStarted)return;const{serviceManager:s}=this;W(t);const a=j(e);a.input.agent_message_type=Se,await s.fire({type:"agent:pre:send",data:a,files:t});const i=U(a,a.input.text),r=i.ui_state.id,n=[];i.item.text&&n.push(E([i],a)),t.forEach(h=>{const u=Y(h),p=U(u,u.input.text,h.id);n.push(E([p],u)),this.uploadingFiles.add(h.id)}),this.serviceManager.store.dispatch(R(this.uploadingFiles.size>0)),await y(n,!0,!0,!this.isSuspended(),s);const c={eventName:"Human Message Received from User",eventDescription:"User sends message to human agent."};s.actions.track(c);let g=!1,l=!1;setTimeout(()=>{!g&&!l&&this.setMessageErrorState(i.fullMessageID,f.RETRYING)},he),setTimeout(()=>{g||this.setMessageErrorState(i.fullMessageID,f.FAILED)},de);const A={filesToUpload:t};try{await this.serviceDesk.sendMessageToAgent(a,r,A),g=!0,this.setMessageErrorState(i.fullMessageID,f.NONE),await s.fire({type:"agent:send",data:a,files:t})}catch(h){l=!0,d("[sendMessageToAgent] An error with the service desk occurred.",h),this.setMessageErrorState(i.fullMessageID,f.FAILED)}}filesSelectedForUpload(e){var t,s;if(!(!this.serviceDesk||!this.chatStarted))try{(s=(t=this.serviceDesk).filesSelectedForUpload)==null||s.call(t,e)}catch(a){d("[userReadMessages] An error with the service desk occurred.",a)}}async userReadMessages(){if(!(!this.serviceDesk||!this.chatStarted))try{await this.serviceDesk.userReadMessages()}catch(e){d("[userReadMessages] An error with the service desk occurred.",e)}}async checkAreAnyAgentsOnline(e){var a,i;let t;const s=this.serviceManager.restartCount;if(!((a=this.serviceDesk)!=null&&a.areAnyAgentsOnline))t=C.UNKNOWN;else try{const r=(i=this.serviceManager.store.getState().config.public.serviceDesk)==null?void 0:i.availabilityTimeoutSeconds,n=r?r*1e3:le,c=await F(this.serviceDesk.areAnyAgentsOnline(e),n);c===!0?t=C.ONLINE:c===!1?t=C.OFFLINE:t=C.UNKNOWN}catch(r){d("Error attempting to get agent availability",r),t=C.OFFLINE}return s===this.serviceManager.restartCount&&this.serviceManager.fire({type:"agent:areAnyAgentsOnline",areAnyAgentsOnline:t}),t}async userTyping(e){var t,s;if(!(!this.serviceDesk||!this.chatStarted))try{await((s=(t=this.serviceDesk).userTyping)==null?void 0:s.call(t,e))}catch(a){d("[userTyping] An error with the service desk occurred.",a)}}setMessageErrorState(e,t){this.serviceManager.store.dispatch(S.setMessageErrorState(e,t))}async handleAgentJoinedTimeout(){const e=this.serviceManager.store.getState().languagePack.errors_noAgentsJoined,{originalMessage:t,localMessage:s}=I(e);await y([E([s],t)],!0,!1,!this.isSuspended(),this.serviceManager),this.endChat(!1)}cancelAgentJoinedTimer(){this.waitingForAgentJoinedTimer&&(clearTimeout(this.waitingForAgentJoinedTimer),this.waitingForAgentJoinedTimer=null)}async screenShareUpdateRequestState(e){if(!this.persistedAgentState().isConnected)return;this.closeScreenShareRequestModal(e);let t;switch(e){case v.ACCEPTED:t=ke;break;case v.DECLINED:t=we;break;case v.CANCELLED:t=V;break;case v.ENDED:t=b;break;default:return}await this.addAgentLocalMessage(t)}async screenShareStop(){var e,t;this.serviceManager.store.dispatch(L(!1)),await this.addAgentLocalMessage(b),await((t=(e=this.serviceDesk)==null?void 0:e.screenShareStop)==null?void 0:t.call(e))}async handleHydration(e,t){var r;const{store:s}=this.serviceManager;let a=!1;const{isConnected:i}=this.persistedAgentState();if(i){if(this.chatStarted=!0,e&&((r=this.serviceDesk)!=null&&r.reconnect))try{s.dispatch(G(!0)),setTimeout(this.serviceManager.appWindow.requestFocus),a=await this.serviceDesk.reconnect()}catch(n){d("Error while trying to reconnect to an agent.",n)}if(s.dispatch(G(!1)),!this.persistedAgentState().isConnected){this.chatStarted=!1;return}if(setTimeout(this.serviceManager.appWindow.requestFocus),a)this.showLeaveWarning=!1;else{this.chatStarted=!1;const n=this.isSuspended();if(s.dispatch(P()),t){const{agentProfile:c}=this.persistedAgentState();await O(m.CHAT_WAS_ENDED,c,!1,n,this.serviceManager),await H(0,n,this.serviceManager)}}}}closeScreenShareRequestModal(e){this.serviceManager.store.dispatch(B(!1)),this.screenShareRequestPromise&&(this.screenShareRequestPromise.doResolve(e),this.screenShareRequestPromise=null),this.serviceManager.store.dispatch(L(e===v.ACCEPTED))}async addAgentLocalMessage(e,t,s=!0,a=!0){t||(t=this.persistedAgentState().agentProfile);const{localMessage:i,originalMessage:r}=await Z(e,this.serviceManager,t,s);await y([E([i],r)],a,!1,!this.isSuspended(),this.serviceManager)}persistedAgentState(){return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState}isSuspended(){return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState.isSuspended}}class _e{constructor(e,t){this.serviceManager=e,this.service=t}updateCapabilities(e){this.serviceManager.store.dispatch(Q(_(e)))}async updateAgentAvailability(e){this.service.chatStarted&&this.serviceManager.store.dispatch(X(e))}async agentJoined(e){if(!this.service.chatStarted)return;this.service.cancelAgentJoinedTimer(),this.serviceManager.store.dispatch(q(e)),await this.service.addAgentLocalMessage(Ee,e),this.service.showLeaveWarning&&(await this.service.addAgentLocalMessage(De,null,!1,!1),this.service.showLeaveWarning=!1);const t={eventName:"Human Chat Started",eventDescription:"Human chat started and agent joined."};this.serviceManager.actions.track(t)}async agentReadMessages(){this.service.chatStarted&&N("[ServiceDeskCallbackImpl] agentReadMessages")}async agentTyping(e){this.persistedAgentState().isConnected&&e!==this.service.isAgentTyping&&(this.serviceManager.store.dispatch(ee(e)),this.service.isAgentTyping=e)}async sendMessageToUser(e,t){var c,g;if(!this.service.chatStarted||!e)return;const s=typeof e=="string"?te(e):e;se(s),(g=(c=s.output)==null?void 0:c.generic)!=null&&g.length&&s.output.generic.forEach(l=>{l.agent_message_type||(l.agent_message_type=m.FROM_AGENT)});const{serviceManager:a}=this;let i;t===void 0?i=this.persistedAgentState().agentProfile:(i=this.persistedAgentState().agentProfiles[t],i||(i=this.persistedAgentState().agentProfile,i&&d(`Got agent ID ${t} but no agent with that ID joined the conversation. Using the current agent instead.`))),await a.fire({type:"agent:pre:receive",data:s,agentProfile:i}),s.history.agent_profile=i;const r=s.output.generic.map(l=>ae(l,s));await y([E(r,s)],!0,!0,!this.service.isSuspended(),this.serviceManager);const n={eventName:"Human Message Sent to User",eventDescription:"Human agent sends message to user."};a.actions.track(n),await a.fire({type:"agent:receive",data:s,agentProfile:i})}async beginTransferToAnotherAgent(e){this.service.chatStarted&&(e&&this.serviceManager.store.dispatch(q(e)),await this.service.addAgentLocalMessage(Ae,e))}async agentLeftChat(){this.service.chatStarted&&(await this.service.addAgentLocalMessage(Ce),this.service.isAgentTyping=!1,this.serviceManager.store.dispatch(ie()))}async agentEndedChat(){if(!this.service.chatStarted)return;const e=await this.service.firePreEndChat(!0);if(e.cancelEndChat)return;const t={eventName:"Human chat ended",eventDescription:"Agent ended chat"};this.serviceManager.actions.track(t),await this.service.doEndChat(!0,e.preEndChatPayload,!0,!0,fe)}async setErrorStatus(e){if(!this.service.chatStarted)return;const{type:t,logInfo:s}=e,{store:a}=this.serviceManager,{isConnecting:i}=a.getState().agentState;switch(s&&d(`An error occurred in the service desk (type=${t})`,s),i&&e.type===M.DISCONNECTED&&e.isDisconnected&&(e={type:M.CONNECTING}),e.type){case M.DISCONNECTED:{e.isDisconnected?(this.service.showingDisconnectedError=!0,await this.service.addAgentLocalMessage(ve,null,!0,!1),a.dispatch(S.updateInputState({isReadonly:!0},!0))):this.service.showingDisconnectedError&&(this.service.showingDisconnectedError=!1,await this.service.addAgentLocalMessage(pe,null,!0,!1),a.dispatch(S.updateInputState({isReadonly:!1},!0)));break}case M.CONNECTING:{const{languagePack:r}=this.serviceManager.store.getState(),n=e.messageToUser||r.errors_connectingToAgent,{originalMessage:c,localMessage:g}=I(n);await y([E([g],c)],!0,!1,!this.service.isSuspended(),this.serviceManager),this.serviceManager.store.dispatch(k(!1,null)),this.service.chatStarted=!1,this.service.cancelAgentJoinedTimer(),await this.service.fireEndChat(!1,i);break}case M.USER_MESSAGE:{this.service.setMessageErrorState(e.messageID,f.FAILED);break}}}async setFileUploadStatus(e,t,s){const{store:a}=this.serviceManager;if(a.getState().allMessagesByID[e]){const r={history:{file_upload_status:T.COMPLETE}};if(t){if(a.dispatch(S.setMessageHistoryProperty(e,"file_upload_status",T.COMPLETE)),a.dispatch(S.setMessageHistoryProperty(e,"error_state",f.FAILED)),r.history.error_state=f.FAILED,s){const{originalMessage:n,localMessage:c}=I(s);c.item.agent_message_type=m.INLINE_ERROR,await y([E([c],n)],!0,!0,!this.service.isSuspended(),this.serviceManager)}}else a.dispatch(S.setMessageHistoryProperty(e,"file_upload_status",T.SUCCESS)),a.dispatch(S.announceMessage({messageID:"fileSharing_ariaAnnounceSuccess"}));await this.serviceManager.actions.sendUpdateHistoryEvent(e,r)}else t&&a.dispatch(S.fileUploadInputError(e,s,!0));this.service.uploadingFiles.delete(e),this.serviceManager.store.dispatch(R(this.service.uploadingFiles.size>0))}async screenShareRequest(){return this.persistedAgentState().isConnected?(this.service.screenShareRequestPromise||(this.service.screenShareRequestPromise=re(),this.serviceManager.store.dispatch(B(!0)),await this.service.addAgentLocalMessage(me)),this.service.screenShareRequestPromise):Promise.reject(new Error("Cannot request screen sharing if no chat is in progress."))}async screenShareEnded(){const e=this.serviceManager.store.getState().agentState.isScreenSharing,t=this.service.screenShareRequestPromise;this.service.closeScreenShareRequestModal(v.CANCELLED),e?(this.serviceManager.store.dispatch(L(!1)),await this.service.addAgentLocalMessage(b)):t&&await this.service.addAgentLocalMessage(V)}persistedAgentState(){return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState}persistedState(){return this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState.serviceDeskState}updatePersistedState(e,t=!0){const{store:s}=this.serviceManager;let a;t?a=ne({},s.getState().persistedToBrowserStorage.chatState.agentState.serviceDeskState,e):a=_(e),s.dispatch(ce(W(a)))}}function be(o){return new Te(o)}function Ne(o){var e;if(!o)d("The custom service desk does not appear to be valid. No service desk was provided.",o);else if(typeof o!="object")d(`The custom service desk does not appear to be valid. The type should be "object" but is "${typeof o}"`,o);else{["startChat","endChat","sendMessageToAgent"].forEach(a=>{const i=o[a];typeof i!="function"&&d(`The custom service desk does not appear to be valid. The type of property "${a}"should be "function" but is "${typeof i}"`,i,o)});const s=(e=o.getName)==null?void 0:e.call(o);if(!s)throw Error("The custom service desk does not have a name.");if(s&&(typeof s!="string"||s.length>40))throw new Error(`The custom service desk name "${s}" is not valid.`)}}function Re(o){var t;const e=(t=o.item.transfer_info)==null?void 0:t.session_history_key;if(e){const s=z.deserialize(e);return s.version=oe,z.serialize(s)}return""}export{Te as HumanAgentServiceImpl,be as createService,Ne as validateCustomServiceDesk};
