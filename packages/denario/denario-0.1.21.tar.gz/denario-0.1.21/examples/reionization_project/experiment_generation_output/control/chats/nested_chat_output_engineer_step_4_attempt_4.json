[
  {
    "name": "engineer_response_formatter",
    "content": "**Code Explanation:**\n\nThis code implements the main function to run the complete Bayesian parameter estimation workflow. It:\n1. Extracts observational data from the reference paper\n2. Runs MCMC sampling to explore the parameter space\n3. Checks convergence using diagnostics\n4. Generates diagnostic plots and summary statistics\n5. Plots the best-fit model with credible intervals against observational data\n\n**Python Code:**\n\n```python\n# filename: codebase/run_mcmc_analysis.py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\nimport time\nfrom codebase.mcmc_sampling import (\n    run_mcmc, check_convergence, plot_chains, plot_corner, \n    compute_summary_statistics, plot_best_fit_model\n)\nfrom codebase.bayesian_framework import extract_observational_data\n\n# Create data directory if it doesn't exist\ndatabase_path = \"data/\"\nif not os.path.exists(database_path):\n    os.makedirs(database_path)\n\n# Set matplotlib parameters to avoid LaTeX rendering\nplt.rcParams['text.usetex'] = False\n\ndef run_bayesian_analysis(nwalkers=32, nsteps=1000, discard=200, z_range=(20.0, 5.0), \n                          QHII_init=1e-4, include_tau_e=True):\n    \"\"\"\n    Run the complete Bayesian parameter estimation workflow.\n    \n    Parameters:\n    -----------\n    nwalkers : int, optional\n        Number of walkers for MCMC\n    nsteps : int, optional\n        Number of steps per walker\n    discard : int, optional\n        Number of steps to discard as burn-in\n    z_range : tuple, optional\n        Redshift range for model calculation\n    QHII_init : float, optional\n        Initial ionization fraction\n    include_tau_e : bool, optional\n        Whether to include CMB optical depth constraint\n        \n    Returns:\n    --------\n    tuple\n        (flat_samples, param_names, summary_stats) containing the MCMC results\n    \"\"\"\n    print(\"Starting Bayesian analysis of cosmic reionization model\")\n    start_time = time.time()\n    \n    # Extract observational data\n    print(\"Extracting observational constraints...\")\n    obs_data = extract_observational_data()\n    \n    # Print summary of observational data\n    print(\"Observational data summary:\")\n    print(\"Number of data points:\", len(obs_data['z']))\n    print(\"Redshift range:\", min(obs_data['z']), \"to\", max(obs_data['z']))\n    print(\"Measurement methods:\", np.unique(obs_data['method']))\n    \n    if 'tau_e' in obs_data:\n        print(\"CMB optical depth constraint:\", obs_data['tau_e'], \"\u00b1\", obs_data['tau_e_error'])\n    \n    # Run MCMC sampling\n    print(\"\\nRunning MCMC sampling...\")\n    sampler, samples, flat_samples, param_names = run_mcmc(\n        obs_data, nwalkers=nwalkers, nsteps=nsteps, z_range=z_range, \n        QHII_init=QHII_init, include_tau_e=include_tau_e, progress=True, discard=discard\n    )\n    \n    # Check convergence\n    print(\"\\nChecking convergence...\")\n    convergence_results = check_convergence(sampler, discard=discard)\n    \n    if 'converged' in convergence_results and convergence_results['converged']:\n        print(\"MCMC chains have converged!\")\n    else:\n        print(\"Warning: MCMC chains may not have fully converged. Consider running for more steps.\")\n    \n    # Plot chains\n    print(\"\\nGenerating diagnostic plots...\")\n    chains_file = plot_chains(samples, param_names, discard=discard)\n    \n    # Plot corner plot\n    corner_file = plot_corner(flat_samples, param_names)\n    \n    # Compute summary statistics\n    print(\"\\nComputing summary statistics...\")\n    summary_stats = compute_summary_statistics(flat_samples, param_names)\n    \n    # Plot best-fit model\n    print(\"\\nGenerating best-fit model plot...\")\n    model_file = plot_best_fit_model(flat_samples, obs_data, param_names, z_range=z_range, QHII_init=QHII_init)\n    \n    # Calculate total runtime\n    end_time = time.time()\n    runtime = end_time - start_time\n    print(\"\\nBayesian analysis completed in\", round(runtime, 2), \"seconds\")\n    \n    # Save flat samples to file\n    samples_file = os.path.join(database_path, \"mcmc_samples.npz\")\n    np.savez(samples_file, flat_samples=flat_samples, param_names=param_names)\n    print(\"Saved MCMC samples to:\", samples_file)\n    \n    return flat_samples, param_names, summary_stats\n\n\nif __name__ == \"__main__\":\n    # Run the analysis with default parameters\n    flat_samples, param_names, summary_stats = run_bayesian_analysis(\n        nwalkers=32,\n        nsteps=1000,  # Reduced for demonstration, use 5000+ for production\n        discard=200,\n        z_range=(20.0, 5.0),\n        QHII_init=1e-4,\n        include_tau_e=True\n    )\n```",
    "timestamp": "2025-07-28 19:00:32",
    "cost": {
      "Agent": [
        "engineer_response_formatter",
        "engineer_response_formatter",
        "engineer_response_formatter",
        "engineer_response_formatter"
      ],
      "Model": [
        "o3-mini-2025-01-31",
        "o3-mini-2025-01-31",
        "o3-mini-2025-01-31",
        "o3-mini-2025-01-31"
      ],
      "Cost": [
        0.023485,
        0.0253209,
        0.025164700000000005,
        0.0097284
      ],
      "Prompt Tokens": [
        4054,
        4055,
        4053,
        1852
      ],
      "Completion Tokens": [
        4324,
        4741,
        4706,
        1748
      ],
      "Total Tokens": [
        8378,
        8796,
        8759,
        3600
      ]
    }
  },
  {
    "name": "executor",
    "content": "execution results:\nExecution output: \nTraceback (most recent call last):\n  File \u001b[35m\"/home/tda/PABLO/AstroPilot/examples/reionization_project/experiment_generation_output/control/codebase/run_mcmc_analysis.py\"\u001b[0m, line \u001b[35m6\u001b[0m, in \u001b[35m<module>\u001b[0m\n    from codebase.mcmc_sampling import (\n    ...<2 lines>...\n    )\n  File \u001b[35m\"/home/tda/PABLO/AstroPilot/examples/reionization_project/experiment_generation_output/control/codebase/mcmc_sampling.py\"\u001b[0m, line \u001b[35m5\u001b[0m, in \u001b[35m<module>\u001b[0m\n    import corner\n\u001b[1;35mModuleNotFoundError\u001b[0m: \u001b[35mNo module named 'corner'\u001b[0m\n",
    "timestamp": "2025-07-28 19:00:33",
    "cost": {
      "Agent": [],
      "Model": [],
      "Cost": [],
      "Prompt Tokens": [],
      "Completion Tokens": [],
      "Total Tokens": []
    }
  }
]