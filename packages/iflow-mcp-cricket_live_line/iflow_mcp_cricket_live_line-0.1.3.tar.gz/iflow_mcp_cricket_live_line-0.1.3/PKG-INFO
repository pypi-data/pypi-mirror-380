Metadata-Version: 2.4
Name: iflow-mcp-cricket_live_line
Version: 0.1.3
Summary: Looking to exchange your love for cricket? ğŸ¤”ğŸ‘€ Search no further, here's the best one-stop-app for all things cricket
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: mcp>=1.6.0
Requires-Dist: pyyaml>=6.0.2
Requires-Dist: jinja2>=3.0.0
Dynamic: license-file

# MCP Gateway

MCP (Model Context Protocol) Gateway can translate MCP tool callings to traditional HTTP API requests. It can provide a configurable way to get existing HTTP API to MCP territory.



## Getting Started

Create config file from `config.example.yaml`:

```shell
$ cp config.example.yaml config.yaml
```



Edit `config.yaml` file, map all APIs to MCP tools.

Then start launch it with SSE transport:

```shell
$ uv run mcp-gateway
INFO:     Started server process [15400]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:3001 (Press CTRL+C to quit)
```



Default is 3001.



## Server Control

### Change Port

Provide parameter `--port=<port_no>`  in command line will change the port to SSE transport.

Launch gateway with port 3002:

```shell
$ uv run mcp-gateway --port=3002
INFO:     Started server process [15400]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:3002 (Press CTRL+C to quit)
```



### stdio Transport

Provide parameter `--transport=stdio` in command line will change the transport to stdio.

E.G.:

```shell
$ uv run mcp-gateway --transport=stdio
```



It's meaningless to **manually** launch gateway in stdio transport. You can configure in Cursor or Cline like:

```json
{
    "mcpServers": {
        "mcp-gateway": {
          "command": "uv",
          "args": ["run", "mcp-gateway", "--transport=stdio"]
        }
      }
}
```



Or MCP Inspector with form values:

| Item           | Value                             |
| -------------- | --------------------------------- |
| Transport Type | STDIO                             |
| Command        | uv                                |
| Arguments      | run mcp-gateway --transport=stdio |



## Configuration File

There is two parts in configuration YAML, `server` and `tools`. `server` defines the basic info for gateway server use. `tools` defines the mapping from single MCP tool to HTTP API request.

```yaml
server:
  name: rest-amap-server
  config:
    apiKey: foo
tools:
- name: maps-geo
  description: "å°†è¯¦ç»†çš„ç»“æ„åŒ–åœ°å€è½¬æ¢ä¸ºç»çº¬åº¦åæ ‡ã€‚æ”¯æŒå¯¹åœ°æ ‡æ€§åèƒœæ™¯åŒºã€å»ºç­‘ç‰©åç§°è§£æä¸ºç»çº¬åº¦åæ ‡"
  args:
  - name: address
    description: "å¾…è§£æçš„ç»“æ„åŒ–åœ°å€ä¿¡æ¯"
    required: true
  - name: city
    description: "æŒ‡å®šæŸ¥è¯¢çš„åŸå¸‚"
    required: false
  requestTemplate:
    url: "https://restapi.amap.com/v3/geocode/geo?key={{.config.apiKey}}&address={{.args.address}}&city={{.args.city}}&source=ts_mcp"
    method: GET
    headers:
    - key: x-api-key
      value: "{{.config.apiKey}}"
    - key: Content-Type
      value: application/json
  responseTemplate:
    body: |
      # åœ°ç†ç¼–ç ä¿¡æ¯
      {{- range $index, $geo := .Geocodes }}
      ## åœ°ç‚¹ {{add $index 1}}

      - **å›½å®¶**: {{ $geo.Country }}
      - **çœä»½**: {{ $geo.Province }}
      - **åŸå¸‚**: {{ $geo.City }}
      - **åŸå¸‚ä»£ç **: {{ $geo.Citycode }}
      - **åŒº/å¿**: {{ $geo.District }}
      - **è¡—é“**: {{ $geo.Street }}
      - **é—¨ç‰Œå·**: {{ $geo.Number }}
      - **è¡Œæ”¿ç¼–ç **: {{ $geo.Adcode }}
      - **åæ ‡**: {{ $geo.Location }}
      - **çº§åˆ«**: {{ $geo.Level }}
      {{- end }}
```



### Server

| Item   | Description                                                  |
| ------ | ------------------------------------------------------------ |
| name   | Server name                                                  |
| config | Key/Value pairs that can be referenced by var `{{.config.xxx}}` in templates |



### Tools

`tools` is list of MCP tools mapping. Single tool props. are defined as follows:

| Item             | Description                                                  |
| ---------------- | ------------------------------------------------------------ |
| name             | Tool name (Function name), which is provided to LLM.         |
| description      | Tool description through which LLM can understand what the tool could do. |
| args             | Arguments of tool (Function arguments).                      |
| requestTemplate  | Request mapping to target HTTP API.                          |
| responseTemplate | Response mapping for response of target HTTP API.            |



Single argument props. are defined as follows:

| Item        | Type    | Description                                                  |
| ----------- | ------- | ------------------------------------------------------------ |
| name        |         | Argument name, which is provided to LLM.                     |
| description |         | Argument description through which LLM can understand and decide what value should be filled. |
| required    | Boolean | Required argument or not.                                    |



Request template props. are defined as follows:

| Item    | Description                  |
| ------- | ---------------------------- |
| method  | HTTP method                  |
| url     | Target HTTP API url template |
| headers | HTTP headers                 |



HTTP headers are defined as follows:

| Item  | Description           |
| ----- | --------------------- |
| key   | Header key            |
| value | Header value template |



Response template props are defined as follows:

| Item | Description            |
| ---- | ---------------------- |
| body | Response body template |



## Contribution

All kinds of contribution are welcomed.
