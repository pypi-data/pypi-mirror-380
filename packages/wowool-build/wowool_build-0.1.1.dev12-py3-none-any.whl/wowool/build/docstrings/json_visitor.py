"""
JSON Visitor Pattern for traversing docstring JSON structures.

This module provides a visitor pattern implementation to traverse and process
the JSON structures generated by the docstring extraction tool.
"""

from abc import ABC, abstractmethod
from typing import Any, Dict, Optional


class DocstringVisitor(ABC):
    """Abstract base class for visiting docstring JSON structures."""

    def visit(self, data: Dict[str, Any]) -> Any:
        """Main entry point for visiting a module's JSON data."""
        return self.visit_module(data)

    def visit_module(self, module_data: Dict[str, Any]) -> Any:
        """Visit a module and its contents."""
        module_name = module_data.get("module", "")
        self.on_module(module_data)

        # Visit module-level methods
        methods = module_data.get("methods", [])
        for method in methods:
            self.visit_method(method, class_name=None, module_name=module_name)

        # Visit classes
        classes = module_data.get("classes", [])
        for class_data in classes:
            self.visit_class(class_data, module_name=module_name)

        # Visit interfaces
        interfaces = module_data.get("interfaces", [])
        for interface_data in interfaces:
            self.visit_interface(interface_data, module_name=module_name)

        # Visit interfaces
        enums = module_data.get("enum", [])
        for enum_data in enums:
            self.visit_enum(enum_data, module_name=module_name)

        # Visit interfaces
        types = module_data.get("types", [])
        for type_data in types:
            self.visit_type(type_data, module_name=module_name)

        return self.on_module_complete(module_data)

    def visit_type(self, type_data: Dict[str, Any], module_name: str = "") -> Any:
        """Visit a type definition."""
        # type_name = type_data.get("name", "")
        self.on_type(type_data, module_name)

        # Visit type parameters if they exist
        alias = type_data.get("alias", [])
        if alias:
            self.on_type_alias(alias, type_data, module_name)
        return self.on_type_complete(type_data, module_name)

    # def visit_enum(self, enum_data: Dict[str, Any], module_name: str = "") -> Any:
    #     """Visit an enum and its members."""
    #     enum_name = enum_data.get("name", "")

    #     # Visit the enum itself
    #     self.on_enum(enum_data, module_name)
    #     # Visit enum members
    #     members = enum_data.get("members", [])
    #     for member in members:
    #         self.visit_enum_member(member, enum_name=enum_name, module_name=module_name)

    #     return self.on_enum_complete(enum_data, module_name)

    # def visit_enum_member(self, member_data: Dict[str, Any], enum_name: str, module_name: str = "") -> Any:
    #     """Visit an enum member."""
    #     member_name = member_data.get("name", "")
    #     # Visit the enum member
    #     self.on_enum_member(member_data, enum_name, module_name)
    #     # Visit type if exists
    #     type_info = member_data.get("type")
    #     if type_info:
    #         self.visit_type(type_info, enum_name=enum_name, module_name=module_name)

    #     return self.on_enum_member_complete(member_data, enum_name, module_name)

    def visit_class(self, class_data: Dict[str, Any], module_name: str = "") -> Any:
        """Visit a class and its members."""
        class_name = class_data.get("name", "")

        # Visit the class itself
        self.on_class(class_data, module_name)
        # Visit instance methods
        attributes = class_data.get("attributes", [])
        # attributes = sorted(attributes, key=lambda x: x.get("name", ""))
        for attr in attributes:
            self.visit_attribute(attr, method_name="", class_name=class_name, module_name=module_name)

        methods = class_data.get("methods", [])
        all_special_methods = [m for m in methods if m.get("name").startswith("__") and m.get("name").endswith("__")]
        init_methods = []
        special_methods = []
        for method in all_special_methods:
            if method.get("name") in ["__init__", "__new__"]:
                init_methods.append(method)
            else:
                special_methods.append(method)

        other_methods = [m for m in methods if not m.get("name").startswith("__")]
        other_methods = sorted(other_methods, key=lambda x: x.get("name", ""))

        # Visit static methods
        static_methods = class_data.get("static_methods", [])
        static_methods = sorted(static_methods, key=lambda x: x.get("name", ""))
        for method in static_methods:
            self.visit_static_method(method, class_name=class_name, module_name=module_name)

        if init_methods:
            # If the class has an __init__ or __new__ method, we treat it as a constructor
            for method in init_methods:
                self.visit_method(method, class_name=class_name, module_name=module_name, method_type="constructor")
            methods = [m for m in methods if m not in init_methods]

        params = class_data.get("params", [])
        for param in params:
            self.visit_param(param, method_name="", class_name=class_name, module_name=module_name)

        # Visit property methods
        properties = class_data.get("properties", [])
        properties = sorted(properties, key=lambda x: x.get("name", ""))
        for prop in properties:
            self.visit_property(prop, class_name=class_name, module_name=module_name)

        for method in other_methods:
            self.visit_method(method, class_name=class_name, module_name=module_name)

        # Visit static methods
        special_methods = sorted(special_methods, key=lambda x: x.get("name", ""))
        for method in special_methods:
            self.visit_special_method(method, class_name=class_name, module_name=module_name)

        return self.on_class_complete(class_data, module_name)

    def visit_interface(self, interface_data: Dict[str, Any], module_name: str = "") -> Any:
        """Visit an interface and its members."""
        interface_name = interface_data.get("name", "")

        # Visit the interface itself
        self.on_interface(interface_data, module_name)
        # Visit instance methods
        attributes = interface_data.get("attributes", [])
        # attributes = sorted(attributes, key=lambda x: x.get("name", ""))
        for attr in attributes:
            self.visit_attribute(attr, method_name="", class_name=interface_name, module_name=module_name)

        methods = interface_data.get("methods", [])
        all_special_methods = [m for m in methods if m.get("name").startswith("__") and m.get("name").endswith("__")]
        init_methods = []
        special_methods = []
        for method in all_special_methods:
            if method.get("name") in ["__init__", "__new__"]:
                init_methods.append(method)
            else:
                special_methods.append(method)

        other_methods = [m for m in methods if not m.get("name").startswith("__")]
        other_methods = sorted(other_methods, key=lambda x: x.get("name", ""))

        # Visit static methods
        static_methods = interface_data.get("static_methods", [])
        static_methods = sorted(static_methods, key=lambda x: x.get("name", ""))
        for method in static_methods:
            self.visit_static_method(method, class_name=interface_name, module_name=module_name)

        if init_methods:
            # If the interface has an __init__ or __new__ method, we treat it as a constructor
            for method in init_methods:
                self.visit_method(method, class_name=interface_name, module_name=module_name, method_type="constructor")
            methods = [m for m in methods if m not in init_methods]

        params = interface_data.get("params", [])
        for param in params:
            self.visit_param(param, method_name="", class_name=interface_name, module_name=module_name)

        # Visit property methods
        properties = interface_data.get("properties", [])
        properties = sorted(properties, key=lambda x: x.get("name", ""))
        for prop in properties:
            self.visit_property(prop, class_name=interface_name, module_name=module_name)

        for method in other_methods:
            self.visit_method(method, class_name=interface_name, module_name=module_name)

        # Visit static methods
        special_methods = sorted(special_methods, key=lambda x: x.get("name", ""))
        for method in special_methods:
            self.visit_special_method(method, class_name=interface_name, module_name=module_name)

        return self.on_interface_complete(interface_data, module_name)

    def visit_method(
        self, method_data: Dict[str, Any], class_name: Optional[str] = None, module_name: str = "", method_type: str = ""
    ) -> Any:
        """Visit a method (instance or module-level)."""
        return self.on_method(method_data, class_name, module_name, method_type=method_type)

    def visit_property(self, property_data: Dict[str, Any], class_name: str, module_name: str = "") -> Any:
        """Visit a property method."""
        property_name = property_data.get("name", "")

        # Visit returns
        # returns = property_data.get("returns")
        # if returns:
        #     self.visit_returns(returns, property_name, class_name, module_name)

        # # Visit raises
        # raises = property_data.get("raises", [])
        # for raise_info in raises:
        #     self.visit_raises(raise_info, property_name, class_name, module_name)

        # # Visit examples
        # examples = property_data.get("examples", [])
        # for example in examples:
        #     self.visit_example(example, property_name, class_name, module_name)

        # # Visit notes
        # notes = property_data.get("notes", [])
        # for note in notes:
        #     self.visit_note(note, property_name, class_name, module_name)

        return self.on_property(property_data, class_name, module_name)

    def visit_static_method(self, method_data: Dict[str, Any], class_name: str, module_name: str = "") -> Any:
        """Visit a static method."""
        return self.visit_method(method_data, class_name, module_name, method_type="static")

    def visit_special_method(self, method_data: Dict[str, Any], class_name: str, module_name: str = "") -> Any:
        """Visit a special method."""
        return self.visit_method(method_data, class_name, module_name, method_type="special")

    def visit_param(self, param_data: Dict[str, Any], method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Visit a parameter."""
        return self.on_param(param_data, method_name, class_name, module_name)

    def visit_attribute(self, attribute_data: Dict[str, Any], method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Visit a attribute."""
        return self.on_attribute(attribute_data, method_name, class_name, module_name)

    def visit_returns(self, returns_data: Dict[str, Any], method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Visit a returns specification."""
        return self.on_returns(returns_data, method_name, class_name, module_name)

    def visit_raises(self, raises_data: Dict[str, Any], method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Visit a raises specification."""
        return self.on_raises(raises_data, method_name, class_name, module_name)

    def visit_example(self, example: str, method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Visit an example."""
        return self.on_example(example, method_name, class_name, module_name)

    def visit_note(self, note: str, method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Visit a note."""
        return self.on_note(note, method_name, class_name, module_name)

    # Abstract methods to be implemented by concrete visitors

    @abstractmethod
    def on_module(self, module_data: Dict[str, Any]) -> Any:
        """Called when module traversal is complete."""
        pass

    @abstractmethod
    def on_module_complete(self, module_data: Dict[str, Any]) -> Any:
        """Called when module traversal is complete."""
        pass

    @abstractmethod
    def on_class(self, class_data: Dict[str, Any], module_name: str) -> Any:
        """Called when visiting a class."""
        pass

    @abstractmethod
    def on_class_complete(self, class_data: Dict[str, Any], module_name: str) -> Any:
        """Called when class traversal is complete."""
        pass

    @abstractmethod
    def on_interface(self, interface_data: Dict[str, Any], module_name: str) -> Any:
        """Called when visiting an interface."""
        pass

    @abstractmethod
    def on_interface_complete(self, interface_data: Dict[str, Any], module_name: str) -> Any:
        """Called when interface traversal is complete."""
        pass

    @abstractmethod
    def on_method(self, method_data: Dict[str, Any], class_name: Optional[str], module_name: str, method_type: str) -> Any:
        """Called when visiting a method."""
        pass

    @abstractmethod
    def on_property(self, property_data: Dict[str, Any], class_name: str, module_name: str) -> Any:
        """Called when visiting a property."""
        pass

    @abstractmethod
    def on_param(self, param_data: Dict[str, Any], method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Called when visiting a parameter."""
        pass

    @abstractmethod
    def on_attribute(self, attribute_data: Dict[str, Any], method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Called when visiting a parameter."""
        pass

    @abstractmethod
    def on_returns(self, returns_data: Dict[str, Any], method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Called when visiting a returns specification."""
        pass

    @abstractmethod
    def on_raises(self, raises_data: Dict[str, Any], method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Called when visiting a raises specification."""
        pass

    @abstractmethod
    def on_example(self, example: str, method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Called when visiting an example."""
        pass

    @abstractmethod
    def on_note(self, note: str, method_name: str, class_name: Optional[str], module_name: str) -> Any:
        """Called when visiting a note."""
        pass

    # @abstractmethod
    # def on_enum(self, enum_data: Dict[str, Any], module_name: str) -> Any:
    #     """Called when visiting an enum."""
    #     pass

    # @abstractmethod
    # def on_enum_complete(self, enum_data: Dict[str, Any], module_name: str) -> Any:
    #     """Called when enum traversal is complete."""
    #     return enum_data

    # @abstractmethod
    # def on_enum_member(self, member_data: Dict[str, Any], enum_name: str, module_name: str = "") -> Any:
    #     """Called when visiting an enum member."""
    #     pass

    # @abstractmethod
    # def on_enum_member_complete(self, member_data: Dict[str, Any], enum_name: str, module_name: str = "") -> Any:
    #     """Called when enum member traversal is complete."""
    #     return member_data

    @abstractmethod
    def on_type(self, type_data: Dict[str, Any], module_name: str) -> Any:
        """Called when visiting a type."""
        pass

    @abstractmethod
    def on_type_complete(self, type_data: Dict[str, Any], module_name: str) -> Any:
        """Called when type traversal is complete."""
        return type_data

    @abstractmethod
    def on_type_alias(self, alias: list[str], type_data: Dict[str, Any], module_name: str = "") -> Any:
        """Visit an alias value."""
        # This method can be overridden by subclasses if needed
        return alias
