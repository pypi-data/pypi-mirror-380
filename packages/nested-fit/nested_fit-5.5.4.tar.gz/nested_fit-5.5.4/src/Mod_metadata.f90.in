MODULE MOD_METADATA
    ! Module for program runtime metadata
    USE MOD_LOGGER

    IMPLICIT NONE

    PUBLIC :: INIT_NF_CACHE, nf_cache_folder, version_full, version, parallel_on,&
              static_seed, exec_target_name

    ! Version static flags
    CHARACTER(LEN=*), PARAMETER :: version_full = '@nested_fit_version_full_str@'
    CHARACTER(LEN=*), PARAMETER :: version = '@nested_fit_version_str@'

    ! System / Install specific flags
    CHARACTER(LEN=1024) :: nf_cache_folder
    LOGICAL, PARAMETER :: parallel_on = @nested_fit_parallel_on@
    LOGICAL, PARAMETER :: static_seed = @nested_fit_static_seed@

#ifdef FUNC_TARGET
    CHARACTER(LEN=*), PARAMETER :: exec_target_name = '@nested_fit_target_func@'
#else
    CHARACTER(LEN=*), PARAMETER :: exec_target_name = '@nested_fit_target@'
#endif

    INTERFACE
        SUBROUTINE MAKE_DIRECTORY(path, errcode) BIND(c, name='MakeDirectory')
            USE, INTRINSIC :: ISO_C_BINDING
            IMPLICIT NONE
            CHARACTER(c_char), INTENT(IN), DIMENSION(*) :: path
            LOGICAL(c_bool)  , INTENT(OUT)              :: errcode
        END SUBROUTINE

        FUNCTION COPY_CACHE_DATA_OBJ(cache_root) RESULT(output) BIND(c, name='CopyCacheDataObjFiles')
            USE, INTRINSIC :: ISO_C_BINDING
            IMPLICIT NONE
            CHARACTER(c_char), INTENT(IN), DIMENSION(*) :: cache_root
            LOGICAL(c_bool) :: output
        END FUNCTION

        FUNCTION COPY_CACHE_DATA_MAN(cache_root) RESULT(output) BIND(c, name='CopyCacheDataManifestFile')
            USE, INTRINSIC :: ISO_C_BINDING
            IMPLICIT NONE
            CHARACTER(c_char), INTENT(IN), DIMENSION(*) :: cache_root
            LOGICAL(c_bool) :: output
        END FUNCTION
    END INTERFACE

    PRIVATE
    CONTAINS
        SUBROUTINE MAKE_DIRECTORY_F(path)
            USE ISO_C_BINDING
            IMPLICIT NONE
            CHARACTER(LEN=*) , INTENT(IN)            :: path
            CHARACTER(c_char), DIMENSION(:), POINTER :: c_path
            LOGICAL(c_bool)                          :: make_dir_err
            
            CALL F_C_STRING_ALLOC_I(path, c_path)
            CALL MAKE_DIRECTORY(c_path(1), make_dir_err)
            CALL F_C_STRING_DEALLOC_I(c_path)

            IF(make_dir_err) THEN
                CALL LOG_ERROR_HEADER()
                CALL LOG_ERROR('Failed to create cache under user home directory.')
                CALL LOG_ERROR_HEADER()
            ENDIF
        END SUBROUTINE

        SUBROUTINE COPY_CACHE_DATA_F(cache_root, result)
            USE ISO_C_BINDING
            IMPLICIT NONE
            CHARACTER(LEN=*), INTENT(IN)  :: cache_root
            LOGICAL         , INTENT(OUT) :: result
            LOGICAL :: obj_result, man_result
            CHARACTER(c_char), DIMENSION(:), POINTER :: c_path

            CALL F_C_STRING_ALLOC_I(cache_root, c_path)
            obj_result = COPY_CACHE_DATA_OBJ(c_path(1))
            man_result = COPY_CACHE_DATA_MAN(c_path(1)) 
            CALL F_C_STRING_DEALLOC_I(c_path)

            result = obj_result.AND.man_result
        END SUBROUTINE

        SUBROUTINE F_C_STRING_ALLOC_I(f_string, c_string)
            USE ISO_C_BINDING
            CHARACTER(c_char), DIMENSION(:), POINTER, INTENT(OUT) :: c_string
            CHARACTER(LEN=*), INTENT(IN)                          :: f_string

            INTEGER :: len

            len = LEN_TRIM(f_string)
            ALLOCATE(c_string(len + 1))
            c_string = TRANSFER(TRIM(f_string), c_string)
            c_string(len + 1) = c_null_char
        END SUBROUTINE

        SUBROUTINE F_C_STRING_DEALLOC_I(c_string)
            USE ISO_C_BINDING
            CHARACTER(c_char), DIMENSION(:), POINTER, INTENT(INOUT) :: c_string

            DEALLOCATE(c_string)
        END SUBROUTINE

        SUBROUTINE GET_CACHE_DIR(created)
            IMPLICIT NONE
            CHARACTER(LEN=512)   :: home
            CHARACTER(LEN=1024)  :: cache_dir
            INTEGER              :: hlength, hstatus
            LOGICAL              :: exists
            LOGICAL, INTENT(OUT) :: created

            created = .FALSE.

            ! Get user home dir
#ifndef _WIN32
            CALL GET_ENVIRONMENT_VARIABLE('HOME', home, hlength, hstatus)
#else
            CALL GET_ENVIRONMENT_VARIABLE('USERPROFILE', home, hlength, hstatus)
#endif
            IF(hstatus.NE.0) THEN
                CALL LOG_ERROR_HEADER()
                CALL LOG_ERROR('Failed to fetch user home directory.')
                CALL LOG_ERROR_HEADER()
                CALL HALT_EXECUTION()
            ENDIF

            cache_dir = TRIM(home(1:hlength)) // '/.nested_fit/'

            INQUIRE(FILE=cache_dir, EXIST=exists)
            IF(.NOT.exists) THEN
                CALL LOG_TRACE('Cache dir does not exist. Creating...')
                CALL MAKE_DIRECTORY_F(TRIM(cache_dir) // 'user/')
                CALL MAKE_DIRECTORY_F(TRIM(cache_dir) // 'sys/')
                created = .TRUE.
            ENDIF

            nf_cache_folder = TRIM(cache_dir)
        END SUBROUTINE

        SUBROUTINE POPULATE_CACHE()
            IMPLICIT NONE
            LOGICAL :: result
            CALL LOG_TRACE('System cache is empty. Populating...')
            CALL COPY_CACHE_DATA_F(nf_cache_folder, result)
            IF(.NOT.result) THEN
                CALL LOG_ERROR_HEADER()
                CALL LOG_ERROR('Failed to copy nested_fit internal cache files.')
                CALL LOG_ERROR_HEADER()
                CALL HALT_EXECUTION()
            ENDIF
        END SUBROUTINE

        SUBROUTINE INIT_NF_CACHE()
            IMPLICIT NONE
            LOGICAL :: cache_created

            ! Create or get the cache directory
            CALL GET_CACHE_DIR(cache_created)

            ! Populate the cache if it does not exist
            IF(cache_created) THEN
                CALL POPULATE_CACHE()
            ENDIF
        END SUBROUTINE
END MODULE MOD_METADATA
