#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class Operation(object):
    MIN = 0
    MAX = 1
    FIRST = 2
    LAST = 3
    UNIQUE_COUNT = 4
    APPROX_UNIQUE_COUNT = 5
    COUNT = 6
    SUM = 7
    AVERAGE = 8
    VARIANCE = 9
    SKEW = 10
    KURTOSIS = 11
    APPROX_PERCENTILE = 12
    LAST_K = 13
    FIRST_K = 14
    TOP_K = 15
    BOTTOM_K = 16
    HISTOGRAM = 17
    APPROX_HISTOGRAM_K = 18
    BOUNDED_UNIQUE_COUNT = 19

    _VALUES_TO_NAMES = {
        0: "MIN",
        1: "MAX",
        2: "FIRST",
        3: "LAST",
        4: "UNIQUE_COUNT",
        5: "APPROX_UNIQUE_COUNT",
        6: "COUNT",
        7: "SUM",
        8: "AVERAGE",
        9: "VARIANCE",
        10: "SKEW",
        11: "KURTOSIS",
        12: "APPROX_PERCENTILE",
        13: "LAST_K",
        14: "FIRST_K",
        15: "TOP_K",
        16: "BOTTOM_K",
        17: "HISTOGRAM",
        18: "APPROX_HISTOGRAM_K",
        19: "BOUNDED_UNIQUE_COUNT",
    }

    _NAMES_TO_VALUES = {
        "MIN": 0,
        "MAX": 1,
        "FIRST": 2,
        "LAST": 3,
        "UNIQUE_COUNT": 4,
        "APPROX_UNIQUE_COUNT": 5,
        "COUNT": 6,
        "SUM": 7,
        "AVERAGE": 8,
        "VARIANCE": 9,
        "SKEW": 10,
        "KURTOSIS": 11,
        "APPROX_PERCENTILE": 12,
        "LAST_K": 13,
        "FIRST_K": 14,
        "TOP_K": 15,
        "BOTTOM_K": 16,
        "HISTOGRAM": 17,
        "APPROX_HISTOGRAM_K": 18,
        "BOUNDED_UNIQUE_COUNT": 19,
    }


class TimeUnit(object):
    HOURS = 0
    DAYS = 1

    _VALUES_TO_NAMES = {
        0: "HOURS",
        1: "DAYS",
    }

    _NAMES_TO_VALUES = {
        "HOURS": 0,
        "DAYS": 1,
    }


class Accuracy(object):
    TEMPORAL = 0
    SNAPSHOT = 1

    _VALUES_TO_NAMES = {
        0: "TEMPORAL",
        1: "SNAPSHOT",
    }

    _NAMES_TO_VALUES = {
        "TEMPORAL": 0,
        "SNAPSHOT": 1,
    }


class DataKind(object):
    BOOLEAN = 0
    BYTE = 1
    SHORT = 2
    INT = 3
    LONG = 4
    FLOAT = 5
    DOUBLE = 6
    STRING = 7
    BINARY = 8
    DATE = 9
    TIMESTAMP = 10
    MAP = 11
    LIST = 12
    STRUCT = 13

    _VALUES_TO_NAMES = {
        0: "BOOLEAN",
        1: "BYTE",
        2: "SHORT",
        3: "INT",
        4: "LONG",
        5: "FLOAT",
        6: "DOUBLE",
        7: "STRING",
        8: "BINARY",
        9: "DATE",
        10: "TIMESTAMP",
        11: "MAP",
        12: "LIST",
        13: "STRUCT",
    }

    _NAMES_TO_VALUES = {
        "BOOLEAN": 0,
        "BYTE": 1,
        "SHORT": 2,
        "INT": 3,
        "LONG": 4,
        "FLOAT": 5,
        "DOUBLE": 6,
        "STRING": 7,
        "BINARY": 8,
        "DATE": 9,
        "TIMESTAMP": 10,
        "MAP": 11,
        "LIST": 12,
        "STRUCT": 13,
    }


class Query(object):
    """
    Attributes:
     - selects
     - wheres
     - startPartition
     - endPartition
     - timeColumn
     - setups
     - mutationTimeColumn
     - reversalColumn
     - partitionColumn

    """


    def __init__(self, selects=None, wheres=None, startPartition=None, endPartition=None, timeColumn=None, setups=[
    ], mutationTimeColumn=None, reversalColumn=None, partitionColumn=None,):
        self.selects = selects
        self.wheres = wheres
        self.startPartition = startPartition
        self.endPartition = endPartition
        self.timeColumn = timeColumn
        if setups is self.thrift_spec[6][4]:
            setups = [
            ]
        self.setups = setups
        self.mutationTimeColumn = mutationTimeColumn
        self.reversalColumn = reversalColumn
        self.partitionColumn = partitionColumn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.selects = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.selects[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.wheres = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.wheres.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endPartition = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.timeColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.setups = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.setups.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.mutationTimeColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.reversalColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.partitionColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Query')
        if self.selects is not None:
            oprot.writeFieldBegin('selects', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.selects))
            for kiter19, viter20 in self.selects.items():
                oprot.writeString(kiter19.encode('utf-8') if sys.version_info[0] == 2 else kiter19)
                oprot.writeString(viter20.encode('utf-8') if sys.version_info[0] == 2 else viter20)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.wheres is not None:
            oprot.writeFieldBegin('wheres', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.wheres))
            for iter21 in self.wheres:
                oprot.writeString(iter21.encode('utf-8') if sys.version_info[0] == 2 else iter21)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 3)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.endPartition is not None:
            oprot.writeFieldBegin('endPartition', TType.STRING, 4)
            oprot.writeString(self.endPartition.encode('utf-8') if sys.version_info[0] == 2 else self.endPartition)
            oprot.writeFieldEnd()
        if self.timeColumn is not None:
            oprot.writeFieldBegin('timeColumn', TType.STRING, 5)
            oprot.writeString(self.timeColumn.encode('utf-8') if sys.version_info[0] == 2 else self.timeColumn)
            oprot.writeFieldEnd()
        if self.setups is not None:
            oprot.writeFieldBegin('setups', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.setups))
            for iter22 in self.setups:
                oprot.writeString(iter22.encode('utf-8') if sys.version_info[0] == 2 else iter22)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mutationTimeColumn is not None:
            oprot.writeFieldBegin('mutationTimeColumn', TType.STRING, 7)
            oprot.writeString(self.mutationTimeColumn.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTimeColumn)
            oprot.writeFieldEnd()
        if self.reversalColumn is not None:
            oprot.writeFieldBegin('reversalColumn', TType.STRING, 8)
            oprot.writeString(self.reversalColumn.encode('utf-8') if sys.version_info[0] == 2 else self.reversalColumn)
            oprot.writeFieldEnd()
        if self.partitionColumn is not None:
            oprot.writeFieldBegin('partitionColumn', TType.STRING, 9)
            oprot.writeString(self.partitionColumn.encode('utf-8') if sys.version_info[0] == 2 else self.partitionColumn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StagingQuery(object):
    """
    Staging Query encapsulates arbitrary spark computation. One key feature is that the computation follows a
    "fill-what's-missing" pattern. Basically instead of explicitly specifying dates you specify two macros.
    `{{ start_date }}` and `{{end_date}}`. Chronon will pass in earliest-missing-partition for `start_date` and
    execution-date / today for `end_date`. So the query will compute multiple partitions at once.

    Attributes:
     - metaData: Contains name, team, output_namespace, execution parameters etc. Things that don't change the semantics of the computation itself.

     - query: Arbitrary spark query that should be written with `{{ start_date }}`, `{{ end_date }}` and `{{ latest_date }}` templates
         - `{{ start_date }}` will be set to this user provided start date, future incremental runs will set it to the latest existing partition + 1 day.
         - `{{ end_date }}` is the end partition of the computing range.
         - `{{ latest_date }}` is the end partition independent of the computing range (meant for cumulative sources).
         - `{{ max_date(table=namespace.my_table) }}` is the max partition available for a given table.

     - startPartition: on the first run, `{{ start_date }}` will be set to this user provided start date, future incremental runs will set it to the latest existing partition + 1 day.

     - setups: Spark SQL setup statements. Used typically to register UDFs.

     - createView: If true, creates a view in the warehouse (for intermediate tables).
    If false, creates a table in the warehouse (for final tables).


    """


    def __init__(self, metaData=None, query=None, startPartition=None, setups=None, createView=None,):
        self.metaData = metaData
        self.query = query
        self.startPartition = startPartition
        self.setups = setups
        self.createView = createView

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.setups = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.setups.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.createView = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StagingQuery')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 3)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.setups is not None:
            oprot.writeFieldBegin('setups', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.setups))
            for iter29 in self.setups:
                oprot.writeString(iter29.encode('utf-8') if sys.version_info[0] == 2 else iter29)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.createView is not None:
            oprot.writeFieldBegin('createView', TType.BOOL, 5)
            oprot.writeBool(self.createView)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EventSource(object):
    """
    Attributes:
     - table: Table currently needs to be a 'ds' (date string - yyyy-MM-dd) partitioned hive table. Table names can contain subpartition specs, example db.table/system=mobile/currency=USD

     - topic: Topic is a kafka table. The table contains all the events that historically came through this topic.

     - query: The logic used to scan both the table and the topic. Contains row level transformations and filtering expressed as Spark SQL statements.

     - isCumulative: If each new hive partition contains not just the current day's events but the entire set of events since the begininng. The key property is that the events are not mutated across partitions.


    """


    def __init__(self, table=None, topic=None, query=None, isCumulative=None,):
        self.table = table
        self.topic = topic
        self.query = query
        self.isCumulative = isCumulative

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.topic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isCumulative = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EventSource')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 1)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.topic is not None:
            oprot.writeFieldBegin('topic', TType.STRING, 2)
            oprot.writeString(self.topic.encode('utf-8') if sys.version_info[0] == 2 else self.topic)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 3)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        if self.isCumulative is not None:
            oprot.writeFieldBegin('isCumulative', TType.BOOL, 4)
            oprot.writeBool(self.isCumulative)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EntitySource(object):
    """
    Entity Sources represent data that gets mutated over-time - at row-level. This is a group of three data elements.
    snapshotTable, mutationTable and mutationTopic. mutationTable and mutationTopic are only necessary if we are trying
    to create realtime or point-in-time aggregations over these sources. Entity sources usually map 1:1 with a database
    tables in your OLTP store that typically serves live application traffic. When mutation data is absent they map 1:1
    to `dim` tables in star schema.

    Attributes:
     - snapshotTable: Snapshot table currently needs to be a 'ds' (date string - yyyy-MM-dd) partitioned hive table.
     - mutationTable: Topic is a kafka table. The table contains all the events that historically came through this topic.
     - mutationTopic: The logic used to scan both the table and the topic. Contains row level transformations and filtering expressed as Spark SQL statements.
     - query: The logic used to scan both the table and the topic. Contains row level transformations and filtering expressed as Spark SQL statements.

    """


    def __init__(self, snapshotTable=None, mutationTable=None, mutationTopic=None, query=None,):
        self.snapshotTable = snapshotTable
        self.mutationTable = mutationTable
        self.mutationTopic = mutationTopic
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapshotTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mutationTable = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mutationTopic = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EntitySource')
        if self.snapshotTable is not None:
            oprot.writeFieldBegin('snapshotTable', TType.STRING, 1)
            oprot.writeString(self.snapshotTable.encode('utf-8') if sys.version_info[0] == 2 else self.snapshotTable)
            oprot.writeFieldEnd()
        if self.mutationTable is not None:
            oprot.writeFieldBegin('mutationTable', TType.STRING, 2)
            oprot.writeString(self.mutationTable.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTable)
            oprot.writeFieldEnd()
        if self.mutationTopic is not None:
            oprot.writeFieldBegin('mutationTopic', TType.STRING, 3)
            oprot.writeString(self.mutationTopic.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTopic)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 4)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExternalSourceFactoryConfig(object):
    """
    Configuration for external source factory-based handler creation.
    Used to dynamically create external source handlers at runtime using registered factories.

    Attributes:
     - factoryName
     - factoryParams

    """


    def __init__(self, factoryName=None, factoryParams=None,):
        self.factoryName = factoryName
        self.factoryParams = factoryParams

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.factoryName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.factoryParams = {}
                    (_ktype31, _vtype32, _size30) = iprot.readMapBegin()
                    for _i34 in range(_size30):
                        _key35 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val36 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.factoryParams[_key35] = _val36
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExternalSourceFactoryConfig')
        if self.factoryName is not None:
            oprot.writeFieldBegin('factoryName', TType.STRING, 1)
            oprot.writeString(self.factoryName.encode('utf-8') if sys.version_info[0] == 2 else self.factoryName)
            oprot.writeFieldEnd()
        if self.factoryParams is not None:
            oprot.writeFieldBegin('factoryParams', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.factoryParams))
            for kiter37, viter38 in self.factoryParams.items():
                oprot.writeString(kiter37.encode('utf-8') if sys.version_info[0] == 2 else kiter37)
                oprot.writeString(viter38.encode('utf-8') if sys.version_info[0] == 2 else viter38)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExternalSource(object):
    """
    Attributes:
     - metadata
     - keySchema
     - valueSchema
     - factoryConfig

    """


    def __init__(self, metadata=None, keySchema=None, valueSchema=None, factoryConfig=None,):
        self.metadata = metadata
        self.keySchema = keySchema
        self.valueSchema = valueSchema
        self.factoryConfig = factoryConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metadata = MetaData()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.keySchema = TDataType()
                    self.keySchema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.valueSchema = TDataType()
                    self.valueSchema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.factoryConfig = ExternalSourceFactoryConfig()
                    self.factoryConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExternalSource')
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 1)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.keySchema is not None:
            oprot.writeFieldBegin('keySchema', TType.STRUCT, 2)
            self.keySchema.write(oprot)
            oprot.writeFieldEnd()
        if self.valueSchema is not None:
            oprot.writeFieldBegin('valueSchema', TType.STRUCT, 3)
            self.valueSchema.write(oprot)
            oprot.writeFieldEnd()
        if self.factoryConfig is not None:
            oprot.writeFieldBegin('factoryConfig', TType.STRUCT, 4)
            self.factoryConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinSource(object):
    """
    Output of a Join can be used as input to downstream computations like GroupBy or a Join.
    Below is a short description of each of the cases we handle.
    Case #1: a join's source is another join [TODO]
      - while serving, we expect the keys for the upstream join to be passed in the request.
        we will query upstream first, and use the result to query downstream
      - while backfill, we will backfill the upstream first, and use the table as the left of the subsequent join
      - this is currently a "to do" because users can achieve this by themselves unlike case 2:
    Case #2: a join is the source of another GroupBy
      - We will support arbitrarily long transformation chains with this.
      - for batch (Accuracy.SNAPSHOT), we simply backfill the join first and compute groupBy as usual
        - will substitute the joinSource with the resulting table and continue computation
        - we will add a "resolve source" step prior to backfills that will compute the parent join and update the source
      - for realtime (Accuracy.TEMPORAL), we need to do "stream enrichment"
        - we will simply issue "fetchJoin" and create an enriched source. Note the join left should be of type "events".


    Attributes:
     - join
     - query

    """


    def __init__(self, join=None, query=None,):
        self.join = join
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.join = Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinSource')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 1)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 2)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Source(object):
    """
    Attributes:
     - events
     - entities
     - joinSource

    """


    def __init__(self, events=None, entities=None, joinSource=None,):
        self.events = events
        self.entities = entities
        self.joinSource = joinSource

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.events = EventSource()
                    self.events.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.entities = EntitySource()
                    self.entities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.joinSource = JoinSource()
                    self.joinSource.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Source')
        if self.events is not None:
            oprot.writeFieldBegin('events', TType.STRUCT, 1)
            self.events.write(oprot)
            oprot.writeFieldEnd()
        if self.entities is not None:
            oprot.writeFieldBegin('entities', TType.STRUCT, 2)
            self.entities.write(oprot)
            oprot.writeFieldEnd()
        if self.joinSource is not None:
            oprot.writeFieldBegin('joinSource', TType.STRUCT, 3)
            self.joinSource.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Window(object):
    """
    Attributes:
     - length
     - timeUnit

    """


    def __init__(self, length=None, timeUnit=None,):
        self.length = length
        self.timeUnit = timeUnit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeUnit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Window')
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 1)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        if self.timeUnit is not None:
            oprot.writeFieldBegin('timeUnit', TType.I32, 2)
            oprot.writeI32(self.timeUnit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Aggregation(object):
    """
    Chronon provides a powerful aggregations primitive - that takes the familiar aggregation operation, via groupBy in
    SQL and extends it with three things - windowing, bucketing and auto-explode.

    Attributes:
     - inputColumn: The column as specified in source.query.selects - on which we need to aggregate with.

     - operation: The type of aggregation that needs to be performed on the inputColumn.

     - argMap: Extra arguments that needs to be passed to some of the operations like LAST_K, APPROX_PERCENTILE.

     - windows: For TEMPORAL case, windows are sawtooth. Meaning head slides ahead continuously in time, whereas, the tail only hops ahead, at discrete points in time. Hop is determined by the window size automatically. The maximum hop size is 1/12 of window size. You can specify multiple such windows at once.
      - Window > 12 days  -> Hop Size = 1 day
      - Window > 12 hours -> Hop Size = 1 hr
      - Window > 1hr      -> Hop Size = 5 minutes
     - buckets: This is an additional layer of aggregation. You can key a group_by by user, and bucket a “item_view” count by “item_category”. This will produce one row per user, with column containing map of “item_category” to “view_count”. You can specify multiple such buckets at once

    """


    def __init__(self, inputColumn=None, operation=None, argMap=None, windows=None, buckets=None,):
        self.inputColumn = inputColumn
        self.operation = operation
        self.argMap = argMap
        self.windows = windows
        self.buckets = buckets

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.inputColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.argMap = {}
                    (_ktype40, _vtype41, _size39) = iprot.readMapBegin()
                    for _i43 in range(_size39):
                        _key44 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val45 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.argMap[_key44] = _val45
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.windows = []
                    (_etype49, _size46) = iprot.readListBegin()
                    for _i50 in range(_size46):
                        _elem51 = Window()
                        _elem51.read(iprot)
                        self.windows.append(_elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.buckets = []
                    (_etype55, _size52) = iprot.readListBegin()
                    for _i56 in range(_size52):
                        _elem57 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.buckets.append(_elem57)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Aggregation')
        if self.inputColumn is not None:
            oprot.writeFieldBegin('inputColumn', TType.STRING, 1)
            oprot.writeString(self.inputColumn.encode('utf-8') if sys.version_info[0] == 2 else self.inputColumn)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.I32, 2)
            oprot.writeI32(self.operation)
            oprot.writeFieldEnd()
        if self.argMap is not None:
            oprot.writeFieldBegin('argMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.argMap))
            for kiter58, viter59 in self.argMap.items():
                oprot.writeString(kiter58.encode('utf-8') if sys.version_info[0] == 2 else kiter58)
                oprot.writeString(viter59.encode('utf-8') if sys.version_info[0] == 2 else viter59)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.windows is not None:
            oprot.writeFieldBegin('windows', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.windows))
            for iter60 in self.windows:
                iter60.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.buckets is not None:
            oprot.writeFieldBegin('buckets', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.buckets))
            for iter61 in self.buckets:
                oprot.writeString(iter61.encode('utf-8') if sys.version_info[0] == 2 else iter61)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggregationPart(object):
    """
    Attributes:
     - inputColumn
     - operation
     - argMap
     - window
     - bucket

    """


    def __init__(self, inputColumn=None, operation=None, argMap=None, window=None, bucket=None,):
        self.inputColumn = inputColumn
        self.operation = operation
        self.argMap = argMap
        self.window = window
        self.bucket = bucket

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.inputColumn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.argMap = {}
                    (_ktype63, _vtype64, _size62) = iprot.readMapBegin()
                    for _i66 in range(_size62):
                        _key67 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val68 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.argMap[_key67] = _val68
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.window = Window()
                    self.window.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bucket = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggregationPart')
        if self.inputColumn is not None:
            oprot.writeFieldBegin('inputColumn', TType.STRING, 1)
            oprot.writeString(self.inputColumn.encode('utf-8') if sys.version_info[0] == 2 else self.inputColumn)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.I32, 2)
            oprot.writeI32(self.operation)
            oprot.writeFieldEnd()
        if self.argMap is not None:
            oprot.writeFieldBegin('argMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.argMap))
            for kiter69, viter70 in self.argMap.items():
                oprot.writeString(kiter69.encode('utf-8') if sys.version_info[0] == 2 else kiter69)
                oprot.writeString(viter70.encode('utf-8') if sys.version_info[0] == 2 else viter70)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.window is not None:
            oprot.writeFieldBegin('window', TType.STRUCT, 4)
            self.window.write(oprot)
            oprot.writeFieldEnd()
        if self.bucket is not None:
            oprot.writeFieldBegin('bucket', TType.STRING, 5)
            oprot.writeString(self.bucket.encode('utf-8') if sys.version_info[0] == 2 else self.bucket)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MetaData(object):
    """
    Attributes:
     - name
     - online
     - production
     - customJson
     - dependencies
     - tableProperties
     - outputNamespace
     - team
     - modeToEnvMap
     - consistencyCheck
     - samplePercent
     - offlineSchedule
     - consistencySamplePercent
     - historicalBackfill
     - deprecationDate
     - description

    """


    def __init__(self, name=None, online=None, production=None, customJson=None, dependencies=None, tableProperties=None, outputNamespace=None, team=None, modeToEnvMap=None, consistencyCheck=None, samplePercent=None, offlineSchedule=None, consistencySamplePercent=None, historicalBackfill=None, deprecationDate=None, description=None,):
        self.name = name
        self.online = online
        self.production = production
        self.customJson = customJson
        self.dependencies = dependencies
        self.tableProperties = tableProperties
        self.outputNamespace = outputNamespace
        self.team = team
        self.modeToEnvMap = modeToEnvMap
        self.consistencyCheck = consistencyCheck
        self.samplePercent = samplePercent
        self.offlineSchedule = offlineSchedule
        self.consistencySamplePercent = consistencySamplePercent
        self.historicalBackfill = historicalBackfill
        self.deprecationDate = deprecationDate
        self.description = description

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.online = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.production = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.customJson = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.dependencies = []
                    (_etype74, _size71) = iprot.readListBegin()
                    for _i75 in range(_size71):
                        _elem76 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.dependencies.append(_elem76)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.tableProperties = {}
                    (_ktype78, _vtype79, _size77) = iprot.readMapBegin()
                    for _i81 in range(_size77):
                        _key82 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val83 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tableProperties[_key82] = _val83
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.outputNamespace = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.team = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.modeToEnvMap = {}
                    (_ktype85, _vtype86, _size84) = iprot.readMapBegin()
                    for _i88 in range(_size84):
                        _key89 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val90 = {}
                        (_ktype92, _vtype93, _size91) = iprot.readMapBegin()
                        for _i95 in range(_size91):
                            _key96 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val97 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val90[_key96] = _val97
                        iprot.readMapEnd()
                        self.modeToEnvMap[_key89] = _val90
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.consistencyCheck = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.samplePercent = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.offlineSchedule = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.DOUBLE:
                    self.consistencySamplePercent = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.historicalBackfill = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.deprecationDate = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MetaData')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.online is not None:
            oprot.writeFieldBegin('online', TType.BOOL, 2)
            oprot.writeBool(self.online)
            oprot.writeFieldEnd()
        if self.production is not None:
            oprot.writeFieldBegin('production', TType.BOOL, 3)
            oprot.writeBool(self.production)
            oprot.writeFieldEnd()
        if self.customJson is not None:
            oprot.writeFieldBegin('customJson', TType.STRING, 4)
            oprot.writeString(self.customJson.encode('utf-8') if sys.version_info[0] == 2 else self.customJson)
            oprot.writeFieldEnd()
        if self.dependencies is not None:
            oprot.writeFieldBegin('dependencies', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.dependencies))
            for iter98 in self.dependencies:
                oprot.writeString(iter98.encode('utf-8') if sys.version_info[0] == 2 else iter98)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableProperties is not None:
            oprot.writeFieldBegin('tableProperties', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tableProperties))
            for kiter99, viter100 in self.tableProperties.items():
                oprot.writeString(kiter99.encode('utf-8') if sys.version_info[0] == 2 else kiter99)
                oprot.writeString(viter100.encode('utf-8') if sys.version_info[0] == 2 else viter100)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.outputNamespace is not None:
            oprot.writeFieldBegin('outputNamespace', TType.STRING, 7)
            oprot.writeString(self.outputNamespace.encode('utf-8') if sys.version_info[0] == 2 else self.outputNamespace)
            oprot.writeFieldEnd()
        if self.team is not None:
            oprot.writeFieldBegin('team', TType.STRING, 8)
            oprot.writeString(self.team.encode('utf-8') if sys.version_info[0] == 2 else self.team)
            oprot.writeFieldEnd()
        if self.modeToEnvMap is not None:
            oprot.writeFieldBegin('modeToEnvMap', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.modeToEnvMap))
            for kiter101, viter102 in self.modeToEnvMap.items():
                oprot.writeString(kiter101.encode('utf-8') if sys.version_info[0] == 2 else kiter101)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter102))
                for kiter103, viter104 in viter102.items():
                    oprot.writeString(kiter103.encode('utf-8') if sys.version_info[0] == 2 else kiter103)
                    oprot.writeString(viter104.encode('utf-8') if sys.version_info[0] == 2 else viter104)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.consistencyCheck is not None:
            oprot.writeFieldBegin('consistencyCheck', TType.BOOL, 10)
            oprot.writeBool(self.consistencyCheck)
            oprot.writeFieldEnd()
        if self.samplePercent is not None:
            oprot.writeFieldBegin('samplePercent', TType.DOUBLE, 11)
            oprot.writeDouble(self.samplePercent)
            oprot.writeFieldEnd()
        if self.offlineSchedule is not None:
            oprot.writeFieldBegin('offlineSchedule', TType.STRING, 12)
            oprot.writeString(self.offlineSchedule.encode('utf-8') if sys.version_info[0] == 2 else self.offlineSchedule)
            oprot.writeFieldEnd()
        if self.consistencySamplePercent is not None:
            oprot.writeFieldBegin('consistencySamplePercent', TType.DOUBLE, 13)
            oprot.writeDouble(self.consistencySamplePercent)
            oprot.writeFieldEnd()
        if self.historicalBackfill is not None:
            oprot.writeFieldBegin('historicalBackfill', TType.BOOL, 14)
            oprot.writeBool(self.historicalBackfill)
            oprot.writeFieldEnd()
        if self.deprecationDate is not None:
            oprot.writeFieldBegin('deprecationDate', TType.STRING, 15)
            oprot.writeString(self.deprecationDate.encode('utf-8') if sys.version_info[0] == 2 else self.deprecationDate)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 16)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupBy(object):
    """
    Attributes:
     - metaData
     - sources
     - keyColumns
     - aggregations
     - accuracy
     - backfillStartDate
     - derivations

    """


    def __init__(self, metaData=None, sources=None, keyColumns=None, aggregations=None, accuracy=None, backfillStartDate=None, derivations=None,):
        self.metaData = metaData
        self.sources = sources
        self.keyColumns = keyColumns
        self.aggregations = aggregations
        self.accuracy = accuracy
        self.backfillStartDate = backfillStartDate
        self.derivations = derivations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sources = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = Source()
                        _elem110.read(iprot)
                        self.sources.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.keyColumns = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyColumns.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aggregations = []
                    (_etype120, _size117) = iprot.readListBegin()
                    for _i121 in range(_size117):
                        _elem122 = Aggregation()
                        _elem122.read(iprot)
                        self.aggregations.append(_elem122)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.accuracy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.backfillStartDate = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.derivations = []
                    (_etype126, _size123) = iprot.readListBegin()
                    for _i127 in range(_size123):
                        _elem128 = Derivation()
                        _elem128.read(iprot)
                        self.derivations.append(_elem128)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupBy')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.sources is not None:
            oprot.writeFieldBegin('sources', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.sources))
            for iter129 in self.sources:
                iter129.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keyColumns is not None:
            oprot.writeFieldBegin('keyColumns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.keyColumns))
            for iter130 in self.keyColumns:
                oprot.writeString(iter130.encode('utf-8') if sys.version_info[0] == 2 else iter130)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregations is not None:
            oprot.writeFieldBegin('aggregations', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.aggregations))
            for iter131 in self.aggregations:
                iter131.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.accuracy is not None:
            oprot.writeFieldBegin('accuracy', TType.I32, 5)
            oprot.writeI32(self.accuracy)
            oprot.writeFieldEnd()
        if self.backfillStartDate is not None:
            oprot.writeFieldBegin('backfillStartDate', TType.STRING, 6)
            oprot.writeString(self.backfillStartDate.encode('utf-8') if sys.version_info[0] == 2 else self.backfillStartDate)
            oprot.writeFieldEnd()
        if self.derivations is not None:
            oprot.writeFieldBegin('derivations', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.derivations))
            for iter132 in self.derivations:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinPart(object):
    """
    Attributes:
     - groupBy
     - keyMapping
     - prefix

    """


    def __init__(self, groupBy=None, keyMapping=None, prefix=None,):
        self.groupBy = groupBy
        self.keyMapping = keyMapping
        self.prefix = prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.groupBy = GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.keyMapping = {}
                    (_ktype134, _vtype135, _size133) = iprot.readMapBegin()
                    for _i137 in range(_size133):
                        _key138 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val139 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyMapping[_key138] = _val139
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.prefix = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinPart')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.keyMapping is not None:
            oprot.writeFieldBegin('keyMapping', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyMapping))
            for kiter140, viter141 in self.keyMapping.items():
                oprot.writeString(kiter140.encode('utf-8') if sys.version_info[0] == 2 else kiter140)
                oprot.writeString(viter141.encode('utf-8') if sys.version_info[0] == 2 else viter141)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.prefix is not None:
            oprot.writeFieldBegin('prefix', TType.STRING, 4)
            oprot.writeString(self.prefix.encode('utf-8') if sys.version_info[0] == 2 else self.prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExternalPart(object):
    """
    Attributes:
     - source
     - keyMapping
     - prefix

    """


    def __init__(self, source=None, keyMapping=None, prefix=None,):
        self.source = source
        self.keyMapping = keyMapping
        self.prefix = prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.source = ExternalSource()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.keyMapping = {}
                    (_ktype143, _vtype144, _size142) = iprot.readMapBegin()
                    for _i146 in range(_size142):
                        _key147 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val148 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyMapping[_key147] = _val148
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prefix = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExternalPart')
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 1)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        if self.keyMapping is not None:
            oprot.writeFieldBegin('keyMapping', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyMapping))
            for kiter149, viter150 in self.keyMapping.items():
                oprot.writeString(kiter149.encode('utf-8') if sys.version_info[0] == 2 else kiter149)
                oprot.writeString(viter150.encode('utf-8') if sys.version_info[0] == 2 else viter150)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.prefix is not None:
            oprot.writeFieldBegin('prefix', TType.STRING, 3)
            oprot.writeString(self.prefix.encode('utf-8') if sys.version_info[0] == 2 else self.prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Derivation(object):
    """
    Attributes:
     - name
     - expression
     - metaData

    """


    def __init__(self, name=None, expression=None, metaData=None,):
        self.name = name
        self.expression = expression
        self.metaData = metaData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Derivation')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 2)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 3)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Join(object):
    """
    Attributes:
     - metaData
     - left
     - joinParts
     - skewKeys
     - onlineExternalParts
     - labelPart
     - bootstrapParts
     - rowIds
     - derivations: List of a struct with derived column name and the expression based on joinPart / externalPart columns
    The expression can be any valid Spark SQL select clause without aggregation functions.

    joinPart column names are automatically constructed according to the below convention
     `{join_part_prefix}_{group_by_name}_{input_column_name}_{aggregation_operation}_{window}_{by_bucket}`
     prefix, window and bucket are optional. You can find the type information of columns using the analyzer tool.

    externalPart column names are automatically constructed according to the below convention
     `ext_{external_source_name}_{value_column}`
    Types are defined along with the schema by users for external sources.

    Including a column with key "*" and value "*", means that every raw column will be included along with the derived
    columns.

     - modelTransforms: (CHIP-9) A list of model_trnsforms that will convert derivations (raw data) into model outputs for each
    of the models in the list. The union of the model outputs will become the final output of the join.


    """


    def __init__(self, metaData=None, left=None, joinParts=None, skewKeys=None, onlineExternalParts=None, labelPart=None, bootstrapParts=None, rowIds=None, derivations=None, modelTransforms=None,):
        self.metaData = metaData
        self.left = left
        self.joinParts = joinParts
        self.skewKeys = skewKeys
        self.onlineExternalParts = onlineExternalParts
        self.labelPart = labelPart
        self.bootstrapParts = bootstrapParts
        self.rowIds = rowIds
        self.derivations = derivations
        self.modelTransforms = modelTransforms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.left = Source()
                    self.left.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.joinParts = []
                    (_etype154, _size151) = iprot.readListBegin()
                    for _i155 in range(_size151):
                        _elem156 = JoinPart()
                        _elem156.read(iprot)
                        self.joinParts.append(_elem156)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.skewKeys = {}
                    (_ktype158, _vtype159, _size157) = iprot.readMapBegin()
                    for _i161 in range(_size157):
                        _key162 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val163 = []
                        (_etype167, _size164) = iprot.readListBegin()
                        for _i168 in range(_size164):
                            _elem169 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val163.append(_elem169)
                        iprot.readListEnd()
                        self.skewKeys[_key162] = _val163
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.onlineExternalParts = []
                    (_etype173, _size170) = iprot.readListBegin()
                    for _i174 in range(_size170):
                        _elem175 = ExternalPart()
                        _elem175.read(iprot)
                        self.onlineExternalParts.append(_elem175)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.labelPart = LabelPart()
                    self.labelPart.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.bootstrapParts = []
                    (_etype179, _size176) = iprot.readListBegin()
                    for _i180 in range(_size176):
                        _elem181 = BootstrapPart()
                        _elem181.read(iprot)
                        self.bootstrapParts.append(_elem181)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.rowIds = []
                    (_etype185, _size182) = iprot.readListBegin()
                    for _i186 in range(_size182):
                        _elem187 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.rowIds.append(_elem187)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.derivations = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = Derivation()
                        _elem193.read(iprot)
                        self.derivations.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.modelTransforms = ModelTransforms()
                    self.modelTransforms.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Join')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.STRUCT, 2)
            self.left.write(oprot)
            oprot.writeFieldEnd()
        if self.joinParts is not None:
            oprot.writeFieldBegin('joinParts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.joinParts))
            for iter194 in self.joinParts:
                iter194.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.skewKeys is not None:
            oprot.writeFieldBegin('skewKeys', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.skewKeys))
            for kiter195, viter196 in self.skewKeys.items():
                oprot.writeString(kiter195.encode('utf-8') if sys.version_info[0] == 2 else kiter195)
                oprot.writeListBegin(TType.STRING, len(viter196))
                for iter197 in viter196:
                    oprot.writeString(iter197.encode('utf-8') if sys.version_info[0] == 2 else iter197)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.onlineExternalParts is not None:
            oprot.writeFieldBegin('onlineExternalParts', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.onlineExternalParts))
            for iter198 in self.onlineExternalParts:
                iter198.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.labelPart is not None:
            oprot.writeFieldBegin('labelPart', TType.STRUCT, 6)
            self.labelPart.write(oprot)
            oprot.writeFieldEnd()
        if self.bootstrapParts is not None:
            oprot.writeFieldBegin('bootstrapParts', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.bootstrapParts))
            for iter199 in self.bootstrapParts:
                iter199.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rowIds is not None:
            oprot.writeFieldBegin('rowIds', TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.rowIds))
            for iter200 in self.rowIds:
                oprot.writeString(iter200.encode('utf-8') if sys.version_info[0] == 2 else iter200)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.derivations is not None:
            oprot.writeFieldBegin('derivations', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.derivations))
            for iter201 in self.derivations:
                iter201.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.modelTransforms is not None:
            oprot.writeFieldBegin('modelTransforms', TType.STRUCT, 10)
            self.modelTransforms.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BootstrapPart(object):
    """
    Attributes:
     - metaData
     - table
     - query
     - keyColumns

    """


    def __init__(self, metaData=None, table=None, query=None, keyColumns=None,):
        self.metaData = metaData
        self.table = table
        self.query = query
        self.keyColumns = keyColumns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.keyColumns = []
                    (_etype205, _size202) = iprot.readListBegin()
                    for _i206 in range(_size202):
                        _elem207 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyColumns.append(_elem207)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BootstrapPart')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 2)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 3)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        if self.keyColumns is not None:
            oprot.writeFieldBegin('keyColumns', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.keyColumns))
            for iter208 in self.keyColumns:
                oprot.writeString(iter208.encode('utf-8') if sys.version_info[0] == 2 else iter208)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LabelPart(object):
    """
    Attributes:
     - labels
     - leftStartOffset
     - leftEndOffset
     - metaData

    """


    def __init__(self, labels=None, leftStartOffset=None, leftEndOffset=None, metaData=None,):
        self.labels = labels
        self.leftStartOffset = leftStartOffset
        self.leftEndOffset = leftEndOffset
        self.metaData = metaData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.labels = []
                    (_etype212, _size209) = iprot.readListBegin()
                    for _i213 in range(_size209):
                        _elem214 = JoinPart()
                        _elem214.read(iprot)
                        self.labels.append(_elem214)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.leftStartOffset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.leftEndOffset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LabelPart')
        if self.labels is not None:
            oprot.writeFieldBegin('labels', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.labels))
            for iter215 in self.labels:
                iter215.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.leftStartOffset is not None:
            oprot.writeFieldBegin('leftStartOffset', TType.I32, 2)
            oprot.writeI32(self.leftStartOffset)
            oprot.writeFieldEnd()
        if self.leftEndOffset is not None:
            oprot.writeFieldBegin('leftEndOffset', TType.I32, 3)
            oprot.writeI32(self.leftEndOffset)
            oprot.writeFieldEnd()
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 4)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupByServingInfo(object):
    """
    Attributes:
     - groupBy
     - inputAvroSchema
     - selectedAvroSchema
     - keyAvroSchema
     - batchEndDate
     - dateFormat

    """


    def __init__(self, groupBy=None, inputAvroSchema=None, selectedAvroSchema=None, keyAvroSchema=None, batchEndDate=None, dateFormat=None,):
        self.groupBy = groupBy
        self.inputAvroSchema = inputAvroSchema
        self.selectedAvroSchema = selectedAvroSchema
        self.keyAvroSchema = keyAvroSchema
        self.batchEndDate = batchEndDate
        self.dateFormat = dateFormat

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.groupBy = GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.inputAvroSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.selectedAvroSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.keyAvroSchema = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.batchEndDate = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.dateFormat = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupByServingInfo')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.inputAvroSchema is not None:
            oprot.writeFieldBegin('inputAvroSchema', TType.STRING, 2)
            oprot.writeString(self.inputAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.inputAvroSchema)
            oprot.writeFieldEnd()
        if self.selectedAvroSchema is not None:
            oprot.writeFieldBegin('selectedAvroSchema', TType.STRING, 3)
            oprot.writeString(self.selectedAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.selectedAvroSchema)
            oprot.writeFieldEnd()
        if self.keyAvroSchema is not None:
            oprot.writeFieldBegin('keyAvroSchema', TType.STRING, 4)
            oprot.writeString(self.keyAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.keyAvroSchema)
            oprot.writeFieldEnd()
        if self.batchEndDate is not None:
            oprot.writeFieldBegin('batchEndDate', TType.STRING, 5)
            oprot.writeString(self.batchEndDate.encode('utf-8') if sys.version_info[0] == 2 else self.batchEndDate)
            oprot.writeFieldEnd()
        if self.dateFormat is not None:
            oprot.writeFieldBegin('dateFormat', TType.STRING, 6)
            oprot.writeString(self.dateFormat.encode('utf-8') if sys.version_info[0] == 2 else self.dateFormat)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DataField(object):
    """
    Attributes:
     - name
     - dataType

    """


    def __init__(self, name=None, dataType=None,):
        self.name = name
        self.dataType = dataType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataType = TDataType()
                    self.dataType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DataField')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.STRUCT, 2)
            self.dataType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataType(object):
    """
    Attributes:
     - kind
     - params
     - name

    """


    def __init__(self, kind=None, params=None, name=None,):
        self.kind = kind
        self.params = params
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.kind = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.params = []
                    (_etype219, _size216) = iprot.readListBegin()
                    for _i220 in range(_size216):
                        _elem221 = DataField()
                        _elem221.read(iprot)
                        self.params.append(_elem221)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataType')
        if self.kind is not None:
            oprot.writeFieldBegin('kind', TType.I32, 1)
            oprot.writeI32(self.kind)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.params))
            for iter222 in self.params:
                iter222.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InferenceSpec(object):
    """
    Attributes:
     - modelBackend
     - modelBackendParams

    """


    def __init__(self, modelBackend=None, modelBackendParams=None,):
        self.modelBackend = modelBackend
        self.modelBackendParams = modelBackendParams

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.modelBackend = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modelBackendParams = {}
                    (_ktype224, _vtype225, _size223) = iprot.readMapBegin()
                    for _i227 in range(_size223):
                        _key228 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val229 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.modelBackendParams[_key228] = _val229
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InferenceSpec')
        if self.modelBackend is not None:
            oprot.writeFieldBegin('modelBackend', TType.STRING, 1)
            oprot.writeString(self.modelBackend.encode('utf-8') if sys.version_info[0] == 2 else self.modelBackend)
            oprot.writeFieldEnd()
        if self.modelBackendParams is not None:
            oprot.writeFieldBegin('modelBackendParams', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.modelBackendParams))
            for kiter230, viter231 in self.modelBackendParams.items():
                oprot.writeString(kiter230.encode('utf-8') if sys.version_info[0] == 2 else kiter230)
                oprot.writeString(viter231.encode('utf-8') if sys.version_info[0] == 2 else viter231)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Model(object):
    """
    Attributes:
     - metaData
     - inferenceSpec
     - inputSchema
     - outputSchema

    """


    def __init__(self, metaData=None, inferenceSpec=None, inputSchema=None, outputSchema=None,):
        self.metaData = metaData
        self.inferenceSpec = inferenceSpec
        self.inputSchema = inputSchema
        self.outputSchema = outputSchema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.inferenceSpec = InferenceSpec()
                    self.inferenceSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.inputSchema = TDataType()
                    self.inputSchema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.outputSchema = TDataType()
                    self.outputSchema.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Model')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.inferenceSpec is not None:
            oprot.writeFieldBegin('inferenceSpec', TType.STRUCT, 2)
            self.inferenceSpec.write(oprot)
            oprot.writeFieldEnd()
        if self.inputSchema is not None:
            oprot.writeFieldBegin('inputSchema', TType.STRUCT, 3)
            self.inputSchema.write(oprot)
            oprot.writeFieldEnd()
        if self.outputSchema is not None:
            oprot.writeFieldBegin('outputSchema', TType.STRUCT, 4)
            self.outputSchema.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelTransform(object):
    """
    Attributes:
     - model
     - inputMappings
     - outputMappings
     - prefix

    """


    def __init__(self, model=None, inputMappings=None, outputMappings=None, prefix=None,):
        self.model = model
        self.inputMappings = inputMappings
        self.outputMappings = outputMappings
        self.prefix = prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.model = Model()
                    self.model.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.inputMappings = {}
                    (_ktype233, _vtype234, _size232) = iprot.readMapBegin()
                    for _i236 in range(_size232):
                        _key237 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val238 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.inputMappings[_key237] = _val238
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.outputMappings = {}
                    (_ktype240, _vtype241, _size239) = iprot.readMapBegin()
                    for _i243 in range(_size239):
                        _key244 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val245 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.outputMappings[_key244] = _val245
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.prefix = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModelTransform')
        if self.model is not None:
            oprot.writeFieldBegin('model', TType.STRUCT, 1)
            self.model.write(oprot)
            oprot.writeFieldEnd()
        if self.inputMappings is not None:
            oprot.writeFieldBegin('inputMappings', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.inputMappings))
            for kiter246, viter247 in self.inputMappings.items():
                oprot.writeString(kiter246.encode('utf-8') if sys.version_info[0] == 2 else kiter246)
                oprot.writeString(viter247.encode('utf-8') if sys.version_info[0] == 2 else viter247)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.outputMappings is not None:
            oprot.writeFieldBegin('outputMappings', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.outputMappings))
            for kiter248, viter249 in self.outputMappings.items():
                oprot.writeString(kiter248.encode('utf-8') if sys.version_info[0] == 2 else kiter248)
                oprot.writeString(viter249.encode('utf-8') if sys.version_info[0] == 2 else viter249)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.prefix is not None:
            oprot.writeFieldBegin('prefix', TType.STRING, 4)
            oprot.writeString(self.prefix.encode('utf-8') if sys.version_info[0] == 2 else self.prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelTransforms(object):
    """
    Attributes:
     - transforms
     - passthroughFields

    """


    def __init__(self, transforms=None, passthroughFields=None,):
        self.transforms = transforms
        self.passthroughFields = passthroughFields

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.transforms = []
                    (_etype253, _size250) = iprot.readListBegin()
                    for _i254 in range(_size250):
                        _elem255 = ModelTransform()
                        _elem255.read(iprot)
                        self.transforms.append(_elem255)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.passthroughFields = []
                    (_etype259, _size256) = iprot.readListBegin()
                    for _i260 in range(_size256):
                        _elem261 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.passthroughFields.append(_elem261)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModelTransforms')
        if self.transforms is not None:
            oprot.writeFieldBegin('transforms', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.transforms))
            for iter262 in self.transforms:
                iter262.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.passthroughFields is not None:
            oprot.writeFieldBegin('passthroughFields', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.passthroughFields))
            for iter263 in self.passthroughFields:
                oprot.writeString(iter263.encode('utf-8') if sys.version_info[0] == 2 else iter263)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Query)
Query.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'selects', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'wheres', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'startPartition', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'endPartition', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'timeColumn', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'setups', (TType.STRING, 'UTF8', False), [
    ], ),  # 6
    (7, TType.STRING, 'mutationTimeColumn', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'reversalColumn', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'partitionColumn', 'UTF8', None, ),  # 9
)
all_structs.append(StagingQuery)
StagingQuery.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startPartition', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'setups', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.BOOL, 'createView', None, None, ),  # 5
)
all_structs.append(EventSource)
EventSource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'topic', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'query', [Query, None], None, ),  # 3
    (4, TType.BOOL, 'isCumulative', None, None, ),  # 4
)
all_structs.append(EntitySource)
EntitySource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snapshotTable', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mutationTable', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mutationTopic', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'query', [Query, None], None, ),  # 4
)
all_structs.append(ExternalSourceFactoryConfig)
ExternalSourceFactoryConfig.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'factoryName', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'factoryParams', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(ExternalSource)
ExternalSource.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metadata', [MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'keySchema', [TDataType, None], None, ),  # 2
    (3, TType.STRUCT, 'valueSchema', [TDataType, None], None, ),  # 3
    (4, TType.STRUCT, 'factoryConfig', [ExternalSourceFactoryConfig, None], None, ),  # 4
)
all_structs.append(JoinSource)
JoinSource.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'join', [Join, None], None, ),  # 1
    (2, TType.STRUCT, 'query', [Query, None], None, ),  # 2
)
all_structs.append(Source)
Source.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'events', [EventSource, None], None, ),  # 1
    (2, TType.STRUCT, 'entities', [EntitySource, None], None, ),  # 2
    (3, TType.STRUCT, 'joinSource', [JoinSource, None], None, ),  # 3
)
all_structs.append(Window)
Window.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'length', None, None, ),  # 1
    (2, TType.I32, 'timeUnit', None, None, ),  # 2
)
all_structs.append(Aggregation)
Aggregation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'inputColumn', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operation', None, None, ),  # 2
    (3, TType.MAP, 'argMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'windows', (TType.STRUCT, [Window, None], False), None, ),  # 4
    (5, TType.LIST, 'buckets', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(AggregationPart)
AggregationPart.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'inputColumn', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operation', None, None, ),  # 2
    (3, TType.MAP, 'argMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'window', [Window, None], None, ),  # 4
    (5, TType.STRING, 'bucket', 'UTF8', None, ),  # 5
)
all_structs.append(MetaData)
MetaData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'online', None, None, ),  # 2
    (3, TType.BOOL, 'production', None, None, ),  # 3
    (4, TType.STRING, 'customJson', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'dependencies', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.MAP, 'tableProperties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRING, 'outputNamespace', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'team', 'UTF8', None, ),  # 8
    (9, TType.MAP, 'modeToEnvMap', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 9
    (10, TType.BOOL, 'consistencyCheck', None, None, ),  # 10
    (11, TType.DOUBLE, 'samplePercent', None, None, ),  # 11
    (12, TType.STRING, 'offlineSchedule', 'UTF8', None, ),  # 12
    (13, TType.DOUBLE, 'consistencySamplePercent', None, None, ),  # 13
    (14, TType.BOOL, 'historicalBackfill', None, None, ),  # 14
    (15, TType.STRING, 'deprecationDate', 'UTF8', None, ),  # 15
    (16, TType.STRING, 'description', 'UTF8', None, ),  # 16
)
all_structs.append(GroupBy)
GroupBy.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.LIST, 'sources', (TType.STRUCT, [Source, None], False), None, ),  # 2
    (3, TType.LIST, 'keyColumns', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'aggregations', (TType.STRUCT, [Aggregation, None], False), None, ),  # 4
    (5, TType.I32, 'accuracy', None, None, ),  # 5
    (6, TType.STRING, 'backfillStartDate', 'UTF8', None, ),  # 6
    (7, TType.LIST, 'derivations', (TType.STRUCT, [Derivation, None], False), None, ),  # 7
)
all_structs.append(JoinPart)
JoinPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'groupBy', [GroupBy, None], None, ),  # 1
    (2, TType.MAP, 'keyMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    None,  # 3
    (4, TType.STRING, 'prefix', 'UTF8', None, ),  # 4
)
all_structs.append(ExternalPart)
ExternalPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'source', [ExternalSource, None], None, ),  # 1
    (2, TType.MAP, 'keyMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'prefix', 'UTF8', None, ),  # 3
)
all_structs.append(Derivation)
Derivation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'expression', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 3
)
all_structs.append(Join)
Join.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'left', [Source, None], None, ),  # 2
    (3, TType.LIST, 'joinParts', (TType.STRUCT, [JoinPart, None], False), None, ),  # 3
    (4, TType.MAP, 'skewKeys', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'onlineExternalParts', (TType.STRUCT, [ExternalPart, None], False), None, ),  # 5
    (6, TType.STRUCT, 'labelPart', [LabelPart, None], None, ),  # 6
    (7, TType.LIST, 'bootstrapParts', (TType.STRUCT, [BootstrapPart, None], False), None, ),  # 7
    (8, TType.LIST, 'rowIds', (TType.STRING, 'UTF8', False), None, ),  # 8
    (9, TType.LIST, 'derivations', (TType.STRUCT, [Derivation, None], False), None, ),  # 9
    (10, TType.STRUCT, 'modelTransforms', [ModelTransforms, None], None, ),  # 10
)
all_structs.append(BootstrapPart)
BootstrapPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRING, 'table', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'query', [Query, None], None, ),  # 3
    (4, TType.LIST, 'keyColumns', (TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(LabelPart)
LabelPart.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'labels', (TType.STRUCT, [JoinPart, None], False), None, ),  # 1
    (2, TType.I32, 'leftStartOffset', None, None, ),  # 2
    (3, TType.I32, 'leftEndOffset', None, None, ),  # 3
    (4, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 4
)
all_structs.append(GroupByServingInfo)
GroupByServingInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'groupBy', [GroupBy, None], None, ),  # 1
    (2, TType.STRING, 'inputAvroSchema', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'selectedAvroSchema', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'keyAvroSchema', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'batchEndDate', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'dateFormat', 'UTF8', None, ),  # 6
)
all_structs.append(DataField)
DataField.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'dataType', [TDataType, None], None, ),  # 2
)
all_structs.append(TDataType)
TDataType.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'kind', None, None, ),  # 1
    (2, TType.LIST, 'params', (TType.STRUCT, [DataField, None], False), None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
)
all_structs.append(InferenceSpec)
InferenceSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'modelBackend', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'modelBackendParams', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(Model)
Model.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'inferenceSpec', [InferenceSpec, None], None, ),  # 2
    (3, TType.STRUCT, 'inputSchema', [TDataType, None], None, ),  # 3
    (4, TType.STRUCT, 'outputSchema', [TDataType, None], None, ),  # 4
)
all_structs.append(ModelTransform)
ModelTransform.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'model', [Model, None], None, ),  # 1
    (2, TType.MAP, 'inputMappings', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.MAP, 'outputMappings', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'prefix', 'UTF8', None, ),  # 4
)
all_structs.append(ModelTransforms)
ModelTransforms.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'transforms', (TType.STRUCT, [ModelTransform, None], False), None, ),  # 1
    (2, TType.LIST, 'passthroughFields', (TType.STRING, 'UTF8', False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
